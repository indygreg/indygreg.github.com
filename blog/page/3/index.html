


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
Design by Free CSS Templates
http://www.freecsstemplates.org
Released for free under a Creative Commons Attribution 2.5 License

Name       : Pollinating  
Description: A two-column, fixed-width design with dark color scheme.
Version    : 1.0
Released   : 20101114

-->
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    
  <title>Gregory Szorc's Digital Home
</title>
<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
<link rel="alternate" type="application/atom+xml" title="Atom 1.0"
href="/blog/feed/atom" />
<link rel="stylesheet" href="/style/style.css" type="text/css" />
<link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />


  </head>
  <body>
    <div id="wrapper">
      
  <div id="menu">
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="/blog/">Blog</a></li>
    <li><a href="/notes">Notes</a></li>
    <li><a href="/work.html">Work</a></li>
    <li><a href="/skills.html">Skills</a></li>
    <li><a href="/thoughts.html">Thoughts</a></li>
    <li><a href="/resume.pdf">Resume</a></li>
  </ul>
</div>


      <div id="page">
        <div id="page-bgtop">
          <div id="page-bgbtm">
              <div id="content">
                
  
<div class="blog_post">
  <a name="surprisingly-slow"></a>
  <h2 class="blog_post_title"><a href="/blog/2021/04/06/surprisingly-slow" rel="bookmark" title="Permanent Link to Surprisingly Slow">Surprisingly Slow</a></h2>
  <small>April 06, 2021 at 07:00 AM | categories: 

<a href='/blog/category/programming'>Programming</a>
</small><p/>
  <div class="post_prose">
    
  <p>I have an affinity for performance optimization and making software as
efficient as possible. Over the years, I've encountered specific instances
and common patterns that make software or computers slow. In this post,
I'll shine a spotlight on some of them.</p>
<p>I'm titling this post <em>Surprisingly Slow</em> because the slowness was either
surprising to me or the sub-optimal practices leading to slowness are
prevalent enough that I think many programmers would be surprised by
their existence.</p>
<p>The sections below are largely independent. So feel free to cherry pick
the ones that interest you.</p>
<h1>Environment Detection in Build Systems (e.g. configure and cmake)</h1>
<p>This is the topic that inspired this post.</p>
<p>Build systems often feature an <em>environment detection</em> / <em>configuration</em>
phase before the <em>build phase</em>. In UNIX land, autoconf generated <code>configure</code>
scripts are prevalent. CMake is also popular. These tools run a bunch of code
to probe the state of the current system so that the build configuration is
appropriate for the current build environment. For example, they'll probe for
which compiler to use, its version, and what bugs and capabilities it has.</p>
<p>This environment detection and configuration is a necessary evil because
machines and environments often vary substantially and you need to account
for those variances.</p>
<p><strong>The problem is that this configuration step often takes longer to run than
the build itself!</strong> Build systems for small programs or libraries will often
spend 10+ seconds running <code>configure</code> and complete the actual compilation
and linking in a fraction of that time. In other words, the setup to perform
the build takes longer than the build itself!</p>
<p>Depending on how many CPU cores you have, the discrepancy may not be obvious.
But I have a 16 core / 32 thread Ryzen 5950X as my primary PC and the relative
slowness of the configuration step is painful to observe.</p>
<p><strong>What I find even more shocking is that <em>configuration</em> time often still
eclipses actual build time even for large projects.</strong> I'm not sure if this
is still true, but a few years ago Mozilla observed that building LLVM/Clang
on a 96 vCPU EC2 instance resulted in more time spent in cmake/configuring
than compiling and linking! And that's a very large C++ project with thousands
of source files being compiled!</p>
<p>Build configuration is often a discrete step that executes serially before
what most people consider the actual build. To improve efficiency, build
configuration needs to be parallelized. Even better, it should be integrated
into the main build DAG itself so parts of the build can start running without
having to wait for all build configuration. Unfortunately, many common tools
performing build configuration can't easily be adapted to this model. So there's
not much many of us can do.</p>
<p>Another solution to this problem is avoiding the problem of environment detection
in the first place. If you have deterministic and reproducible build
environments, you can take a lot of shortcuts to skip environment detection
that just isn't needed any more. This is more or less the approach of modern
build tools like Bazel. I do wonder how much of the speed gains from tools
like Bazel are due to eliminating environment configuration. I suspect it is
a lot!</p>
<h1>New Process Overhead on Windows</h1>
<p>New processes on Windows can't be spawned as quickly as they can on POSIX
based operating systems, like Linux. On Windows, assume a new process will
take 10-30ms to spawn. On Linux, new processes (often via <code>fork()</code> + <code>exec()</code>
will take single digit milliseconds to spawn, if that).</p>
<p>However, thread creation on Windows is very fast (~dozens of microseconds).</p>
<p>These
<a href="https://stackoverflow.com/questions/10710912/what-is-the-process-creation-overhead-in-windows">Stack</a>
<a href="https://stackoverflow.com/questions/47845/why-is-creating-a-new-process-more-expensive-on-windows-than-linux">Overflow</a>
have some more details.</p>
<p>A few dozen milliseconds is an eternity in CPU time. And it is long enough
that it eats into a large percentage of the time budget for people to perceive
something as instantaneous. So this may contribute to the perception that
<em>Windows is slower than Linux</em>.</p>
<p>If your program architecture consists of spawning new processes left and
right (this is common in UNIX land), this can pose performance problems on
Windows, as the overhead of new process creation on Windows can really add
up:</p>
<ul>
<li>10ms * 1,000 invocations = 10s</li>
<li>20ms * 10,000 invocations = 200s</li>
<li>30ms * 100,000 invocations = 3,000s</li>
</ul>
<p>Using the example of configure above, configure files are often shell
scripts. And shell scripts often do a lot of their work by spawning other
processes like <code>grep</code>, <code>sed</code>, and <code>sort</code>. Even the <code>[</code> operator could be a
new process (seriously: there's probably a <code>/usr/bin/[</code> executable in your
POSIX environment). (Although <code>[</code> might be a shell built-in.) Command
pipe chains (e.g. <code>command | grep | awk</code>) spawn multiple processes serially
and can be visually slow to run. Anyway, it is not uncommon for a configure
script to spawn thousands of new processes. Assuming 10ms per process, at
1,000 invocations that is 10s of overhead just spawning new processes! This
further exacerbates the problem in the previous section!</p>
<p>If your software runs on Windows, consider the impact that relatively
slow process spawning will have. Consider a multi-threaded architecture
or using longer-lived daemon/background processes instead.</p>
<h1>Closing File Handles on Windows</h1>
<p>Many years ago I was profiling Mercurial to help improve the working
directory checkout speed on Windows, as users were observing that checkout
times on Windows were much slower than on Linux, even on the same machine.</p>
<p>I thought I could chalk this up to NTFS versus Linux filesystems or
general kernel/OS level efficiency differences. What I actually learned
was much more surprising.</p>
<p>When I started profiling Mercurial on Windows, I observed that most I/O
APIs were completing in a few dozen microseconds, maybe a single millisecond
or two ever now and then. Windows/NTFS performance seemed great!</p>
<p>Except for <code>CloseHandle()</code>. These calls were often taking 1-10+ milliseconds
to complete. It seemed odd to me that file writes - even sustained file writes
that were sufficient to blow past any write buffering capacity - were fast
but closes slow. It was even more perplexing that <code>CloseHandle()</code> was slow
even if you were using completion ports (i.e. async I/O). This behavior for
completion ports was counter to what the MSDN documentation said should happen
(the function should return immediately and its status can be retrieved later).</p>
<p>While I didn't realize it at the time, the cause for this was/is Windows
Defender. Windows Defender (and other anti-virus / scanning software)
typically work on Windows by installing what's called a filesystem filter
driver. This is a kernel driver that essentially hooks itself into the kernel
and receives callbacks on I/O and filesystem events. It turns out the <em>close
file</em> callback triggers scanning of written data. And this scanning appears
to occur synchronously, blocking <code>CloseHandle()</code> from returning. This adds
milliseconds of overhead. The net effect is that file mutation I/O on Windows
is drastically reduced by Windows Defender and other A/V scanners.</p>
<p>As far as I can tell, as long as Windows Defender (and presumably other A/V
scanners) are running, there's no way to make the Windows I/O APIs consistently
fast. You can disable A/V scanning (at your own peril). But the trick that
Mercurial <a href="https://www.mercurial-scm.org/repo/hg/rev/2fdbf22a1b63f7b4c94393dbf45ad417da257fe0">employs</a>
(which has later been emulated by rustup among other tools) is to use a
thread pool for calling <code>CloseHandle()</code>. Even if you perform all file
open and write I/O on a single thread and use a background thread pool only
for calling <code>CloseHandle()</code>, you can see a &gt;3x speedup in time to write files.
<strong>This optimization should ideally be employed by any software that creates
or mutates as little as a few hundred files on Windows.</strong> This includes
version control tools, installers, and archive extraction tools. Fun fact:
<code>rustup</code> can extract tar files on Windows faster than open source and commercial
<em>fast</em> extraction/copy tools because it employs this trick and more. I believe
<code>rustup</code> on Windows is actually faster at extracting tar archives than it is
on Linux!</p>
<p>The artificial I/O latency added by scanning software such as Windows Defender
is super annoying. But the performance gains from working around it by using
a thread pool for background is often worth the complexity. I have no doubt
that if this optimization were baked into popular Windows tools (namely
installers), people would be shocked by how much faster things could be.</p>
<h1>Writing to Terminals</h1>
<p>As a maintainer of Firefox's build system, I fielded a handful of reports
from people complaining about builds being slower than their peers on
identical hardware. While there are many causes for this, one of the most
surprising was the impact the terminal has on build performance.</p>
<p>Writing to the terminal is usually fast. Until it isn't.</p>
<p>What I learned is that writing tons of output or getting clever with
writing to the terminal (e.g. writing colors, moving the cursor position
to write over existing content) can drastically slow down applications.</p>
<p>Writing to the terminal via stderr/stdout is likely performed via blocking
I/O. So if the thing handling your <code>write()</code> (the terminal emulator) doesn't
finish its handling promptly, your process just sits around waiting on
the terminal to do its thing.</p>
<p>We discovered that different terminals have their own quirks. Historically,
the Windows Command Prompt and the built-in Terminal.app on macOS were
very slow at handling tons of output. I remember (but can't find the bug or
commit to Firefox) when we made the build system quiet by default and that
reduced build times by <em>minutes</em> in some configurations.</p>
<p>A few years ago, npm infamously had a
<a href="https://github.com/npm/npm/issues/11283">performance sucking progress spinner</a>.
While I'm not sure how much of this was terminal slowness versus calling
progress update code too frequently, the terminal likely played a part because
terminals do have a limit to how often they can accept input to draw.</p>
<p>I've found that modern terminals are better about writing a ton of plain text
than they were in ~2012, when I was tackling these problems in Firefox's build
system. But I would still exercise extreme caution when doing fancy things
with the terminal, like coloring text, drawing footers, etc. Always use buffered
I/O to minimize the number of <code>write()</code> actually going to the terminal, flushing
as needed (hopefully sparingly). Consider using an async thread for writing to
stdout/stderr. Record the total time spent in blocking I/O to stdout/stderr so you
can measure terminal I/O latency. And periodically compare the wall time delta
between stdout/stderr connected to a terminal and /dev/null when running your
program to see if there is a discrepancy worth caring about. Finally, consider
throttling writes to the terminal. Instead of writing a footer after every line
of output, consider buffering lines for a few milliseconds and emitting all
lines plus the new footer in batches. If drawing a progress bar or spinner or
something of that nature, I would limit drawing to ~10 Hz to minimize
terminal overhead.</p>
<h1>Thermal Throttling / ACPI C/P-States / Processor Throttling Behavior</h1>
<p>We like to think that a computer and its processors are either on or off.
If only things were that simple.</p>
<p>Processors are constantly changing their operating envelope as they are
running. The following statements are all true (although not every item applies
to all machines or CPU models):</p>
<ul>
<li>The MHz each CPU core is running at can fluctuate wildly from 1 second to
  the next.</li>
<li>CPU cores may go to sleep or enter a very low power mode, even if others are
  running.</li>
<li>Cores may underclock significantly if temperature goes beyond a threshold.
  They may refuse to run faster until the temperature drops. Faulty sensors
  can lead to premature behavior.</li>
<li>Cores may only reach their maximum frequency if other cores are also
  running. The physical proximity of that other core may matter.</li>
<li>It could take dozens, hundreds, or even thousands of milliseconds for an
  idling core to ramp up to its full speed.</li>
<li>The behavior of power scaling can vary substantially depending on whether
  a machine is connected to external power or running off the battery.</li>
<li>The behavior of power scaling can vary substantially depending on whether
  the battery is fully charged or nearly empty.</li>
<li>Apple laptops may exhibit thermal throttling when
  <a href="https://apple.stackexchange.com/questions/363337/how-to-find-cause-of-high-kernel-task-cpu-usage">charging from the left side</a>.
  (Yes, seriously: always charge your MacBook Pro from the right. And if
  your employees use Apple laptops for CPU heavy tasks, consider an awareness
  campaign to encourage charging from the right side. Even better, deploy
  software that checks for left side charging and alert accordingly. Although
  I have yet to find any software or API to detect this.)</li>
<li>A core may slow down in order to process certain instructions (like
  <a href="https://travisdowns.github.io/blog/2020/01/17/avxfreq1.html">AVX-512</a>).</li>
</ul>
<p>Modern CPUs are really dynamic beasts and their operating behavior is often
seemingly unpredictable. Furthermore, CPU models can vary from one to the
next. For example, an EPYC or Xeon processor will likely behave differently
from a Ryzen or Core i7/i9 which will behave differently depending on
whether you are running in a desktop or laptop. (I observed a few years ago
that Xeon cores won't turbo as <em>easily</em> as consumer grade CPUs.)</p>
<p>Power fluctuations and their impact on performance are one of the reasons
why it is extremely difficult to conduct proper benchmarks. When
benchmarking, you need to control the power variable or at least report its
state so results are qualified appropriately. I am very skeptical of benchmark
results that don't report the power configuration/methodology (this is
most of them, sadly) and especially of benchmarks conducted on laptops, as
battery operated devices are much more susceptible to power throttling than
desktops or servers.</p>
<p>I have personally had a MacBook Pro become thermal throttled because an
internal screw came loose and blocked a fan from spinning. macOS didn't
warn me: all I knew was that my Firefox builds become 2-3x slower for no
apparent reason! I have also observed my MacBook Pro becoming hot due to
left side charging. Charging from the right magically made things faster.</p>
<p>At Mozilla, when we started rolling out Xeon desktops to employees,
we had reports of wildly varying build speeds. On some operating systems
(Mozilla had very lax central machine provisioning and allowed people full
domain of their company issued hardware), the default ACPI C/P-States were
such that CPU cores were scaling differently.</p>
<p>What we observed was the <em>compile</em> phase of the build was fine. But some
people were reporting linking times 2-4x longer (dozens of seconds to minutes)
than others on equivalent configurations! This was a big deal because the wall
time of an incremental/non-full build is dominated by linking time. We
eventually discovered that on the slow machines, the CPU core doing the linking
was only running at 25-50% of its potential. Think 1.0-1.5 GHz. But if you
started additional CPU heavy tasks, that core ramped up. We discovered that
different operating systems had different defaults for the ACPI C/P-States.
The more conservative settings would result in CPU cores not scaling their
frequency unless there was sufficient CPU load to merit it. Changing to more
aggressive power settings ensured better and consistent results.</p>
<p>Laptops are highly susceptible to thermal throttling and aggressive power
throttling to conserve battery. I hold the general opinion that laptops are
just too variable to have reliable performance. Given the choice, I want
CPU heavy workloads running in controlled and observed desktops or server
environments.</p>
<p>But servers aren't immune: their ACPI C-State and P-State settings can
drastically impact performance. Dialing these up to max so all the cores
run at full (or are ready to run at full in a few milliseconds) is possible.
However, this may greatly increase your power consumption. You can do this
on some cloud providers (like AWS) for no additional direct cost to you.
However, higher energy consumption is bad for the environment. Data centers
already have a
<a href="https://www.datacenterknowledge.com/energy/study-data-centers-responsible-1-percent-all-electricity-consumed-worldwide">carbon footprint about the size of the airline industry</a>
(during non-pandemic times) and that footprint is growing. So think about
your ethical responsibilities to the environment before having your server
fleet consume potentially megawatts more power.</p>
<h1>Python, Node.js, Ruby, and other Interpreter Startup Overhead</h1>
<p>Complex systems will often execute Python, Node.js, and other interpreters
thousands or more times during their execution. For example, the Firefox
build system invokes thousands of Python processes performing common tasks,
such as wrapping the compiler invocation. And the Mercurial test harness invokes
thousands of Python processes by running <code>hg</code> as part of its testing. I've
heard of similar stories involving Node.js, Ruby, and other interpreters,
often in the context of use in build systems.</p>
<p>An oft ignored fact about launching a new interpreter process is that each
invocation often takes single to dozens of milliseconds to initialize the
interpreter. i.e. the new process spends time at the beginning of process
execution just getting to the code you are telling it to run. Sometimes the
new process overhead is so bad that the slowdown is obvious and rules out
the use of a technology. The JVM historically has been notorious for this,
which is why use of Java typically entails fewer, longer-running processes
over more, domain-limited processes.</p>
<p>I've <a href="https://mail.python.org/pipermail/python-dev/2018-May/153296.html">written</a>
<a href="https://mail.python.org/pipermail/python-dev/2014-May/134528.html">about</a>
Python's startup overhead before. In 2014 I measured that Mercurial's test
harness spends 10-18% of its total CPU time just getting to the point where
the interpreter/process can run custom bytecode and 30-38% of its total CPU
time getting to the point where Mercurial performs command dispatch
(additional time here is mostly module importing overhead).</p>
<p>You may think that a few milliseconds of overhead can't matter that much.
But if you multiply by 1,000, 10,000, 100,000 or more, milliseconds matter:</p>
<ul>
<li>1ms * 1,000 invocations = 1s</li>
<li>10ms * 10,000 invocations = 100s</li>
<li>100ms * 100,000 invocations = 10,000s (2.77 hours)</li>
</ul>
<p>On Windows, this problem is compounded because of it relatively slow new
process startup (see section above).</p>
<p>Programmers need to think long and hard about your process invocation model.
Consider the use of fewer processes and/or consider alternative programming
languages that don't have significant startup overhead if this could become
a problem (anything that compiles down to assembly is usually fine).</p>
<h1>Pretty Much all Storage I/O</h1>
<p>Of my general affinity for performance optimization, I have a special
affinity for I/O optimization. I think the main reason is that the disconnect
between the potential for modern storage devices and what is actually
achieved is so wide. On paper, software should be getting ~10x the
performance from modern storage devices than what we typically see.</p>
<p>Modern storage devices are absurdly fast. The NVMe storage in my primary
PC can sustain reads at &gt;3 GB/s (&gt;6 GB/s sequential), writes at ~1
GB/s (4+ GB/s sequential), can perform &gt;500,000 I/O operations per
second, and can service many I/O operations in the ~10 microsecond latency
range. Modern NVMe storage is roughly on par with the performance of DDR2
DRAM (launched in 2003) in terms of throughput (latency still trails but
~10us is nothing to scoff at).</p>
<p>For comparison, the 1 TB Western Digital Caviar Black spinning disk I
retired from my PC a few weeks ago can only do ~90 MB/s sequential reads
and writes, 1-2 MB/s random reads and writes, ~12 ms access times. I'm unsure
what IOPS is, but considering ~12 ms access times and the physical
nature of spinning disks, it can't be more than a few hundred.</p>
<p>Modern NVMe storage is 1.5-3 <strong>magnitudes</strong> faster than the best
spinning disks from little over a decade ago. So why isn't all storage
I/O ~instantaneous?</p>
<p>The short answer is that most software fails to utilize the potential
of modern storage devices or even worse actively undermines it through
bad practices.</p>
<p>For the former, I'll refer you to the excellent
<a href="https://itnext.io/modern-storage-is-plenty-fast-it-is-the-apis-that-are-bad-6a68319fbc1a">Modern Storage is Plenty Fast. It is the APIs That are Bad</a>.
tl;dr you can harness the full power of your modern storage device
if you bypass the standard OS/kernel I/O primitives and issue I/O
operations directly against the device. So, software abstractions in
the OS/kernel are eating a lot of potential.</p>
<p>For the software undermining storage device potential aspect, I'll briefly
touch on the <code>fsync()</code> POSIX function. By calling this function, you effectively
say <em>be sure the state of this file descriptor is persisted to the storage
device</em> or <em>I don't want to lose any changes I've made</em>.</p>
<p>Data consistency and durability are important. But the cost to achieving
them can be absurdly high. And as it turns out, it is also subtly difficult
to do correctly in practice. I'll refer you to Dan Luu's excellent
<a href="https://danluu.com/file-consistency/">Files are Hard</a>. The papers linked
offer a sobering assessment. I'll reinforce the message with
<a href="https://lwn.net/Articles/752063/">PostgreSQL's fsync() surprise</a>, which
chronicles how PostgreSQL maintainers learned about how Linux can flat
out drop errors when performing device I/O, leading to data corruption.
Yikes!</p>
<p>Anyway, about <code>fsync()</code>. The concept of <code>fsync()</code> is sound: <em>ensure this
thing is persisted to the storage device</em>. But the implementation is often
a pile of inefficiency leading to slowness.</p>
<p>On many Linux filesystems (including ext4), the implementation of <code>fsync()</code>
is such that upon calls, <em>all</em> unflushed writes are persisted to storage.
So if process A writes out a 1 GB file and process B writes 1 byte to another
file and calls <code>fsync()</code> on that single byte write, Linux/ext4 will need to
write 1 GB to the storage device, not 1 byte. So on Linux/ext4, all it takes
is a random process somewhere to issue <code>fsync()</code> and all dirty page cache
entries need to be flushed. On most systems, there's usually something
continuously incurring write I/O, so the amount of storage device I/O incurred
by <code>fsync()</code> is almost always larger than just the mutated file/directory
you actually want persisted.</p>
<p>This behavior can cause a ton of problems. For starters, it artificially
increases I/O latency. You'd think that calling <code>fsync()</code> after a minimal
change would be ~instantaneous. But if there are lots of dirty pages to be
flushed, it could take seconds. At my current employer, we ran into this
exact problem with GitHub Enterprise, which has a monolithic architecture.
A MySQL database was running off the same ext4 filesystem as the Git
repositories. MySQL will call <code>fsync()</code> frequently to ensure transactions and
the transaction journal are persisted to storage. But if a Git GC were running
and Git just finished writing a multi-gigabyte packfile, MySQL's <code>fsync()</code> would
be stuck waiting on Git's large write to finish persisting. This led to
slowness of future MySQL transactions and even some application-level timeouts.
When people say databases and other stores should be isolated to their own
volumes/filesystems, <code>fsync()</code>'s wonky behavior is a big reason why.</p>
<p>Fortunately, newer versions of Linux/ext4 contain a
<a href="https://lwn.net/Articles/842385/">fast commits feature</a> that changes
behavior and enables more granular flushing of <code>fsync()</code> to storage, just
like it is documented to do. But as the feature is pretty new, it could
take a while to stabilize and make its way to distros. I can't wait for
it though!</p>
<p>Another problem with <code>fsync()</code> is that it is called more often than it
needs to be. Now, if you have mission critical data and need consistency
and durability, you should absolutely be calling <code>fsync()</code> appropriately.
But the reality is that many data workloads and machine environments don't
actually need strong data guarantees!</p>
<p>Take for example Kubernetes pods or CI runners. Or even servers for a
<em>stateless</em> service. Ask yourself, <em>what's the worst that could happen if
the machine loses power and there is data loss on the local filesystem?</em> In a
lot of scenarios the answer is <em>nothing</em>. You've designed your system to be
stateless and fault tolerant. You manage your servers as cattle. You treat local
filesystems as ephemeral. So if a machine fails, you provision a new one to
replace it. In these scenarios, <code>fsync()</code> buys you little to nothing but
can cost you a lot!</p>
<p>The cost of avoidable <code>fsync()</code> can be substantial. Combined with the
inefficient global flushing behavior of Linux/ext4, it can be a performance
sapper, especially on slower storage devices. Fortunately, there are
options. Many databases and other popular software has a way to prevent
the issuance of <code>fsync()</code>. If your data is ephemeral, consider disabling
<code>fsync()</code> for a likely significant performance boost! For software that
doesn't support disabling <code>fsync()</code>, the aptly named
<a href="https://www.flamingspork.com/projects/libeatmydata/">eatmydata</a> tool and
LD_PRELOAD library can be used to nerf <code>fsync()</code> and other similar
functionality by intercepting the function calls and making them no-op.
Last but not least, for ephemeral machines, consider building a patched
Linux kernel that turns <code>fsync()</code> and friends into no-ops. (I'm not sure
of anyone who does this. But I've considered it because getting eatmydata
to work in places like launched containers can be a bit of a pain.)</p>
<p>I'll close this section with a link to my favorite commit to the Firefox
repository: <a href="https://hg.mozilla.org/mozilla-central/rev/6b064f9f6e10b25bf2edc916b1b9a8b78cff0465">Disable Places during reftests, preventing 50 GB of I/O</a>.
While this commit goes beyond disabling <code>fsync()</code>, <code>fsync()</code> (and its
Windows equivalent) was responsible for some of the performance loss.
Excessive I/O and needless persisting of changes to device can really
sap performance. Storage software usually errors on the side of consistency
(this is the correct default in my opinion). Given the costs that consistency
imposes, you should seriously consider nerfing the guarantees and speeding
up I/O when that option is viable for you.</p>
<h1>Data Compression</h1>
<p>I could write an entire post on the topic of data compression and its
widespread suboptimal use. Here is the concise version.</p>
<p>At its core, data compression is a trade-off between CPU and I/O usage.
Typically it involves one of the following scenarios:</p>
<ol>
<li>I/O (either storage or network) is the bottleneck, so we want to trade
   more CPU to reduce I/O throughput.</li>
<li>At rest storage is expensive, so we want to trade more CPU for lower
   storage utilization/costs.</li>
</ol>
<p>Since the early days of computing, a maxim has been that storage is
slow and expensive compared to CPU. So trading CPU to reduce storage
utilization seemed like a solid bet.</p>
<p>Fast forward to 2021.</p>
<p>As I wrote in the previous section, modern storage I/O is absurdly fast.
It is also historically cheap.</p>
<p>Networks have also gotten faster. 1 gbps (125 MB/s) is pretty universal at
this point. 2.5 gbps (312 MB/s) is getting deployed in consumer and office
environments. 10 gbps (1250 MB/s) is common in data centers. And faster than
10 gbps is possible.</p>
<p>Meanwhile CPUs have somewhat plateaued in their single core <em>performance</em>
in the past decade. We've been <em>stuck</em> at ~4 GHz for years. All of the
performance gains from CPUs have come from adding more CPU cores to the package
and instructions per cycle (IPC) efficiency wins (we've also gotten some
agonizing security vulnerabilities like Spectre and Meltdown out of this IPC
work as well).</p>
<p>What this all means is that the relative performance difference between
CPUs and I/O has compressed significantly (pardon my pun). ~30 years ago,
CPUs ran at ~100 MHz and Internet was using dial-up at say 50 kbps, or 0.05 mbps,
or 6.25 kBps. That's 16,000 cycles per byte. Today, we're at ~4 GHz with say 1
Gbps / 125 MB/s networks. That's 32 cycles per byte, a decrease of 500x. (In
fairness, the ratio closes when you consider that we likely have &gt;1 CPU core
competing for I/O and factor in IPC gains. But we're still talking about the
relative difference in CPU and I/O decreasing by 1-1.5 magnitudes.) <strong>Years ago,
trading CPU to lessen the I/O load was often <em>obviously correct</em>. Today,
because of the advancements in I/O performance relative to CPU and a
substantially reduced cycles per I/O byte budget, the answer is a lot murkier.</strong></p>
<p>Not helping is the prevalence of ancient compression algorithms. DEFLATE - the
algorithm behind the ubiquitous zlib library and gzip data format - is ~30
years old. DEFLATE was designed in an era when computers had like 1 MB RAM and
100 MB hard drives. Different times.</p>
<p>DEFLATE/zlib became very popular in a world where I/O was much slower and
compression was often a necessity. Not using compression on a dial-up modem
resulted in massive performance differences! And because of its popularity in
the early days of the Internet, DEFLATE/zlib is available in the standard library
of many programming languages. It seems to be the first compression format people
reach for when someone says/thinks <em>add compression</em>.</p>
<p>The ubiquity of zlib is good from a dependency perspective: <em>everyone can read
zlib/gzip</em>. But for scenarios where you control the reader and writer, <strong>use of
zlib in 2021 constitutes negligence because its performance lags contemporary
solutions</strong>. Modern compression libraries (<a href="https://github.com/facebook/zstd">zstandard</a>
is my favorite) can yield substantially faster compression and decompression speed
while delivering better compression ratios in most data sets. My
2017 <a href="https://gregoryszorc.com/blog/2017/03/07/better-compression-with-zstandard/">Better Compression with Zstandard</a>
post dives into the numbers. (I've been meaning to revisit that post since zstandard
has since seen multiple 10+% speedups in subsequent releases, making it even more
compelling.) If you don't need the ubiquity of zlib (e.g. you control the writers
and readers), there's little reason to use zlib over something more modern.
Compared to zlib, modern compression libraries like zstandard are the closest thing to
magical pixie dust that you can sprinkle on your software for free performance.</p>
<p>If you are using compression (especially zlib) for real-time compression (sending
compressed data somewhere where it will be decompressed immediately), you need
to measure the line speed of the compressor and decompressor. Then compare that
to the uncompressed line speed. Are you bottlenecked by I/O in the uncompressed
case? If not, do you need the bandwidth or I/O capacity being saved by
compression? If not, why are you using compression at all? You just measured that
all compression did was artificially slow down your software for no reason!
Given that zlib compression will often fail to saturate a 1 gbps link, there's
a very real chance your use of compression introduces an artificial CPU bottleneck!</p>
<p>If you are using compression (especially zlib) for data archiving (storing
compressed data somewhere where it will be decompressed eventually), you need
to measure and compare compression ratios and line speeds of different compression
formats and their settings. Like the real-time compression scenario, if
decompression reduces your line speed from uncompressed, you are artificially
slowing down access to your data. Maybe that's justified to save on storage costs.
But in many cases, you can swap in a different compression library and get
similar to better compression ratios while achieving better (de)compression speeds.
Who wouldn't want free performance and storage cost reductions?</p>
<p>As an aside, one of the reasons I love zstandard is it can be tuned from something
that is screaming fast (GB/s at compression and decompression ends) to something
that is very slow on the compression side but yields terrific compression ratios,
while still preserving GB/s decompression speeds. This enables you to use the same
format for vastly different use cases. You can also dynamically change the storage
characteristics of your data. For example, you can initially write data with a <em>fast</em>
setting so you aren't CPU constrained on the writer. Then you can have some batch
job come around and recompress your data with more aggressive settings, making it
much smaller. It's not like zlib where the range of compression settings goes from
<em>kinda slow and not very good compression ratios</em> to <em>pretty slow and still not very
good compression ratios</em>.</p>
<p><strong>When you know to look for it, inefficiency due to unjustified use of compression or
failure to leverage modern compression libraries is everywhere.</strong> Here are some common
operations in my daily workflow that are bottlenecked by use of slow compression
formats and could be made faster by using a different compression format:</p>
<ul>
<li>Installing Apt packages (packages are gzip compressed). (Fun fact, installing apt
  packages is also subject to <code>fsync()</code> slowness as described above because the package
  manager will issue an <code>fsync()</code> at least once for each package.)</li>
<li>Installing Homebrew packages (packages are gzip compressed).</li>
<li>Installing Python packages via pip (source archives are gzip tarballs and wheels are
  zip files, which use zlib compression).</li>
<li>Pushing/pulling Docker images (layers inside Docker images are gzip compressed).</li>
<li>Git (wire protocol data exchange and on-disk storage is using zlib). (When I added
  zstandard support to Mercurial, it reduced the transfer size from servers to ~89%
  of original while using ~60% of the server-side CPU.)</li>
</ul>
<p>In the corporate world, there's probably multiple petabyte scale data warehouses,
data lakes, data coliseums (I can't keep up with what we're calling them now) storing
data in gzip. Dozens of terabytes could likely be shaved by moving to something
like zstandard. If using LZMA (which has extremely slow decompression speeds),
storage costs are cheap, but data access is extremely slow, making your
data querying slow. I haven't had the opportunity to measure it, but I suspect
some of the reputation Hadoop and other Big Data systems have for being slow is
because they are CPU constrained by suboptimal use of compression.</p>
<p>My experience is that many programmers don't understand the trade-offs and
nuances of compression and/or lack knowledge about the existence of more modern,
superior compression libraries. Instead, the collective opinion is <em>compression
is good, use [zlib] compression</em>. Like many things in software, the real world
is complex and nuanced. The dynamics of the relative power and cost of computer
components has shifted the pendulum towards compression adding more cost than
it saves. And it hasn't helped that industry still widely uses a ~30 year old
compression format (DEFLATE/zlib) that is far from ideal for modern computers.
If you take the time to measure, I'm sure you'll find many cases where use of
compression is either ill-advised or would benefit from a more modern compression
library (like zstandard).</p>
<h1>x86_64 Binaries in Linux Distribution Packages</h1>
<p>Linux distributions often provide pre-built binaries to install via
packaging tools (e.g. <code>apt install</code> or <code>yum install</code>).</p>
<p>To keep things simpler and to ensure maximum compatibility, these pre-built
binaries are built such that they run on as many computers as possible.
Currently, many Linux distributions (including RHEL and Debian) have binary
compatibility with the <em>first</em> x86_64 processor, the AMD K8, launched in 2003.
These processors featured <em>modern</em> instruction sets, like MMX, 3DNow!, SSE,
and SSE2.</p>
<p>What this means is that by default, binaries provided by many Linux
distributions won't contain instructions from modern Instruction Set
Architectures (ISAs). No SSE4. No AVX. No AVX2. And more. (Well,
technically binaries can contain newer instructions. But they likely won't
be in default code paths and there will likely be run-time dispatching
code to opt into using them.)</p>
<p>Furthermore, C/C++ compilers (like Clang and GCC) will also target an
ancient x86_64 microarchitecture level by default (this is where the
distribution's binary compatibility defaults come from). So if you compile
your own code and don't specify settings like <code>-march</code> or <code>-mtune</code> to
change the default targeting settings, your compiled binaries won't
leverage SSE4, AVX, etc. You can still force your application to emit
these instructions in dynamic code paths without <code>-march</code>/<code>-mtune</code>
overrides. But you have to opt in and add additional code complexity to
do that.</p>
<p>Because of the conservative microarchitecture targeting settings of compilers
and distribution binaries by extension, that's nearly 20 years of ISA work
and efficiency gains from more powerful ISAs (like superlinear vectorized
instructions) left on the table. And here I get frustrated when my PRs linger
unreviewed for more than a day. Imagine what it is like to be an AMD or
Intel engineer and have your ISA work take ~decades to be adopted at scale!</p>
<p>Truth be told, I'm unsure how much of a performance impact this ISA
backwards compatibility sacrifices. It will vary heavily from workload
to workload. But I have no doubt there are some very large datacenters
running CPU intensive workloads that could see massive efficiency gains
by leveraging modern ISAs. If you are running thousands of servers and your
CPU load isn't coming from a JIT'ed language like Java (JITs can emit
instructions for the machine they are running on... because they compile
<em>just in time</em>), it might very well be worth compiling CPU heavy packages
(and their dependencies of course) from source targeting a modern
microarchitecture level so you don't leave the benefits of modern ISAs on
the table. And be forewarned: use of modern ISAs isn't a silver bullet!
Some instructions can actually result in the CPU underclocking in order to
run them, making code using those instructions fast but other code slow.</p>
<p>Maintaining binary compatibility with a vanishingly small number of ancient
CPUs at the expense of performance on modern CPUs seems... questionable.
Fortunately, Linux distributions and Clang/GCC are paying attention.</p>
<p>GCC 11 and Clang 12 define <code>x86_64-{v2, v3, v4}</code> architecture levels targeting
~Nehalem (released 2008), ~Haswell (released 2013), and AVX-512 (~2015),
respectively. So you can add e.g. <code>-march=x86_64-v3</code> to target Haswell era
and newer and have the compiler emit SSE4, AVX, AVX2, and other modern
instructions.</p>
<p>RHEL9 will be raising their minimum architecture requirement from
<code>x86_64</code> to <code>x86_64-v2</code>, effectively requiring CPUs from 2008+ instead of 2003+.</p>
<p>If you'd like to learn more about this topic, start at
<a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=RHEL-9-x86-64-v2-Plans">this Pharonix article</a>
and follow the links to other articles and mailing list discussions.</p>
<p>It's worth noting that at the time I write this, AWS 4th generation EC2 instances
(<code>c4</code>, <code>m4</code>, and <code>r4</code>) all support AVX2 and I believe are compatible with
GCC/Clang's <code>x86_64-v3</code> target. And 5th generation Intel instances have AVX-512,
presumably making them compatible with <code>x86_64-v4</code>. So even if your distribution
targets <code>x86_64-v2</code>, there is still potential <em>free</em> performance from newer ISAs on
the table.</p>
<p>If I were operating a server fleet consisting of thousands of machines,
I would be very tempted to compile all packages from source targeting a modern
microarchitecture level. This would be costly in terms of complexity. But
for some workloads, the performance gains could be worth the effort. And
this conservative targeting approach <em>may</em> provide justification for running
modern-optimized Linux distributions or cloud vendor specific Linux
distributions (e.g. Amazon Linux). I'm unsure if distributions like Amazon
Linux take advantage of this. If not, they should look into it!</p>
<p>Read the next section for an example of where failure to leverage modern
ISAs translates to a performance loss.</p>
<h1>Many Implementations of Myers Diff and Other Line Based Diffing Algorithms</h1>
<p>This one is rather domain specific but I find it an illustrious example
because the behavior is quite counter-intuitive!</p>
<p>Various classes of software need to take two text documents and emit
a textual <em>diff</em> of their contents. Think what <code>git diff</code> displays.</p>
<p>There are various algorithms for generating a diff of text. Myers Diff
is probably the most famous. The run-time of the algorithms is proportional
to the number of lines. Probably <code>O(nlog(n))</code> or <code>O(n^2)</code>.</p>
<p>These text-based diffing algorithms often operate at the line level (rather than
say the byte or codepoint level) because it drastically limits the search
space and minimizes <code>n</code> to keep the algorithm run-time in check.</p>
<p>Over the years, various people have realized that when diffing two text
documents, large parts of the inputs are often identical (why would you diff
unrelated content after all). So most implementations of diff algorithms have
a myriad of <em>optimizations</em> to limit the number of lines compared. Two common
optimizations are to identify and exclude the common prefix and suffix of the
input.</p>
<p>This is over-simplified, but text-based diffing algorithms often do the
following:</p>
<ol>
<li>Split the input into lines.</li>
<li>Hash each line to facilitate fast line equivalence testing (comparing a
   <code>u32</code> or <code>u64</code> checksum is a <strong>ton</strong> faster than <code>memcmp()</code> or <code>strcmp()</code>).</li>
<li>Identity and exclude common prefix and suffix lines.</li>
<li>Feed remaining lines into diffing algorithm.</li>
</ol>
<p>The idea is that steps 1-3 - which should be <code>O(n)</code> - reduce work for an
algorithm (step 4) with run-time complexity worse than <code>O(n)</code>. Sounds good
on paper.</p>
<p>So what actually happens?</p>
<p>If you profile a number of these diff implementations, you find that steps
1-3 actually take <em>more</em> time than the supposedly slow/expensive algorithm!
How can this be?!</p>
<p>One culprit is the line splitting. Even assuming we can use memory 0-copy /
references for storing the line contents (as opposed to allocating a new
string to hold each parsed line, which can be much less efficient), splitting
text into lines can be grossly inefficient!</p>
<p>There are various reasons for this. Maybe you are decoding the text into
code points rather than operate in the domain of bytes (you shouldn't need
to decode the entire input to search for newlines). Maybe you are traversing
the file one character/byte at a time looking for LF.</p>
<p>An efficient solution to this problem employs the use of vectorized CPU
instructions (like AVX/AVX2) which can scan several bytes at a time looking
for a sentinel value or matching a byte mask. So instead of 1 instruction
per input byte, you have 1/n. Your C runtime library probably has assembly
implementations of <code>memchr()</code>, <code>strchr()</code>, and similar functions and
automatically chooses the newest/fastest assembly/instructions supported
by the run-time CPU (glibc does).</p>
<p>In theory, compilers recognize such patterns and emit modern vectorized
instructions automagically. In reality, because the default target ISA of
compilers is relatively ancient compared to what your CPU is capable of
(see previous section), you are stuck with <em>old</em> instructions and linear
scanning. Your best bet is to stick with functions in the C runtime that
are probably backed by assembly. (Although watch out for function call
overhead.)</p>
<p>Another culprit causing inefficiency is hashing each line. The hashing is
performed to reduce equivalence testing to a <code>u32</code>/<code>u64</code> compare rather than
<code>strcmp()</code>. Many implementations don't seem to give much consideration to
the hashing algorithm, using something like crc32 or djb2. An inefficiency here
is many older hashing algorithms operate at the byte level: you need to feed in
1 byte at a time, update state (XOR if often employed), then feed in the next
byte. This is inefficient because it throws away the instruction pipelining
and superscalar properties of modern CPUs. A better approach is to use a
hashing algorithm that digests 4, 8, or more bytes at a time. Again, this
lowers run-time from <em>~n</em> cycles per byte to <em>~1/n</em>.</p>
<p>Another common inefficiency is computing the lines and hashes of content in
the common prefix and suffix. Use of <code>memcmp()</code> (or even better: hand-rolled
assembly to give you the offset of the first divergence) is more efficient, as
again, your C runtime library probably has assembly implementations of
<code>memcmp()</code> which can compare input at near native memory speed.</p>
<p>I quite enjoy this example because it demonstrates that something that is
seemingly <code>O(n)</code> is slower than <code>O(nlog(n))</code>/<code>O(n^2)</code>. This is because often
the result of the optimization reduces the <code>n</code> of the expensive algorithm to
such a small value that the computational complexity is trivial. Compilers
targeting ancient microarchitectures and failing to leverage vectorized
instructions which unlock superlinear performance further shift the time
towards the <code>O(n)</code> optimizations.</p>
<h1>Conclusion</h1>
<p>Computers and software can be surprisingly slow for surprising reasons. While
this post was long and touched on a number of topics, it only scratched the
surface of potential topics. I could easily find another 10 topics to write
about. But that will have to be for another post.</p>
<p>Before I go, if you find inaccuracies in this post, please shoot me an email
(address in resume in site header) so I can correct the post, as I don't want
to unintentionally mislead others.</p>
<p>Also, computers and software are complex. When it comes to performance and
optimizations, always be measuring. The issues I described could be manifesting
in your software and environments but the effort to address them may not be worth
the reward. Computers and software, like life, are full of trade-offs.
Performance is just one trade-off. Please don't cargo cult my advice without
measuring and applying critical thinking first.</p>

  </div>
</div>



  <hr class="interblog" />
  
<div class="blog_post">
  <a name="announcing-the-0.9-release-of-pyoxidizer"></a>
  <h2 class="blog_post_title"><a href="/blog/2020/10/18/announcing-the-0.9-release-of-pyoxidizer" rel="bookmark" title="Permanent Link to Announcing the 0.9 Release of PyOxidizer">Announcing the 0.9 Release of PyOxidizer</a></h2>
  <small>October 18, 2020 at 10:00 PM | categories: 

<a href='/blog/category/python'>Python</a>, <a href='/blog/category/pyoxidizer'>PyOxidizer</a>
</small><p/>
  <div class="post_prose">
    
  <p>I have decided to make up for the 6 month lull between PyOxidizer's
0.7 and 0.8 releases by releasing
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/">PyOxidizer</a> 0.9 just 1 week
after 0.8!</p>
<p>The full 0.9 changelog is found
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/history.html#version-0-9-0">in the docs</a>.
First time user? See the
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/getting_started.html">Getting Started</a>
documentation.</p>
<p>While the 0.9 release is far smaller in terms of features compared to 0.8,
it is an important release because of progress closing compatibility gaps.</p>
<h2>Build a <code>python</code> Executable</h2>
<p>PyOxidizer 0.8 quietly shipped the ability to build executables that
behave like <code>python</code> executables via enhancements to the configurability of
embedded Python interpreters.</p>
<p>PyOxidizer 0.9 made some minor changes to make this scenario work better
and there is even
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/packaging_python_executable.html">official documentation</a>
on how to achieve this. So now you can emit a <code>python</code> executable next to your
application's executable. Or you could use PyOxidizer to build a highly portable,
self-contained <code>python</code> executable and ship your Python scripts next to it,
using PyOxidizer's <code>python</code> in your <code>#!</code>.</p>
<h2>Support Packaging Files as Files for Maximum Compatibility</h2>
<p>There is a long-tail of Python packages that don't <em>just work</em> with
PyOxidizer. A subset of these packages don't work because of bugs with how
PyOxidizer attempts to classify files as specific types of Python resources.</p>
<p>The way that normal Python works is you materialize a bunch of files on
the filesystem and at run-time the filesystem-based importer <code>stat()</code>s a
bunch of paths until it finds a candidate file satisfying the <code>import</code>
request. This works of course. But it is inefficient. Since PyOxidizer has
awareness of every resource being packaged at build time, it attempts to
index all known resources and serialize them to an efficient data structure
so finding and loading a resource can be extremely quick (effectively just a
hashmap lookup in Rust code to resolve the memory address of data).</p>
<p>PyOxidizer's approach does work in the majority of cases. But there are
edge cases. For example, NumPy's binary wheels have installed file paths
like <code>numpy.libs/libopenblasp-r0-ae94cfde.3.9.dev.so</code>. The <code>numpy.libs</code>
directory is not a valid Python package directory since it has a <code>.</code> and
since it doesn't have an <code>__init__.py[c]</code> file. This is a case where
PyOxidizer's code for turning files into <em>resources</em> is currently confused.</p>
<p>It is tempting to argue that file layouts like NumPy's are <em>wrong</em>. But
there doesn't seem to be any formal specification preventing the use of
such layouts. The arbiter of truth here is what Python packaging tools
accept and the current code for installing <em>wheels</em> gladly accepts file
layouts like these. So I've accepted that PyOxidizer is just going to have
to support edge cases like this. (I've captured more details about this
particular issue
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/technotes.html#ambiguous-file-classification">in the docs</a>).</p>
<p>Anyway, PyOxidizer 0.9 ships a new, simpler mode for handling files:
<em>files mode</em>. In <a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/packaging_resources.html#classified-resources-versus-files">files mode</a>,
PyOxidizer disables its code for <em>classifying</em> files as typed Python
resources (like module sources and extension modules) and instead treats
a file as... a file.</p>
<p>When in files mode, actions that invoke Python packaging tools return
files objects instead of classified resources. If you then add these files
for packaging, those files are materialized on the filesystem next to your
built executable. You can then use Python's standard filesystem importer
to load these files at run-time.</p>
<p>This allows you to use PyOxidizer with packages like NumPy that were
previously incompatible due to bugs with file/resource classification.
In fact, getting NumPy working with PyOxidizer is
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/packaging_additional_files.html#installing-unclassified-files-on-the-filesystem">now in the official documentation</a>!</p>
<p><em>Files mode</em> is still in its infancy. There exists code for embedding
files data in the produced executable. I plan to eventually teach PyOxidizer's
run-time code to extract these embedded files to a temporary directory,
SquashFS FUSE filesystem, etc. This is the approach that other Python
packaging tools like PyInstaller and XAR use. While it is less efficient, this
approach is highly compatible with Python code in the wild since you sidestep
issues with <code>__file__</code> and other assumptions about installed file layouts. So
it makes sense for PyOxidizer to provide support for this so you can still
achieve the friendliness of a self-contained executable without worrying
about compatibility. Look for improvements to <em>files mode</em> in future releases.</p>
<p>And to help debug issues with PyOxidizer's file handling and resource
classification, the new
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/managing_projects.html#debugging-resource-scanning-and-identification-with-find-resources">pyoxidizer find-resources</a>
command can be used to invoke PyOxidizer's code for scanning and classifying
files. Hopefully this makes it easier to diagnose bugs in this critical
component of PyOxidizer!</p>
<h2>Some Important Bug Fixes</h2>
<p>PyOxidizer 0.8 shipped with some pretty annoying bugs and behavior quirks.</p>
<p>The ability to set custom <code>sys.path</code> values via Starlark was broken. How I
managed to ship that, I'm not sure. But it is fixed in 0.9.</p>
<p>Another bug I can't believe I shipped was
the <code>PythonExecutable.read_virtualenv()</code> Starlark method being broken due to
a typo. You can read from virtualenvs again in PyOxidizer 0.9.</p>
<p>Another important improvement is in the default Python interpreter
configuration. We now automatically initialize Python's locales configuration
by default. Without this, the encoding of filesystem paths and <code>sys.argv</code> may
not have been correct. If someone passed a non-ASCII argument, the Python <code>str</code>
value was likely mangled. PyOxidizer built binaries should behave reasonably
by default now. The <a href="https://github.com/indygreg/PyOxidizer/issues/294">issue</a>
is a good read if the subtle behaviors of how encodings work in Python and on
different operating systems is interesting to you.</p>
<h2>Better Binary Portability Documentation</h2>
<p>The documentation on
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/packaging_binary_compatibility.html">binary portability</a>
has been overhauled. Hopefully it is much more clear about the capabilities
of PyOxidizer to produce a binary that <em>just works</em> on other machines.</p>
<p>I eventually want to get PyOxidizer to a point where users don't have to
think about binary portability. But until PyOxidizer starts generating
installers and providing the ability to run builds in deterministic and
reproducible environments, it is sadly a problem that is being externalized
to end users.</p>
<h2>In Conclusion</h2>
<p>PyOxidizer 0.9 is a small release representing just 1 week of work. But
it contains some notable features that I wanted to get out the door.</p>
<p>As always, please report any issues or feedback in the
<a href="https://github.com/indygreg/PyOxidizer/issues/new">GitHub issue tracker</a>
or the <a href="https://groups.google.com/forum/#!forum/pyoxidizer-users">users mailing list</a>.</p>

  </div>
</div>



  <hr class="interblog" />
  
<div class="blog_post">
  <a name="announcing-the-0.8-release-of-pyoxidizer"></a>
  <h2 class="blog_post_title"><a href="/blog/2020/10/12/announcing-the-0.8-release-of-pyoxidizer" rel="bookmark" title="Permanent Link to Announcing the 0.8 Release of PyOxidizer">Announcing the 0.8 Release of PyOxidizer</a></h2>
  <small>October 12, 2020 at 12:45 AM | categories: 

<a href='/blog/category/python'>Python</a>, <a href='/blog/category/pyoxidizer'>PyOxidizer</a>
</small><p/>
  <div class="post_prose">
    
  <p>I am very excited to announce the 0.8 release of
<a href="https://pyoxidizer.readthedocs.io/en/stable/">PyOxidizer</a>, a modern
Python application packaging tool. You can find the full changelog
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/history.html">in the docs</a>.
First time user? See the
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/getting_started.html">Getting Started</a>
documentation.</p>
<p>Foremost, I apologize that this release took so long to publish (0.7 was
released on 2020-04-09). I fervently believe that frequent releases are
a healthy software development practice. And 6 months between PyOxidizer
releases was way too long. Part of the delay was due to world events
(it has proven difficult to focus on... anything given a global pandemic,
social unrest, and wildfires further undermining any resemblance of
lifestyle normalcy in California). Another contributing factor was I was
waiting on a few 3rd party Rust crates to have new versions published to
crates.io (you can't release a crate to crates.io unless all your
dependencies are also published there).</p>
<p>Release delay and general life hardships aside, the 0.8 release is here
and it is full of notable improvements!</p>
<h2>Python 3.8 and 3.9 Support</h2>
<p><strong>PyOxidizer 0.8 now targets Python 3.8 by default and support for Python
3.9 is available</strong> by tweaking configuration files. Previously, we only
supported Python 3.7 and this release drops support for Python 3.7. I feel
a bit bad for dropping compatibility. But Python 3.8 introduced a
<a href="https://docs.python.org/3/c-api/init_config.html">new C API</a> for initializing
Python interpreters (thank you Victor Stinner!) and this makes PyOxidizer's
run-time code for interfacing with Python interpreters vastly simpler.
I decided that given the beta nature of PyOxidizer, it wasn't worth
maintaining complexity to continue to support Python 3.7. I'm optimistic
that I'll be able to support Python 3.8 as a baseline for a while.</p>
<h1>Better Default Packaging Settings</h1>
<p>PyOxidizer started as a science experiment of sorts to see if I could
achieve the elusive goal of producing a single file executable providing
a Python application. I was successful in proving this hypothesis. But the
cost to achieving this outcome was rather high in terms of end-user
experience: in order to produce single file executables, you had to break
a lot of assumptions about how Python typically works and this in turn broke
a lot of Python code and packages in the wild.</p>
<p>In other words, <strong>PyOxidizer's opinionated defaults of producing a single file
executable were externalizing hardship on end-users and preventing them from
using PyOxidizer.</strong></p>
<p>PyOxidizer 0.8 contains a handful of changes to defaults that should hopefully
lessen the friction.</p>
<p>On Windows, the default Python distribution now has a more traditional
build configuration (using <code>.pyd</code> extension modules and a <code>pythonXY.dll</code>
file). <strong>This means that PyOxidizer can consume pre-built extension modules
without having to recompile them from source.</strong> If you publish a Windows
binary wheel on PyPI, in many cases it will <em>just work</em> with PyOxidizer
0.8! (There are some notable exceptions to this, such as <em>numpy</em>, which is
doing wonky things with the location of shared libraries in wheels - but
I aim to fix this soon.)</p>
<p>Also on Windows, we no longer attempt to embed Python extension modules
(<code>.pyd</code> files) and their shared library dependencies in the produced
binary and load them from memory by default. This is because PyOxidizer's
from-memory library loader didn't work in all cases. For example, some
OpenSSL functionality used by the <code>_ssl</code> module in the standard library
didn't work, preventing Python from establishing TLS connections. The old
mode enabling you to produce a single file executable on Windows is still
available. But you have to opt in to it (at the likely cost of more
packaging and compatibility pain).</p>
<h2>Starlark Configuration Overhaul</h2>
<p>PyOxidizer 0.8 contains a <strong>ton</strong> of changes to its Starlark configuration
files. There are so many changes that you may find it easier to port to
PyOxidizer 0.8 by creating a new configuration file rather than attempting
to port an existing one.</p>
<p>I apologize for this churn and recognize it will be disruptive. However,
this churn needed to happen for various reasons.</p>
<p>Much of the old Starlark configuration semantics was rooted in the days
when configuration files were static TOML files. Now that configuration
files provide the power of a (Python-inspired) programming language, we
are free to expose much more flexibility. But that flexibility requires
refactoring things so the experience feels more <em>native</em>.</p>
<p>Many changes to Starlark were rooted in necessity. For example,
the methods for invoking <code>setup.py</code> or <code>pip install</code> used to live on a
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/config_type_python_distribution.html">Python distribution type</a>
and have been moved to a
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/config_type_python_executable.html">type representing executables</a>.
This is because the binary we are targeting influences how
packaging actions behave. For example, if the binary only supports
loading resources from memory (as opposed to standalone files), we need
to know that when invoking the packaging tool so we can produce files
(notably Python extension modules) compatible with the destination.</p>
<p>A major change to Starlark in 0.8 is around resource location handling.
Before, you could define a static string denoting the <em>resources policy</em>
for where things should be placed. And there were 10+ methods for
adding different resource types (source, bytecode, extensions, package
data) to different load locations (memory, filesystem). This mechanism
is vastly simplified and more powerful in PyOxidizer 0.8!</p>
<p>In PyOxidizer 0.8, there is a single
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/config_type_python_executable.html#pythonexecutable-add-python-resource">add_python_resource()</a>
method for adding a resource to a binary and the Starlark objects you add
can denote where they should be added by
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/config_resource_add_attributes.html">defining attributes on those objects</a>.</p>
<p>Furthermore, you can
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/packaging_resources.html#using-callbacks-to-influence-resource-attributes">define a Starlark function</a>
that is called when resource objects are created to apply custom packaging
<em>rules</em> using custom Starlark code defined in your PyOxidizer config file.
So rather than having everyone try to abide by a few pre-canned <em>policies</em> for
packaging resources, you can define a proper function in your config file
that can be as complex as you want/need it to be! I feel this is vastly simpler
and more powerful than implementing a custom DSL in static configuration files
(like TOML, JSON, YAML, etc).</p>
<p>While the ability to implement your own arbitrarily complex packaging
policies is useful, there is a new
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/config_type_python_packaging_policy.html">PythonPackagingPolicy</a>
Starlark type with enough flexibility to suit most needs.</p>
<h2>Shipping <code>oxidized_importer</code></h2>
<p>During the development of PyOxidizer 0.8, I broke out the custom
Rust-based Python <em>meta-path importer</em> used by PyOxidizer's run-time code
into a standalone Python package. This sub-project is called
<code>oxidized_importer</code> and I previously
<a href="/blog/2020/05/10/using-rust-to-power-python-importing-with-oxidized_importer/">blogged about it</a>.</p>
<p>PyOxidizer 0.8 ships <code>oxidized_importer</code> and all of its useful APIs
available to Python. Read more in the
<a href="https://pyoxidizer.readthedocs.io/v0.8.0/latest/oxidized_importer.html">official docs</a>.
The new Python APIs should make debugging issues with PyOxidizer-packaged
applications vastly simpler: I found them invaluable when tracking down
user-reported bugs!</p>
<h2>Tons of New Tests and Refactored Code</h2>
<p>PyOxidizer was my first non-toy Rust project. And the quality of the Rust
code I produced in early versions of PyOxidizer clearly showed it. And when I
was in the rapid-prototyping phase of PyOxidizer, I eschewed writing tests
in favor of short-term progress.</p>
<p>PyOxidizer 0.8 pays down a ton of technical debt in the code base. Lots of
Rust code has been refactored and is using somewhat reasonable practices.
I'm not yet a Rust guru. But I'm at the point where I cringe when I look at
some of the early code I wrote, which is a good sign. I do have to say that
Rust has been a dream to work with during this transition. Despite being a
low-level language, my early <em>misuse</em> of Rust did not result in crashes like
you would see in languages like C/C++. And Rust's seemingly omniscient compiler
and IDE tools facilitating refactoring have ensured that code changes aren't
accompanied by subtle random bugs that would occur in dynamic programming
languages. I really need to write a dedicated post espousing the virtues of
Rust...</p>
<p>There are a <strong>ton</strong> of new tests in PyOxidizer 0.8 and I now feel somewhat
confident that the <code>main</code> branch of PyOxidizer should be considered
<em>production-ready</em> at any time assuming the tests pass. This will hopefully
lead to more rapid releases in the future.</p>
<p>There are now tests for the <code>pyembed</code> Rust crate, which provides the
run-time code for PyOxidizer-built binaries. We even have
<a href="https://github.com/indygreg/PyOxidizer/tree/main/pyembed/src/test">Python-based unit tests</a>
for validating the Python-exposed APIs behave as expected. These tests have
been invaluable for ensuring that the run-time code works as expected. So now
when someone files a bug I can easily write a test to capture it and keep
the code working as intended through various refactors.</p>
<p>The packaging-time Rust code has also gained its fair share of tests.
We now have fairly comprehensive test coverage around how resources
are added/packaged. Python extension modules have proved to be highly
nuanced in how they are handled. Tremendously helping testing of extension
modules is that we're able to run tests for platform non-native extensions!
While not yet exposed/supported by Starlark configuration files, <strong>I've taught
PyOxidizer's core Rust code to be cross-compiling aware</strong> so that we can
e.g. test Windows or macOS behavior from Linux. Before, I'd have to test
Windows wheel handling on Windows. But after writing a wheel parser in Rust
and teaching PyOxidizer to use a different Python distribution for the
host architecture from the target architecture, I'm now able to write
tests for platform-specific functionality that run on any platform that
PyOxidizer can run on. This <em>may</em> eventually lead to proper cross-compiling
support (at least in some configuration). Time will tell. But the foundation
is definitely there!</p>
<h2>New Rust Crates</h2>
<p>As part of the aforementioned refactoring of PyOxidizer's Rust code, I've
been extracting some useful/generic functionality built as part of
developing PyOxidizer to their own Rust crates.</p>
<p>As part of this release, I'm publishing the initial 0.1 release of the
<a href="https://crates.io/crates/python-packaging">python-packaging</a> crate
(<a href="https://docs.rs/python-packaging/0.1.0/python_packaging/">docs</a>). This crate
provides pure Rust code for various Python <em>packaging</em> related functionality.
This includes:</p>
<ul>
<li>Rust types representing Python resource types (source modules, bytecode
  modules, extension modules, package resources, etc).</li>
<li>Scanning the filesystem for Python resource files .</li>
<li>Configuring an embedded Python interpreter.</li>
<li>Parsing <code>PKG-INFO</code> and related files.</li>
<li>Parsing wheel files.</li>
<li>Collecting Python resources and serializing them to a data structure.</li>
</ul>
<p>The crate is somewhat PyOxidizer centric. But if others are interested
in improving its utility, I'll happily accept pull requests!</p>
<p>PyOxidizer's crates footprint now includes:</p>
<ul>
<li><a href="https://crates.io/crates/python-packed-resources">python-packed-resources</a></li>
<li><a href="https://crates.io/crates/python-packaging">python-packaging</a></li>
<li><a href="https://crates.io/crates/pyembed">pyembed</a></li>
<li><a href="https://crates.io/crates/pyoxidizer">pyoxidizer</a></li>
</ul>
<h2>Major Documentation Updates</h2>
<p>I strongly believe that software should be documented thoroughly and I strive
for PyOxidizer's documentation to be useful and comprehensive.</p>
<p>There have been a lot of changes to PyOxidizer's documentation since the
0.7 release.</p>
<p>All <a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/config.html">configuration file documentation</a>
has been consolidated.</p>
<p>Likewise, I've attempted to consolidate a lot of the <em>paved road</em> documentation
for how to use PyOxidizer in the
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/packaging.html">Packaging User Guide</a>
section of the docs.</p>
<p>I'll be honest, since I have so much of PyOxidizer's workings internalized,
it can be difficult for me to empathize with PyOxidizer's users. So if you
have difficult with the <em>readability</em> of the documentation, please
<a href="https://github.com/indygreg/PyOxidizer/issues/new">file an issue</a> and report
what is confusing so the documentation can be improved!</p>
<h2>Mercurial Shipping With PyOxidizer 0.8</h2>
<p>PyOxidizer is arguably an epic yak shave of mine to help the
<a href="https://www.mercurial-scm.org/">Mercurial version control tool</a> transition
to Python 3 and Rust.</p>
<p>I'm pleased to report that Mercurial is
<a href="https://www.mercurial-scm.org/pipermail/mercurial/2020-October/052395.html">now shipping</a>
PyOxidizer-built distributions on Windows as of the 5.2.2 release a few days
ago! If a complex Python application like Mercurial can be
<a href="https://www.mercurial-scm.org/repo/hg/file/0627cd03b1e9/rust/hgcli/pyoxidizer.bzl">configured</a>
to work with PyOxidizer, chances are your Python application will work as
well.</p>
<h2>Whats Next</h2>
<p>I view PyOxidizer 0.8 as a pivotal release where PyOxidizer is turning the
corner from a prototyping science experiment to something more generally
usable. The investments in test coverage and refactoring of the Rust
internals are paving the way towards future features and bug fixes.</p>
<p>In upcoming releases, I'd like to close remaining known compatibility
gaps with popular Python packages (such as <em>numpy</em> and other packages in
the <em>scientific/data</em> space). I have a general idea of what work needs to
be done and I've been laying the ground work via various refactorings to
execute here.</p>
<p><strong>I want a general theme of future releases to be eliminating reasons why
people can't use PyOxidizer.</strong> PyOxidizer's historical origin was as a
science experiment to see if single file Python applications were possible.
It is clear that achieving this is fundamentally incompatible with
compatibility with tons of Python packages in the wild. I'd like to find a
way where PyOxidizer can achieve 99% package compatibility by default
so new users don't get discouraged when using PyOxidizer. And for the
subset of users who want single file executables, they can spend the
magnitude of additional effort to achieve that.</p>
<p>At some point, I also want to make a pivot towards focusing on producing
distributable artifacts (Debian/RPM packages, MSI installers, macOS DMG
files, etc). I'm slightly bummed that I haven't made much progress here.
But I have a vision in my mind of where I want to go (I'll be making
a standalone Rust crate + Starlark dialect to facilitate producing
distributable artifacts for <em>any</em> application) and I'm anticipating
starting this work in the next few months. In the mean time, PyOxidizer
0.8 should be able to give people a directory tree that they can coerce
into distributable artifacts using existing packaging tooling. That's not as
turnkey as I would like it to be. But the technical problems around
building a distributable Python application binary still needs some work
and I view that as the most pressing need for the Python ecosystem. So
I'll continue to focus there so there is a solid foundation to build upon.</p>
<p>In conclusion, I hope you enjoy the new release! Please report any issues
or feedback in the
<a href="https://github.com/indygreg/PyOxidizer/issues/new">GitHub issue tracker</a>.</p>

  </div>
</div>



  <hr class="interblog" />
  
<div class="blog_post">
  <a name="using-rust-to-power-python-importing-with-oxidized_importer"></a>
  <h2 class="blog_post_title"><a href="/blog/2020/05/10/using-rust-to-power-python-importing-with-oxidized_importer" rel="bookmark" title="Permanent Link to Using Rust to Power Python Importing With oxidized_importer">Using Rust to Power Python Importing With oxidized_importer</a></h2>
  <small>May 10, 2020 at 01:15 PM | categories: 

<a href='/blog/category/python'>Python</a>, <a href='/blog/category/pyoxidizer'>PyOxidizer</a>
</small><p/>
  <div class="post_prose">
    
  <p>I'm pleased to announce the availability of the <code>oxidized_importer</code>
Python package, a standalone version of the custom Python module importer
used by <a href="https://github.com/indygreg/PyOxidizer">PyOxidizer</a>.
<code>oxidized_importer</code> - a Python extension module implemented in Rust - enables
Python applications to start and run quicker by providing an alternate,
more efficient mechanism for loading Python resources (such as source
and bytecode modules).</p>
<p>Installation instructions and detailed usage information are available
<a href="https://pyoxidizer.readthedocs.io/en/oxidized_importer-0.1/oxidized_importer.html">in the official documentation</a>.
The rest of this post hopefully answers the questions of <em>why are you doing
this</em> and <em>why should I care</em>.</p>
<p>In a traditional Python process, Python's module importer inspects the
filesystem at run-time to find and load resources like Python source and
bytecode modules. It is highly dynamic in nature and relies on the filesystem
as a point-in-time source of truth for resource availability.</p>
<p><code>oxidized_importer</code> takes a different approach to resource loading that is
more static in nature and more suitable to application environments (where
Python resources aren't changing). Instead of dynamically probing the
filesystem for available resources, resources are instead <em>indexed</em> ahead
of time. When Python goes to resolve a resource (say it is looking to
<code>import</code> a module), <code>oxidized_importer</code> simply needs to perform a lookup
in an in-memory data structure to locate said resource. This means
<code>oxidized_importer</code> only has marginal reliance on the filesystem, <strong>which
can make it much faster than Python's traditional importer</strong>. (Performance
benefits of binaries built with PyOxidizer have already been
<a href="https://pyoxidizer.readthedocs.io/en/oxidized_importer-0.1/packaging_performance.html">clearly demonstrated</a>.)</p>
<p>The <code>oxidized_importer</code> Python extension module exposes parts of
PyOxidizer's packaging and run-time functionality to Python code, <strong>without
requiring the full use of PyOxidizer for application packaging</strong>.
Specifically, <code>oxidized_importer</code> allows you to:</p>
<ul>
<li>Install a custom, high-performance module importer
  (<a href="https://pyoxidizer.readthedocs.io/en/oxidized_importer-0.1/oxidized_importer_oxidized_finder.html">OxidizedFinder</a>)
  to service Python <code>import</code> statements and resource loading (potentially
  from memory, using zero-copy).</li>
<li><a href="https://pyoxidizer.readthedocs.io/en/oxidized_importer-0.1/oxidized_importer_resource_scanning.html">Scan the filesystem for Python resources</a>
  (source modules, bytecode files, package resources, distribution metadata,
  etc) and turn them into Python objects, which can be loaded into
  <code>OxidizedFinder</code> instances.</li>
<li>Serialize Python resource data into an efficient binary data structure
  for loading into an <code>OxidizedFinder</code> instance. This facilitates
  producing a standalone <em>resources blob</em> that can be distributed with
  a Python application which contains all the Python modules, bytecode,
  etc required to power that application. See the docs on
  <a href="https://pyoxidizer.readthedocs.io/en/oxidized_importer-0.1/oxidized_importer_freezing_applications.html">freezing an application with oxidized_importer</a>.</li>
</ul>
<p><code>oxidized_importer</code> can be thought of as PyOxidizer-lite: it provides just
enough functionality to allow Python application maintainers to leverage some
of the technical advancements of PyOxidizer (such as in-memory module imports)
without using PyOxidizer for application packaging. <strong><code>oxidized_importer</code> can
work with the Python distribution already installed on your system. You just
<code>pip install</code> it like any other Python package.</strong></p>
<p>By releasing <code>oxidized_importer</code> as a standalone Python package, my hope is
to allow more people to leverage some of the technical achievements and
performance benefits coming out of PyOxidizer. I also hope that having more
users of PyOxidizer's underlying code will help uncover bugs and conformance
issues, raising the quality and viability of the projects.</p>
<p>I would also like to use <code>oxidized_importer</code> as an opportunity to advance the
discourse around Python's resource loading mechanism. Filesystem I/O can be
extremely slow, especially in mobile and embedded environments. Dynamically
probing the filesystem to service module imports can therefore be slow. (The
Python standard library has the <code>zipimport</code> module for importing Python resources
from a zip file. But in my opinion, we can do much better.) <strong>I would like to
see Python move towards leveraging immutable, serialized data structures for
loading resources as efficiently as possible.</strong> After all, Python resources
like the Python standard library are likely not changing between Python process
invocations. The performance zealot in me cringes thinking of all the overhead
that Python's filesystem probing approach incurs - all of the excessive <code>stat()</code>
and other filesystem I/O calls that must be performed to answer questions about
state that is easily indexed and often doesn't change. <code>oxidized_importer</code>
represents my vision for what a high-performance Python resource loader should
look like. I hope it can be successful in steering Python towards a better
approach for resource loading.</p>
<p>I plan to release <code>oxidized_importer</code> independently from <code>PyOxidizer</code>. While
the projects will continue to be developed in the same
<a href="https://github.com/indygreg/PyOxidizer">repository</a> and will leverage the
same underlying Rust code, I view them as somewhat independent and serving
different audiences.</p>
<p>While <code>oxidized_importer</code> evolved from facilitating PyOxidizer's run-time use
cases, I'm not opposed to taking it in new directions. For example, I would
entertain implementing Python's dynamic filesystem probing logic in
<code>oxidized_importer</code>, allowing it to serve as a functional stand-in for the
official importer shipped with the Python standard library. I have little
doubt an importer implemented in 100% Rust would outperform the official
importer, which is implemented in Python. There's all kinds of possibilities
here, such as using a background thread to index <code>sys.path</code> outside the
constraints of the GIL. But I don't want to get ahead of myself...</p>
<p>If you are a Python application maintainer and want to make your Python
processes execute a bit faster by leveraging a pre-built index of available
Python resources and/or taking advantage of in-memory module importing,
I highly encourage you to take a look at <code>oxidized_importer</code>!</p>

  </div>
</div>



  <hr class="interblog" />
  
<div class="blog_post">
  <a name="pyoxidizer-0.7"></a>
  <h2 class="blog_post_title"><a href="/blog/2020/04/09/pyoxidizer-0.7" rel="bookmark" title="Permanent Link to PyOxidizer 0.7">PyOxidizer 0.7</a></h2>
  <small>April 09, 2020 at 09:00 PM | categories: 

<a href='/blog/category/python'>Python</a>, <a href='/blog/category/pyoxidizer'>PyOxidizer</a>
</small><p/>
  <div class="post_prose">
    
  <p>I am very pleased to announce the 0.7 release of
<a href="https://pyoxidizer.readthedocs.io/en/stable/">PyOxidizer</a>, a modern
Python application packaging tool.</p>
<p>There are a host of notable new features in this release. You can
read all about them in the project
<a href="https://pyoxidizer.readthedocs.io/en/stable/history.html">history</a>.</p>
<p>I want to use this blog post to call out the more meaningful ones.</p>
<p>I started PyOxidizer as a science experiment of sorts: I sat out to
prove the hypothesis that it was possible to produce high performance
single file executables embedding Python and all of its resources
(Python modules, non-module resource files, compiled extensions, etc).
PyOxidizer has achieved this on Windows, Linux, and macOS since its
very earliest releases. Hypothesis confirmed!</p>
<p>In order to actually achieve single file executables, you have to
fundamentally change aspects of Python's behavior. Some of these
changes invalidate deeply rooted assumptions about how Python works,
such as the existence of <code>__file__</code> in modules. As you can imagine,
these broken assumptions translated to numerous compatibility issues
and PyOxidizer didn't work with many popular Python packages.</p>
<p>With the science experiment phase of PyOxidizer out of the way, I
have been making a concerted effort to broaden the user base of
PyOxidizer. While single file executables can be an amazing property,
it isn't critical for many use cases and the issues it was causing
were preventing people from exploring PyOxidizer.</p>
<p>This brings us to what I think are the major new features in
PyOxidizer 0.7.</p>
<h2>Better Support for Loading Extension Modules</h2>
<p>Earlier versions of PyOxidizer insisted that you compile Python
(C) extension modules from source and statically link them into
a produced binary. This requirement prevented the use of pre-built
extension modules (commonly found in Python binary wheels available
on PyPI) with PyOxidizer, forcing people to compile them locally.
While this often <em>just worked</em> for many extension modules, it
frequently failed on complex extension modules and it frequently
failed on Windows.</p>
<p>PyOxidizer now supports loading compiled extension modules from
standalone files (typically <code>.so</code> or <code>.pyd</code> files, which are actually
shared libraries). There are still some sharp edges and known
deficiencies. But in many cases, if you tell PyOxidizer to run
<code>pip install</code> and package the result, pre-built wheels can be
installed and PyOxidizer will pick up the standalone files.</p>
<p>On Windows, PyOxidizer even supports embedding the shared library
data into the produced <code>.exe</code> and loading the <code>.pyd</code>/DLL directly
from memory.</p>
<h2>Loading Resources from the Filesystem</h2>
<p>Binaries built with PyOxidizer contain a blob holding an index
of available Python resources along with their data.</p>
<p>Earlier versions of PyOxidizer only allowed you to define resources
as <em>in-memory</em>. If the resource was defined in this blob, it was
imported from memory. Otherwise it wasn't known to PyOxidizer.
You could still install files next to the produced binary and
tell PyOxidizer to enable Python's default filesystem-based
importer. But PyOxidizer didn't explicitly know about these
files on the filesystem.</p>
<p>In PyOxidizer 0.7, the blob index of Python resources is able to
express different <em>locations</em> for that resource. Currently, a
resource can have its data made available <em>in-memory</em> or
<em>filesystem-relative</em>. <em>in-memory</em> works as before: the raw
data is embedded next to the next in memory and loaded from
there (using 0-copy). <em>filesystem-relative</em> encodes a filesystem
path to the resource. During packaging, PyOxidizer will place
the resource next to the executable (using a typical Python
file layout scheme) and store the relative path to that resource
in the resources index.</p>
<p>The <em>filesystem-relative</em> resource indexing feature has a few
implications for PyOxidizer.</p>
<p>First, it is more standard. When PyOxidizer loads a Python
module from the filesystem, it sets <code>__file__</code>, <code>__path__</code>,
etc and the module semantics should behave as if the file
were imported by Python's standard importer. This means that
if a package is having issues with <em>in-memory</em> importing, you
can simply fall back to <em>filesystem-relative</em> to get standard
Python behavior and everything should <em>just work</em>.</p>
<p>Second, PyOxidizer's filesystem resource loading is faster
than Python's! When Python's standard importer goes to
<code>import</code> a module, it needs to <code>stat()</code> various paths to
first locate the file. It then performs some sanity checking
and other minor actions before actually importing the module.
All of this has overhead. Since the goal of PyOxidizer is
to produce standalone applications and applications should
be immutable, PyOxidizer can avoid most of this overhead.
PyOxidizer simply tries to <code>open()</code> and <code>read()</code> the relative
path baked into the resource index at build time. If that
works, the resource is loaded. Else there is a failure.
The code path in PyOxidizer to locate a Python resource
is effectively a lookup in a Rust <code>HashMap&lt;&amp;str, T&gt;</code>.</p>
<p>I thought it would be interesting to isolate the performance
benefits of this new feature. I ran Mercurial's test harness
with different variants of <code>hg</code> on Linux on my Ryzen 3950X.</p>
<ul>
<li><em>traditional</em> - A <code>hg</code> script with a <code>#!/path/to/python3.7</code> shebang.</li>
<li><em>oxidized</em> - A <code>hg</code> executable built with PyOxidizer, without
  PyOxidizer's custom module importer.</li>
<li><em>filesystem</em> - A <code>hg</code> executable built with PyOxidizer using the
  new filesystem-relative resource index.</li>
<li><em>in-memory</em> - A <code>hg</code> executable built with PyOxidizer with all
  resources loaded from memory (how PyOxidizer has traditionally worked).</li>
</ul>
<p>The results are quite clear:</p>
<table border="1">
  <thead>
    <tr>
      <th>Variant</th><th>CPU Time (s)</th><th>Delta (s)</th><th>% Orig</th>
    </tr>
  </thead>
  <tbody>
    <tr><td>traditional</td><td style="text-align: right">11,287</td><td style="text-align: right">-552</td><td style="text-align: right">100</td></tr>
    <tr><td>oxidized</td><td style="text-align: right">10,735</td><td style="text-align: right">-552</td><td style="text-align: right">95.1</td></tr>
    <tr><td>filesystem</td><td style="text-align: right">10,186</td><td style="text-align: right">-1,101</td><td style="text-align: right">90.2</td></tr>
    <tr><td>in-memory</td><td style="text-align: right">9,883</td><td style="text-align: right">-1,404</td><td style="text-align: right">87.6</td></tr>
  </tbody>
</table>

<p>We see a nice win just from using a native executable built
with PyOxidizer (<em>traditional</em> to <em>oxidized</em>).</p>
<p>Then from <em>oxidized</em> to <em>filesystem</em> we see another jump of
~5%. This difference is attributed to using PyOxidizer's
Rust-powered importer with an index of resources available
on the filesystem. In other words, all that work that Python's
standard importer is doing to discover files and then operate
on them is non-trivial!</p>
<p>Finally, the smaller jump from <em>filesystem</em> to <em>in-memory</em>
isolates the benefits of importing resource data from
memory instead of involving filesystem I/O. (Filesystems
are generally slow.) While I haven't measured explicitly,
I hypothesize that macOS and Windows will see a bigger
jump between these two variants, as the filesystem
performance on these platforms generally isn't as good
as it is on Linux.</p>
<h2>PyOxidizer's Future</h2>
<p>With PyOxidizer now supporting a couple of much-needed
features to support a broader set of users, I'm hoping that
future releases of PyOxidizer continue to broaden the utility
of PyOxidizer.</p>
<p>The over-arching goal of PyOxidizer is to solve large aspects
of the Python application packaging and distribution problem.
So far a lot of focus has been spent on the former. PyOxidizer
in its current form can materialize files on the filesystem
that you can copy or package up manually and distribute. But
I want these processes to be part of PyOxidizer: I want it to
be possible for PyOxidizer to emit a Windows MSI installer, a
macOS dmg, a Debian package, etc for a Python application.</p>
<p>In order to support the aforementioned marquee features
of this PyOxidizer release, I had to pay down a lot of
technical debt in the code base left over from the science
experiment phase of PyOxidizer's inception.</p>
<p>In the short term, I plan to continue shoring up the code base
and rounding out support for features requested in the
issue tracker on GitHub. The next release of PyOxidizer will
also <a href="https://github.com/indygreg/PyOxidizer/issues/234">likely require</a>
Python 3.8, as this will improve run-time control over the
embedded Python interpreter and enable PyOxidizer to better
support package metadata (<code>importlib.metadata</code>), enabling
support for features like <em>entry points</em>.</p>
<p>I've also been thinking about extracting PyOxidizer's custom
module importer to be usable as a standalone Python extension
module. I think there's some value in publishing a
<code>pyoxidizer_importer</code> package on PyPI that you can easily
add to your installed packages to speed up Python's
standard filesystem importer by a few percent. If nothing else,
this may drum up interest in the larger Python community for
standardizing a format for serializing Python resources in a
single file. Perhaps we can get other Python packaging tools
producing the same
<a href="https://crates.io/crates/python-packed-resources">packed resources data</a>
blob that PyOxidizer uses so we can all standardize on a
more efficient mechanism for loading Python modules. Time
will tell.</p>
<p>Enjoy the new release. File issues at
<a href="https://github.com/indygreg/PyOxidizer">https://github.com/indygreg/PyOxidizer</a>
as you encounter them.</p>

  </div>
</div>



  <hr class="interblog" />
 <a href="../2">« Previous Page</a>
  --  
 <a href="../4">Next Page »</a>

              </div>
              
          <div id="sidebar">
          <ul>
            <li>
              <h2>Categories</h2>
              <ul>
                <li><a href="/blog/category/apple">Apple</a></li>
                <li><a href="/blog/category/bugzilla">Bugzilla</a></li>
                <li><a href="/blog/category/ci">CI</a></li>
                <li><a href="/blog/category/clang">Clang</a></li>
                <li><a href="/blog/category/docker">Docker</a></li>
                <li><a href="/blog/category/firefox">Firefox</a></li>
                <li><a href="/blog/category/git">Git</a></li>
                <li><a href="/blog/category/javascript">JavaScript</a></li>
                <li><a href="/blog/category/mercurial">Mercurial</a></li>
                <li><a href="/blog/category/mozreview">MozReview</a></li>
                <li><a href="/blog/category/mozilla">Mozilla</a></li>
                <li><a href="/blog/category/personal">Personal</a></li>
                <li><a href="/blog/category/programming">Programming</a></li>
                <li><a href="/blog/category/puppet">Puppet</a></li>
                <li><a href="/blog/category/pyoxidizer">PyOxidizer</a></li>
                <li><a href="/blog/category/python">Python</a></li>
                <li><a href="/blog/category/review-board">Review Board</a></li>
                <li><a href="/blog/category/rust">Rust</a></li>
                <li><a href="/blog/category/sync">Sync</a></li>
                <li><a href="/blog/category/browsers">browsers</a></li>
                <li><a href="/blog/category/build-system">build system</a></li>
                <li><a href="/blog/category/code-review">code review</a></li>
                <li><a href="/blog/category/compilers">compilers</a></li>
                <li><a href="/blog/category/internet">internet</a></li>
                <li><a href="/blog/category/logging">logging</a></li>
                <li><a href="/blog/category/mach">mach</a></li>
                <li><a href="/blog/category/make">make</a></li>
                <li><a href="/blog/category/misc">misc</a></li>
                <li><a href="/blog/category/movies">movies</a></li>
                <li><a href="/blog/category/packaging">packaging</a></li>
                <li><a href="/blog/category/pymake">pymake</a></li>
                <li><a href="/blog/category/security">security</a></li>
                <li><a href="/blog/category/sysadmin">sysadmin</a></li>
                <li><a href="/blog/category/testing">testing</a></li>
              </ul>
            </li>
          </ul>
        </div>



              <div style="clear: both;">&nbsp;</div>
          </div>
        </div>
      </div>
      <div id="footer">
        
  <hr/>
  <p>Copyright (c) 2012- Gregory Szorc. All rights reserved. Design by <a href="http://www.freecsstemplates.org/"> CSS Templates</a>.</p>


      </div>
    </div>
  </body>
</html>





