


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
Design by Free CSS Templates
http://www.freecsstemplates.org
Released for free under a Creative Commons Attribution 2.5 License

Name       : Pollinating  
Description: A two-column, fixed-width design with dark color scheme.
Version    : 1.0
Released   : 20101114

-->
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    
  <title>Gregory Szorc's Digital Home
</title>
<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
<link rel="alternate" type="application/atom+xml" title="Atom 1.0"
href="/blog/feed/atom" />
<link rel="stylesheet" href="/style/style.css" type="text/css" />
<link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />


  </head>
  <body>
    <div id="wrapper">
      
  <div id="menu">
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="/blog/">Blog</a></li>
    <li><a href="/notes">Notes</a></li>
    <li><a href="/work.html">Work</a></li>
    <li><a href="/skills.html">Skills</a></li>
    <li><a href="/thoughts.html">Thoughts</a></li>
    <li><a href="/resume.pdf">Resume</a></li>
  </ul>
</div>


      <div id="page">
        <div id="page-bgtop">
          <div id="page-bgbtm">
              <div id="content">
                
  
<div class="blog_post">
  <a name="bugzilla-and-the-future-of-firefox-development"></a>
  <h2 class="blog_post_title"><a href="/blog/2015/01/16/bugzilla-and-the-future-of-firefox-development" rel="bookmark" title="Permanent Link to Bugzilla and the Future of Firefox Development">Bugzilla and the Future of Firefox Development</a></h2>
  <small>January 16, 2015 at 10:50 AM | categories: 

<a href='/blog/category/bugzilla'>Bugzilla</a>, <a href='/blog/category/mozilla'>Mozilla</a>, <a href='/blog/category/code-review'>code review</a>
 | <a href="http://gregoryszorc.com/blog/2015/01/16/bugzilla-and-the-future-of-firefox-development#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p><a href="https://bugzilla.mozilla.org">Bugzilla</a> has played a major role in the
Firefox development process for over 15 years. <strong>With upcoming changes
to how code changes to Firefox are submitted and reviewed, I think it is
time to revisit the central role of Bugzilla and bugs in the Firefox
development process.</strong> I know this is a contentious thing to say. Please,
gather your breath, and calmly read on as I explain why I believe this.</p>
<p>The current Firefox change process defaults to requiring a Bugzilla bug
for everything. It is rare (and from my experience frowned upon) when a
commit to Firefox doesn't reference a bug number. We've essentially made
Bugzilla and a bug prerequisites for changing anything in the Firefox
version control repository. For the remainder of this post, I'm going to
say that we <em>require</em> a bug for any change, even though that statement
isn't technically accurate. Also, when I say <em>Bugzilla</em>, I mean
<em>bugzilla.mozilla.org</em>, not the generic project.</p>
<p>Before I go on, let's boil the Firefox change process down to basics.</p>
<p>At the heart of any change to the Firefox source repository is a diff.
The diff (a representation of the differences between a set of files)
is the smallest piece of data necessary to represent a change to the
Firefox code. I argue that anything more than the vanilla diff is
overhead and could contribute to
<a href="/blog/2015/01/09/firefox-contribution-process-debt/">process debt</a>.
Now, there is some essential overhead. Version control tools supplement
diffs with metadata, such as the author, commit message, and date. Mozilla
has also instituted a near-mandatory code review policy, where changes
need to be signed off by a set of trusted individuals. I view both of
these additions to the vanilla diff as essential for Firefox development
and non-negotiable. Therefore, the bare minimum requirements for changing
Firefox code are a diff plus metadata (a commit/patch) and (almost
always) a review/sign-off. That's it. Notably absent from this list is a
Bugzilla bug. <strong>I argue that a bug is not strictly required to
change Firefox.</strong> Instead, we've instituted a near-universal policy
that we should have bugs. We've <strong>chosen</strong> to add overhead and process
debt - interaction with Bugzilla - to our Firefox change process.</p>
<p>Now, this choice to require all changes be associated with bugs has its
merits. Bugs provide excellent anchor points for historical context and
for additional information after the change has been committed and is
forever set in stone in the repository (commits are immutable in
Mercurial and Git and you can't easily attach metadata to the commit
after the fact). Bugs are great to track relationships between different
problems or units of work. Bugs can even be used to track progress
towards a large feature. Bugzilla components also provide a decent
mechanism to follow related activity. There's also a lot of tooling and
familiar process standing on top of the Bugzilla <em>platform</em>. There's a
lot to love here and I don't want diminish the importance of all these
things.</p>
<p><strong>When I look to the future, I see a world where the current, central
role of Bugzilla and bugs as part of the Firefox change process begin to
wane.</strong> I see a world where the benefits to maintaining our current
Bugzilla-centric workflow start to erode and the cost of maintaining
it becomes higher and harder to justify. You actually don't have to look
too far into the future: that world is already here and I've already
started to feel the pains of it.</p>
<p>A few days ago, I blogged about
<a href="/blog/2015/01/10/code-first-and-the-rise-of-the-dvcs-and-github/">GitHub and its code first approach to change</a>.
That post was spun off from an early draft of this post (as were the
posts about <a href="/blog/2015/01/09/firefox-contribution-process-debt/">Firefox contribution debt</a>
and <a href="/blog/2015/01/12/utilizing-github-for-firefox-development/">utilizing GitHub for Firefox development</a>).
I wanted to introduce the concept of <em>code first</em> because it is
central to my justification for changing how we do things. In summary,
<strong>code first capitalizes on the fact that any change to software
involves code and therefore puts code front and center in the change
process.</strong> (In hindsight, I probably should have used the term <em>code
centric</em>, because that's how I want people to think about things.) So
how does <em>code first</em> relate to Bugzilla and Firefox development?</p>
<p>Historically, code review has occurred in Bugzilla: upload a patch to
Bugzilla, ask for review, and someone will look at it. And, since
practically every change to Firefox requires review, you need a bug in
Bugzilla to contain that review. Thus, <strong>one way to view a bug is as a
vehicle for code review</strong>. Not every bug is <em>just</em> a code review, of
course. But a good number of them are.</p>
<p>The only constant is change. And <strong>the way Mozilla conducts code review
for changes to Firefox (and other projects) is changing</strong>. We now have
<a href="https://mozilla-version-control-tools.readthedocs.org/en/latest/mozreview.html">MozReview</a>,
a code review tool that is <em>not Bugzilla</em>. If we start accepting GitHub
pull requests, we <em>may</em> perform reviews exclusively on GitHub, another
tool that is <em>not Bugzilla</em>.</p>
<p>(Before I go on, I want to quickly point out that MozReview is nowhere
close to its final form. Parts of MozReview are pretty bad right now.
The maintainers all know this and we have plans to fix it. We'll be in
Toronto all of next week working on it. If you don't think you'll ever
use it because parts are bad today, I ask you to withhold judgement for
a few more months.)</p>
<p>In case you were wondering, the question on whether Bugzilla should
always be used for code review for Firefox has been answered and that
answer is <em>no</em>. People, including maintainers of Bugzilla, realized
that better-than-Splinter/Bugzilla code review tools exist and that
continuing to invest time to develop Bugzilla/Splinter into a
best-in-class code review tool would be better spent <em>integrating</em>
Bugzilla with an existing tool. This is why we now have a
<a href="https://www.reviewboard.org/">Review Board</a> based code review tool -
MozReview - integrated with Bugzilla. If you care about code quality and
more powerful workflows, you should be rejoicing at this because
<a href="/blog/2014/10/27/implications-of-using-bugzilla-for-firefox-patch-development/">the implementation of code review in Bugzilla does not maximize optimal outcomes</a>.</p>
<p>The world we're moving to is one where code review occurs outside of
Bugzilla. This raises an important question: <strong>if Bugzilla was being used
primarily as a vehicle for code review, what benefit and/or role should
Bugzilla play when code review is conducted outside of Bugzilla?</strong></p>
<p><strong>I posit that there are a class of bugs that won't need to exist
going forward because bugs will provide little to no value.</strong> Put
another way, I believe that a growing number of commits to the Firefox
repository won't reference bugs.</p>
<p>Come with me on a journey to the future.</p>
<p>MozReview is purposefully being designed in a code and repository
centric way. To initiate the formal process for considering a change to
code, you push to a Mercurial (or Git!) repository. This could be
directly to Mozilla's review repository. If I have my way, this could
even be kicked off by submitting a pull request on GitHub or Bitbucket.
No Bugzilla attachment uploading here: our systems talk in terms of
repositories and commits. Again, this is by design: we don't want
submitting code to Mozilla to be any harder than <em>hg push</em> or <em>git
push</em> so as to not introduce <em>process debt</em>. If you have code, you'll be
able to send it to us.</p>
<p>In the near future, MozReview will stop cross-posting detailed review
updates to Bugzilla. Instead, we'll use Review Board's e-mail feature
to send its flavor of emails. These will have rich HTML content (or
plain text if you insist) and will provide a better experience
than Bugzilla ever will. We'll adopt the model of tools like
Phabricator and GitHub and only post summaries or links of activity,
not full content, to bugs. You may be familiar with the concept as
applied to the web: it's called hyperlinking.</p>
<p>Work is being invested into Autoland. Autoland is an automated landing
queue that pushes/lands commits semi-automatically once they are ready
(have review, pass automation, etc). Think of Autoland as a bot that
does all the labor intensive and menial actions around pushing that
you do now. I believe Autoland will eventually handle near 100% of
pushes to the Firefox repository. And, if I have my way, Autoland will
result in the abolishment of <em>integration branches</em> and merge commits in
the Firefox repository. Good riddance.</p>
<p>MozReview and Autoland will be highly integrated. MozReview will be the
primary user interface for interacting with Autoland. (Some of this
should be in place by the end of the quarter.)</p>
<p>In this world, MozReview and its underlying version control repositories
essentially become a <em>database</em> of all submitted, pending, and discarded
commits to Firefox. The metaphorical <em>primary keys</em> of this <em>database</em>
are not bug numbers: they are code/commits. (Code first!) Some of the
flags stored in this <em>database</em> tell Autoland what it should do. And the
MozReview user interface (and API) provide a mechanism into controlling
those flags.</p>
<p>Landing a change in Firefox will be initiated by a simple action such as
clicking a checkbox in MozReview. (That could even be the <em>Grant Review</em>
checkbox.) Commits cleared for landing will be picked up by
Autoland and eventually automatically pushed to the Firefox repository
(assuming the build and test automation is happy, of course). Once
Autoland takes control, humans are just passengers. We won't be bothered
with menial tasks like updating the commit message to reflect a review
was performed: this will happen automatically inside MozReview or
Autoland. (Although, there's a chance we may adopt some PGP-based
signing to more strongly convey review for some code changes in order to
facilitate stronger auditing and trust guarantees. Stay tuned.)
Likewise, if a commit becomes associated with a bug, we can add that
metadata to the commit before it is landed, no human involvement
necessary beyond specifying the link in the MozReview web UI (or API).
Autoland/MozReview will close review requests and/or bugs automatically.
(Are you excited about performing less work yet?)</p>
<p>When commits are added to MozReview, <strong>MozReview will read metadata from
the repository they came from to automatically determine an appropriate
reviewer</strong>. (We <a href="https://groups.google.com/d/msg/mozilla.dev.platform/iXr70VgapWk/GkTCcKRjNi8J">plan</a>
to leverage moz.build files for this in the case of Firefox.) This
should eliminate a lot of <em>process debt</em> around choosing a reviewer.
<strong>Similar metadata will also be used to determine what Bugzilla component
a change is related to, static analysis rules to use to critique the
phsyical structure of the change, and even automation jobs that should
be executed given the set of files that changed.</strong> The use of this
metadata will erode significant <em>process debt</em> around the change
contribution workflow.</p>
<p>As commits are pushed into MozReview/Autoland, the systems will be
intelligent about automatically tracking dependencies and facilitating
complex development workflows that people run into on a daily basis.</p>
<p>If I create a commit on top of someone else's commit that hasn't been
checked in yet, MozReview will detect the dependency between
my changes and the parent ones. This is an advantage of being code
first: by interfacing with repositories rather than patch files, you
have an explicit dependency graph embedded in the repository commit DAG
that can be used to aid machines in their activities.</p>
<p>It will also be possible to partially land a series of commits. If I get
review on the first 5 of 10 commits but things stall on commit 6, I can ask
Autoland to land the already-reviewed commits so they don't get bit
rotted and so you have partial progress (psychological studies show that
a partial reward for work results in greater happiness through a sense
of accomplishment).</p>
<p>Since initiating actions in MozReview is light weight (just <em>hg push</em>),
itch scratching is encouraged. I don't know about you, but in the course
of working on the Firefox code base, I frequently find myself wanting to
make small, 15-30s changes to fix something really minor. In today's world,
the overhead for these small changes is often high. I need to upload a
separate patch to Bugzilla. Sometimes I even need to create a new bug to
hold that patch. If that patch depends on other work I did, I need to
set up bug dependencies then worry about landing everything in the right
order. All of a sudden, the overhead isn't worth it and my positive
intentions go unacted on. Multiplied by hundreds of developers over
many years, and you can imagine the effect on software quality. With
MozReview, the overhead for itch scratching like this is minor. Just
make a small commit, push, and the system will sort everything out.
(These small commits are where I think a <em>bugless</em> process really
shines.)</p>
<p>This future world revolves around code and commits and operations on
them. While <em>MozReview</em> has <em>review</em> in its name, it's more than a
review tool: it's a <em>database</em> and interface to code and its state.</p>
<p><strong>In this code first world, Bugzilla performs an ancillary role.</strong>
Bugzilla is still there. Bugs are still there. MozReview review requests
and commits <em>link</em> to bugs. But it is the code, not bugs, that are king.
If you want to do anything with code, you interact with the code
tools. And Bugzilla is not one of them.</p>
<p>Another way of looking at this is that nearly everything involving code
or commits becomes excised from Bugzilla. This would relegate Bugzilla
to, well, an issue/bug tracker. And - ta da - that's something it excels
at since that's what it was originally designed to do! MozReview will
provide an adequate platform to discuss code (a platform that Bugzilla
provides today since it hosts code review). So if <em>not Bugzilla</em>
tools are handling everything related to code, do you really need a bug
any more?</p>
<p>This is the future we're trying to build with MozReview and Autoland.
And this is why I think bugs and Bugzilla will play a less central role
in the development process of Firefox in the future.</p>
<p>Yes, there are many consequences and concerns about making this shift.
You would be rational to be skeptical and doubt that this is the right
thing to do. I have another post in the works that attempts to outline
some common conerns and propose solutions to many of them. Before writing
a long comment pointing out every way in which this will fail to work,
I encourage you to wait for that post to be published. Stay tuned.</p>

  </div>
</div>



  <div class="after_post"><a href="http://gregoryszorc.com/blog/2015/01/16/bugzilla-and-the-future-of-firefox-development#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  
<div class="blog_post">
  <a name="modern-mercurial-documentation-for-mozillians"></a>
  <h2 class="blog_post_title"><a href="/blog/2015/01/15/modern-mercurial-documentation-for-mozillians" rel="bookmark" title="Permanent Link to Modern Mercurial Documentation for Mozillians">Modern Mercurial Documentation for Mozillians</a></h2>
  <small>January 15, 2015 at 02:45 PM | categories: 

<a href='/blog/category/mercurial'>Mercurial</a>, <a href='/blog/category/mozilla'>Mozilla</a>
 | <a href="http://gregoryszorc.com/blog/2015/01/15/modern-mercurial-documentation-for-mozillians#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>Mozilla's Mercurial documentation has historically been pretty bad. The
documentation on MDN (which I refuse to link to) is horribly disjointed
and contains a lot of outdated recommendations. I've made attempts to
burn some of it to the ground, but it is just too overwhelming.</p>
<p>I've been casually creating my own Mercurial documentation tailored for
Mozillians. It's called
<a href="https://mozilla-version-control-tools.readthedocs.org/en/latest/hgmozilla/index.html">Mercurial for Mozillians</a>.</p>
<p>It started as a way to document extensions inside the
<a href="https://hg.mozilla.org/hgcustom/version-control-tools/">version-control-tools</a>
repository. But, it has since evolved to cover other topics, like how to
install Mercurial, how to develop using bookmarks, and how to interact
with a unified Firefox repository. The documentation is nowhere near
complete. But it already has some very useful content beyond what MDN
offers.</p>
<p>I'm not crazy about the idea of having generic Mercurial documentation
on a Mozilla domain (this should be part of the official Mercurial
documentation). Nor am I crazy about moving content off MDN. I'm sure
content will move to its appropriate location later. Until then,
enjoy some curated Mercurial documentation!</p>
<p>If you would like to contribute to Mercurial for Mozillians,
<a href="https://mozilla-version-control-tools.readthedocs.org/en/latest/contributing.html">read the docs</a>.</p>

  </div>
</div>



  <div class="after_post"><a href="http://gregoryszorc.com/blog/2015/01/15/modern-mercurial-documentation-for-mozillians#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  
<div class="blog_post">
  <a name="major-bzexport-updates"></a>
  <h2 class="blog_post_title"><a href="/blog/2015/01/13/major-bzexport-updates" rel="bookmark" title="Permanent Link to Major bzexport Updates">Major bzexport Updates</a></h2>
  <small>January 13, 2015 at 03:55 PM | categories: 

<a href='/blog/category/mercurial'>Mercurial</a>, <a href='/blog/category/mozilla'>Mozilla</a>
 | <a href="http://gregoryszorc.com/blog/2015/01/13/major-bzexport-updates#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>The <em>bzexport</em> Mercurial extension - an extension that enables you to
easily create new Bugzilla bugs and upload patches to Bugzilla for
review - just received some
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1033394">major updates</a>.</p>
<p>First, we now have automated test coverage of bzexport! This is built on
top of the version control test harness I
<a href="/blog/2014/10/14/robustly-testing-version-control-at-mozilla/">previously blogged about</a>.
As part of the tests, we start Docker containers that run the same code
that's running on <a href="https://bugzilla.mozilla.org/">bugzilla.mozilla.org</a>,
so interactions with Bugzilla are properly tested. This is much, much
better than mocking HTTP requests and responses because if Bugzilla
changes, our tests will detect it. Yay continuous integration.</p>
<p>Second, bzexport now uses Bugzilla' REST API instead of the legacy bzAPI
endpoint for all but 1 HTTP request. This should make BMO maintainers
very happy.</p>
<p>Third and finally, bzexport now uses shared code for obtaining Bugzilla
credentials. The behavior is
<a href="https://mozilla-version-control-tools.readthedocs.org/en/latest/hgmozilla/auth.html">documented</a>,
of course. Behavior is <strong>not backwards compatible</strong>. If you were using some
old configuration values, you will now see warnings when running bzexport.
These warnings are actionable, so I shouldn't need to describe them
here.</p>
<p>Please obtain the new code by pulling the
<a href="https://hg.mozilla.org/hgcustom/version-control-tools">version-control-tools</a>
repository. Or, if you have a Firefox clone, run <em>mach mercurial-setup</em>.</p>
<p>If you find any regressions, file a bug in the
<a href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Developer%20Services&amp;component=Mercurial%3A%20bzexport">Developers Services :: Mercurial: bzexport</a>
component and have it depend on
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1033394">bug 1033394</a>.</p>
<p>Thanks go out to Steve Fink, Ed Morley, and Ted Mielczarek for looking
at the code.</p>

  </div>
</div>



  <div class="after_post"><a href="http://gregoryszorc.com/blog/2015/01/13/major-bzexport-updates#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  
<div class="blog_post">
  <a name="utilizing-github-for-firefox-development"></a>
  <h2 class="blog_post_title"><a href="/blog/2015/01/12/utilizing-github-for-firefox-development" rel="bookmark" title="Permanent Link to Utilizing GitHub for Firefox Development">Utilizing GitHub for Firefox Development</a></h2>
  <small>January 12, 2015 at 11:00 AM | categories: 

<a href='/blog/category/mozilla'>Mozilla</a>
 | <a href="http://gregoryszorc.com/blog/2015/01/12/utilizing-github-for-firefox-development#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>Recent posts on my blog have talked about the
<a href="/blog/2015/01/09/firefox-contribution-process-debt/">difficulty submitting changes to Firefox</a>
and the <a href="/blog/2015/01/10/code-first-and-the-rise-of-the-dvcs-and-github/">rise of GitHub</a>.
I encourage you to stop reading this post and read them now if you
haven't already.</p>
<p>As I was looking at the
<a href="/blog/2015/01/09/firefox-contribution-process-debt/#list-of-process-debt">list of process debt contributing to Firefox</a>,
one thought kept creeping into my mind: <strong>how many of these items go
away if we utilize GitHub?</strong></p>
<p>As I mentioned in these two posts, GitHub's popularity has essentially
commoditized many items on this list, especially the parts around source
control and submitting patches for consideration (just fork and open a
pull request). It seems that everyone these days is on GitHub and asking
people to use GitHub to send changes to Firefox would almost certainly
be well-received by contributors and even Mozilla staff.</p>
<p>Here's what I think: <strong>Mozilla should utilize GitHub for Firefox
development.</strong></p>
<p>The verb in that sentence is important: I purposefully said <em>utilize</em>
and not something like <em>switch to</em>. <strong>To switch or not to switch to
GitHub for Firefox development is a false dillemma and a logical
fallacy.</strong> So is the question about <em>switching to Git</em>. As I explain later,
there is a spectrum of options available and <em>switching</em> or <em>not
switching</em> are on the extremes. <em>Utilize</em> doesn't preclude a binary
<em>switch</em> or <em>don't switch</em> outcome, but it does keep an array of options
on the table for consideration.</p>
<p>So, how should Mozilla <em>utilize</em> GitHub for Firefox development?</p>
<p>I think that insisting people establish Bugzilla accounts and upload
patches to Bugzilla/bugs is an anitquated practice in desperate need of
an overhaul. I think that if someone has written code, they should be
able to essentially throw it over a wall to initiate the change process.
They should be able to do this in a manner that incurs little to no
<em>process debt</em>. We, Mozilla, should be able to take only code and
integrate it into Firefox, assuming a trusted person - a module owner
or peer - agrees and grants review. <strong>GitHub pull requests would
facilitate a lesser-involved code contribution mechanism.</strong></p>
<p>Another benefit of GitHub is that the web interface goes further than
just code submission: they also have facilities for editing files. It's
possible to
<a href="https://help.github.com/articles/editing-files-in-another-user-s-repository/">edit a file in someone else's repository and create a pull request</a>
direct from the web interface! My
<a href="/blog/2015/01/09/firefox-contribution-process-debt/">post on process debt</a>
began by comparing the process of <em>edit a wiki</em> versus the current
Firefox change process. GitHub's web-based editing essentially reduces
the gap to cosmetic differences. <strong>GitHub's ease of contributing purely
via the browser would open the door to more contribution for
lesser-involved changes</strong> (sometimes referred to as <em>good first bugs</em>).</p>
<p>To state it explicitly, <strong>I support the use of GitHub pull requests for
submitting changes to Firefox</strong>.</p>
<p>Now, there are some concerns and challenges about doing this. These
include:</p>
<ul>
<li>Fragmentation of code review and tracking could be problematic for
  Mozilla staff and other highly-active individuals.</li>
<li>GitHub can lose some parts of code review after rebasing and force
  pushes. <strong>Edit: Comments below indicate this is no longer a problem.
  Great!</strong></li>
<li>You can only assign 1 reviewer per pull request.</li>
<li>GitHub sends an email/notification per review comment. This can be
  extremely annoying for some mail clients.</li>
<li>GitHub doesn't have a mechanism for dealing with security bugs.</li>
<li>Data sovereignty concerns (all data hosted on GitHub and subject to
  their data retention and access policies). Their API has query limits,
  which can limit machine use somewhat.</li>
<li>GitHub's model favors merges over rebases. Merges have a number of
  downsides, especially for large projects, and we strongly prefer to
  maintain our mostly-linear Firefox repository history.</li>
<li>GitHub's model favors appending commits rather than rewriting commits.
  (This is due to Git badness when you force push.) Mozilla favors a
  world where the final commit is what's reviewed and landed.</li>
<li>Git != Mercurial. Firefox is canonically stored in Mercurial. There is
  some impedence mismatch here. But nothing tools can't overcome.</li>
<li>The <em>Merge Pull Request</em> button is almost completely useless for
  Firefox's existing and future workflows. This partially invalidates
  other niceness the pure GitHub pull request workflow buys you.</li>
<li>Everything is lumped into a single bucket. We lose component-level
  subscriptions, making following harder.</li>
<li>Following the entire Firefox project on GitHub would produce an
  overwhelming fire hose of data.</li>
<li>We don't control GitHub and our options for extending it to extract
  even more process optimization are limited to what their APIs support
  and what they choose to implement.</li>
<li>We are at the whim of GitHub should they ever change a feature or API.</li>
<li>See also <a href="https://github.com/servo/servo/wiki/Github-challenges">Servo's list of challenges</a>.</li>
</ul>
<p>Some of these issues can be overcome by tools and automation (which I
would happily build in my capacity as a Developer Productivity Engineer
at Mozilla). Others are more fundamental and seemingly would require
buy-in and/or support from very senior Mozillians.</p>
<p>If Mozilla were to go forward utilizing GitHub pull requests for
Firefox, I think it should be done incrementally rather than going
all-in and attempting the entire GitHub workflow from the start.
Although, this would mean diverging from GitHub's well-known practices,
which would <em>increase</em> process debt from the GitHub base level. I don't
like that. But I think it is a step in the right direction. Partial
reduction in process debt is better than no reduction.</p>
<p>What do I mean by <em>incrementally</em> start accepting pull requests? Well,
<strong>I don't think code review should initially be conducted on GitHub</strong>.
When you look at the above list of concerns, many of them are around code
review and interacting with pull requests. I think there's too much
badness and risk there to make me comfortable about <em>moving</em> things to
GitHub and giving GitHub exclusive domain over this important data,
at least initially.</p>
<p>But if code review isn't conducted on GitHub, what's the value of a pull
request? <strong>A pull request would be a well-defined and well-understood
mechanism for importing data into Mozilla's systems</strong>. For example,
submitting a pull request would automatically result in the creation
of a review request on
<a href="https://mozilla-version-control-tools.readthedocs.org/en/latest/mozreview.html">MozReview</a>
or even a bug/attachment/review on Bugzilla.
This would allow people to send code to Mozilla easily while
simultaneously allowing Mozillians to use familiar tools and processes
without the aforementioned concerns with GitHub. That appears to be
win-win.</p>
<p>Once we have a simple mechanism in place for turning pull requests into
MozReview's review requests, we can start playing around with the
syncing of code review activity between Mozilla and GitHub so review
activity on either system results in cross-posting. There is precedent
for this today. <a href="http://gerrithub.io/">GerritHub</a> has bi-directional
syncing of code review activity between GitHub and Gerrit. Facebook also
does something similar, syncing data between their internal Phabricator
instance. Mozilla to GitHub sync would not be difficult: we control all
those systems and I'm pretty confident in our ability to make a GitHub API
call when a MozReview review request is updated (we already make
Bugzilla API calls, so we know this works). GitHub to Mozilla is a bit more
difficult. But, others have done it: I'm confident we can too.</p>
<p>I see bi-directional syncing of GitHub pull request / code review data
between GitHub and Mozilla as achievable and relatively free from
controversy. I think we should experiment with this sometime in 2015,
probably in Q2, once MozReview is in better condition to <em>host</em> GitHub
pull requests. Although, supporting Git in MozReview is on my Q1 goals
list, so maybe I sneak this into Q1. Time will tell.</p>
<p>At this time, I believe using GitHub for the ingestion of proposed
Firefox commits into existing Mozilla systems should be the limit of
Firefox's GitHub presence, at least as far as day-to-day development
goes. If other groups want to use GitHub more actively and they find a
way to make that work while placating everyone who cares, power to them.
But I think moving the pendulum any further toward GitHub - including
things like making GitHub the exclusive location for code review data,
utilizing GitHub Issues, and making Git[Hub] the canonical Firefox
repository - remain difficult and controverial propositions. I believe
each of these to be medium to high cost and risk with low to medium
reward. I believe it would be wise to defer these questions until we
have data about the value of GitHub pull requests for Firefox
development.</p>
<p>To summarize, I propose using GitHub pull requests as an alternate,
supported front end to the code contribution pathway. We would eliminate
a lot of <em>process debt</em> for non-Mozillians by supporting a known process.
Mozillians on the review and code submission side of the process
shouldn't have to worry about change because, well, it shouldn't matter
if a commit came from GitHub or elsewhere: it will all appear mostly
the same. I'm not saying that we will never expand our utilization
of GitHub for Firefox development beyond this scope. But I am saying
that I don't think it would be prudent to do so today.</p>
<p>And that's how and why I think Mozilla should utilize GitHub for Firefox
development.</p>
<h2>Addendum</h2>
<p>While I'm here, <strong>it's important to note that GitHub does not and will
likely never solve many items from our list of Firefox contribution
process debt</strong>. GitHub is not a build system nor a tool for running
and analyzing code and tests. We still have many, many deficiencies
and usability concerns here. We have historically under-invested in
this area and utilizing GitHub in any capacity won't address these
other issues. In addition, <strong>Firefox is a magnitude larger and more
complex than the vast majority of projects on GitHub. We will always
be burdened with the cost of our success - of coping with and
maintaining the additional complexity associated with that scale</strong>.
Firefox is <em>at least</em> the 0.1%. There's a good chance GitHub and/or many
of the amazing services associated with it (like Travis-CI) won't scale to
our needs. I'd love to be proved wrong here, but the reality is
supporting a marginal use case like Firefox likely isn't at the top of
goals for GitHub and related organizations unless it is in their
business interest (read: financial interest) to do so. One can hope that
as these companies try to capture more of the enterprise market via
offerings such as GitHub Enterprise that they invest in the features
and scalability that large projects and organizations like Mozilla and
Firefox need.</p>

  </div>
</div>



  <div class="after_post"><a href="http://gregoryszorc.com/blog/2015/01/12/utilizing-github-for-firefox-development#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  
<div class="blog_post">
  <a name="code-first-and-the-rise-of-the-dvcs-and-github"></a>
  <h2 class="blog_post_title"><a href="/blog/2015/01/10/code-first-and-the-rise-of-the-dvcs-and-github" rel="bookmark" title="Permanent Link to Code First and the Rise of the DVCS and GitHub">Code First and the Rise of the DVCS and GitHub</a></h2>
  <small>January 10, 2015 at 12:35 PM | categories: 

<a href='/blog/category/git'>Git</a>, <a href='/blog/category/mozilla'>Mozilla</a>
 | <a href="http://gregoryszorc.com/blog/2015/01/10/code-first-and-the-rise-of-the-dvcs-and-github#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>The ascendancy of GitHub has very little to do with its namesake tool,
Git.</p>
<p>What GitHub did that was so radical for its time and the strategy that
GitHub continues to execute so well on today is the approach of
putting <em>code first</em> and enabling change to be a frictionless process.</p>
<p>In case you weren't around for the pre-GitHub days or don't remember,
they were not pleasant. Tools around code management were a far cry
from where they are today (I still argue the tools are pretty bad, but
that's for another post). Centralized version control systems were
prevalent (CVS and Subversion in open source, Perforce, ClearCase,
Team Foundation Server, and others in the corporate world). Tools for
looking at and querying code had horrible, ugly interfaces and came out
of a previous era of web design and browser capabilities. It felt like
a chore to do anything, including committing code. Yes, the world
had awesome services like <a href="https://sourceforge.net/">SourceForge</a>,
but they weren't the same as GitHub is today.</p>
<p>Before I get to my central thesis, I want to highlight some supporting
reasons for GitHub's success. There were two developments in the second
half of the 2000s the contributed to the success of GitHub: the rises
of the distributed version control system (DVCS) and the modern web.</p>
<p>While distributed version control systems like Sun WorkShop TeamWare and
BitKeeper existed earlier, it wasn't until the second half of the 2000s
that DVCS systems took off. You can argue part of the reason for this
was open source: my recollection is there wasn't a well-known DVCS
available as free software before 2005. Speaking of 2005, it was a big
year for DVCS projects: Git, Mercurial, and Bazaar all had initial
releases. Suddenly, there were old-but-new ideas on how to do source
control being exposed to new and willing-to-experiment audiences. DVCS
were a critical leap from traditional version control because they
(theoretically) impose less process and workflow limitations on users.
With traditional version control, you needed to be online to commit,
meaning you were managing patches, not commits, in your local
development workflow. There were some forms of branching and merging,
but they were a far cry from what is available today and were often too
complex for mere mortals to use. As more and more people were exposed to
<em>distributed</em> version control, they welcomed its less-restrictive and
more powerful workflows. They realized that source control tools don't
have to be so limiting. <em>Distributed</em> version control also promised all
kinds of revamped workflows that could be harnessed. There were
potential wins all around.</p>
<p>Around the same time that open source DVCS systems were emerging, web
browsers were evolving from an application to render static pages to a
platform for running web <em>applications</em>. Web sites using JavaScript
to dynamically manipulate web page content (DHTML as it was known back
then) were starting to hit their stride. I believe it was GMail that
turned the most heads as to the full power of the <em>modern web</em>
experience, with its novel-for-its-time extreme reliance on
XMLHttpRequest for dynamically changing page content. People were
realizing that powerful, desktop-like applications could be built for
the web and could run everywhere.</p>
<p>GitHub launched in April 2008 standing on the shoulders of both the
emerging interest in the Git content tracking tool and the capabilities
of modern browsers.</p>
<p>I wasn't an early user of GitHub. My recollection is that GitHub was
mostly a Rubyist's playground back then. I wasn't a Ruby programmer, so
I had little reason to use GitHub in the early stages. But people did
start using GitHub. And in the spirit of Ruby (on Rails), GitHub moved
fast, or at least was projecting the notion that they were. While other
services built on top of DVCS tools - like Bitbucket - did exist back then,
GitHub seemed to have momentum associated with it. (Look at the archives
for <a href="https://github.com/blog">GitHub's</a> and
<a href="https://blog.bitbucket.org/">Bitbucket's</a> respective blogs. GitHub has
hundreds of blog entries; Bitbucket numbers in the dozens.) Developers
everywhere up until this point had all been dealing with sub-optimal tools
and workflows. Some of us realized it. Others hadn't. Many of those who
did saw GitHub as a beacon of hope: we have all these new ideas and new
potentials with distributed version control and here is a service under
active development trying to figure out how to exploit that. Oh, and
it's free for open source. Sign me up!</p>
<p>GitHub did capitalize on a market opportunity. They also capitalized on
the value of marketing and the perception that they were moving fast and
providing features that people - especially in open source - wanted.
This captured the early adopters market. But I think what really set
GitHub apart and led to the success they are enjoying today is their
<em>code first</em> approach and their desire to make contribution easy, and
even fun and sociable.</p>
<p>As developers, our job is to solve problems. We often do that by writing
and changing code. And this often involves working as part of a team, or
collaborating. To collaborate, we need tools. You eventually need some
processes. And as I
<a href="/blog/2015/01/09/firefox-contribution-process-debt/">recently blogged</a>,
this can lead to <em>process debt</em> and inefficiencies associated with them.</p>
<p>Before GitHub, the <em>process debt</em> for contributing to other projects was
high. You often had to subscribe to mailing lists in order to submit
patches as emails. Or, you had to create an account on someone's bug
tracker or code review tool before you could send patches. Then you had
to figure out how to use these tools and any organization or
project-specific extensions and workflows attached to them. It was quite
involved and a lot could go wrong. Many projects and organizations (like
Mozilla) still practice this traditional methology. Furthermore (and as
I've
<a href="/blog/2014/10/27/implications-of-using-bugzilla-for-firefox-patch-development/">written before</a>),
these traditional, single patch/commit-based tools often aren't
effective at ensuring the desired output of high quality software.</p>
<p>Before GitHub solved <em>process debt</em> via commoditization of knowledge via
market dominance, they took another approach: emphasizing <em>code first</em>
development.</p>
<p>GitHub is all about the <strong>code</strong>. You load a project page and you see
<strong>code</strong>. You may think a README with basic project information would be
the first thing on a <em>project</em> page. But it isn't. <em>Code</em>, like data,
is king.</p>
<p>Collaboration and contribution on GitHub revolve around the <em>pull
request</em>. It's a way of saying, <em>hey, I made a change, will you take
it?</em> There's nothing too novel in the concept of the <em>pull request</em>:
it's fundamentally no different than sending emails with patches to a
mailing list. But what is so special is GitHub's execution. Gone are
the days of configuring and using one-off tools and processes. Instead,
we have the friendly confines of a clean, friendly, and modern web
experience. While GitHub is built upon the Git tool, you don't even
need to use Git (a tool
<a href="http://git-man-page-generator.lokaltog.net/">lampooned</a>
for its
<a href="http://stevelosh.com/blog/2013/04/git-koans/">horrible usability and approachability</a>)
to contribute on GitHub! Instead, you can
<a href="https://help.github.com/articles/github-flow-in-the-browser/">do everything from your browser</a>.
That warrants repeating: <strong>you don't need to leave your browser to
contribute on GitHub</strong>. GitHub has essentially reduced <em>process debt</em>
to <em>edit a text document</em> territory, and pretty much anybody who has
used a computer can do that. This has enabled GitHub to dabble into
non-code territory, such as its
<a href="https://government.github.com/">GitHub and Government</a> initiative to
foster community involvement in government. (GitHub is really a platform
for easily seeing and changing <em>any</em> content or data. But, please, let
me continue using <em>code</em> as a stand-in, since I want to focus on the
developer audience.)</p>
<p>GitHub took an overly-complicated and fragmented world of varying
contribution processes and made the new world revolve around code and a
unified and simple process for change - the <em>pull request</em>.</p>
<p>Yes, there are other reasons for GitHub's success. You can make strong
arguments that GitHub has capitalized on the social and psychological
aspects of coding and human desire for success and happiness. I agree.</p>
<p>You can also argue GitHub succeeded because of Git. That statement is
more or less technically accurate, but I don't think it is a sound
argument. Git may have been the most feature complete open source
DVCS at the time GitHub came into existence. But that doesn't mean there
is something special about Git that no other DVCS has that makes GitHub
popular. Had another tool been more feature complete or had the backing
of a project as large as Linux at the time of GitHub's launch, we could
very well be looking at a successful service built on something that
isn't Git. Git had early market advantage and I argue its popularity
today - a lot of it via GitHub - is largely a result of its early
advantages over competing tools. And, I would go so far to say that when
you consider the poor usability of Git and the pain that its users go
through when first learning it, more accurate statements would be that
<em>GitHub succeeded in spite of Git</em> and <em>Git owes much of its success to
GitHub</em>.</p>
<p>When I look back at the rise of GitHub, I see a service that has
succeeded by putting people first by allowing them to capitalize
on more productive workflows and processes. They've done this by
emphasizing <em>code</em>, not process, as the means for change. Organizations
and projects should take note.</p>

  </div>
</div>



  <div class="after_post"><a href="http://gregoryszorc.com/blog/2015/01/10/code-first-and-the-rise-of-the-dvcs-and-github#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
 <a href="../2">« Previous Page</a>
  --  
 <a href="../4">Next Page »</a>

              </div>
              
          <div id="sidebar">
          <ul>
            <li>
              <h2>Categories</h2>
              <ul>
                <li><a href="/blog/category/bugzilla">Bugzilla</a></li>
                <li><a href="/blog/category/clang">Clang</a></li>
                <li><a href="/blog/category/docker">Docker</a></li>
                <li><a href="/blog/category/firefox">Firefox</a></li>
                <li><a href="/blog/category/git">Git</a></li>
                <li><a href="/blog/category/javascript">JavaScript</a></li>
                <li><a href="/blog/category/mercurial">Mercurial</a></li>
                <li><a href="/blog/category/mozilla">Mozilla</a></li>
                <li><a href="/blog/category/puppet">Puppet</a></li>
                <li><a href="/blog/category/python">Python</a></li>
                <li><a href="/blog/category/review-board">Review Board</a></li>
                <li><a href="/blog/category/sync">Sync</a></li>
                <li><a href="/blog/category/browsers">browsers</a></li>
                <li><a href="/blog/category/build-system">build system</a></li>
                <li><a href="/blog/category/code-review">code review</a></li>
                <li><a href="/blog/category/compilers">compilers</a></li>
                <li><a href="/blog/category/internet">internet</a></li>
                <li><a href="/blog/category/logging">logging</a></li>
                <li><a href="/blog/category/mach">mach</a></li>
                <li><a href="/blog/category/make">make</a></li>
                <li><a href="/blog/category/misc">misc</a></li>
                <li><a href="/blog/category/movies">movies</a></li>
                <li><a href="/blog/category/pymake">pymake</a></li>
                <li><a href="/blog/category/security">security</a></li>
                <li><a href="/blog/category/sysadmin">sysadmin</a></li>
                <li><a href="/blog/category/testing">testing</a></li>
              </ul>
            </li>
          </ul>
        </div>



              <div style="clear: both;">&nbsp;</div>
          </div>
        </div>
      </div>
      <div id="footer">
        
  <hr/>
  <p>Copyright (c) 2012 Gregory Szorc. All rights reserved. Design by <a href="http://www.freecsstemplates.org/"> CSS Templates</a>.</p>


      </div>
    </div>
  </body>
</html>





