


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
Design by Free CSS Templates
http://www.freecsstemplates.org
Released for free under a Creative Commons Attribution 2.5 License

Name       : Pollinating  
Description: A two-column, fixed-width design with dark color scheme.
Version    : 1.0
Released   : 20101114

-->
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    
  <title>Gregory Szorc's Digital Home
</title>
<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
<link rel="alternate" type="application/atom+xml" title="Atom 1.0"
href="/blog/feed/atom" />
<link rel="stylesheet" href="/style/style.css" type="text/css" />
<link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />


  </head>
  <body>
    <div id="wrapper">
      
  <div id="menu">
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="/blog/">Blog</a></li>
    <li><a href="/notes">Notes</a></li>
    <li><a href="/work.html">Work</a></li>
    <li><a href="/skills.html">Skills</a></li>
    <li><a href="/thoughts.html">Thoughts</a></li>
    <li><a href="/resume.pdf">Resume</a></li>
  </ul>
</div>


      <div id="page">
        <div id="page-bgtop">
          <div id="page-bgbtm">
              <div id="content">
                
  
<div class="blog_post">
  <a name="scaling-firefox-development-workflows"></a>
  <h2 class="blog_post_title"><a href="/blog/2018/05/16/scaling-firefox-development-workflows" rel="bookmark" title="Permanent Link to Scaling Firefox Development Workflows">Scaling Firefox Development Workflows</a></h2>
  <small>May 16, 2018 at 04:10 PM | categories: 

<a href='/blog/category/mozilla'>Mozilla</a>
</small><p/>
  <div class="post_prose">
    
  <p>One of the central themes of my time at Mozilla has been my pursuit
of making it easier to contribute to and hack on Firefox.</p>
<p>I vividly remember my first day at Mozilla in 2011 when I went to
build Firefox for the first time. I thought the entire experience -
from obtaining the source code, installing build dependencies, building,
running tests, submitting patches for review, etc was quite... lacking.
When I asked others if they thought this was an issue, many rightfully
identified problems (like the build system being slow). But there was
a significant population who seemed to be naive and/or apathetic to
the breadth of the user experience shortcomings. This is totally
understandable: the scope of the problem is immense and various
people don't have the perspective, are blinded/biased by personal
experience, and/or don't have the product design or UX experience
necessary to comprehend the problem.</p>
<p><strong>When it comes to contributing to Firefox, I think the problems have
as much to do with user experience (UX) as they do with technical
matters.</strong> As I
<a href="/blog/2012/05/07/improving-the-mozilla-build-system-experience/">wrote in 2012</a>,
<em>user experience matters and developers are people too.</em> You can have
a technically superior product, but if the UX is bad, you will have a
hard time attracting and retaining new users. And existing users won't
be as happy. These are the kinds of problems that a product manager or
designer deals with. A difference is that in the case of Firefox
development, the target audience is a very narrow and highly
technically-minded subset of the larger population - much smaller than
what your typical product targets. The total addressable population is
(realistically) in the thousands instead of millions. But this doesn't
mean you ignore the principles of good product design when designing
developer tooling. <strong>When it comes to developer tooling and workflows, I
think it is important to have a <em>product manager</em> mindset and treat it
not as a collection of tools for technically-minded individuals, but as
a product having an overall experience.</strong> You only have to look as far as
the Firefox Developer Tools to see this approach applied and the positive
results it has achieved.</p>
<p>Historically, Mozilla has lacked a formal team with the domain expertise
and mandate to treat Firefox contribution as a <em>product</em>. We didn't have
anything close to this until a few years ago. Before we had such a team,
I took on some of these problems individually. In 2012, I wrote <code>mach</code> - a
generic CLI command dispatch tool - to provide a central, convenient,
and easy-to-use command to discover development actions and to run them.
(Read the <a href="/blog/2012/09/26/mach-has-landed/">announcement blog post</a> for
some historical context.) I also
<a href="/blog/2012/09/18/bootstrap-your-system-to-build-firefox/">introduced</a>
a one-line bootstrap tool (now <code>mach bootstrap</code>) to make it easier to
configure your machine for building Firefox. A few months later, I
was responsible for
<a href="/blog/2013/02/28/moz.build-files-and-the-firefox-build-system/">introducing moz.build files</a>,
which paved the way for countless optimizations and for rearchitecting
the Firefox build system to use modern tools - a project that is still
ongoing (digging out from ~two decades of technical debt is a massive
effort). And a few months after that, I started going down the version
control rabbit hole and improving matters there. And I was also heavily
involved with MozReview for improving the code review experience.</p>
<p>Looking back, I was responsible for and participated in a ton of
foundational changes to how Firefox is developed. Of course, dozens of
others have contributed to getting us to where we are today and I can't
and won't take credit for the hard work of others. Nor will I claim I was the
only person coming up with good ideas or transforming them into reality. I
can name several projects (like Taskcluster and Treeherder) that have
been just as or more transformational than the changes I can take credit
for. It would be vain and naive of me to elevate my contributions on a
taller pedestal and I hope nobody reads this and thinks I'm doing that.</p>
<p>(On a personal note, numerous people have told me that things like <code>mach</code>
and the bootstrap tool have transformed the Firefox contribution experience
for the better. I've also had very senior people tell me that they don't
understand why these tools are important and/or are skeptical of the need
for investments in this space. I've found this dichotomy perplexing and
troubling. Because some of the <em>detractors</em> (for lack of a better word) are
highly influential and respected, their apparent skepticism sews seeds of
doubt and causes me to second guess my contributions and world view. This
feels like a form or variation of imposter syndrome and it is something I
have struggled with during my time at Mozilla.)</p>
<p>From my perspective, the previous five or so years in Firefox development
workflows has been about initiating foundational changes and executing on
them. When it was introduced, <code>mach</code> was <em>radical</em>. It didn't do much and
its use was optional. Now almost everyone uses it. Similar stories have
unfolded for Taskcluster, MozReview, and various other tools and
platforms. In other words, we laid a foundation and have been steadily
building upon it for the past several years. That's not to say other
foundational changes haven't occurred since (they have - the imminent switch
to Phabricator is a terrific example). But the volume of foundational
changes has slowed since 2012-2014. (I think this is due to Mozilla
deciding to invest more in tools as a result of growing pains from
significant company expansion that began in 2010. With that investment, we
invested in the bigger ticket long-standing workflow pain points, such as
CI (Taskcluster), the Firefox build system, Treeherder, and code review.)</p>
<h2>Workflows Today and in the Future</h2>
<p>Over the past several years, the size, scope, and complexity of Firefox
development activities has increased.</p>
<p>One way to see this is at the source code level. The following chart
shows the size of the <a href="https://hg.mozilla.org/mozilla-central/">mozilla-central</a>
version control repository over time.</p>
<p><img alt="mozilla-central size over time" src="/images/firefox-repo-size-over-time.png" /></p>
<p>The size increases are obvious. The increases cumulatively represent
new features, technologies, and workflows. For example, the repository
contains thousands of <em>Web Platform Tests</em> (WPT) files, a shared test
suite for web platform implementations, like Gecko and Blink. WPT didn't
exist a few years ago. Now we have files under source control, tools for
running those tests, and workflows revolving around changing those tests.
The incorporation of Rust and components of Servo into Firefox is also
responsible for significant changes. Firefox features such as Developer
Tools have been introduced or ballooned in size in recent years. The
<em>Go Faster</em> project and the move to system add-ons has introduced various
new workflows and challenges for testing Firefox.</p>
<p>Many of these changes are building upon the user-facing foundational
workflow infrastructure that was last significantly changed in 2012-2014.
This has definitely contributed to some growing pains. For example, there
are now 92 <code>mach</code> commands instead of like 5. <code>mach help</code> - intended to
answer <em>what can I do and how should I do it</em> - is overwhelming, especially
to new users. The repository is around 2 gigabytes of data to clone instead
of around 500 megabytes. We have 240,000 files in a full checkout instead
of 70,000 files. There's a <strong>ton</strong> of new pieces floating around. Any
product manager tasked with user acquisition and retention will tell you
that increasing the barrier to entry and use will jeopardize these
outcomes. But with the growth of Firefox's technical underbelly in the
previous years, we've made it harder to contribute by requiring users to
download and see a lot more files (version control) and be overwhelmed
by all the options for actions to take (<code>mach</code> having 92 commands). And
as the sheer number of components constituting Firefox increases, it
becomes harder and harder for everyone - not just new contributors - to
reason about how everything fits together.</p>
<p>I've been framing this general problem as <em>scaling Firefox development
workflows</em> and <strong>every time I think about the high-level challenges facing
Firefox contribution today and in the years ahead, this problem floats
to the top of my list of concerns</strong>. Yes, we have pressing issues like
improving the code review experience and making the Firefox build
system and Taskcluster-based CI fast, efficient, and reliable. But even
if you make these individual pieces great, there is still a cross-domain
problem of how all these components weave together. <strong>This is why I think
it is important to take a wholistic view and treat developer workflow
as a product.</strong></p>
<p>When I look at this the way a product manager or designer would, I see a
few fundamental problems that need addressing.</p>
<p>First, we're not optimizing for comprehensive end-to-end workflows. By and
large, we're designing our tools in isolation. We focus more on maximizing
the individual components instead of maximizing the interaction between
them. For example, Taskcluster and Treeherder are pretty good in isolation.
But we're missing features like Treeherder being able to tell me the
command to run locally to reproduce a failure: I want to see a failure on
Treeherder and be able to copy and paste commands into my terminal to
debug the failure. In the case of code review, we've designed two good
code review tools (MozReview and Phabricator) but we haven't invested in
making submitting code reviews turn key (the initial system configuration
is difficult and we still don't have things like automatic bug filing or
reviewer selection). <strong>We are leaving many workflow optimizations on
the table by not implementing thoughtful tie-ins and transitions between
various tools.</strong></p>
<p>Second, by-and-large we're still optimizing for a single, monolithic user
segment instead of recognizing and optimizing for different users and
their workflow requirements. For example, <code>mach help</code> lists 92 commands.
I don't think any single person cares about all 92 of those commands. The
average person may only care about 10 or even 20. In terms of user
interface design, the features and workflow requirements of small user
segments are polluting the interface for all users and making the entire
experience complicated and difficult to reason about. As a concrete
example, why should a system add-on developer or a Firefox Developer Tools
developer (these people tend to care about testing a standalone Firefox
add-on) care about Gecko's build system or tests? If you aren't touching
Gecko or Firefox's <em>chrome</em> code, why should you be exposed to workflows
and requirements that don't have a major impact on you? Or something more
extreme, if you are developing a standalone Rust module or Python package
in mozilla-central, why do you need to care about Firefox at all? (Yes,
Firefox or another downstream consumer may care about changes to that
<em>standalone</em> component and you can't ignore those dependencies. But it
should at least be possible to hide those dependencies.)</p>
<p>Waving my hands, the solution to these problems is to treat Firefox
development workflow as a product and to apply the same rigor that we
use for actual Firefox product development. Give people with a vision
for the entire workflow the ability to prioritize investment across
tools and platforms. Give them a process for defining features that
work across tools. Perform formal user studies. See how people are
actually using the tools you build. Bring in design and user experience
experts to help formulate better workflows. Perform user typing so
different, segmentable workflows can be optimized for. Treat developers
as you treat users of <em>real</em> products: listen to them. Give developers
a voice to express frustrations. Let them tell you what they are trying
to do and what they wish they could do. Integrate this feedback into a
feature roadmap. Turn common feedback into action items for new features.</p>
<p>If you think these ideas are silly and it doesn't make sense to apply a
<em>product mindset</em> to developer workflows and tooling, then you should be
asking whether product management and all that it entails is also a silly
idea. If you believe that aspects of product management have beneficial
outcomes (which most companies do because otherwise there wouldn't be
product managers), then why <em>wouldn't</em> you want to apply the methods of
that discipline to developers and development workflows? Developers are
users too and the fact that they work for the same company that is
creating the product shouldn't make them immune from the benefits of
product management.</p>
<p>If we want to make contributing to Firefox an even better experience for
Mozilla employees and community contributors, I think we need to take a step
back and assess the situation as a product manager would. The improvements
that have been made to the individual pieces constituting Firefox's
development workflow during my nearly seven years at Mozilla have been
incredible. But I think in order to achieve the next round of major
advancements in workflow productivity, we'll need to focus on how all of
the pieces fit together. And that requires treating the entire workflow
as a cohesive product.</p>

  </div>
</div>



  <hr class="interblog" />
  
<div class="blog_post">
  <a name="revisiting-using-docker"></a>
  <h2 class="blog_post_title"><a href="/blog/2018/05/16/revisiting-using-docker" rel="bookmark" title="Permanent Link to Revisiting Using Docker">Revisiting Using Docker</a></h2>
  <small>May 16, 2018 at 01:45 PM | categories: 

<a href='/blog/category/docker'>Docker</a>, <a href='/blog/category/mozilla'>Mozilla</a>
</small><p/>
  <div class="post_prose">
    
  <p>When Docker was taking off like wildfire in 2013, I was caught up in the
excitement like everyone else. I remember knowing of the existence
of LXC and container technologies in Linux at the time. But Docker seemed to
be the first open source tool to actually make that technology usable (a
terrific example of how user experience matters).</p>
<p>At Mozilla, Docker was adopted all around me and by me for various utilities.
<a href="https://docs.taskcluster.net/">Taskcluster</a> - Mozilla's task execution
framework geared for running complex CI systems - adopted Docker as a
mechanism to run processes in self-contained images. Various groups in
Mozilla adopted Docker for running services in production. I adopted Docker
for
<a href="/blog/2015/01/24/end-to-end-testing-with-docker/">integration testing of complex systems</a>.</p>
<p>Having seen various groups use Docker and having spent a lot of time in the
trenches battling technical problems, my conclusion is <strong>Docker is unsuitable
as a general purpose container runtime. Instead, Docker has its niche
for hosting complex network services.</strong> Other uses of Docker should be highly
scrutinized and potentially discouraged.</p>
<p>When Docker hit first the market, it was arguably the only game in town.
Using Docker to achieve containerization was defensible because there weren't
exactly many (any?) practical alternatives. So if you wanted to use containers,
you used Docker.</p>
<p>Fast forward a few years. We now have the
<a href="https://www.opencontainers.org/">Open Container Initiative</a> (OCI). There are
specifications describing common container formats. So you can produce a
container once and take it to any number OCI compatible <em>container runtimes</em>
for execution. And in 2018, there are a <em>ton</em> of players in this space.
<a href="https://github.com/opencontainers/runc">runc</a>,
<a href="https://github.com/rkt/rkt">rkt</a>, and
<a href="https://github.com/google/gvisor">gVisor</a> are just some. So Docker is no
longer the only viable tool for executing a container. If you are just
getting started with the container space, you would be wise to research the
available options and their pros and cons.</p>
<p>When you look at all the options for running containers in 2018, I think it
is obvious that Docker - usable though it may be - is not ideal for a
significant number of container use cases. If you divide use cases into a spectrum
where one end is <em>run a process in a sandbox</em> and the other is <em>run a complex system
of orchestrated services in production</em>, Docker appears to be focusing on the
latter. Take it from <a href="https://www.docker.com/what-docker">Docker themselves</a>:</p>
<p><em>Docker is the company driving the container movement and the only container
platform provider to address every application across the hybrid cloud. Today's
businesses are under pressure to digitally transform but are constrained by
existing applications and infrastructure while rationalizing an increasingly
diverse portfolio of clouds, datacenters and application architectures. Docker
enables true independence between applications and infrastructure and developers
and IT ops to unlock their potential and creates a model for better
collaboration and innovation.</em></p>
<p>That description of Docker (the company) does a pretty good job of
describing what Docker (the technology) has become: a constellation
of software components providing the underbelly for managing complex
applications in complex infrastructures. That's pretty far detached on the
spectrum from <em>run a process in a sandbox</em>.</p>
<p>Just because Docker (the company) is focused on a complex space doesn't mean
they are incapable of exceeding at solving simple problems. However, I believe
that in this particular case, the complexity of what Docker (the company) is
focusing on has inhibited its Docker products to adequately address simple
problems.</p>
<p>Let's dive into some technical specifics.</p>
<p>At its most primitive, Docker is a glorified tool to run a process in a
sandbox. On Linux, this is accomplished by using
the <a href="http://man7.org/linux/man-pages/man2/clone.2.html">clone(2)</a> function
with specific flags and combined with various other techniques (filesystem
remounting, capabilities, cgroups, chroot, seccomp, etc) to <em>sandbox</em> the
process from the main operating system environment and kernel. There are a host
of tools living at this not-quite-containers level that make it easy to run
a sandboxed process. The
<a href="https://github.com/projectatomic/bubblewrap">bubblewrap</a> tool is one of them.</p>
<p>Strictly speaking, you don't need anything fancy to create a process
sandbox: just an executable you want to invoke and an executable that makes
a set of system calls (like bubblewrap) to run that executable.</p>
<p>When you install Docker on a machine, it starts a daemon running as root.
That daemon listens for HTTP requests on a network port and/or UNIX socket.
When you run <code>docker run</code> from the command line, that command establishes
a connection to the Docker daemon and sends any number of HTTP requests to
instruct the daemon to take actions.</p>
<p>A daemon with a remote control protocol is useful. But it shouldn't be the
only way to spawn containers with Docker. If all I want to do is spawn a temporary
container that is destroyed afterwards, I should be able to do that from
a local command without touching a network service. Something like bubblewrap.
The daemon adds all kinds of complexity and overhead. Especially if I just want
to run a simple, short-lived command.</p>
<p>Docker at this point is already pretty far detached from a tool like bubblewrap.
And the disparity gets worse.</p>
<p>Docker adds another abstraction on top of basic process sandboxing in the form
of storage / filesystem management. Docker insists that processes execute in
self-contained, chroot()'d filesystem environment and that these environments
(Docker images) be managed by Docker itself. When Docker images are <em>imported</em>
into Docker, Docker manages them using one of a handful of
<a href="https://docs.docker.com/storage/storagedriver/">storage drivers</a>. You can choose
from devicemapper, overlayfs, zfs, btrfs, and aufs and employ various
configurations of all these. Docker images are composed of <em>layers</em>, with one
layer stacked on top of the prior. This allows you to have an immutable base
layer (that can be shared across containers) where run-time file changes can be
isolated to a specific container instance.</p>
<p>Docker's ability to manage storage is pretty cool. And I dare say Docker's killer
feature in the very beginning of Docker was the ability to easily produce and
exchange self-contained Docker <em>images</em> across machines.</p>
<p>But this utility comes at a <em>very</em> steep price. Again, if our use case is
<em>run a process in a sandbox</em>, do we really care about all this advanced
storage functionality? Yes, if you are running hundreds of containers on
a single system, a storage model built on top of copy-on-write is perhaps
necessary for scaling. But for simple cases where you just want to run a single
or small number of processes, it is extremely overkill and adds many more
problems than it solves.</p>
<p>I cannot stress this enough, but <strong>I have spent hours debugging and working
around problems due to how filesystems/storage works in Docker</strong>.</p>
<p>When Docker was initially released, aufs was widely used. As I
<a href="/blog/2017/12/08/good-riddance-to-aufs/">previously wrote</a>, aufs has abysmal
performance as you scale up the number of concurrent I/O operations. We shaved
<strong>minutes</strong> off tasks in Firefox CI by ditching aufs for overlayfs.</p>
<p>But overlayfs is far from a panacea. File metadata-only updates are
<a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/63f19cfacc5c">apparently very slow in overlayfs</a>.
We're talking ~100ms to call <code>fchownat()</code> or <code>utimensat()</code>. If you perform
an <code>rsync -a</code> or <code>chown -R</code> on a directory with only just a hundred files that
were defined in a base image layer, you can have delays of seconds.</p>
<p>The Docker storage drivers backed by <em>real</em> filesystems like zfs and btrfs are
a bit better. But they have their quirks too. For example, creating layers in
images is comparatively very slow compared to overlayfs (which are practically
instantaneous). This matters when you are iterating on a Dockerfile for example
and want to quickly test changes. Your edit-compile cycle grows frustratingly
long very quickly.</p>
<p>And I could opine on a handful of other problems I've encountered over the years.</p>
<p>Having spent hours of my life debugging and working around issues with
Docker's storage, my current attitude is <em>enough of this complexity, just let me
use a directory backed by the local filesystem, dammit</em>.</p>
<p>For many use cases, <strong>you don't need the storage complexity that Docker forces
upon you</strong>. Pointing Docker at a directory on a local filesystem to chroot into
is <em>good enough</em>. I know the behavior and performance properties of common Linux
filesystems. ext4 isn't going to start making <code>fchownat()</code> or <code>utimensat()</code> calls
take ~100ms. It isn't going to complain when a hard link spans multiple layers in
an image. Or slow down to a crawl when multiple threads are performing concurrent
read I/O. There's not going to be intrinsically complicated algorithms and
caching to walk N image layers to find the most recent version of a file (or if
there is, it will be so far down the stack in kernel land that I likely won't
ever have to deal with it as a normal user). Docker images with their multiple
layers add complexity and overhead. For many use uses, the pain it inflicts
offsets the initial convenience it saves.</p>
<p>Docker's optimized-for-complex-use-cases architecture demonstrates its
inefficiency in simple benchmarks.</p>
<p>On my machine, <code>docker run -i --rm debian:stretch /bin/ls /</code> takes ~850ms.
Almost a second to perform a directory listing (sometimes it does take over
1 second - I was being generous and quoting a quicker time). This command
takes ~1ms when run in a local shell. So we're at 2.5-3 magnitudes of overhead.
The time here does include time to initially create the container and
destroy it afterwards. We can isolate that overhead by starting a persistent
container and running <code>docker exec -i &lt;cid&gt; /bin/ls /</code> to spawn a new process
in an existing container. This takes ~85ms. So, ~2 magnitudes of overhead to
spawn a process in a Docker container versus spawning it <em>natively</em>. What's
adding so much overhead, I'm not sure. Yes, there are HTTP requests under
the hood. But HTTP to a local daemon shouldn't be that slow. I'm not sure
what's going on.</p>
<p>If we <code>docker export</code> that image to the local filesystem and use <code>runc state</code>
to configure so we can run it with <code>runc</code>, <code>runc run</code> takes ~85ms to run
<code>/bin/ls /</code>. If we <code>runc exec &lt;cid&gt; /bin/ls /</code> to start a process in an
existing container, that completes in ~10ms. <code>runc</code> appears to be executing
these simple tasks ~10x faster than Docker.</p>
<p>But to even get to that point, we had to make a filesystem available to
spawn the container in. With Docker, you need to load an image into Docker.
Using <code>docker save</code> to produce a 105,523,712 tar file,
<code>docker load -i image.tar</code> takes ~1200ms to complete. <code>tar xf image.tar</code>
takes ~65ms to extract that image to the local filesystem. Granted, Docker
is computing the SHA-256 of the image as part of import. But SHA-256 runs
at ~250MB/s on my machine and on that ~105MB input takes ~400ms. Where is
that extra ~750ms of overhead in Docker coming from?</p>
<p>The Docker image loading overhead is still present on large images. With
a 4,336,605,184 image, <code>docker load</code> was taking ~32s and <code>tar x</code> was
taking ~2s. Obviously the filesystem was buffering writes in the <code>tar</code>
case. And the ~2s is ignoring the ~17s to obtain the SHA-256 of the
entire input. But there's still a substantial disparity here. (I suspect
a lot of it is overlayfs not being as optimal as ext4.)</p>
<p>Several years ago there weren't many good choices for tools to execute containers.
But today, there are good tools readily available. And thanks to OCI standards,
you can often swap in alternate container runtimes. Docker (the tool) has an
architecture that is optimized for solving complex use cases (coincidentally use
cases that Docker the company makes money from). Because of this, my conclusion -
drawn from using Docker for several years - is that Docker is unsuitable for
many common use cases. <strong>If you care about low container startup/teardown
overhead, low latency when interacting with containers (including spawning
processes from outside of them), and for workloads where Docker's storage model
interferes with understanding or performance, I think Docker should be avoided.</strong>
A simpler tool (such as <code>runc</code> or even <code>bubblewrap</code>) should be used instead.</p>
<p>Call me a curmudgeon, but having seen all the problems that Docker's complexity
causes, I'd rather see my containers resemble a tarball that can easily be
chroot()'d into. <strong>I will likely be revisiting projects that use Docker and
replacing Docker with something lighter weight and architecturally simpler.</strong> As
for the use of Docker in the more complex environments it seems to be designed
for, I don't have a meaningful opinion as I've never really used it in that
capacity. But given my negative experiences with Docker over the years, I am
definitely biased against Docker and will lean towards simpler products, especially
if their storage/filesystem management model is simpler. Docker introduced
containers to the masses and they should be commended for that. But for my
day-to-day use cases for containers, Docker is simply not the right tool for
the job.</p>
<p>I'm not sure exactly what I'll replace Docker with for my simpler use cases.
If you have experiences you'd like to share, sharing them in the comments
will be greatly appreciated.</p>

  </div>
</div>



  <hr class="interblog" />

              </div>
              
          <div id="sidebar">
          <ul>
            <li>
              <h2>Categories</h2>
              <ul>
                <li><a href="/blog/category/apple">Apple</a></li>
                <li><a href="/blog/category/bugzilla">Bugzilla</a></li>
                <li><a href="/blog/category/clang">Clang</a></li>
                <li><a href="/blog/category/docker">Docker</a></li>
                <li><a href="/blog/category/firefox">Firefox</a></li>
                <li><a href="/blog/category/git">Git</a></li>
                <li><a href="/blog/category/javascript">JavaScript</a></li>
                <li><a href="/blog/category/mercurial">Mercurial</a></li>
                <li><a href="/blog/category/mozreview">MozReview</a></li>
                <li><a href="/blog/category/mozilla">Mozilla</a></li>
                <li><a href="/blog/category/personal">Personal</a></li>
                <li><a href="/blog/category/programming">Programming</a></li>
                <li><a href="/blog/category/puppet">Puppet</a></li>
                <li><a href="/blog/category/pyoxidizer">PyOxidizer</a></li>
                <li><a href="/blog/category/python">Python</a></li>
                <li><a href="/blog/category/review-board">Review Board</a></li>
                <li><a href="/blog/category/rust">Rust</a></li>
                <li><a href="/blog/category/sync">Sync</a></li>
                <li><a href="/blog/category/browsers">browsers</a></li>
                <li><a href="/blog/category/build-system">build system</a></li>
                <li><a href="/blog/category/code-review">code review</a></li>
                <li><a href="/blog/category/compilers">compilers</a></li>
                <li><a href="/blog/category/internet">internet</a></li>
                <li><a href="/blog/category/logging">logging</a></li>
                <li><a href="/blog/category/mach">mach</a></li>
                <li><a href="/blog/category/make">make</a></li>
                <li><a href="/blog/category/misc">misc</a></li>
                <li><a href="/blog/category/movies">movies</a></li>
                <li><a href="/blog/category/pymake">pymake</a></li>
                <li><a href="/blog/category/security">security</a></li>
                <li><a href="/blog/category/sysadmin">sysadmin</a></li>
                <li><a href="/blog/category/testing">testing</a></li>
              </ul>
            </li>
          </ul>
        </div>



              <div style="clear: both;">&nbsp;</div>
          </div>
        </div>
      </div>
      <div id="footer">
        
  <hr/>
  <p>Copyright (c) 2012- Gregory Szorc. All rights reserved. Design by <a href="http://www.freecsstemplates.org/"> CSS Templates</a>.</p>


      </div>
    </div>
  </body>
</html>





