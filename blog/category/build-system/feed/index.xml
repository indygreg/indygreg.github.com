<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>Gregory Szorc's Digital Home</title>
    <link>http://gregoryszorc.com/blog</link>
    <description>Rambling on</description>
    <pubDate>Wed, 12 May 2021 17:35:34 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Modern CI is Too Complex and Misdirected</title>
      <link>http://gregoryszorc.com/blog/2021/04/07/modern-ci-is-too-complex-and-misdirected</link>
      <pubDate>Wed, 07 Apr 2021 09:00:00 PDT</pubDate>
      <category><![CDATA[CI]]></category>
      <category><![CDATA[build system]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2021/04/07/modern-ci-is-too-complex-and-misdirected</guid>
      <description>Modern CI is Too Complex and Misdirected</description>
      <content:encoded><![CDATA[<p>The state of CI platforms is much stronger than it was just a few years ago.
Overall, this is a good thing: access to powerful CI platforms enables
software developers and companies to ship more reliable software more
frequently, which benefits its users/customers. Centralized CI platforms
like GitHub Actions, GitLab Pipelines, and Bitbucket provide benefits of
scale, as the Internet serves as a collective information repository for
how to use them. Do a search for <em>how to do X on CI platform Y</em> and
you'll typically find some code you can copy and paste. Nobody wants to
toil with wrangling their CI configuration after all: they just want
to ship.</p>
<h2>Modern CI Systems are Too Complex</h2>
<p>The advancements in CI platforms have come at a cost: increased complexity.
And the more I think about it, <strong>I'm coming around to the belief that
modern CI systems are too complex</strong>. Let me explain.</p>
<p>At its core, a CI platform is a specialized <em>remote code execution as a
service</em> (it's a feature, not a CVE!) where the code being executed is
in pursuit of building, testing, and shipping software (unless you
<a href="https://dev.to/thibaultduponchelle/the-github-action-mining-attack-through-pull-request-2lmc">abuse it to mine cryptocurrency</a>).
So, CI platforms typically throw in a bunch of value-add features to enable
you to ship software more easily. There are vastly different approaches and
business models here. (I must tip my hat to GitHub Actions leveraging network
effects via community maintained <em>actions</em>: this lowers TCO for GitHub as they
don't need to maintain many <em>actions</em>, creates vendor lock-in as users develop
a dependence on platform-proprietary <em>actions</em>, all while increasing the
value of the platform for end-users - a rare product trifecta.) A common
value-add property of CI platforms is some kind of configuration file
(often YAML) which itself offers common functionality, such as configuring
the version control checkout and specifying what commands to run. This is
where we start to get into problems.</p>
<p>(I'm going to focus on GitHub Actions here, not because they are the worst
(far from it), but because they seem to be the most popular and readers can
relate more easily. But my commentary applies to other platforms like GitLab
as well.)</p>
<p>The YAML configuration of modern CI platforms is... powerful. Here are features
present in <a href="https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions">GitHub Actions workflow YAML</a>:</p>
<ul>
<li>An embedded templating system that results in the source YAML being
  expanded into a final YAML document that is actually evaluated. This
  includes a custom <a href="https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions">expression mini language</a>.</li>
<li>Triggers for when to run jobs.</li>
<li>Named variables.</li>
<li>Conditional job execution.</li>
<li>Dependencies between jobs.</li>
<li>Defining Docker-based run-time environment.</li>
<li>Encrypted secrets.</li>
<li>Steps constituting each job and what actions those steps should take.</li>
</ul>
<p>If we expand scope slightly to include actions maintained by GitHub, we also have
steps/actions features for:</p>
<ul>
<li>Performing Git checkouts.</li>
<li>Storing artifacts used by workflows/jobs.</li>
<li>Caching artifacts used by workflows/jobs.</li>
<li>Installing common programming languages and environments (like Java, Node.js,
  Python, and Ruby).</li>
<li>And a whole lot more.</li>
</ul>
<p>And then of course there are 3rd party Actions. And there's a lot of them!</p>
<p>There's a lot of functionality here and a lot of it is arguably necessary:
I'm hard pressed to name a feature to cut. (Although I'm no fan of using YAML
as a programming language but I concede it use is a fair compromise compared
to forcing people to write code to produce YAML or make equivalent API calls
to do what the YAML would do.) All these features seem necessary for a
sufficiently powerful CI offering. Nobody would use your offering if it didn't
offer turnkey functionality after all.</p>
<p>So what's my complaint?</p>
<p>I posit that <strong>a sufficiently complex CI system becomes indistinguishable from
a build system</strong>. I challenge you: try to convince me or yourself that GitHub
Actions, GitLab CI, and other CI systems aren't build systems. The basic
primitives are all there. GitHub Actions Workflows comprised of jobs comprised
of steps are little different from say Makefiles comprised of rules comprised
of commands to execute for that rule, with dependencies gluing everything
together. The main difference is the <em>form factor</em> and the execution model (build
systems are traditionally local and single machine but CI systems are
remote/distributed).</p>
<p>Then we have a similar conjecture: <strong>a sufficiently complex build system becomes
indistinguishable from a CI system</strong>. Earlier I said that CI systems are
<em>remote code execution as a service</em>. While build systems are historically
things that run locally (and therefore not a <em>service</em>), modern build systems
like Bazel (or Buck or Gradle) are completely different animals. For example,
Bazel has
<a href="https://docs.bazel.build/versions/master/remote-execution.html">remote execution</a>
and
<a href="https://docs.bazel.build/versions/master/remote-caching.html">remote caching</a> as
built-in features. Hey - those are built-in features of modern CI systems too!
<strong>So here's a thought experiment: if I define a build system in Bazel and then
define a server-side Git push hook so the remote server triggers Bazel to build,
run tests, and post the results somewhere, is that a CI system? I think it is!</strong>
A crude one. But I think that qualifies as a CI system.</p>
<p><strong>If you squint hard enough, sufficiently complex CI systems and sufficiently
complex build systems start to look like the same thing to me.</strong> At a very high
level, both are providing a pool of servers offering general compute/execute
functionality with specialized features in the domain of building/shipping software,
like inter-task artifact exchange, caching, dependencies, and a frontend language
to define how everything works.</p>
<p>(If you squint really hard you can start to see a value proposition of Kubernetes
for even more general compute scheduling, but I'm not going to go that far in this
post because it is a much harder point to make and I don't necessarily believe in
it myself. But I thought I'd mention it as an interesting thought experiment. But
an easier leap to make is to throw batch job execution (as is often found in data
warehouses) in with build and CI systems as belonging in the same bucket: batch
job execution also tends to have dependencies, exchange of artifacts between jobs,
and I think can strongly resemble a CI system and therefore a build system.)</p>
<p><strong>The thing that bugs me about modern CI systems is that I inevitably feel like
I'm reinventing a build system and fragmenting build system logic.</strong> Your CI
configuration inevitably devolves into a bunch of complex YAML with all kinds of
caching and dependency optimizations to keep execution time low and reliability
in check - just like your build system. You find yourself contorting your
project's build system to work in the context of CI and vice versa. You end up
managing two complex DAGs and platforms/systems instead of one.</p>
<p><strong>Because build systems are more generic than CI systems (I think a sufficiently
advanced build system can do a superset of the things that a sufficiently complex
CI system can do), that means that CI systems are redundant with sufficiently
advanced build systems. So going beyond the section title: CI systems aren't
too complex: they shouldn't need to exist. Your CI functionality should be an
extension of the build system.</strong></p>
<p>In addition to the redundancy argument, I think unified systems are more
user friendly. By integrating your CI system into your build system
(which by definition can be driven locally as part of regular development
workflows), you can expose the full power of the CI system to developers
more easily. Think running ad-hoc CI jobs without having to push your changes
to a remote server first, just like you can with <em>local</em> builds or tests. This
is huge for ergonomics and can drastically compress the cycle time for changes
to these systems (which are often brittle to change/test).</p>
<p>Don't get me wrong, aspects of CI systems not traditionally found in build
systems (such as centralized results reporting and a UI/API for (re)triggering
jobs) absolutely need to exist. Instead, it is the remote compute and work
definition aspects that are completely redundant with build systems.</p>
<p>Let's explore the implications of build and CI systems being more of the
same.</p>
<h2>Modern CI Offerings are Targeting the Wrong Abstraction</h2>
<p>If you assume that build and CI systems can be / are more of the same, then it
follows that many modern CI offerings like GitHub Actions, GitLab CI, and
others are targeting the wrong abstraction: they are defined as domain
specific platforms for running CI systems when instead they should take a step
back and target the broader general compute platform that is also needed for
build systems (and maybe batch job execution, such as what's commonly found
in data warehouses/pipelines).</p>
<p>Every CI offering is somewhere different on the spectrum here. I would
go so far as to argue that GitHub Actions is more a <em>CI product</em> than a
<em>platform</em>. Let me explain.</p>
<p>In my ideal <em>CI platform</em>, I have the ability to schedule an ad-hoc graph of
tasks against that platform. I have the ability to hit some APIs with definitions
of the tasks I want that platform to run and it accepts them, executes them,
uploads artifacts somewhere, reports task results so dependent tasks can execute,
etc.</p>
<p>There is a <a href="https://docs.github.com/en/rest/reference/actions">GitHub Actions API</a>
that allows you to interact with the service. But the critical feature it
doesn't let me do is define ad-hoc units of work: the actual <em>remote execute
as a service</em>. Rather, the only way to define units of work is via workflow YAML
files checked into your repository. That's so constraining!</p>
<p>GitLab Pipelines is a lot better. GitLab Pipelines supports features like
<a href="https://docs.gitlab.com/ee/ci/parent_child_pipelines.html">parent-child pipelines</a>
(dependencies between different pipelines),
<a href="https://docs.gitlab.com/ee/ci/multi_project_pipelines.html">multi-project pipelines</a>
(dependencies between different projects/repos), and
<a href="https://docs.gitlab.com/ee/ci/parent_child_pipelines.html#dynamic-child-pipelines">dynamic child pipelines</a>
(generate YAML files in pipeline job that defines a new pipeline). (I don't
believe GitHub Actions supports any of these features.) Dynamic child
pipelines are an important feature, as they mostly divorce the checked-in YAML
configuration from the <em>remote execute as a service</em> feature. The main missing
feature here is a generic API that allows you achieve this functionality without
having to go through a parent pipeline / YAML first. If that API existed, you
could build your own build/CI/batch execute system on top of GitLab Pipelines
with fewer constraints imposed on you by GitLab Pipeline's opinionated YAML
configuration files and the intended use of its creators. (Generally, I think
a good litmus test for a well-designed platform or tool is when its authors
are surprised by someone's unintended use for it. Of course this knife cuts
both ways, as sometimes people do undesirable things, like mine
cryptocurrency.)</p>
<p><strong>CI offerings like GitHub Actions and GitLab Pipelines are more products
than platforms because they tightly couple an opinionated configuration
mechanism (YAML files) and web UI (and corresponding APIs) on top of a
theoretically generic <em>remote execute as a service</em> offering.</strong> For me to
consider these offerings as platforms, they need to grow the ability to
schedule arbitrary compute via an API, without being constrained by the
YAML officially supported out of the box. GitLab is <em>almost</em> there (the
critical missing link is a <em>schedule an inline-defined pipeline</em> API). It
is unknown if GitHub is - or is even interested in - pursuing this
direction. (More on this later.)</p>
<h2>Taskcluster: The Most Powerful CI Platform You've Never Heard Of</h2>
<p>I wanted to just mention Taskcluster in passing as a counterexample to the
CI offerings that GitHub, GitLab, and others are pursuing. But I found myself
heaping praises towards it, so you get a full section on Taskcluster. This
content isn't critical to the overall post, so feel free to skip. But if
you want to know what a CI platform built for engineers looks like or you
are a developer of CI platforms and would like to read about some worthwhile
ideas to steal, keep reading.</p>
<p>Mozilla's <a href="https://docs.taskcluster.net/docs">Taskcluster</a> is a generic CI
platform originally built for Firefox. At the time it was conceived and
initially built out in 2014-2015, there was nothing else quite like it.
And I'm still not aware of anything that can match its raw capabilities.
There might be something proprietary behind corporate walls. But nothing
close to it in the open source domain. And even the proprietary CI platforms
I'm aware of often fall short of Taskcluster's feature list.</p>
<p><strong>To my knowledge, Taskcluster is the only publicly available, mega
project scale, true <em>CI platform</em> in existence.</strong></p>
<p>Germane to this post, one thing I love about Taskcluster is its core
primitives around defining execution units. The core execute primitive in
Taskcluster is a <a href="https://docs.taskcluster.net/docs/manual/tasks">task</a>.
Tasks are connected together to form a DAG. (This is not unlike how a
build system works.)</p>
<p>A <em>task</em> is created by issuing an API request to a <em>queue service</em>. That
API request essentially says <em>schedule this unit of work</em>.</p>
<p>Tasks are
<a href="https://docs.taskcluster.net/docs/reference/platform/queue/task-schema">defined</a>
somewhat generically, essentially as units of arbitrary compute along with metadata,
such as task dependencies, permissions/scopes that task has, etc. That
<a href="https://docs.taskcluster.net/docs/reference/workers/docker-worker/payload">unit of work</a>
has many of the primitives that are familiar to you if you use GitHub Actions,
GitLab Pipelines, etc: a list of commands to execute, which Docker image to
execute in, paths to files constituting artifacts, retry settings, etc.</p>
<p>Taskcluster has features far beyond what are offered by GitHub, GitLab, and
others today.</p>
<p>For example, Taskcluster offers an IAM-like
<a href="https://docs.taskcluster.net/docs/manual/tasks/scopes">scopes</a> feature that
moderates access control. Scopes control what actions you can perform, what
services you have access to, which runner features you can use (e.g. whether
you can use ptrace), which secrets you have access to, and more. As a concrete
example, Firefox's Taskcluster settings are such that the cryptographic
keys/secrets used to sign Firefox builds are inaccessible to untrusted tasks
(like the equivalent of tasks initiated by PRs - the <em>Try Server</em> in Mozilla
speak). Taskcluster is the only CI platform I'm aware of that has sufficient
protections in place to mitigate the fact that CI platforms are gaping <em>remote
code execution as a service</em> risks that can and should keep your internal
security and risk teams up at night. Taskcluster's security model makes
GitHub Actions, GitLab Pipelines, and other commonly used CI services look
like data exfiltration and software supply chain vulnerability factories by
comparison.</p>
<p>Taskcluster does support
<a href="https://docs.taskcluster.net/docs/reference/integrations/github/taskcluster-yml-v1">adding a YAML file to your repository to define tasks</a>.
However, because there's a generic scheduling API, you don't need to use it and
you aren't constrained by its features. You could roll your own
configuration/frontend for defining tasks: Taskcluster doesn't care because it is
a true <em>platform</em>. In fact, Firefox mostly eschews this Taskcluster YAML, instead
building out its own functionality for defining tasks. There's a pile of code
checked into the Firefox repository that when run will derive the thousands of
discrete tasks constituting Firefox's build and release DAG and will register the
appropriate sub-graph as Taskcluster tasks. (This also happens to be a
<a href="https://hg.mozilla.org/mozilla-central/file/tip/taskcluster/ci">pile of YAML</a>.
But the programming primitives and control flow are largely absent from YAML files,
making it a bit cleaner than the <em>YAML DSL</em> that e.g. GitHub and GitLab CI
YAML has evolved into.) This functionality is its own mini build system where
the Taskcluster platform is the execution/evaluation mechanism.</p>
<p>Taskcluster's model and capabilities are vastly beyond anything in GitHub
Actions or GitLab Pipelines today. There's a lot of great ideas worth copying.</p>
<p>Unfortunately, Taskcluster is very much a power user CI offering. There's no
centralized instance that anyone can use (unlike GitHub or GitLab). The learning
curve is quite steep. All that power comes at a cost of complexity. I can't in
good faith recommend Taskcluster to casual users. But if you want to host your
own CI platform, other CI offerings don't quite cut it for you, and you can
afford a few people to support your CI platform on an ongoing basis (i.e. your
total cost to operate CI including people and machines is &gt;$1M annually), then
Taskcluster is worth considering.</p>
<p>Let's get back to the post at hand.</p>
<h2>Looking to the Future</h2>
<p>In my ideal world there exists a single <em>remote code execution as a service</em>
platform purpose built for servicing both near real time and batch/delayed
execution. It is probably tailored towards supporting software development,
as those domain specific features set it apart from generic compute as a
service tools like Kubernetes, Lambda, and others. But something more
generic could potentially work.</p>
<p>The concept of a DAG is strongly baked into the execution model so you can
define execution units as a graph, capturing dependencies. Sure, you could
define isolated, ad-hoc units of work. But if you wanted to define a set
of units, you could do that without having to run a persistent agent to
coordinate execution through completion like build systems typically do.
(Think of this as <em>uploading your DAG to an execution service</em>.)</p>
<p>In my ideal world, there is a single DAG dictating all build, testing, and
release tasks. There is no DAG fragmentation at the build, CI, and other
batch execute boundaries. No N+1 system or configuration to manage and
additional platform to maintain because everything is unified. Economies
of scale applies and overall efficiency improves through consolidation.</p>
<p>The platform consists of pools of workers running agents capable of
performing work. There are probably pools for near real time / synchronous
RPC style invocations and pools for scheduled / delayed / asynchronous
execution. You can define your own worker pools and bring your own workers.
Advanced customers will likely throw autoscaling groups consisting of
highly ephemeral workers (such as EC2 spot instances) at these pools,
scaling capacity to meet demand relatively cheaply, terminating workers
and machines when capacity is no longer needed to save on billing
costs (this is what Firefox's Taskcluster instance has been doing for at
least 6 years).</p>
<p>To end-users, a <em>local build</em> consists of driving or scheduling the subset
of the complete task graph necessary to produce the build artifacts you
need. A <em>CI build/test</em> consists of the subset of the task graph necessary
to achieve that (it is probably a superset of the <em>local build</em> graph). Same
for releasing.</p>
<p>As for the configuration frontend and how execution units are defined, this
platform only needs to provide a single thing: an API that can be used to
schedule/execute work. However, for this product offering to be user-friendly,
it should offer something like YAML configuration files like CI systems do
today. That's fine: many (most?) users will stick to using the simplified
YAML interface. Just as long as power users have an escape/scaling vector
and can use the low-level schedule/execute API to write their own driver.
People will write plug-ins for their build systems enabling it to integrate
with this platform. Someone will coerce existing extensible build systems
like Bazel, Buck, and Gradle to convert nodes in the build graph to
compute tasks in this platform. This unlocks the unification of the build
and CI systems (and maybe things like data pipelines too).</p>
<p>Finally, because we're talking about a specialized system tailored for
software development, we need robust result/reporting APIs and interfaces.
What good is all this fancy distributed remote compute if nobody can see
what it is doing? This is probably the most specialized service of the bunch,
as how you track results is exceptionally domain specific. Power users may
want to build their own result tracking service, so keep that in mind. But
the platform should provide a generic one (like what GitHub Actions and GitLab
Pipelines do today) because it is a massive value add and few will use
your product without such a feature.</p>
<p>Quickly, my proposed unified world will not alleviate the CI complexity concerns
raised above: sufficiently large build/CI systems will always have an intrinsic
complexity to them and possibly require specialists to maintain. However,
because a complex CI system is almost always attached to a complex build system,
by consolidating build and CI systems, you reduce the surface area of complexity
(you don't have to worry about build/CI interop as much). Lower fragmentation
reduces overall complexity, and is therefore a new win. (A similar line of
thinking applies to justifying monorepositories.)</p>
<p><strong>All of the components for my vision exist in some working form today.</strong>
Bazel, Gradle Enterprise, and other modern build systems have RPCs for
remote execute and/or caching. They are even extensible and you can write
your own plugins to change core functionality for how the build system runs
(to varying degrees of course). CI offerings like Taskcluster and GitLab
Pipelines support scheduling DAGs of tasks (with Taskcluster's support far
more suited for the desired end state). There are batch job execution
frameworks like Airflow that look an awful lot like a domain-specific,
specialized versions of Taskcluster. <strong>What we don't have a is a single
product or service with all these features bundled as a cohesive offering.</strong></p>
<p><strong>I'm convinced that building what I'd like to see is not a question of
<em>if it can be done</em> but <em>whether we should</em> and <em>who will do it</em>.</strong></p>
<p>And this is where we probably run into problems. I hate to say it, but
I'm skeptical this will exist as a widely available service outside a few
corporations' walls any time soon. The reason is the total addressable market.</p>
<p>The value of my vision is through unification of discrete systems (build,
CI, and maybe some one-offs like data pipelines) that are themselves
complex enough that unification is something you'd want to do for
business/efficiency reasons. After all, if it isn't complex/inefficient,
you probably don't care about making it simpler/faster. Right here we
are probably filtering out &gt;90% of the market because their systems
just aren't complex enough for this to matter.</p>
<p>This vision requires adoption of a sufficiently advanced build system so it
can serve as the brains behind a unified DAG driving remote execute. Some
companies and projects will adopt compatible, advanced build systems like Bazel
because they have the resources, technical know-how, and efficiency incentives
to pull it off. But many won't. The benefit of a more advanced build system
over something simpler is often marginal. Factor in that many companies perceive
build and CI support as product development overhead and a virtual cost center
whose line item needs to be minimized. If you can get by on a less advanced
build system that is <em>good enough</em> for a fraction of the cost without excessive
hardship, that's the path many companies and projects will follow. Again,
people and companies generally don't care about wrangling build and CI
systems: they just want to ship.</p>
<p>The total addressable market for this idea seems too small for me to see
any major player with the technical know-how to implement and offer such
a service in the next few years. After all, we're not even over the hurdle
that what I propose (unifying build and CI systems) is a good idea. Having
worked in this space for a decade, witnessed the potential of Taskcluster's
model, and seen former, present, and potential employers all struggling in
this space to varying degrees, I know that this idea would be extremely
valuable to some. (For some companies multiple millions of dollars could be
saved annually by eliminating redundant human capital maintaining similar
systems, reducing machine idle/run costs, and improving turnaround times of
critical development loops.) As important as this would be to some companies,
my intuition is they represent such a small sliver of the total addressable
market that this slice of pie is too small for an existing CI operator like
GitHub or GitLab to care about at this time. There are far more lucrative
opportunities. (Such as security scanning, as laws/regulation/litigation are
finally catching up to the software industry and forcing companies to take
security and privacy more seriously, which translates to spending money on
security services. This is why GitHub and GitLab have been stumbling over
each other to announce new security features over the past 1-2 years.)</p>
<p>I don't think a startup in this area would be a good idea: customer acquisition
is too hard. And because much of the core tech already exists in existing tools,
there's not much of a moat in the way of proprietary IP to keep copycats
with deep pockets at bay. Your best exit here is likely an early acquisition
by a Microsoft/GitHub, GitLab, or wannabe player in this space like Amazon/AWS.</p>
<p>Rather, I think our best hope for seeing this vision realized is an operator
of an existing major CI platform (either private or public) who also has major
build system or other ad-hoc batch execute challenges will implement it and
release it upon the world, either as open source or as a service offering.
GitHub, GitLab, and other code hosting providers are the ideal candidates since
their community effect could help drive industry adoption. But I'd happily
accept pretty much any high quality offering from a reputable company!</p>
<p>I'm not sure when, but my money is on GitHub/Microsoft executing on this vision
first. They have a stronger incentive in the form of broader market/product
tie-ins (think integrated build and CI in Visual Studio or GitHub Workspaces
[for Enterprises]). Furthermore, they'll feel the call from within. Microsoft
has some really massive build systems and CI challenges (notably Windows). It
is clear that elements of Microsoft are conducting development on GitHub, in
the open even (at this point Satya Nadella's Microsoft has frozen over so many
levels of hell that Dante's classics need new revisions). Microsoft engineers
will feel the pain and limitations of discrete build and CI systems. Eventually
there will be calls for at least a build system remote execute service/offering
on GitHub. (This would naturally fall under GitHub's existing apparent market
strategy of capturing more and more of the software development lifecycle.) My
hope is GitHub (or whomever) will implement this as a unified
platform/service/product rather than discrete services because as I've argued
they are practically the same problem. But a unified offering isn't the path of
least resistance, so who knows what will happen.</p>
<h2>Conclusion</h2>
<p>If I could snap my fingers and move industry's discrete build, CI, and
maybe batch execute (e.g. data pipelines) ahead 10 years, I would:</p>
<ol>
<li>Take Mozilla's Taskcluster and its best-in-class specialized <em>remote execute
  as a service</em> platform.</li>
<li>Add support for a real-time, synchronous execute API (like Bazel's remote
   execute API) to supplement the existing batch/asynchronous functionality.</li>
<li>Define Starlark dialects so you define CI/release like primitives in build
   tools like Bazel. (You could also do YAML here. But if your configuration
   files devolve into DSL, just use a real programming language already.)</li>
<li>Teach build tools like Bazel to work better when units of work that can
   take minutes or even hours to run (a synchronous/online driver model such
   as classically employed by build systems isn't appropriate for long-running
   test, release, or say data pipelines).</li>
<li>Throw a polished web UI for platform interaction, result reporting, etc on
   top.</li>
<li>Release it to the world.</li>
</ol>
<p>Will this dream become a reality any time soon? Probably not. But I can dream.
And maybe I'll have convinced a reader to pursue it.</p>]]></content:encoded>
    </item>
    <item>
      <title>Investing in the Firefox Build System in 2016</title>
      <link>http://gregoryszorc.com/blog/2016/01/11/investing-in-the-firefox-build-system-in-2016</link>
      <pubDate>Mon, 11 Jan 2016 14:20:00 PST</pubDate>
      <category><![CDATA[Mozilla]]></category>
      <category><![CDATA[build system]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2016/01/11/investing-in-the-firefox-build-system-in-2016</guid>
      <description>Investing in the Firefox Build System in 2016</description>
      <content:encoded><![CDATA[<p>Most of Mozilla gathered in Orlando in December for an all hands meeting.
If you attended any of the plenary sessions, you probably heard people
like David Bryant and Lawrence Mandel make references to improving the
Firefox build system and related tools. Well, the cat is out of the bag:
<strong>Mozilla will be investing heavily in the Firefox build system and related
tooling in 2016!</strong></p>
<p>In the past 4+ years, the Firefox build system has mostly been held
together and incrementally improved by a loose coalition of people who
cared. We had a period in 2013 where a number of people were making
significant updates (this is when moz.build files happened). But for the
past 1.5+ years, there hasn't really been a coordinated effort to
improve the build system - just a lot of one-off tasks and
(much-appreciated) individual heroics. This is changing.</p>
<p>Improving the build system is a high priority for Mozilla in 2016.
And investment has already begun. In Orlando, we had a marathon 3 hour
meeting planning work for Q1. At least 8 people have committed to
projects in Q1.</p>
<p>The focus of work is split between immediate short-term wins and
longer-term investments. <strong>We also decided to prioritize the Firefox and
Fennec developer workflows (over Gecko/Platform) as well as the
development experience on Windows.</strong> This is because these areas have
been under-loved and therefore have more potential for impact.</p>
<p>Here are the projects we're focusing on in Q1:</p>
<ul>
<li>Turnkey artifact based builds for Firefox and Fennec (download
  pre-built binaries so you don't have to spend 20 minutes compiling
  C++)</li>
<li>Running tests from the source directory (so you don't have to copy
  tens of thousands of files to the object directory)</li>
<li>Speed up configure / prototype a replacement</li>
<li>Telemetry for mach and the build system</li>
<li>NSPR, NSS, and (maybe) ICU build system rewrites</li>
<li><em>mach build faster</em> improvements</li>
<li>Improvements to build rules used for building binaries (enables
  non-make build backends)</li>
<li>mach command for analyzing C++ dependencies</li>
<li>Deploy automated testing for <em>mach bootstrap</em> on TaskCluster</li>
</ul>
<p>Work has already started on a number of these projects. I'm optimistic
2016 will be a watershed year for the Firefox build system and the
improvements will have a drastic positive impact on developer
productivity.</p>]]></content:encoded>
    </item>
    <item>
      <title>MacBook Pro Firefox Build Times Comparison</title>
      <link>http://gregoryszorc.com/blog/2013/11/05/macbook-pro-firefox-build-times-comparison</link>
      <pubDate>Tue, 05 Nov 2013 10:00:00 PST</pubDate>
      <category><![CDATA[Mozilla]]></category>
      <category><![CDATA[build system]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2013/11/05/macbook-pro-firefox-build-times-comparison</guid>
      <description>MacBook Pro Firefox Build Times Comparison</description>
      <content:encoded><![CDATA[<p>Many developers use MacBook Pros for day-to-day Firefox development.
So, I thought it would be worthwhile to perform a comparison of
Firefox build times for various models of MacBook Pros.</p>
<h2>Test setup</h2>
<p>The numbers in this post are obtained from 3 generations of MacBook
Pros:</p>
<ol>
<li>
<p>A 2011 Sandy Bridge 4 core x 2.3 GHz with 8 GB RAM and an aftermarket
   SSD.</p>
</li>
<li>
<p>A 2012 Ivy Bridge retina with 4 core x 2.6 GHz, 16 GB RAM, and a
   factory SSD (or possibly flash storage).</p>
</li>
<li>
<p>A 2013 Haswell retina with 4 core x 2.6 GHz, 16 GB RAM, and flash
   storage.</p>
</li>
</ol>
<p>All machines were running OS X 10.9 Mavericks and were using the
Xcode 5.0.1 toolchain (<em>Xcode 5 clang: Apple LLVM version 5.0
(clang-500.2.79) (based on LLVM 3.3svn)</em>) to build.</p>
<p>The power settings prevented machine sleep and machines were plugged
into A/C power during measuring. I did not use the machines while
obtaining measurements.</p>
<p>The 2012 and 2013 machines were very vanilla OS installs. However,
the 2011 machine was my primary work computer and may have had a
few background services running and may have been slower due to
normal wear and tear. The 2012 machine was a loaner machine from
IT and has an unknown history.</p>
<p>All data was obtained from mozilla-central revision d4a27d8eda28.</p>
<p>The mozconfig used contained:</p>
<p>export MOZ_PSEUDO_DERECURSE=1
  mk_add_options MOZ_OBJDIR=@TOPSRCDIR@/obj-firefox.noindex</p>
<p>Please note that the objdir name ends with <em>.noindex</em> to prevent Finder
from indexing build files.</p>
<p>I performed all tests multiple times and used the fastest time. I used
<em>time</em> command for obtaining measurements of wall, user, and system
time.</p>
<h2>Results</h2>
<h3>Configure Times</h3>
<p>The result of <em>mach configure</em> is as follows:</p>
<table border="1">
  <tr>
    <th>Machine</th>
    <th>Wall time</th>
    <th>User time</th>
    <th>System time</th>
  </tr>
  <tr>
    <td>2011</td>
    <td>29.748</td>
    <td>17.921</td>
    <td>11.644</td>
  </tr>
  <tr>
    <td>2012</td>
    <td>26.765</td>
    <td>15.942</td>
    <td>10.501</td>
  </tr>
  <tr>
    <td>2013</td>
    <td>21.581</td>
    <td>12.597</td>
    <td>8.595</td>
  </tr>
</table>

<h3>Clobber build no ccache</h3>
<p><em>mach build</em> was performed <em>after</em> running <em>mach configure</em>. ccache was
not enabled.</p>
<table border="1">
  <tr>
    <th>Machine</th>
    <th>Wall time</th>
    <th>User time</th>
    <th>System time</th>
    <th>Total CPU time</th>
  </tr>
  <tr>
    <td>2011</td>
    <td>22:29 (1349)</td>
    <td>145:35 (8735)</td>
    <td>12:03 (723)</td>
    <td>157:38 (9458)</td>
  </tr>
  <tr>
    <td>2012</td>
    <td>15:00 (900)</td>
    <td>94:18 (5658)</td>
    <td>8:14 (494)</td>
    <td>102:32 (6152)</td>
  </tr>
  <tr>
    <td>2013</td>
    <td>11:13 (673)</td>
    <td>69:55 (4195)</td>
    <td>6:04 (364)</td>
    <td>75:59 (4559)</td>
  </tr>
</table>

<h3>Clobber build with empty ccache</h3>
<p><em>mach build</em> was performed <em>after</em> running <em>mach configure</em>. ccache was
enabled. The ccache ccache was cleared before running <em>mach configure</em>.</p>
<table border="1">
  <tr>
    <th>Machine</th>
    <th>Wall time</th>
    <th>User time</th>
    <th>System time</th>
    <th>Total CPU time</th>
  </tr>
  <tr>
    <td>2011</td>
    <td>25:57 (1557)</td>
    <td>161:30 (9690)</td>
    <td>18:21 (1101)</td>
    <td>179:51 (10791)</td>
  </tr>
  <tr>
    <td>2012</td>
    <td>16:58 (1018)</td>
    <td>104:50 (6290)</td>
    <td>12:32 (752)</td>
    <td>117:22 (7042)</td>
  </tr>
  <tr>
    <td>2013</td>
    <td>12:59 (779)</td>
    <td>79:51 (4791)</td>
    <td>9:24 (564)</td>
    <td>89:15 (5355)</td>
  </tr>
</table>

<h3>Clobber build with populated ccache</h3>
<p><em>mach build</em> was performed after running <em>mach configure</em>. ccache was
enabled and the ccache was populated with the results of a prior build.
In theory, all compiler invocations should be serviced by ccache
entries.</p>
<p>This measure is a very crude way to measure how fast clobber builds
would be if compiler invocations were nearly instantaneous.</p>
<table border="1">
  <tr>
    <th>Machine</th>
    <th>Wall time</th>
    <th>User time</th>
    <th>System time</th>
  </tr>
  <tr>
    <td>2011</td>
    <td>3:59 (239)</td>
    <td>8:04 (484)</td>
    <td>3:21 (201)(</td>
  </tr>
  <tr>
    <td>2012</td>
    <td>3:11 (191)</td>
    <td>6:45 (405)</td>
    <td>2:53 (173)</td>
  </tr>
  <tr>
    <td>2013</td>
    <td>2:31 (151)</td>
    <td>5:22 (322)</td>
    <td>2:12 (132)</td>
  </tr>
</table>

<h3>No-op builds</h3>
<p><em>mach build</em> was performed on a tree that was already built.</p>
<table border="1">
  <tr>
    <th>Machine</th>
    <th>Wall time</th>
    <th>User time</th>
    <th>System time</th>
  </tr>
  <tr>
    <td>2011</td>
    <td>1:58 (118)</td>
    <td>2:25 (145)</td>
    <td>0:41 (41)</td>
  </tr>
  <tr>
    <td>2012</td>
    <td>1:42 (102)</td>
    <td>2:02 (122)</td>
    <td>0:37 (37)</td>
  </tr>
  <tr>
    <td>2013</td>
    <td>1:20 (80)</td>
    <td>1:39 (99)</td>
    <td>0:28 (28)</td>
  </tr>
</table>

<h3>binaries no-op</h3>
<p><em>mach build binaries</em> was performed on a fully built tree. This results
in nothing being executed. It's a way to test the overhead of the
<em>binaries</em> make target.</p>
<table border="1">
  <tr>
    <th>Machine</th>
    <th>Wall time</th>
    <th>User time</th>
    <th>System time</th>
  </tr>
  <tr>
    <td>2011</td>
    <td>4.21</td>
    <td>4.38</td>
    <td>0.92</td>
  </tr>
  <tr>
    <td>2012</td>
    <td>3.17</td>
    <td>3.37</td>
    <td>0.71</td>
  </tr>
  <tr>
    <td>2013</td>
    <td>2.67</td>
    <td>2.75</td>
    <td>0.56</td>
  </tr>
</table>

<h3>binaries touch single .cpp</h3>
<p><em>mach build binaries</em> was performed on a fully built tree after touching
the file <em>netwerk/dns/nsHostResolver.cpp</em>. ccache was enabled but
cleared before running this test. This test simulates common C++
developer workflow of changing C++ and recompiling.</p>
<table border="1">
  <tr>
    <th>Machine</th>
    <th>Wall time</th>
    <th>User time</th>
    <th>System time</th>
  </tr>
  <tr>
    <td>2011</td>
    <td>12.89</td>
    <td>13.88</td>
    <td>1.96</td>
  </tr>
  <tr>
    <td>2012</td>
    <td>10.82</td>
    <td>11.63</td>
    <td>1.78</td>
  </tr>
  <tr>
    <td>2013</td>
    <td>8.57</td>
    <td>9.29</td>
    <td>1.23</td>
  </tr>
</table>

<h3>Tier times</h3>
<p>The times of each build system <em>tier</em> were measured on the 2013 Haswell
MacBook Pro. These timings were obtained out of curiosity to help
isolate the impact of different parts of the build. ccache was not
enabled for these tests.</p>
<table border="1">
  <tr>
    <th>Action</th>
    <th>Wall time</th>
    <th>User time</th>
    <th>System time</th>
    <th>Total CPU time</th>
  </tr>
  <tr>
    <td>export clobber</td>
    <td>15.75</td>
    <td>66.11</td>
    <td>11.33</td>
    <td>77.44</td>
  </tr>
  <tr>
    <td>compile clobber</td>
    <td>9:01 (541)</td>
    <td>64:58 (3898)</td>
    <td>5:08 (308)</td>
    <td>70:06 (4206)</td>
  </tr>
  <tr>
    <td>libs clobber</td>
    <td>1:34 (94)</td>
    <td>2:15 (135)</td>
    <td>0:39 (39)</td>
    <td>2:54 (174)</td>
  </tr>
  <tr>
    <td>tools clobber</td>
    <td>9.33</td>
    <td>13.41</td>
    <td>2.48</td>
    <td>15.89</td>
  </tr>
  <tr>
    <td>export no-op</td>
    <td>3.01</td>
    <td>9.72</td>
    <td>3.47</td>
    <td>13.19</td>
  </tr>
  <tr>
    <td>compile no-op</td>
    <td>3.18</td>
    <td>18.02</td>
    <td>2.64</td>
    <td>20.66</td>
  </tr>
  <tr>
    <td>libs no-op</td>
    <td>58.2</td>
    <td>46.9</td>
    <td>13.4</td>
    <td>60.3</td>
  </tr>
  <tr>
    <td>tools no-op</td>
    <td>8.82</td>
    <td>12.68</td>
    <td>1.72</td>
    <td>14.40</td>
  </tr>
</table>

<h2>Observations and conclusions</h2>
<p>The data speaks for itself: <strong>the 2013 Haswell MacBook Pro is
significantly faster than its predecessors.</strong> It clocks in at 2x faster
than the benchmarked 2011 Sandy Bridge model (keep in mind the 300 MHz
base clock difference) and is ~34% faster than the 2012 Ivy Bridge (at
similar clock speed). Personally, I was surprised by this. I was
expecting speed improvements over Ivy Bridge, but not 34%.</p>
<p>It should go without saying: <strong>if you have the opportunity to upgrade
to a new, Haswell-based machine: do it.</strong> If possible, purchase
the upgrade to a 2.6 GHz CPU, as it contains ~13% more MHz than the
base 2.3 GHz model: this will make a measurable difference in build
times.</p>
<p>It's worth noting the increased efficiency of Haswell over its
predecessors. The total CPU time required to build decreased from ~158
minutes to ~103 minutes to 76 minutes! That 76 minute number is worth
highlighting because it means if we get 100% CPU saturation during
builds, we'll be able to build the tree in under 10 wall time minutes!</p>
<p>I hadn't performed crude benchmarks of high-level build system actions
since the <em>MOZ_PSEUDO_DERECURSE</em> work landed and I wanted to use the
opportunity of this hardware comparison to grab some numbers.</p>
<p>The overhead of ccache continues to surprise me. On the 2013
machine, enabling ccache increased the wall time of a clobber build by
1:46 and added 13:16 of CPU time. This is an increase of 16% and 17%,
respectively.</p>
<p>It's worth highlighting just how much time is spent compiling C/C++. In
our artificial tier measuring results, our clobber build time was ~660
wall time seconds (11 minutes) and used ~4473s CPU time (74:33). Of
this, 9:01 wall time and 70:06 CPU time was spent compiling C/C++. This
represents ~82% wall time and ~94% CPU time! Please note this does not
include linking. <strong>Anything we can do to decrease the CPU time used by
the compiler will make the build faster.</strong></p>
<p>I also found it interesting to note variances in obtained times. Even on
my brand new 2013 Haswell MacBook Pro where I know there aren't many
background processes running, wall times could vary significantly. I
<em>think</em> I isolated it to CPU bursting and heat issues. If I wait a few
minutes between CPU intensive tests, results are pretty consistent. But
if I perform CPU intensive tests back-to-back, the run times often vary.
The only other thing coming into play could be page caching or
filesystem indexing. I accounted for the latter by disabling Finder
on the object directory. And, I'd like to think that flash storage is
fast enough to remove I/O latency from the equation. Who knows. At the
end of the day, laptops aren't servers and OS X is a consumer OS, so I
don't expect ultra consistency.</p>
<p>Finally, I want to restate just how fast Haswell is. If you have the
opportunity to upgrade, do it.</p>]]></content:encoded>
    </item>
    <item>
      <title>Distributed Compiling and Firefox</title>
      <link>http://gregoryszorc.com/blog/2013/10/31/distributed-compiling-and-firefox</link>
      <pubDate>Thu, 31 Oct 2013 11:35:00 PDT</pubDate>
      <category><![CDATA[Mozilla]]></category>
      <category><![CDATA[build system]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2013/10/31/distributed-compiling-and-firefox</guid>
      <description>Distributed Compiling and Firefox</description>
      <content:encoded><![CDATA[<p>If you had infinite CPU cores available and the Firefox build system
could distribute them all for concurrent compilation, Firefox
clobber build times would likely be 3-5 minutes instead of ~15
minutes on modern machines. This is a massive win. It therefore
should come as no surprise that distributed compiling is very
interesting to us.</p>
<p>Up until recently, the benefits of distributed compiling in the Firefox
build system couldn't be fully realized. This was because the build
system was performing recursive make traversal and make only <em>knew</em>
about a tiny subset of the tree's total C++ files at one time. For
example, when visiting <em>/layout/base</em> it only knew about 35 of the
close to 6000 files that get compiled as part of building Firefox. This
meant there was a hard ceiling to the max concurrency the build system
could achieve. This ceiling was often higher than the number of cores in
an individual machine, so it wasn't a huge issue for single machine
builds. But it did significantly limit the benefits of distributed
compiling. This all changed recently.</p>
<p><strong>As of a few weeks ago, the build system no longer encounters a low
ceiling preventing distributed compilation from reaping massive
benefits.</strong> If you have build with <em>make -j128</em>, make will spawn
128 compiler processes when processing the <em>compile</em> tier (which
is where most compilation occurs). If your compiler is set to a
distributed compiler, you will win.</p>
<p>So, what should you do about it?</p>
<p>I encourage people to set up distributed compilation <em>networks</em>
to reap the benefits of distributed compilation. Here are some tools you
should know about and some things to keep in mind.</p>
<p><a href="https://code.google.com/p/distcc/">distcc</a> is the tried and proven tool
for performing distributed compilation. It's heavily used and gets the
job done. It even works on Windows and can perform remote processing,
which is a huge win for our tree, where preprocessing can be
computationally expensive because of excessive includes. But, it has
a few significant drawbacks. Read the next paragraph.</p>
<p>I'm personally more excited about
<a href="https://github.com/icecc/icecream">icecream</a>. It has some very
compelling advantages to distcc. It has a scheduler that can
intelligently distribute load between machines. It uses network
broadcast to discover the scheduler. So, you just start the client
daemon and if there is a scheduler on the local network, it's all
set up. Icecream transfers the compiler toolchain between nodes
so you are guaranteed to have consistent output. (With distcc,
output may not be idempotent if the nodes aren't homogenous since distcc
relies on the system-local toolchain. If different versions are
installed on different nodes, you are out of luck). Icecream also
supports cross-compiling. In theory, you can have Linux machines
building for OS X, 32-bit machines building for 64-bit, etc. This
is all very difficult (if not impossible) to do with distcc.
Unfortunately, icecream doesn't work on Windows and doesn't appear
to support server-side preprocessing. Although, I imagine
both could be made to work if someone put in the effort.</p>
<p>Distributed compilation is very network intensive. I haven't measured,
but I suspect Wi-Fi bandwidth and latency constraints might make it
prohibitive there. It certainly won't be good for Wi-Fi saturation!
<strong>If you are in a Mozilla office, please do not attempt to perform
distributed compilation over Wi-Fi!</strong> For the same reasons, distributed
compilation will likely not benefit you if you are attempting to compile
on network-distant nodes.</p>
<p>I have set up an icecream server in the Mozilla San Francisco office. If
you install the icecream client daemon (iceccd) on your machine, it
should just work. I'm not sure what broadcast nets are configured as,
but I've successfully had machines on the 7th floor discover it
automatically. I guarantee no SLA for this server. Ping me privately
if you have difficulty connecting.</p>
<p>I've started very preliminary talks with Mozilla IT about setting up
dedicated <em>compiler farms</em> in Mozilla offices. I'm not saying this is
coming any time soon. I feel this will have a major impact on developer
productivity and I wanted to get the ball rolling months in advance
so nobody can claim this is a fire drill.</p>
<p>For distributed compilation to work well, the build system really needs
to be aware of distributed compilation. For example, to yield the
benefits of distributed compilation with make, you need to pass -j64 or
some other large value for concurrency. However, this value would be
universal for <em>every</em> task in the build. There are still thousands of
processes that must run locally. Using -j64 on these local tasks could
cause memory exhaustion, I/O saturation, excessive context switching,
etc. But if you decrease the concurrency ceiling, you lose the benefits
of distributed compilation! The build system thus needs to be taught
when distributed compilation is available and what tasks can be made
concurrent so it can intelligently adjust the -j concurrency limit at
run-time. This is why we have a higher-level build wrapper tool: <em>mach
build</em>. (This is another reason why people should be building through
mach instead of invoking make directly.)</p>
<p>No matter what technical solution we employ, I would like the build
system to automatically discover and use distributed compilation if
it is available. If we need to hardcode Mozilla IP addresses or
hostnames into the build system, I'm fine with that. I just don't want
developers not achieving much-faster build times because they are
ignorant. If you are in a physical location with distributed compilation
support, you should get that automatically: fast builds should not be
hard.</p>
<p>We can and should investigate distributed compilation as part of release
automation. Icecream should mitigate the concerns about build
reproducibility since the toolchain is transferred at build time.</p>
<p>I have had success getting Icecream to work with Linux builds. However,
OS X is problematic. Specifically, Icecream is unable to create the
build environment for distribution (likely modern OS X/Xcode
compatibility issue). Details are in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=927952">bug 927952</a>.</p>
<p>Build peers have a lot on our plate this quarter and making distributed
compilation work well is not in our official goals. <strong>I would love, love,
love if someone could step up and be a hero to make distributed
compilation work better with the build system.</strong> If you are interested,
pop into #build on irc.mozilla.org.</p>
<p>In summary, there are massive developer productivity wins waiting to be
realized through distributed compiling. There is nobody tasked to work
on this officially. Although, I'd love it if there were. If you find
yourself setting up ad-hoc networks in offices, I'd <em>really</em> like to see
some kind of discovery in <em>mach</em>. If not, there will be people left
behind and that really stinks for those individuals. If you do any
work around distributed compiling, please have it tracked under
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=485559">bug 485559</a>.</p>]]></content:encoded>
    </item>
    <item>
      <title>The State of the Firefox Build System (2013 Q3 Review)</title>
      <link>http://gregoryszorc.com/blog/2013/10/15/the-state-of-the-firefox-build-system-(2013-q3-review)</link>
      <pubDate>Tue, 15 Oct 2013 13:00:00 PDT</pubDate>
      <category><![CDATA[Mozilla]]></category>
      <category><![CDATA[build system]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2013/10/15/the-state-of-the-firefox-build-system-(2013-q3-review)</guid>
      <description>The State of the Firefox Build System (2013 Q3 Review)</description>
      <content:encoded><![CDATA[<p>As we look ahead to Q4 planning for the Firefox build system, I wanted
to take the time to reflect on what was accomplished in Q3 and to
simultaneously look forward to Q4 and beyond.</p>
<h2>2013 Q3 Build System Improvements</h2>
<p>There were notable improvements in the build system during the last
quarter.</p>
<p>The issues our <em>customers</em> care most about is speed. Here is a list of
accomplishments in that area:</p>
<ul>
<li>
<p><em>MOZ_PSEUDO_DERECURSE</em> work to change how make directory traversal
  works. This enabled the <em>binaries</em> make target, which can do no-op
  libxul-only builds in just a few seconds. Of all the changes that
  landed this quarter, this is the most impactful to local build
  times. This change also enables C++ compilation to scale out to
  as many cores as you have. Previously, the build system was
  <em>starved</em> in many parts of the tree when compiling C++. Mike Hommey
  is responsible for this work. I reviewed most of it.</p>
</li>
<li>
<p>WebIDL and IPDL bindings are now compiled in <em>unified</em> mode,
  reducing compile times and linker memory usage. Nathan Froyd wrote the
  code. I reviewed the patches.</p>
</li>
<li>
<p>XPIDL files are generated much more efficiently. This removed a
  few minutes of CPU core time from builds. I wrote these patches and
  Mike Hommey reviewed.</p>
</li>
<li>
<p>Increased reliance on install manifests to process file installs.
  They have drastically reduced the number of processes required to
  build by performing all actions inside Python processes as system
  calls and removing the clownshoes of having to delete parts of the
  object directory at the beginning of builds. When many mochitests
  were converted to manifests, no-op build times dropped by ~15%
  on my machine. Many people are responsible for this work. Mike Hommey
  wrote the original install code for packaging a few months ago. I
  built in manifest file support, support for symlinks, and made the
  code a bit more robust and faster. Mike Hommey reviewed these
  patches.</p>
</li>
<li>
<p>Many bugs and issues around dependency files on Windows have been
  discovered and fixed. These were a common source of clobbers.
  Mike Hommey found most of these, many during his work to make
  MOZ_PSEUDO_DERECURSE work.</p>
</li>
<li>
<p>The effort to reduce C++ include hell is resulting in significantly
  shorter incremental builds. While this effort is largely outside the
  build config module, it is worth mentioning. Ehsan Akhgari is leading
  this effort. He's been assisted by too many people to mention.</p>
</li>
<li>
<p>The build system now has different build modes favoring faster
  building vs release build options depending on the environment. Mike
  Hommey wrote most (all?) of the patches.</p>
</li>
</ul>
<p>A number of other non-speed related improvements have been made:</p>
<ul>
<li>
<p>The build system now monitors resource usage during builds and can
  graph the results. I wrote the code. Ted Mielczarek, Mike Hommey,
  and Mike Shal had reviews.</p>
</li>
<li>
<p>Support for test manifests has been integrated with the build system.
  This enabled some build speed wins and is paving the road for better
  testing UX, such as the automagical <em>mach test</em> command, which will
  run the appropriate test suite automatically. Multiple people were
  involved in the work to integrate test manifests with the build
  system. I wrote the patches. But Ted Mielczarek got primary review.
  Joel Maher, Jeff Hammel, and Ms2ger provided excellent assistance
  during the design and implementation phase. The work around
  mochitest manifests likely wouldn't have happened this quarter if
  all of us weren't attending an A*Team work week in August.</p>
</li>
<li>
<p>There are now in-tree build system docs. They are
  <a href="https://ci.mozilla.org/job/mozilla-central-docs/Build_Documentation/index.html">published automatically</a>.
  Efforts have been made to purge MDN of cruft. I am responsible for
  writing the code and most of the docs. Benjamin Smedberg and Mike Shal
  performed code reviews.</p>
</li>
<li>
<p>Improvements have been made to object directory detection in mach.
  This was commonly a barrier to some users using mach. I am responsible
  for the code. Nearly every peer has reviewed patches.</p>
</li>
<li>
<p>We now require Python 2.7.3 to build, making our future Python 3
  compatibility story much easier while eliminating a large class
  of Python 2.7.2 and below bugs that we constantly found ourselves
  working around.</p>
</li>
<li>
<p>mach bootstrap has grown many new features and should be more robust
  than ever. There are numerous contributors here, including many
  community members that have found and fixed bugs and have added
  support for additional distributions.</p>
</li>
<li>
<p>The boilerplate from Makefile.in has disappeared. Mike Hommey is to
  thank.</p>
</li>
<li>
<p>dumbmake integrated with mach. Resulted in friendlier build interface
  for a nice UX win. Code by Nick Alexander. I reviewed.</p>
</li>
<li>
<p>Many variables have been ported from Makefile.in to moz.build. We
  started Q3 with support for 47 variables and now support 73. We
  started with 1226 Makefile.in and 1517 moz.build and currently
  have 941 Makefile.in and 1568 moz.build. Many people contributed to
  this work. Worth mentioning are Joey Armstrong, Mike Shal, Joshua
  Cranmer, and Ms2ger.</p>
</li>
<li>
<p>Many build actions are moving to Python packages. This enabled pymake
  <em>inlining</em> (faster builds) and is paving the road towards no .pyc
  files in the source directory. (pyc files commonly are the source of
  clobber headaches and make it difficult to efficiently perform builds
  on read-only filesystems.) I wrote most of the patches and Mike Shal
  and Mike Hommey reviewed.</p>
</li>
<li>
<p>moz.build is now more strict about what it accepts. We check for
  missing files at config parse time rather than build time, causing
  errors to surface faster. Many people are responsible for this work.
  Mike Shal deserves kudos for work around C/C++ file validation.</p>
</li>
<li>
<p>mach has been added to the B2G repo. Jonathan Griffin and Andrew
  Halberstadt drove this.</p>
</li>
</ul>
<h2>Current status of the build bystem</h2>
<p>Q3 was a very significant quarter for the build system. For the first
time in years, we made fundamental changes to how the build system
goes about building. The moz.build work to free our build config from
the shackles of make files had enabled us to consume that data and do
new and novel things with it. This has enabled improvements in build
robustness and - most importantly - speed.</p>
<p>This is most evident with the MOZ_PSEUDO_DERECURSE work, which
effectively replaces how make traverses directories. The work there
has allowed Gecko developers focused on libxul to go from e.g. 50s
no-op build times to less than 5s. Combined with optimized building
of XPIDL, IPDL, and WebIDL files, processing of file installs via
manifests, and C++ header dependency reduction, and a host of other
changes, and we are finally turning a corner on build times! Much of
this work wouldn't have been possible without moz.build files providing
a whole world view of our build config.</p>
<p>The quarter wasn't all roses. Unfortunately, we also broke things. A lot.
The total number of required clobbers this quarter grew slightly from
38 in Q2 to 43 in Q3. Many of these clobbers were regressions from
supposed improvements to the build system. Too many of these
regressions were Windows/pymake only and surely would have been found
prior to landing if more build peers were actively building on Windows.
There are various reasons we aren't. We should strive to fix them so
more build development occurs on Windows and Windows users aren't
unfairly punished.</p>
<p>The other class of avoidable clobbers mostly revolves
around the theme that <em>the build system is complicated</em>, particularly
when it comes to integration with release automation. Build automation
has its build logic currently coded in Buildbot config files. This means
it's all but impossible for build peers to test and reproduce that build
environment and flow without time-intensive, stop-energy abundant
excessive try pushes or loading out build slaves. The RelEng effort
to extract this code from buildbot to mozharness can't come soon enough. See
<a href="/blog/2013/07/16/analysis-of-firefox%27s-build-automation/">my overview</a>
on how automation works for more.</p>
<p>This quarter, the sheriffs have been filing bugs whenever a clobber is
needed. This has surfaced clobber issues to build peers better and I
have no doubt their constant pestering caused clobber issues to be
resolved sooner. It's a terrific incentive for us to fix the build
system.</p>
<p>I have mixed feelings on the personnel/contribution front in Q3. Kyle
Huey no longer participates in active build system development or patch
review. Ted Mielczarek is also starting to drift away from active coding
and review. Although, he does constantly provide knowledge and historical
context, so not all is lost. It is disappointing to see fantastic
people and contributors no longer actively participating on the coding
front. But, I understand the reasons behind it. Mozilla doesn't have a
build team with a common manager and decree (a mistake if you ask me).
Ted and Kyle are both insanely smart and talented and they work for
teams that have other important goals. They've put in their time (and
suffering). So I see why they've moved on.</p>
<p>On the plus side, Mike Hommey has been spending a lot more time on build
work. He was involved in many of the improvements listed above. Due to
review load and Mike's technical brilliance, I don't think many of our
accomplishments would have happened without him. If there is one
Mozillian who should be commended for build system work in Q3, it should
be Mike Hommey.</p>
<p>Q3 also saw the addition of new build peers. Mike Shal is now a full
build config module peer. Nick Alexander is now a peer of a submodule
covering just the Fennec build system. Aside from his regular patch
work, Mike Shal has been developing his review skills and
responsibilities. Without him, we would likely be drowning in review
requests and bug investigations due to the departures of Kyle and Ted.
Nick is already doing what I'd hope he'd do when put in charge of the
Fennec build system: looking at a proper build backend for Java (not
make) and Eclipse project generation. (I still can't believe many of
our Fennec developers code Java in vanilla text editors, not powerful
IDEs. If there is one language that would miss IDEs the most, I'd think
it would be Java. Anyway.)</p>
<p>There was a steady stream of contributions from people not in the build
config module. Joshua Cranmer has been keeping up with moz.build
conversions for comm-central. Nathan Froyd and Boris Zbarsky have helped
with all kinds of IDL work. Trevor Saunders has helped keep things
clean. Ms2ger has been eager to provide assistance through code and
reviews. Various community contributors have helped with moz.build
conversion patches and improvements to mach and the bootstrapper. Thank
you to everyone who contributed last quarter!</p>
<h2>Looking to the future</h2>
<p>At the beginning of the quarter, I didn't think it would be possible
to attain no-op build speeds with make as quickly as <em>make binaries</em> now
does. But, Mike Hommey worked some magic and this is now possible.
This was a game changer. The code he wrote can be applied to other
build actions. And, our other solutions involving moz.build files to
autogenerated make files seems to be working pretty well too.
This raises some interesting questions with regards to priortization.</p>
<p>Long term, we know we want to move away from make. It is old
and clumsy. It's easy to do things wrong. It doesn't scale to handle a
single DAG as large as our build system. The latter is particularly
important if we are to ever have a build system that doesn't require
clobbers periodically.</p>
<p>Up to this point we've prioritized work on moz.build conversion, with
the rationale being that it would more soon enable a clean break from
make and thus we'd arrive at drastically faster builds sooner. The assumption in that
argument was that drastically faster builds weren't attainable with
make. Between the directory traversal overhaul and the release of GNU
make 4.0 last week (which actually seems to work on Windows, making the
pymake slowness a non-issue), the importance of breaking away from make
now seems much less pressing.</p>
<p>While we would like to actively move off make, developments in the past
few weeks seem to say that we can reassess priorities. I believe that we
can drive down no-op builds with make to a time that satisfies many -
let's say under 10s to be conservative. Using clever tricks optimizing
for common developer workflows, we can probably get that under 5s
everywhere, including Windows (people only caring about libxul can
get 2.5s on mozilla-central today). This isn't the 250ms we could get
with Tup. But it's much better than 45s. If we got there, I don't think
many people would be complaining.</p>
<p>So, the big question for goals setting this quarter will be whether we
want to focus on a new build backend (likely Tup) or whether we should
continue with an emphasis on make. Now, a lot of the work involved
applies to both make and any other build backend. But, I have little
doubt it would be less overall work to support one build backend (make)
than two. On the other hand, we know we want to support multiple build
backends eventually. Why wait? In the balance are
<a href="https://etherpad.mozilla.org/build-system-goals">numerous other projects</a>
that have varying impact for developers and release automation. While
important in their own right, it is difficult to balance them against
build speed. While we could strive towards instantaneous builds, at some
point we'll hit <em>good enough</em> and the diminishing returns that accompany
them. There is already a small vocal faction advocating for Ninja
support, even though it would only decrease no-op libxul build times
from ~2.5s to 250ms. While a factor of 10x improvement, I think this is
dangerously close to diminishing returns territory and our time
investment would be better spent elsehwere. (Of course, once we can
support building libxul with Ninja, we could easily get it for Tup. And,
I believe Tup wins that tie.). Anyway, I'm sure it will be an
interesting discussion!</p>
<p>Whatever the future holds, it was a good quarter for the build system and
the future is looking brighter than ever. We have transitioned from a
maintain-and-react mode (which I understand has largely been the norm
since the dawn of Firefox) to a proactive and future-looking approach
that will satisfy the needs of Firefox and its developers for the next
ten years. All of this progress is even more impressive when you consider
that we still react to an aweful lot of fire drills and unwanted
maintenance!</p>
<p>The Firefox build system is improving. I'm as anxioux as you are to see
various milestones in terms of build speed and other features. But it's
hard work. Wish us luck. Please help out where you can.</p>]]></content:encoded>
    </item>
    <item>
      <title>Build System Status Update 2013-05-14</title>
      <link>http://gregoryszorc.com/blog/2013/05/13/build-system-status-update-2013-05-14</link>
      <pubDate>Mon, 13 May 2013 19:35:00 PDT</pubDate>
      <category><![CDATA[Mozilla]]></category>
      <category><![CDATA[build system]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2013/05/13/build-system-status-update-2013-05-14</guid>
      <description>Build System Status Update 2013-05-14</description>
      <content:encoded><![CDATA[<p>I'd like to make an attempt at delivering regular status updates on the
Gecko/Firefox build system and related topics. Here we go with the
first instance. I'm sure I missed awesomeness. Ping me and I'll add it
to the next update.</p>
<h2>MozillaBuild Windows build environment updated</h2>
<p>Kyle Huey
<a href="https://groups.google.com/d/msg/mozilla.dev.platform/XRecAHF-H28/aSbrdKJLUNoJ">released version 1.7</a>
of our Windows build environment. It contains a newer version of Python
and a modern version of Mercurial among other features.</p>
<p><strong>I highly recommend every Windows developer update ASAP.</strong> Please note
that you will likely encounter Python errors unless you clobber your
build.</p>
<h2>New submodule and peers</h2>
<p>I used my power as module owner to create a submodule of the build
config module whose scope is the (largely mechanical) transition of
content from Makefile.in to moz.build files. I granted Joey Armstrong
and Mike Shal peer status for this module. I would like to eventually
see both elevated to build peers of the main build module.</p>
<h2>moz.build transition</h2>
<p>The following progress has been made:</p>
<ul>
<li>Mike Shal has converted variables related to defining XPIDL files in
  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=818246">bug 818246</a>.</li>
<li>Mike Shal converted MODULE in
  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=844654">bug 844654</a>.</li>
<li>Mike Shal converted EXPORTS in
  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=846634">bug 846634</a>.</li>
<li>Joey Armstrong converted xpcshell test manifests in
  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=844655">bug 844655</a>.</li>
<li>Brian O'Keefe converted PROGRAM in
  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=862986">bug 862986</a>.</li>
<li>Mike Shal is about to land conversion of CPPSRCS in
  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=864774">bug 864774</a>.</li>
</ul>
<h2>Non-recursive XPIDL generation</h2>
<p>In <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=850380">bug 850380</a>
I'm trying to land non-recursive building of XPIDL files. As part of
this I'm trying to combine the generation of .xpt and .h for each input
.idl file into a single process call because profiling revealed that
parsing the IDL consumes most of the CPU time. This shaves a few dozen
seconds off of build times.</p>
<p>I have encounterd multiple pymake bugs when developing this patch, which
is the primary reason it hasn't landed yet.</p>
<h2>WebIDL refactoring</h2>
<p>I was looking at my build logs and noticed WebIDL generation was taking
longer than I thought it should. I filed
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=861587">bug 861587</a> to
investigate making it faster. While my initial profiling turned out to
be wrong, Boris Zbarsky looked into things and discovered that the
serialization and deserialization of the parser output was extremely
slow. He is currently trying to land a refactor of how WebIDL bindings
are handled. The early results look <strong>very</strong> promising.</p>
<p>I think the bug is a good example of the challenges we face improving
the build system, as Boris can surely attest.</p>
<h2>Test directory reorganization</h2>
<p>Joel Maher is injecting sanity into the naming scheme of test
directories in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=852065">bug 852065</a>.</p>
<h2>Manifests for mochitests</h2>
<p>Jeff Hammel, Joel Maher, Ted Mielczarek, and I are working out using
manifests for mochitests (like xpcshell tests) in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=852416">bug 852416</a>.</p>
<h2>Mach core is now a standalone package</h2>
<p>I extracted the mach core to a
<a href="https://github.com/indygreg/mach">standalone repository</a> and
<a href="https://pypi.python.org/pypi/mach/">added it to PyPI</a>.</p>
<p>Mach now <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=856392">categorizes</a>
commands in its help output.</p>
<h2>Requiring Python 2.7.3</h2>
<p>Now that the Windows build environment ships with Python 2.7.4, I've
filed <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=870420">bug 870420</a>
to require Python 2.7.3+ to build the tree. We already require
Python 2.7.0+. I want to bump the point release because there are
<a href="http://hg.python.org/cpython/file/d46c1973d3c4/Misc/NEWS">many</a> small
bug fixes in 2.7.3, especially around Python 3 compatibility.</p>
<p>This is currently blocked on RelEng rolling out 2.7.3 to all the
builders.</p>
<h2>Eliminating master xpcshell manifest</h2>
<p>Now that xpcshell test manifests are defined in moz.build files, we
theoretically don't need the master manifest. Joshua Cranmer is working
on removing them in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=869635">bug 869635</a>.</p>
<h2>Enabling GTests and dual linking libxul</h2>
<p>Benoit Gerard and Mike Hommey are working in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=844288">bug 844288</a> to
dual link libxul so GTests can eventually be enabled and executed as
part of our automation.</p>
<p>This will regress build times since we need to link libxul twice. But,
giving C++ developers the ability to write unit tests with a real
testing framework is worth it, in my opinion.</p>
<h2>ICU landing</h2>
<p>ICU was briefly enabled in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=853301">bug 853301</a> but
then backed out because it broke cross-compiling. It should be on track
for enabling in Firefox 24.</p>
<h2>Resource monitoring in mozbase</h2>
<p>I <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=802420">gave mozbase</a>
a class to record system resource usage. I plan to eventually hook this
up to the build system so the build system records how long it took to
perform key events. This will give us better insight into slow and
inefficient parts of the build and will help us track build system speed
improvements over time.</p>
<h2>Sorted lists in moz.build files</h2>
<p>I'm working on requiring lists in moz.build be sorted. Work is happening
in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=863069">bug 863069</a>.</p>
<p>This idea started as a suggestion on the dev-platform list. If anyone
has more great ideas, don't hold them back!</p>
<h2>Smartmake added to mach</h2>
<p>Nicholas Alexander
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=677452">taught mach</a> how
to build intelligently by importing some of Josh Matthews' smartmake
tool's functionality into the tree.</p>
<h2>Source server fixed</h2>
<p>Kyle Huey and Ted Mielczarek
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=846864">collaborated</a> to
fix the source server.</p>
<h2>Auto clobber functionality</h2>
<p>Auto clobber functionality was added to the tree. After flirting briefly
with on-by-default, we changed it to opt-in. When you encounter it, it
will tell you how to enable it.</p>
<h2>Faster clobbers on automation</h2>
<p>I was looking at build logs and identified we were inefficiently
performing clobber.</p>
<p>Massimo Gervasini and Chris AtLee
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=851270">deployed changes</a>
to automation to make it more efficient. My measurements showed a
Windows try build that took 15 fewer minutes to start - a <em>huge</em>
improvement.</p>
<h2>Upgrading to Mercurial 2.5.4</h2>
<p>RelEng is <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=741353">tracking</a>
the global deployment of Mercurial 2.5.4. hg.mozilla.org is
currently running 2.0.2 and automation is all over the map. The upgrade
should make Mercurial operations faster and more robust across the
board.</p>
<p>I'm considering adding code to mach or the build system that prompts the
user when her Mercurial is out of date (since an out of date Mercurial
can result in a sub-par user experience).</p>
<h2>Parallelize reftests</h2>
<p>Nathan Froyd is
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=813742">leading an effort</a>
to parallelize reftest execution. If he pulls this off, it could shave
hours off of the total automation load per checkin. Go Nathan!</p>
<h2>Overhaul of MozillaBuild in the works</h2>
<p>I am mentoring a pair of interns this summer. I'm still working out the
final set of goals, but I'm keen to have one of them overhaul the
MozillaBuild Windows development environment. Cross your fingers.</p>]]></content:encoded>
    </item>
    <item>
      <title>Mozilla Build System Brain Dump</title>
      <link>http://gregoryszorc.com/blog/2013/05/13/mozilla-build-system-brain-dump</link>
      <pubDate>Mon, 13 May 2013 17:25:00 PDT</pubDate>
      <category><![CDATA[build system]]></category>
      <category><![CDATA[Mozilla]]></category>
      <category><![CDATA[Firefox]]></category>
      <category><![CDATA[mach]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2013/05/13/mozilla-build-system-brain-dump</guid>
      <description>Mozilla Build System Brain Dump</description>
      <content:encoded><![CDATA[<p>I hold a lot of context in my head when it comes to the future of
Mozilla's build system and the interaction with it. I wanted to
perform a brain dump of sorts so people have an idea of where I'm
coming from when I inevitably propose radical changes.</p>
<h2>The sad state of build system interaction and the history of mach</h2>
<p>I believe that Mozilla's build system has had a poor developer
experience for as long as there has been a Mozilla build system.
Getting started with Firefox development was a rite of passage. It
required following (often out-of-date) directions on MDN. It
required finding pages through MDN search or asking other people
for info over IRC. It was the kind of process that turned away
potential contributors because it was just too damn hard.</p>
<p>mach - while born out of my initial efforts to radically change
the build system proper - morphed into a generic command
dispatching framework by the time it landed in mozilla-central.
It has one overarching purpose: provide a single gateway point for
performing common developer tasks (such as building the tree and
running tests). The concept was nothing new - individual developers
had long coded up scripts and tools to streamline workflows. Some
even published these for others to use. What set mach apart was a
unified interface for these <em>commands</em> (the mach script in the
top directory of a checkout) and that these productivity gains
were <strong>in the tree</strong> and thus easily discoverable and usable by
<em>everybody</em> without significant effort (just run <em>mach help</em>).</p>
<p>While mach doesn't yet satisfy everyone's needs, it's slowly
growing new features and making developers' lives easier with
every one. All of this is happening despite that there
is not a single person tasked with working on mach full time.
Until a few months ago, mach was largely my work. Recently, Matt
Brubeck has been contributing a flurry of enhancements - thanks
Matt! Ehsan Akhgari and Nicholas Alexander have contributed a
few commands as well! There are also a few people with a single
command to their name. This is fulfilling my original vision of
facilitating developers to scratch their own itches by
contributing mach commands.</p>
<p>I've noticed more people referencing mach in IRC channels. And,
more people get angry when a mach command breaks or changes
behavior. So, I consider the mach experiment a success. Is it
perfect, no. If it's not good enough for you, please file a bug
and/or code up a patch. If nothing else, please tell me: I love to
know about everyone's subtle requirements so I can keep them in
mind when refactoring the build system and hacking on mach.</p>
<h2>The object directory is a black box</h2>
<p>One of the ideas I'm trying to advance is that the object directory
should be considered a black box for the majority of developers. In
my ideal world, developers don't need to look inside the object
directory. Instead, they interact with it through condoned and
supported tools (like mach).</p>
<p>I say this for a few reasons. First, as the build config module owner
I would like the ability to massively refactor the <em>internals</em> of
the object directory without disrupting workflows. If people are
interacting directly with the object directory, I get significant
push back if things change. This inevitably holds back much-needed
improvements and triggers resentment towards me, build peers, and
the build system. Not a good situation. Whereas if people are
indirectly interacting with the object directory, we simply need to
maintain a consistent interface (like mach) and nobody should care
if things change.</p>
<p>Second, I believe that the methods used when directly interacting
with the object directory are often sub-par compared with going
through a more intelligent tool and that productivity suffers as a
result. For example, when you type <em>make</em> in inside the object
directory you need to know to pass <em>-j8</em>, use make vs pymake,
and that you also need to build <em>toolkit/library</em>, etc.
Also, by invoking make directly, you bypass other handy features,
such as automatic compiler warning aggregation (which only happens
if you invoke the build system through mach). If you go through a
tool like <em>mach</em>, you <em>should</em> automatically get the most ideal
experience possible.</p>
<p>In order for this vision to be realized, we need massive
improvements to tools like mach to cover the missing workflows that
still require direct object directory interaction. We also need people
to start using mach. I think increased mach usage comes after mach
has established itself as obviously superior to the alternatives
(I already believe it offers this for tasks like running tests).</p>
<h2>I don't want to force mach upon people but...</h2>
<p>Nobody likes when they are forced to change a process that has been
familiar for years. Developers especially. I get it. That's why
I've always attempted to position mach as an alternative to
existing workflows. If you don't like mach, you can always fall
back to the previous workflow. Or, you can improve mach (patches
more than welcome!). Having gone down the
please-use-this-tool-it's-better road before at other
organizations, I strongly believe that the best method to incur
adoption of a new tool is to gradually sway people through
obvious superiority and praise (as opposed to a mandate to switch).
I've been trying this approach with mach.</p>
<p>Lately, more and more people have been saying things like
<em>we should have the build infrastructure build through mach
instead of client.mk</em> and <em>why do we need testsuite-targets.mk when
we have mach commands.</em> While I personally feel that client.mk
and testsuite-targets.mk are antiquated as a developer-facing
interface compared to mach, I'm reluctant to eliminate them because
I don't like forcing change on others. That being said, there are
compelling reasons to eliminate or at least refactor how they work.</p>
<p>Let's take <em>testsuite-targets.mk</em> as an example. This is the make
file that provides the targets to run tests (like <em>make xpcshell-test</em>
and <em>make mochitest-browser-chrome</em>). What's interesting about this
file is that it's only used in local builds: our automation
infrastructure does not use <em>testsuite-targets.mk</em>! Instead,
<em>mozharness</em> and the old buildbot configs manually build up the
command used to invoke the test harnesses. Initially, the mach
commands for running tests simply invoked make targets defined
in <em>testsuite-targets.mk</em>. Lately, we've been converting the mach
commands to invoke the Python test runners directly. I'd argue that
the logic for <em>invoke the test runner</em> only needs to live in one
place in the tree. Furthermore as a build module peer, I have little
desire to support multiple implementations. Especially considering
how fragile they can be.</p>
<p>I think we're trending towards an outcome where mach (or the code
behind mach commands) transitions into the authoratitive invocation
method and <em>legacy</em> interfaces like <em>client.mk</em> and
<em>testsuite-targets.mk</em> are reimplemented to either call mach
commands or the same routine that powers them. Hopefully this
will be completely transparent to developers.</p>
<h2>The future of mozconfigs and environment configuration</h2>
<p><em>mozconfig</em> files are shell scripts used to define variables consumed
by the build system. They are the only officially supported mechanism
for configuring how the build system works.</p>
<p>I'd argue mozconfig files are a mediocre solution at best. First,
there's the issue of mozconfig statements that don't actually do
anything. I've seen no-op mozconfig content cargo culted into the
in-tree mozconfigs (used for the builder configurations)! Oops.
Second, doing things in mozconfig files is just awkward. Defining
the object directory requires <em>mk_add_options MOZ_OBJDIR=some-path</em>.
What's <em>mk_add_options</em>? If <em>some-path</em> is relative, what is it
relative <em>to</em>? While certainly addressable, the documentation on
how mozconfig files work is not terrific and fails to explain many
pitfalls. Even with proper documentation, there's still the issue
of the file format allowing no-op variable assignments to persist.</p>
<p>I'm very tempted to reinvent build configuration as something not
mozconfigs. What exactly, I don't know. mach has support for ini-like
configuration files. We could certainly have mach and the build
system pull configs from the same file.</p>
<p>I'm not sure what's going to happen here. But deprecating mozconfig
files as they are today is part of many of the options.</p>
<h2>Handling multiple mozconfig files</h2>
<p>A lot of developers only have a single mozconfig file (per source tree
at least). For these developers, life is easy. You simply install
your mozconfig in one of the default locations and it's automagically
used when you use mach or client.mk. Easy peasy.</p>
<p>I'm not sure what the relative numbers are, but many developers
maintain multiple mozconfig files per source tree. e.g. they'll
have one mozconfig to build desktop Firefox and another one for
Android. They may have debug variations of each.</p>
<p>Some developers even have a single mozconfig file but leverage the
fact that mozconfig files are shell scripts and have their
mozconfig dynamically do things depending on the current working
directory, value of an environment variable, etc.</p>
<p>I've also seen wrapper scripts that glorify setting environment
variables, changing directory, etc and invoke a command.</p>
<p>I've been thinking a lot about providing a common and well-supported
solution for switching between active build configurations.
<a href="https://developer.mozilla.org/en-US/docs/Developer_Guide/mach#Adding_mach_to_your_shell%27s_search_path">Installing mach on $PATH</a>
goes a long way to facilitate this. If you are in an object
directory, the mozconfig used when that object directory was
created is automatically applied. Simple enough. However, I want
people to start treating object directories as black boxes. So, I'd
rather not see people have their shell inside the object directory.</p>
<p>Whenever I think about solutions, I keep arriving at a
virtualenv-like solution. Developers would potentially need to
<em>activate</em> a Mozilla build environment (similar to how Windows
developers need to launch MozillaBuild). Inside this environment,
the shell prompt would contain the name of the current build
configuration. Users could switch between configurations using
<em>mach switch</em> or some other magic command on the $PATH.</p>
<p>Truth be told, I'm skeptical if people would find this useful. I'm
not sure it's that much better than exporting the MOZCONFIG
environment variable to define the active config. This one requires
more thought.</p>
<h2>The integration between the build environment and Python</h2>
<p>We use Python extensively in the build system and for common
developer tasks. mach is written in Python. moz.build processing
is implemented in Python. Most of the test harnesses are written in
Python.</p>
<p>Doing practically anything in the tree requires a Python
interpreter that knows about all the Python code in the tree and
how to load it.</p>
<p>Currently, we have two very similar Python environments. One is
a virtualenv created while running configure at the beginning of
a build. The other is essentially a cheap knock-off that mach
creates when it is launched.</p>
<p>At some point I'd like to consolidate these Python environments.
From any Python process we should have a way to automatically
bootstrap/activate into a well-defined Python environment. This
certainly sounds like establishing a unified Python virtualenv
used by both the build system and mach.</p>
<p>Unfortunately, things aren't straightforward. The virtualenv today
is constructed in the object directory. How do we determine the
current object directory? By loading the mozconfig file. How do we
do that? Well, if you are mach, we use Python. And, how does mach
know where to find the code to load the mozconfig file? You can
see the dilemma here.</p>
<p>A related issue is that of portable build environments. Currently, a
lot of our automation recreates the build system's virtualenv from
its own configuration (not that from the source tree). This has
and will continue to bite us. We'd <em>really</em> like to package up the
virtualenv (or at least its config) with tests so there is no
potential for discrepancy.</p>
<p>The inner workings of how we integrate with Python should be
invisible to most developers. But, I figured I'd capture it
here because it's an annoying problem. And, it's also related
to an <em>activated</em> build environment. What if we required all
developers to <em>activate</em> their shell with a Mozilla build
environment (like we do on Windows)? Not only would this solve
Python issues, but it would also facilitate simpler config
switching (outlined above). Hmmm...</p>
<h2>Direct interaction with the build system considered harmful</h2>
<p>Ever since there was a build system developers have been typing
<em>make</em> (or <em>make.py</em>) to build the tree. One of the goals of the
transition to <em>moz.build</em> files is to facilitate building the tree
with Tup. <em>make</em> will do nothing when you're not using Makefiles!
Another goal of the <em>moz.build</em> transition is to start
derecursifying the make build system such that we build things in
parallel. It's likely we'll produce monolithic make files and then
process <em>all</em> targets for a related class <em>IDLs</em>, <em>C++ compilation</em>,
etc in one invocation of <em>make</em>. So, uh, what happens during a partial
tree build? If a .cpp file from <em>/dom/src/storage</em> is being handled by
a monolithic make file invoked by the Makefile at the top of the
tree, how does a partial tree build pick that up? Does it build just
that target or every target in the monolithic/non-recursive make file?</p>
<p>Unless the build peers go out of our way to install redundant targets
in leaf Makefiles, directly invoking <em>make</em> from a subdirectory of
the tree won't do what it's done for years.</p>
<p>As I said above, I'm sympathetic to forced changes in procedure, so
it's likely we'll provide backwards-compatibile behavior. But, I'd
prefer to not do it. I'd first prefer partial-tree builds are not
necessary and a full tree build finishes quickly. But, we're not going
to get there for a bit. As an alternative, I'll take people building
through <em>mach build</em>. That way, we have an easily extensible interface
on which to build partial tree logic. We saw this recently when
dumbmake/smartmake landed. And, going through <em>mach</em> also reinforces my
ideal that the object directory is a black box.</p>
<h2>Semi-persistent state</h2>
<p>Currently, most state as it pertains to a checkout or build is in the
object directory. This is fine for artifacts from the build system.
However, there is a whole class of state that arguably shouldn't be in
the object directory. Specifically, it shouldn't be clobbered when you
rebuild. This includes logs from previous builds, the warnings database,
previously failing tests, etc. The list is only going to grow over time.</p>
<p>I'd like to establish a location for semi-persistant state related to
the tree and builds. Perhaps we change the clobber logic to ignore a
specific directory. Perhaps we start storing things in the user's home
directory. Perhaps we could establish a second <em>object directory</em> named
the <em>state directory</em>? How would this interact with <em>build environments</em>?</p>
<p>This will probably sit on the backburner until there is a compelling use
case for it.</p>
<h2>The battle against C++</h2>
<p>Compiling C++ consumes the bulk of our build time. Anything we can do to
speed up C++ compilation will work wonders for our build times.</p>
<p>I'm optimistic things like precompiled headers and compiling multiple
.cpp files with a single process invocation will drastically decrease
build times. However, no matter how much work we put in to make C++
compilation faster, we still have a giant issue: dependency hell.</p>
<p>As <a href="/presentations/2012-11-29-firefox-build-system/#34">shown</a> in my
build system presentation a few months back, we have dozens of header
files included by hundreds if not thousands of C++ files. If you change
one file: you invalidate build dependencies and trigger a rebuild. This
is why whenever files like mozilla-config.h change you are essentially
confronted with a full rebuild. ccache may help if you are lucky. But, I
fear that as long as headers proliferate the way they do, there is
little the build system by itself can do.</p>
<p>My attitude towards this is to wait and see what we can get out of
precompiled headers and the like. Maybe that makes it good enough. If
not, I'll likely be making a lot of noise at Platform meetings
requesting that C++ gurus brainstorm on a solution for reducing
header proliferation.</p>
<h2>Conclusion</h2>
<p>Belive it or not, these are only some of the topics floating around in
my head! But I've probably managed to bore everyone enough so I'll
call it a day.</p>
<p>I'm always interested in opinions and ideas, especially if they are
different from mine. I encourage you to leave a comment if you have
something to say.</p>]]></content:encoded>
    </item>
    <item>
      <title>moz.build Files and the Firefox Build System</title>
      <link>http://gregoryszorc.com/blog/2013/02/28/moz.build-files-and-the-firefox-build-system</link>
      <pubDate>Thu, 28 Feb 2013 19:45:00 PST</pubDate>
      <category><![CDATA[Mozilla]]></category>
      <category><![CDATA[Firefox]]></category>
      <category><![CDATA[build system]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2013/02/28/moz.build-files-and-the-firefox-build-system</guid>
      <description>moz.build Files and the Firefox Build System</description>
      <content:encoded><![CDATA[<p>The next time you update mozilla-central you may notice some significant
changes with the build system. That's because this morning we finally
landed the start of a massive overhaul of the build system! There are
many end goals to this effort. The important ones for most will be
faster build times and a build system that is friendlier to make changes
to.</p>
<h2>Introducing moz.build Files</h2>
<p>If you look in the tree, you'll notice that nearly every directory
now has a <em>moz.build</em> file.</p>
<p><em>moz.build</em> files are what we are using to define the build system. Think of
them each as a descriptor that describes how to build its own part of the
tree. An individual <em>moz.build</em> file will contain the C++ sources to
compile, the headers to export, the tests to run, etc. Eventually.
Currently, they are limited to directory traversal information.</p>
<p><em>moz.build</em> files essentially add a level of indirection between the
build system definition and how the tree is actually built. Before
<em>moz.build</em> files, the same metadata we are now capturing in <em>moz.build</em>
files (or plan to capture) was captured in <em>Makefile.in</em> files. We
performed simple variable substitution on these <em>Makefile.in</em> files to
produce <em>Makefile</em> files in the object directory. These <em>Makefile</em> files
were used by GNU Make (or Pymake on Windows) to build the tree.</p>
<p>As I outlined in <a href="/blog/2012/06/25/improving-mozilla's-build-system/">Improving Mozilla's Build System</a>,
<em>Makefile.in</em> are suboptimal for a number of reasons. The important
bit is they essentially tie us to the use of make (recursive or otherwise).
We are very interested in supporting modern build systems such as Tup
(the theory being they will build the tree faster).</p>
<p>Enter <em>moz.build</em> files. Storing our build configuration in
<em>moz.build</em> files allows us to decouple the definition of the build
system from the tool used to build it.</p>
<h2>How moz.build Files Work</h2>
<p>At the tail end of <em>configure</em>, the build system invokes the
<em>config.status</em> script in the object directory. The role of
<em>config.status</em> is to combine the information collected during
<em>configure</em> with the build configuration obtained from <em>moz.build</em> files
and take the necessary actions to ensure the build backend (make) can
build the tree.</p>
<p>Before today, <em>config.status</em> essentially iterated over the source tree
and converted <em>Makefile.in</em> files to <em>Makefile</em> in the object directory.
Things are now slightly more complicated with <em>moz.build</em> files.</p>
<p>When <em>config.status</em> runs, it starts with the
<a href="https://hg.mozilla.org/mozilla-central/file/87de54667483/moz.build">root moz.build</a>
from the source tree. It feeds this file into a Python interpreter. It
then looks for special variables like <em>DIRS</em> and <em>PARALLEL_DIRS</em> to determine
which directories contain additional <em>moz.build</em> files. It then descends
into all the referenced directories, reading their <em>moz.build</em> files.
While this is happening, we are converting the results of each
<em>moz.build</em> file execution into <em>backend.mk</em> files that make knows how
to build. It also performs the <em>Makefile.in</em> to <em>Makefile</em> conversion
like it always has. When the whole process has finished, the object
directory contains a bunch of <em>Makefile</em> and <em>backend.mk</em> files. make
runs like it always has. The only real difference is some variables are
coming from the <em>moz.build</em>-derived <em>backend.mk</em> files instead of
<em>Makefile</em>.</p>
<p>This is just a brief overview, of course. If you want to know more,
see the code in <em>/python/mozbuild/mozbuild/frontend</em> and
<em>/python/mozbuild/mozbuild/backend</em>.</p>
<h2>Build System Future</h2>
<p>With the introduction of <em>moz.build</em> files, the intent is to <strong>eventually
completely eliminate Makefile.in and have all the build definition live
in moz.build files.</strong></p>
<p>Doing this all at once would have been next to impossible. So, we
decided to eliminate <em>Makefile.in</em> gradually. The first step is what
landed today: essentially moving <em>DIRS</em> variables out of <em>Makefile.in</em>
and into <em>moz.build</em> files. Next, we will be eliminating empty
<em>Makefile.in</em> (<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=844635">bug 844635</a>)
and will be moving more parts of the build definition from <em>Makefile.in</em>
to <em>moz.build</em> files. The next part to move over will likely be IDLs
(<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=818246">bug 818246</a>).
After that, it may be exported files (<em>EXPORTS</em> in <em>Makefile.in</em>
parlance). And repeat until we have no more <em>Makefile.in</em> in the tree.</p>
<p>Each migration of build definition data to <em>moz.build</em> files will likely
occur in two phases:</p>
<ol>
<li>A largely mechanical move of the variables from <em>Makefile.in</em> to
   <em>moz.build</em>.</li>
<li>Better build backend integration resulting from the move.</li>
</ol>
<p>In phase #1, we will essentially cut and paste variable assignments to
<em>moz.build</em> files. make will read the same variables it does today and
perform the same actions. The only difference is the values in these
variables will be defined in <em>moz.build</em> files.</p>
<p>In phase #2, we will leverage the fact that our build definition now has
an API. We will change our existing make backend to be more efficient.
For example, we should soon be able to compile IDLs and copy exported
headers without make traversing through the directory tree at build time.
We will be able to do this because the <em>moz.build</em> traversal at
pre-build time sees data from all <em>moz.build</em> files and with this
<em>complete world view</em> is able to produce more optimal make files than
what you would get if you recursed into multiple directories. In short:
it will make the build faster.</p>
<p>Once we have a sufficient portion of the build definition moved to
<em>moz.build</em> files we will be able to experiment with new build backends
(like Tup), look into automatic Visual Studio project generation, and
more easily experiment with different ways of building (such as
precompiled headers, fewer compiler process invocations, etc). These
should all contribute to faster build times.</p>
<h2>Frequently Asked Questions</h2>
<h4>What impact will I see from this change?</h4>
<p>If you never touched <em>Makefile.in</em> files in the tree, you should not
notice anything different about how the tree builds or how the build
system works. You should have nothing to fear.</p>
<p>The most obvious changes to the source tree are:</p>
<ol>
<li>There is a <em>moz.build</em> file in almost every directory now.</li>
<li>The variables related to directory traversal (those containing <em>DIRS</em>
   in their name) are now defined in <em>moz.build</em> files instead of
   <em>Makefile.in</em>.</li>
<li>If your <em>Makefile.in</em> contains a variable that has been moved to
   <em>moz.build</em> files, make will spew an error when processing that file
   and the build will fail.</li>
</ol>
<h4>Will this change how I build?</h4>
<p>It shouldn't. You should build the tree just like you always have. Most
of you won't notice any differences.</p>
<p>If you see something weird, speak up in #build or file a bug if you are
really confident it is wrong.</p>
<h4>What are the risks to this change?</h4>
<p>The migration of variables from <em>Makefile.in</em> to <em>moz.build</em> files is
largely mechanical and significant portions are done manually. This can
be a mind-numbing and tedious process. Not helping things is the fact
that Splinter's review interface for these kinds of patches is hard to
read.</p>
<p>This all means that there is a non-trivial risk for <em>transcription</em>
errors. All it takes is an inverted conditional block and all of a
sudden large parts of the tree are no longer built, for example.</p>
<p>We have established <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=846425">bug 846825</a>
to investigate any oddities from the initial transfer. Developers are
encouraged to help with the effort. Please spot check that your
directories are still being built, tests run, etc. Pay special attention
to changes made in the last 4 months as these parts of <em>Makefile.in</em>
would have been bit rotted and more prone to data loss.</p>
<p>Parts of the tree not enabled in standard configurations are more prone
to breakage due to less testing. i.e. build configurations not captured
by TBPL have a higher chance of breaking.</p>
<h4>Will this make the tree build faster?</h4>
<p>Not yet. But eventually it will. This initial landing paves the
groundwork to making the tree build faster (see the <em>Future</em> section
above).</p>
<h4>I see a lot of empty moz.build files!</h4>
<p>Yes. Sorry about that. The good news is they shouldn't be empty for
long. As things move from <em>Makefile.in</em> to <em>moz.build</em> we'll see fewer
and fewer empty <em>moz.build</em> files. We'll also see fewer and fewer
<em>Makefile.in</em> files once we start deleting empty <em>Makefile.in</em>.</p>
<p>If you want to know why we must have empty files, it's mainly for
validation. If we allowed <em>moz.build</em> files to be optional, how would
you detect a typo in a directory name? Directory exists? What if that
directory exists but isn't supposed to have a <em>moz.build</em> file?</p>
<h4>You bitrotted my patches!</h4>
<p>Yes. I'm sorry. The transition period to <em>moz.build</em> files could be a
little messy. There will be lots of changes to <em>Makefile.in</em> and
<em>moz.build</em> files and lots of chances for bit rot. Uplifts could be
especially nasty. (Although I don't believe many uplifts involve
significant changes to the build configuration.)</p>
<p>This all means there is a strong incentive for us to complete the
transition as quickly as possible.</p>
<h4>Can I help with the transition to moz.build files?</h4>
<p>Yes!</p>
<p>The transition is largely mechanical (at least phase #1). If you are
interested in moving a variable or set of variables, hop in #build on
IRC and speak up!</p>
<h4>You said moz.build files are actually Python files?!</h4>
<p>Yes they are! However, they are executed in a very tightly controlled
sandbox. You can't import modules, open files, etc. UPPERCASE variable
names are reserved and only a few functions are exposed. If you attempt
to assign to an unknown UPPERCASE variable or assign an invalid value,
an error will occur. This is already much better than Makefile because
we can now detect errors earlier in the build process (rather than 15
minutes into a build).</p>
<h4>What variables and functions are available in moz.build files?</h4>
<p>If you run |./mach mozbuild-reference| you will see a print-out of
all the variables, functions, and symbols that are exposed to the Python
sandbox that moz.build files execute in. There are even tests that will
fail the build if the sandbox contains symbols not in this output!</p>
<p>The output should be valid reSTructuredText (in case you want to convert
to HTML for reading in your browser).</p>
<h4>What if a moz.build file contains an error?</h4>
<p>The build will break.</p>
<p>A lot of work has gone into making the output of moz.build errors human
friendly and actionable. If you do something wrong, it won't just
complain: it will tell you how to fix it!</p>
<h4>Besides build times, how else will this improve the build system?</h4>
<p>There are several ways!</p>
<p>As mentioned above, moz.build are more strict about what data is allowed
to be defined. If you assign to an UPPERCASE variable, that variable
must be known to the sandbox or else the assignment will error. This
means that if you assign to an UPPERCASE variable, you know it has a
side-effect. No more cargo culting of old, meaningless variables!</p>
<p>To change the behavior of moz.build files (add new variables or
functions, change how makefile generation works, etc) will require
changes to the code in /python/mozbuild. This code belongs squarely to
the build module and requires appropriate review. A problem with
Makefiles is that they have lots of foot guns by default and its easy
for self-inflicted wounds to land in the tree without explicit build
peer review. This problem largely goes away with moz.build files because
the sandbox takes away all of make's foot guns.</p>
<p>The output of a moz.build execution is essentially a static data
structure. It's easy to validate them for conformance. If we discover
bad practices in our build definition, we can centrally add tests for
them and enforce best practices.</p>
<p>We will also see user experience wins by moving data to moz.build files.
Take mochitests for an example. We currently have several flavors
(plain, browser, chrome, etc). Sometimes you cannot distinguish the
flavor by the filename alone. With moz.build files, it will be easier to
answer questions like "what mochitest flavor is this file?" mach could
hook into this so you can type |mach mochitest path/to/file.html|
instead of |mach mochitest-plain path/to/file.html|. Even better, you
should just be able to type |mach path/to/test.html| and mach knows from
the build definition that path/to/test.html is a plain mochitest file
and assumes you want to run it. There are dozens of small development
workflow wins to be gained here!</p>
<h4>If I change a moz.build file, what happens?</h4>
<p>If you change a moz.build file, then make should detect that it
has changed and it will update the dynamically generated <em>backend.mk</em>
file and reinvoke the requested build action. This should all happen
automatically (just like <em>Makefile.in</em> to <em>Makefile</em> conversion works
automatically).</p>
<h4>My build seems to pause for a few seconds before starting!</h4>
<p>A change to <em>any</em> moz.build file will cause a full traversal of the
entire moz.build tree. On modern machines, this should only take 1-3
seconds. If your source tree is not in the page cache (and you need
to load moz.build files from disk) or if you are on older hardware, this
could be a little slower.</p>
<p>This is an unfortunate side-effect of having a whole world view of the
build definition. The build delay incurred by these full scans should
eventually be cancelled out by build backend optimizations resulting
from having this whole world view, however.</p>
<p>The good news is this full scan should only occur if a mozbuild file
changes. And, if you are performing make recursion, it should only
happen once (not in every directory). If you notice multiple moz.build
scanning-related pauses during builds, please file a bug in Core ::
Build Config!</p>
<p>Finally, we are performing the reads on a single thread currently. We
can throw more cores at the task if someone codes up a patch.</p>
<h4>What happened to allmakefiles.sh?</h4>
<p>It has been sacked. allmakefiles.sh was an optimization to perform all
the Makefile.in to Makefile conversion in one go. The directory
traversal performed by moz.build reading effectively replaces the role
of allmakefiles.sh. Not only that, but the moz.build build definition is
always up to date! allmakefiles.sh was typically out of sync with
reality and was a burden to maintain.</p>
<h4>Did we just invent our own build system?</h4>
<p>Kinda. We invented a generic Python sandboxing infrastructure. Then we
hooked up code to populate it with variables from our build system and
told it how to perform file traversal by reading specific variables set
during file execution. Then we hooked up code for taking the evaluated
results of all those sandboxes and convert them into make files.</p>
<p>Conceptually, what we invented is like GYP but with a different config
file format. We have dabbled with the idea of converting the parsed
build definition into GYP classes and then leveraging GYP to produce
Makefiles, Ninja files, Visual Studio Projects, etc. This would an
interesting experiment!</p>
<p>If you want to call it a build system, call it a build system. However,
it is currently tightly coupled to Mozilla's needs, so you can't just
use it anywhere. The concept might be worth exploring, however.</p>
<h4>Is there anything else you'd like to share?</h4>
<p>I think we set the record for most parts in a bug: 61. Although, they
are numbered 1-17, 19-20. Part 18 has 30+ sub-parts using letters from
the English and Greek alphabet for identifiers. Part 61 uses the
infinity symbol as its number. See the
<a href="https://hg.mozilla.org/mozilla-central/pushloghtml?changeset=c65d59d33aa8">pushlog</a>.</p>
<p>Finally, I'd like to thank everyone who helped with this effort. The bug
itself was <em>only</em> 6 months old and had active development off and on for
a lot of it. Ted Mielczarek and Mike Hommey provided invaluable feedback
on the core build system patches. A number of module owners stepped in
to lend eyes to the mechanical conversion of their files. Last but not
least, Ms2ger provided invaluable review aid on many of the patches. The
work was so good that we all agreed that an Ms2ger f+ was good enough
for a build peer rs! If reviewing the patches wasn't enough, Ms2ger
also oversaw the tree closure and merging of the landing. I don't know
how I will repay this debt.</p>
<h4>Any more questions?</h4>
<p>If you have more questions, drop in #build on irc.mozilla.org and ask
away.</p>]]></content:encoded>
    </item>
    <item>
      <title>Firefox Build System Presentation</title>
      <link>http://gregoryszorc.com/blog/2012/11/30/firefox-build-system-presentation</link>
      <pubDate>Fri, 30 Nov 2012 14:00:00 PST</pubDate>
      <category><![CDATA[Mozilla]]></category>
      <category><![CDATA[Firefox]]></category>
      <category><![CDATA[build system]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2012/11/30/firefox-build-system-presentation</guid>
      <description>Firefox Build System Presentation</description>
      <content:encoded><![CDATA[<p>In case you missed it, I gave a presentation on the state of Firefox's
build system yesterday.</p>
<p>You can <a href="https://air.mozilla.org/the-future-of-the-firefox-build-system/">watch</a>
it and <a href="http://gregoryszorc.com/presentations/2012-11-29-firefox-build-system/#1">view</a>
the slides online.</p>
<p>If you build Firefox from source regularly, you should definitely at
least skim through the slide deck.</p>
<p>I'm not an HTML expert, so my apogolies for bad UI on the interactive
slides. You may need to press <strong>enter</strong> to select items in
dropdown menus. Also, the interactive slides are a bit resource
intensive. If the slide deck is really slow, turn off those elements.
I've also only tested the slides in Firefox 19 and 20. My apologies if
they don't work everywhere.</p>]]></content:encoded>
    </item>
    <item>
      <title>Visual Studio Project Generation for mozilla-central</title>
      <link>http://gregoryszorc.com/blog/2012/08/28/visual-studio-project-generation-for-mozilla-central</link>
      <pubDate>Tue, 28 Aug 2012 12:00:00 PDT</pubDate>
      <category><![CDATA[Mozilla]]></category>
      <category><![CDATA[Firefox]]></category>
      <category><![CDATA[build system]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2012/08/28/visual-studio-project-generation-for-mozilla-central</guid>
      <description>Visual Studio Project Generation for mozilla-central</description>
      <content:encoded><![CDATA[<p>I have very alpha support for Visual Studio project generation for
mozilla-central that daring people can dogfood.</p>
<p>I want to emphasize that this is extremely alpha. Normally, I wouldn't
release things as fragile as they are. But, I know Windows developers
sorely miss Visual Studio, especially IntelliSense. The current Visual
Studio projects support IntelliSense, so I want to get this in the hands
of Windows developers ASAP.</p>
<p>The current directions for making this all work are a bit hacky. Things
will change once things have matured. For now, please excuse the mess.</p>
<p>First, you will need to grab the code. If you use Git, set up a remote
to my repository:</p>
<pre><code>git remote add indygreg git://github.com/indygreg/mozilla-central.git
git fetch indygreg
</code></pre>
<p>The branch of interest is <em>build-splendid</em>. I periodically rebase this
branch on top of master. You have been warned.</p>
<p>You can switch to this branch:</p>
<pre><code>git checkout -b build-splendid indygreg/build-splendid
</code></pre>
<p>Alternatively, you can squash it down to a single commit and merge it
into your local branch. Once you've done that, you can record the SHA-1
of the commit and cherry-pick that wherever you like!</p>
<pre><code>git merge --squash indygreg/build-splendid
git commit
</code></pre>
<p>In the current state, you need to build the tree or the Visual Studio
projects will complain about missing files. It doesn't matter if you
build the tree before or after Visual Studio projects are generated.
But, we might as well get it out of the way. From your MozillaBuild
environment, run:</p>
<pre><code>./mach build
</code></pre>
<p>That should <em>just work</em>. If it doesn't, you may need to configure
mach.ini. See my <a href="http://gregoryszorc.com/blog/2012/08/15/build-firefox-faster-with-build-splendid/">previous post</a>
on how to configure mach.ini. As a reference, my Windows config is:</p>
<pre><code>[build]

configure_extra = --disable-webgl

[compiler]

[paths]
source_directory = c:\dev\src\mozilla-central-git
object_directory = c:\dev\src\mozilla-central-git\objdir
</code></pre>
<p>Now, to generate Visual Studio project files:</p>
<pre><code>./mach backendconfig visualstudio
</code></pre>
<p>That should take about a minute to finish. When it's done, it should
have created <em>objdir/msvc/mozilla.sln</em>. You should be able to load that
in Visual Studio!</p>
<p>You will need to regenerate Visual Studio project files when the build
config changes. As a rule of thumb, do this every time you pull source.
You don't need to perform a full build before you generate Visual Studio
files (you do need to perform configure, however). However, if you have
not performed a full build, Visual Studio may not be able to find some
files, like headers generated from IDLs.</p>
<p><strong>Please close the solution before regenerating the project files.</strong> If
you don't, Visual Studio puts up a modal dialog for each project file
that changed and you have to click through over a hundred of these. It's
extremely frustrating. I'm investigating workarounds.</p>
<h2>Current State</h2>
<p>Currently, it only generates projects for C/C++ compilation (libraries).
I still need to add support for IDL, headers, etc. However, each
project has proper compiler flags, header search paths, etc. So,
IntelliSense is happy and some things do manage to compile!</p>
<p>Many parts are broken and sub-par.</p>
<p>I've only tested on Visual Studio 2008. If you are running Visual Studio
\2010, you can try to upgrade the solution. This <em>may</em> work. The backend
supports generating solutions for different versions. But, I haven't
tested things work on non-2008 and I don't want to expose untested behavior.</p>
<p>Compiling within Visual Studio works for some things. On my system, I
get a lot of <em>nullptr not defined</em> errors. I'm not sure why. This will
hopefully be worked out soon.</p>
<p>If you do manager to compile within Visual Studio, the output files
don't go in the right places. So, if you do a build from the
command-line, it will have to re-compile to pick up changes.</p>
<p>Project names are based on the name of the library they produce. I'm not
sure if this is the best solution.</p>
<p>Project dependencies are not set up. They will be added later.</p>
<p>Projects for linking libxul or building firefox.exe are not yet
provided. Along the same vein, debugging support is not built-in. I'm
working on it.</p>
<p>Basically, IntelliSense works. You can now use Visual Studio as a rich
editor. Hopefully this is a step in the right direction.</p>
<p>I'm anxious to hear if this works for other people. Please leave
comments!</p>]]></content:encoded>
    </item>
  </channel>
</rss>
