<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>Gregory Szorc's Digital Home</title>
    <link>http://gregoryszorc.com/blog</link>
    <description>Rambling on</description>
    <pubDate>Mon, 03 Jan 2022 23:33:40 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Why You Shouldn't Use Git LFS</title>
      <link>http://gregoryszorc.com/blog/2021/05/12/why-you-shouldn't-use-git-lfs</link>
      <pubDate>Wed, 12 May 2021 10:30:00 PDT</pubDate>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Git]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2021/05/12/why-you-shouldn't-use-git-lfs</guid>
      <description>Why You Shouldn't Use Git LFS</description>
      <content:encoded><![CDATA[<p>I have long held the opinion that you should avoid Git LFS if possible.
Since people keeping asking me why, I figured I'd capture my thoughts
in a blog post so I have something to refer them to.</p>
<p>Here are my reasons for not using Git LFS.</p>
<h2>Git LFS is a Stop Gap Solution</h2>
<p>Git LFS was developed outside the official Git project to fulfill a
very real market need that Git didn't/doesn't handle large files very
well.</p>
<p>I believe it is inevitable that Git will gain better support for
handling of large files, as this seems like a critical feature for
a popular version control tool.</p>
<p>If you make this long bet, LFS is only an interim solution and its
value proposition disappears after Git has better native support
for large files.</p>
<p>LFS as a stop gap solution would be tolerable except for the fact
that...</p>
<h2>Git LFS is a One Way Door</h2>
<p>The adoption or removal of Git LFS in a repository is an irreversible
decision that requires rewriting history and losing your original 
commit SHAs.</p>
<p>In some contexts, rewriting history is tolerable. In many others, it
is an extremely expensive proposition. My experience maintaining
version control in professional contexts aligns with the opinion
that rewriting history is expensive and should only be considered a
measure of last resort. Maybe if tools made it easier to rewrite
history without the negative consequences (e.g. GitHub would redirect
references to old SHA1 in URLs and API calls) I would change my opinion
here. Until that day, the drawbacks of losing history are just too
high to stomach for many.</p>
<p>The reason adoption or removal of LFS is irreversible is due to the
way Git LFS works. What LFS does is change the blob content that a
Git commit/tree references. Instead of the content itself, it stores
a pointer to the content. At checkout and commit time, LFS blobs/records
are treated specially via a mechanism in Git that allows content to be
rewritten as it moves between Git's core storage and its materialized
representation. (The same filtering mechanism is responsible for
normalizing line endings in text files. Although that feature is built
into the core Git product and doesn't work exactly the same way. But
the principles are the same.)</p>
<p>Since the LFS pointer is part of the Merkle tree that a Git commit
derives from, you can't add or remove LFS from a repo without rewriting
existing Git commit SHAs.</p>
<p>I want to explicitly call out that even if a rewrite is acceptable in
the short term, things may change in the future. If you adopt LFS
today, you are committing to a) running an LFS server forever b)
incurring a history rewrite in the future in order to remove LFS from
your repo, or c) ceasing to provide an LFS server and locking out people
from using older Git commits. I don't think any of these are great
options: I would prefer if there were a way to offboard from LFS in
the future with minimal disruption. This is theoretically possible, but
it requires the Git core product to recognize LFS blobs/records natively.
There's no guarantee this will happen. So adoption of Git LFS is a one
way door that can't be easily reversed.</p>
<h2>LFS is More Complexity</h2>
<p>LFS is more complex for Git end users.</p>
<p>Git users have to install, configure, and sometimes know about the
existence of Git LFS. Version control should <em>just work</em>. Large file
handling should <em>just work</em>. End-users shouldn't have to care that
large files are handled slightly differently from small files.</p>
<p>The usability of Git LFS is generally pretty good. However, there's an
upper limit on that usability as long as LFS exists outside the core
Git product. And LFS will likely never be integrated into the core Git
product because the Git maintainers know that LFS is only a stop gap
solution. They would rather solve large files storage <em>correctly</em> than
~forever carry the legacy baggage of having to support LFS in the core
product.</p>
<p>LFS is more complexity for Git server operators as well. Instead of
a self-contained Git repository and server to support, you now have
to support a likely separate HTTP server to facilitate LFS access.
This isn't the hardest thing in the world, especially since we're
talking about key-value blob storage, which is arguably a solved problem.
But it's another piece of infrastructure to support and secure and it
increases the surface area of complexity instead of minimizing it.
As a server operator, I would much prefer if the large file storage
were integrated into the core Git product and I simply needed to provide
some settings for it to <em>just work</em>.</p>
<h2>Mercurial Does LFS Slightly Better</h2>
<p>Since I'm a maintainer of the Mercurial version control tool, I thought
I'd throw out how Mercurial handles large file storage better than
Git. Mercurial's large file handling isn't great, but I believe it
is strictly better with regards to the trade-offs of adopting large
file storage.</p>
<p>In Mercurial, use of LFS is a dynamic feature that server/repo operators
can choose to enable or disable whenever they want. When the Mercurial
server sends file content to a client, presence of external/LFS storage
is a <em>flag</em> set on that file revision. Essentially, the flag says <em>the
data you are receiving is an LFS record, not the file content itself</em> and
the client knows how to resolve that record into content.</p>
<p>Conceptually, this is little different from Git LFS records in terms of
content resolution. However, the big difference is this flag is part
of the repository interchange data, not the core repository data as it
is with Git. Since this flag isn't part of the Merkle tree used to
derive the commit SHA, adding, removing, or altering the content of the
LFS records doesn't require rewriting commit SHAs. The tracked content
SHA - the data now stored in LFS - is still tracked as part of the Merkle
tree, so the integrity of the commit / repository can still be verified.</p>
<p>In Mercurial, the choice of whether to use LFS and what to use LFS for
is made by the server operator and settings can change over time. For
example, you could start with no use of LFS and then one day decide to
use LFS for all file revisions larger than 10 MB. Then a year later
you lower that to all revisions larger than 1 MB. Then a year after
that Mercurial gains better <em>native</em> support for large files and
you decide to stop using LFS altogether.</p>
<p>Also in Mercurial, it is possible for clients to push a large file
<em>inline</em> as part of the push operation. When the server sees that
large file, it can be like <em>this is a large file: I'm going to add
it to the blob store and advertise it as LFS</em>. Because the large
file record isn't part of the Merkle tree, you can have nice things
like this.</p>
<p>I suspect it is only a matter of time before Git's wire protocol learns
the ability to dynamically advertise <em>remote servers</em> for content
retrieval and this feature will be leveraged for better large file
handling. Until that day, I suppose we're stuck with having to
rewrite history with LFS and/or funnel large blobs through Git natively,
with all the pain that entails.</p>
<h2>Conclusion</h2>
<p>This post summarized reasons to avoid Git LFS. Are there justifiable
scenarios for using LFS? Absolutely! If you insist on using Git and
insist on tracking many <em>large</em> files in version control, you
should definitely consider LFS. (Although, if you are a heavy user
of large files in version control, I would consider Plastic SCM instead,
as they seem to have the most mature solution for large files handling.)</p>
<p>The main point of this post is to highlight some drawbacks with
using Git LFS because Git LFS is most definitely not a magic bullet. If
you can stomach the short and long term effects of Git LFS adoption, by
all means, use Git LFS. But please make an informed decision either way.</p>]]></content:encoded>
    </item>
    <item>
      <title>Mercurial's Journey to and Reflections on Python 3</title>
      <link>http://gregoryszorc.com/blog/2020/01/13/mercurial's-journey-to-and-reflections-on-python-3</link>
      <pubDate>Mon, 13 Jan 2020 08:45:00 PST</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[Mercurial]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2020/01/13/mercurial's-journey-to-and-reflections-on-python-3</guid>
      <description>Mercurial's Journey to and Reflections on Python 3</description>
      <content:encoded><![CDATA[<p>Mercurial 5.2 was released on November 5, 2019. It is the first version
of Mercurial that supports Python 3. This milestone comes nearly 11 years
after Python 3.0 was first released on December 3, 2008.</p>
<p>Speaking as a maintainer of Mercurial and an avid user of Python, I
feel like the experience of making Mercurial work with Python 3 is
worth sharing because there are a number of lessons to be learned.</p>
<p>This post is logically divided into two sections: a mostly factual recount
of Mercurial's Python 3 porting effort and a more opinionated commentary
of the transition to Python 3 and the Python language ecosystem as a whole.
Those who don't care about the mechanics of porting a large Python project
to Python 3 may want to skip the next section or two.</p>
<h2>Porting Mercurial to Python 3</h2>
<p>Let's start with a brief history lesson of Mercurial's support for
Python 3 as told by its own commit history.</p>
<p>The Mercurial version control tool was first released in April 2005
(the same month that Git was initially released). Version 1.0 came out
in March 2008. The first reference to Python 3 I found in the code base
was in <a href="https://www.mercurial-scm.org/repo/hg/rev/8fee8ff13d37">September 2008</a>.
Then not much happens for a while until
<a href="https://www.mercurial-scm.org/repo/hg/rev/4494fb02d549">June 2010</a>, when
someone authors a bunch of changes to make the Python C extensions
start to recognize Python 3. Then things were again quiet for a while
until <a href="https://www.mercurial-scm.org/repo/hg/rev/56ef99fbd6f2">January 2013</a>,
when a handful of changes landed to remove 2 argument <code>raise</code>. There were
a handful of commits in 2014 but nothing worth calling out.</p>
<p>Mercurial's meaningful journey to Python 3 started in 2015. In code,
the work started in
<a href="https://www.mercurial-scm.org/repo/hg/rev/af6e6a0781d7">April 2015</a>, with
effort to make Mercurial's test harness run with Python 3. Part of
this was a <a href="https://www.mercurial-scm.org/repo/hg/rev/fefc72523491">decision</a>
that Python 3.5 (to be released several months later in September 2015)
would be the minimum Python 3 version that Mercurial would support.</p>
<p>Once the Mercurial Project decided it wanted to port to Python 3 (as opposed
to another language), one of the earliest decisions was how to perform that
port. <strong>Mercurial's code base was too large to attempt a flag day conversion</strong>
where there would be a Python 2 version and a Python 3 version and one day
everyone would switch from Python 2 to 3. <strong>Mercurial needed a way to run the
same code (or as much of the same code) on both Python 2 and 3.</strong> We would
maintain a single code base and users would gradually switch from running with
Python 2 to Python 3.</p>
<p>In <a href="https://www.mercurial-scm.org/repo/hg/rev/e1fb276d4619">May 2015</a>,
Mercurial dropped support for Python 2.4 and 2.5. Dropping support for
these older Python versions was critical, as it was effectively impossible to
write Python code that ran on this wide gamut of versions because of
incompatibilities in syntax and language features. For example, you needed
Python 2.6 to get <code>print()</code> via <code>from __future__ import print_function</code>.
The project's late start at a Python 3 port can be significantly attributed
to Python 2.4 and 2.5 compatibility holding us back.</p>
<p>The main goal with Mercurial's early porting work was just getting the code base
to a point where <code>import mercurial</code> would work. There were a myriad of places
where Mercurial used syntax that was invalid on Python 3 and Python 3
couldn't even parse the source code, let alone compile it to bytecode and
execute it.</p>
<p>This effort began in earnest in
<a href="https://www.mercurial-scm.org/repo/hg/rev/e93036747902">June 2015</a>
with global source code rewrites like using modern octal syntax,
modern exception catching syntax (<code>except Exception as e</code> instead of
<code>except Exception, e</code>), <code>print()</code> instead of <code>print</code>, and a
<a href="https://www.mercurial-scm.org/repo/hg/rev/1a6a117d0b95">modern import convention</a>
along with the use of <code>from __future__ import absolute_import</code>.</p>
<p>In the early days of the port, our first goal was to get all source code
parsing as valid Python 3. The next step was to get all the modules <code>import</code>ing
cleanly. This entailed fixing code that ran at <code>import</code> time to work on
Python 3. Our thinking was that we would need the code base to be <code>import</code>
clean on Python 3 before seriously thinking about run-time behavior. In reality,
we quickly ported a lot of modules to <code>import</code> cleanly and then moved on
to higher-level porting, leaving a long-tail of modules with <code>import</code> failures.</p>
<p>This initial porting effort played out over months. There weren't many
people working on it in the early days: a few people would basically hack on
Python 3 as a form of itch scratching and most of the project's energy was
focused on improving the existing Python 2 based product. You can get a rough
idea of the timeline and participation in the early porting effort through the
<a href="https://www.mercurial-scm.org/repo/hg/log/081a77df7bc6/tests/test-check-py3-compat.t?revcount=960">history of test-check-py3-compat.t</a>.
We see the test being added in <a href="https://www.mercurial-scm.org/repo/hg/rev/40eb385f798f">December 2015</a>,
By June 2016, most of the code base was ported to our modern import convention
and we were ready to move on to more meaningful porting.</p>
<p>One of the biggest early hurdles in our porting effort was how to overcome
the string literals type mismatch between Python 2 and 3. In Python 2, a
<code>''</code> string literal is a sequence of bytes. In Python 3, a <code>''</code> string literal
is a sequence of Unicode code points. These are fundamentally different types.
And in Mercurial's code base, <strong>most of our <em>string</em> types are binary by design:
use of a Unicode based <code>str</code> for representing data is flat out wrong for our use
case</strong>. We knew that Mercurial would need to eventually switch many string
literals from <code>''</code> to <code>b''</code> to preserve type compatibility. But doing so would
be problematic.</p>
<p>In the early days of Mercurial's Python 3 port in 2015, Mercurial's project
maintainer (Matt Mackall) set a ground rule that the Python 3 port shouldn't overly
disrupt others: he wanted the Python 3 port to more or less happen in the background
and not require every developer to be aware of Python 3's low-level behavior in order
to get work done on the existing Python 2 code base. This may seem like a questionable
decision (and I probably disagreed with him to some extent at the time because I was
doing Python 3 porting work and the decision constrained this work). But it was the
correct decision. Matt knew that it would be years before the Python 3 port was either
necessary or resulted in a meaningful return on investment (the value proposition of
Python 3 has always been weak to Mercurial because Python 3 doesn't demonstrate a
compelling advantage over Python 2 for our use case). What Matt was trying to do was
minimize the externalized costs that a Python 3 port would inflict on the project.
He correctly recognized that maintaining the existing product and supporting
existing users was more important than a long-term bet in its infancy.</p>
<p>This ground rule meant that a mass insertion of <code>b''</code> prefixes everywhere
was not desirable, as that would require developers to think about whether
a type was a <code>bytes</code> or <code>str</code>, a distinction they didn't have to worry about
on Python 2 because we practically never used the Unicode-based string type in
Mercurial.</p>
<p>In addition, there were some other practical issues with doing a bulk <code>b''</code>
prefix insertion. One was that the added <code>b</code> characters would cause a lot of lines
to grow beyond our length limits and we'd have to reformat code. That would
require manual intervention and would significantly slow down porting. And
a sub-issue of adding all the <code>b</code> prefixes and reformatting code is that it would
<em>break</em> annotate/blame more than was tolerable. The latter issue was addressed
by teaching Mercurial's annotate/blame feature to <em>skip</em> revisions. The project
now has a convention of annotating commit messages with <code># skip-blame &lt;reason&gt;</code>
so structural only changes can easily be ignored when performing an
annotate/blame.</p>
<p>A stop-gap solution to the <code>b''</code> everywhere issue came in
<a href="https://www.mercurial-scm.org/repo/hg/rev/1c22400db72d">July 2016</a>, when I
introduced a custom Python module importer that rewrote source code as part
of <code>import</code> when running on Python 3. (I have
<a href="/blog/2017/03/13/from-__past__-import-bytes_literals/">previously blogged</a>
about this hack.) What this did was transparently add <code>b''</code> prefixes to all
un-prefixed string literals as well as modify how a few common functions were
called so that we wouldn't need to modify source code so things would run natively
on Python 3. The source transformer allowed us to have the benefits of progressing
in our Python 3 port without having to rewrite tens of thousands of lines of
source code. The solution was hacky. But it enabled us to make significant
progress on the Python 3 port without externalizing a lot of cost onto others.</p>
<p>I thought the source transformer would be relatively short-lived and would be
removed shortly after the project inevitably decided to go all in on Python 3.
To my surprise, others built additional transforms over the years and the source
transformer persisted all the way until
<a href="https://www.mercurial-scm.org/repo/hg/rev/d783f945a701">October 2019</a>, when
I removed it just before the first non-alpha Python 3 compatible version
of Mercurial was released.</p>
<p>A common problem Mercurial faced with making the code base dual Python 2/3 native
was dealing with standard library differences. Most of the problems stemmed
from changes between Python 2.7 and 3.5+. But there are changes within the
versions of Python 3 that we had to wallpaper over as well. In
<a href="https://www.mercurial-scm.org/repo/hg/rev/6041fb8f2da8">April 2016</a>, the
<code>mercurial.pycompat</code> module was introduced to export aliases or wrappers around
standard library functionality to abstract the differences between Python
versions. This file <a href="https://www.mercurial-scm.org/repo/hg/log/66af68d4c751/mercurial/pycompat.py?revcount=240">grew over time</a>
and <a href="https://www.mercurial-scm.org/repo/hg/file/66af68d4c751/mercurial/pycompat.py">eventually became</a>
Mercurial's version of <a href="https://six.readthedocs.io/">six</a>. To be honest, I'm
not sure if we should have used <code>six</code> from the beginning. <code>six</code> probably would
have saved some work. But we had to eventually write a lot of shims for
converting between <code>str</code> and <code>bytes</code> and would have needed to invent a
<code>pycompat</code> layer in some form anyway. So I'm not sure <code>six</code> would have saved
enough effort to justify the baggage of integrating a 3rd party package into
Mercurial. (When Mercurial accepts a 3rd party package, downstream packagers
like Debian get all hot and bothered and end up making questionable patches
to our source code. So we prefer to minimize the surface area for
problems by minimizing dependencies on 3rd party packages.)</p>
<p>Once we had a source transforming module importer and the <code>pycompat</code>
compatibility shim, we started to focus in earnest on making core
functionality actually work on Python 3. We established a convention of
annotating changesets needed for Python 3 with <code>py3</code>, so a
<a href="https://www.mercurial-scm.org/repo/hg/log?rev=desc(py3)&amp;revcount=4000">commit message search</a>
yields a lot of the history. (But it isn't a full history since not every Python 3
oriented change used this convention). We see from that history that after
the source importer landed, a lot of porting effort was spent on things
very early in the <code>hg</code> process lifetime. This included handling environment
variables, loading config files, and argument parsing. We introduced a
<a href="https://www.mercurial-scm.org/repo/hg/log/@/tests/test-check-py3-commands.t">test-check-py3-commands.t</a>
test to track the progress of <code>hg</code> commands working in Python 3. The very early
history of that file shows the various error messages changing, as underlying
early process functionality was slowly ported to work on Python 3. By
<a href="https://www.mercurial-scm.org/repo/hg/rev/2d555d753f0e">December 2016</a>, we
had <code>hg version</code> working on Python 3!</p>
<p>With basic <code>hg</code> command dispatch ported to Python 3 at the end of 2016,
2017 represented an inflection point in the Python 3 porting effort. With the
early process functionality working, different people could pick up different
commands and code paths and start making code work with Python 3. By
<a href="https://www.mercurial-scm.org/repo/hg/rev/52ee1b5ac277">March 2017</a>, basic
repository opening and <code>hg files</code> worked. Shortly thereafter,
<a href="https://www.mercurial-scm.org/repo/hg/rev/ed23f929af38">hg init started working as well</a>.
And <a href="https://www.mercurial-scm.org/repo/hg/rev/935a1b1117c7">hg status</a> and
<a href="https://www.mercurial-scm.org/repo/hg/rev/aea8ec3f7dd1">hg commit</a> did as well.</p>
<p>Within a few months, enough of Mercurial's functionality was working with Python
3 that we started to <a href="https://www.mercurial-scm.org/repo/hg/rev/7a877e569ed6">track which tests passed on Python 3</a>.
The <a href="https://www.mercurial-scm.org/repo/hg/log/@/contrib/python3-whitelist?revcount=480">evolution of this file</a>
shows a reasonable history of the porting velocity.</p>
<p>In <a href="https://www.mercurial-scm.org/repo/hg/rev/feb910d2f59b">May 2017</a>, we dropped
support for Python 2.6. This significantly reduced the complexity of supporting
Python 3, as there was tons of functionality in Python 2.7 that made it easier
to target both Python 2 and 3 and now our hands were untied to utilize it.</p>
<p>In <a href="https://www.mercurial-scm.org/repo/hg/rev/bd8875b6473c">November 2017</a>, I
landed a test harness feature to report exceptions seen during test runs. I
later <a href="https://www.mercurial-scm.org/repo/hg/rev/8de90e006c78">refined the output</a>
so the most frequent failures were reported more prominently. This feature
greatly enabled our ability to target the most common exceptions, allowing
us to write patches to fix the most prevalent issues on Python 3 and uncover
previously unknown failures.</p>
<p>By the end of 2017, we had most of the structural pieces in place to complete
the port. Essentially all that was required at that point was time and labor.
We didn't have a formal mechanism in place to target porting efforts. Instead,
people would pick up a component or test that they wanted to hack on and then
make incremental changes towards making that work. All the while, we didn't
have a strict policy on not regressing Python 3 and regressions in Python 3
porting progress were semi-frequent. Although we did tend to correct
regressions quickly. And over time, developers saw a flurry of Python 3
patches and slowly grew awareness of how to accommodate Python 3, and the
number of Python 3 regressions became less frequent.</p>
<p>As useful as the source-transforming module importer was, it incurred some
additional burden for the porting effort. The source transformer effectively
converted all un-prefixed string literals (<code>''</code>) to bytes literals (<code>b''</code>)
to preserve string type behavior with Python 2. But various aspects of Python
3 didn't like the existence of <code>bytes</code>. Various standard library functionality
now wanted unicode <code>str</code> and didn't accept <code>bytes</code>, even though the Python
2 implementation used the equivalent of <code>bytes</code>. So our <code>pycompat</code> layer
grew pretty large to accommodate calling into various standard library
functionality. Another side-effect which we didn't initially anticipate
was the <code>**kwargs</code> calling convention. Python allows you to use <code>**</code>
with a dict with string keys to turn those keys into named arguments
in a function call. But Python 3 requires these <code>dict</code> keys to be
<code>str</code> and outright rejects <code>bytes</code> keys, even if the <code>bytes</code> instance
is ASCII safe and has the same underlying byte representation of the
string data as the <code>str</code> instance would. So we had to invent support
functions that would convert <code>dict</code> keys from <code>bytes</code> to <code>str</code> for
use with <code>**kwargs</code> and another to convert a <code>**kwargs</code> dict from
<code>str</code> keys to <code>bytes</code> keys so we could use <code>''</code> syntax to access keys
in our source code! Also on the string type front, we had to sprinkle
the codebase with raw string literals (<code>r''</code>) to force the use of
<code>str</code> irregardless of which Python version you were running on (our
source transformer only changed unprefixed string literals, so existing
<code>r''</code> strings would be preserved as <code>str</code>).</p>
<p>Blind transformation of all string literals to <code>bytes</code> was less than ideal
and it did impose some unwanted side-effects. But, again, most <em>strings</em>
in Mercurial are bytes by design, so we thought it would be easier to
<em>byteify</em> all strings then selectively undo that where native strings
were actually warranted (like keys in most <code>dict</code>s) than to take the
up-front cost to examine every string and make an intelligent determination
as to what type it should be. I go back and forth as to whether this was the
correct call. But when you factor in that the source transforming
module importer unblocked Python 3 porting at a time in the project's
history when there was so much focus on improving the core product and it
did so without externalizing many costs onto the people doing the critical
core product work, I think it was the right call.</p>
<p>By mid 2019, the number of test failures in Python 3 had been whittled
down to a reasonable, less daunting number. It felt like victory was
in grasp and inevitable. But a few significant issues lingered.</p>
<p>One remaining question was around addressing differences between Python
3 versions. At the time, Python 3.5, 3.6, and 3.7 were released and 3.8
was scheduled for release by the end of the year. We had a surprising
number of issues with differences in Python 3 versions. Many of us
were running Python 3.7, so it had the fewest failures. We had to spend
extra effort to get Python 3.5 and 3.6 working as well as 3.7. Same for
3.8.</p>
<p>Another task we deferred until the second half of 2019 was standing up
robust CI for Python 3. We had some coverage, but it was minimal. Wanting
a distraction from PyOxidizer for a bit and wanting to overhaul Mercurial's
CI system (which is officially built on Buildbot), I cobbled together a
<em>serverless</em> CI system built on top of AWS DynamoDB and S3 for storage,
Lambda functions and CloudWatch events for all business logic, and EC2 spot
instances for job execution. This CI system executed Python 3.5, 3.6, 3.7,
and 3.8 variants of our test harness on Linux and Python 3.7 on Windows.
This gave developers insight into version-specific failures. More
importantly, it also gave insight into Windows failures, which was
previously not well tested. It was discovered that Python 3 on Windows was
lagging significantly behind POSIX.</p>
<p>By the time of the Mercurial developer meetup in October 2019, nearly
all tests were passing on POSIX platforms and we were confident that
we could declare Python 3 support as at least beta quality for the
Mercurial 5.2 release, planned for early November.</p>
<p>One of our blockers for ripping off the alpha label on Python 3 support
was removing our source-transforming module importer. It had performance
implications and it wasn't something we wanted to ship because it felt
too hacky. A blocker for this was we wanted to automatically format
our source tree with <a href="https://black.readthedocs.io/en/stable/">black</a>
because if we removed the source transformer, we'd have to rewrite
a lot of source code to apply changes the transformer was performing,
which would necessitate wrapping a lot of lines, which would involve a lot
of manual effort. We wanted to <em>blacken</em> our code base first so that
mass rewriting source code wouldn't involve a lot of tedious reformatting
since <code>black</code> would handle that for us automatically. And rewriting the
source tree with <code>black</code> was blocked on a specific feature landing in
<code>black</code>! (We did not agree with <code>black</code>'s behavior of
unwrapping comma-delimited lists of items if they could fit on a single
line. So one of our core contributors wrote a patch to <code>black</code> that
changed its behavior so a trailing <code>,</code> in a list of items will force
items to be formatted on multiple lines. I personally find the multiple line
formatting much easier to read. And the behavior is arguably better for
code review and <em>annotation</em>, which is line based.) Once this feature
landed in <code>black</code>, we reformatted our source tree and started ripping
out the source transformations, starting by inserting <code>b''</code> literals
everywhere. By late October, the source transformer was no more and
we were ready to release beta quality support for Python 3 (at least
on UNIX-like platforms).</p>
<p>Having described a mostly factual overview of Mercurial's port to Python
3, it is now time to shift gears to the speculative and opinionated
parts of this post. <strong>I want to underscore that the opinions reflected
here are my own and do not reflect the overall Mercurial Project or even
a consensus within it.</strong></p>
<h2>The Future of Python 3 and Mercurial</h2>
<p>Mercurial's port to Python 3 is still ongoing. While we've shipped
Python 3 support and the test harness is clean on Python 3, I view shipping
as only a milestone - arguably <em>the</em> most important one - in a longer
journey. There's still a lot of work to do.</p>
<p>It is now 2020 and Python 2 support is now officially dead from the
perspective of the Python language maintainers. Linux distributions are
starting to rip out Python 2. Packages are dropping Python 2 support in
new versions. The world is moving to Python 3 only. But <strong>Mercurial still
officially supports Python 2</strong>. And it is still yet to be determined how
long we will retain support for Python 2 in the code base. We've only had
one release supporting Python 3. Our users still need to port their
extensions (implemented in Python). Our users still need to start widely
using Mercurial with Python 3. Even our own developers need to switch to
Python 3 (old habits are hard to break).</p>
<p>I anticipate a long tail of random bugs in Mercurial on Python 3. While
the tests may pass, our code coverage is not 100%. And even if it were,
Python is a dynamic language and there are tons of invariants that aren't
caught at compile time and can only be discovered at run time. <strong>These
invariants cannot all be detected by tests, no matter how good your test
coverage is.</strong> This is a <em>feature</em>/<em>limitation</em> of dynamic languages. Our
users will likely be finding a long tail of miscellaneous bugs on Python
3 for <em>years</em>.</p>
<p>At present, our code base is littered with tons of random hacks to bridge
the gap between Python 2 and 3. Once Python 2 support is dropped, we'll
need to remove these hacks and make the source tree Python 3 native, with
minimal shims to wallpaper over differences in Python 3 versions. <strong>Removing
this Python version bridge code will likely require hundreds of commits and
will be a non-trivial effort.</strong> It's likely to be deemed a low priority (it
is glorified busy work after all), and code for the express purpose of
supporting Python 2 will likely linger for years.</p>
<p>We are also still shoring up our packaging and distribution story on
Python 3. This is easier on some platforms than others. I created
<a href="https://github.com/indygreg/PyOxidizer">PyOxidizer</a> partially because
of the poor experience I had with Python application packaging and
distribution through the Mercurial Project. The Mercurial Project has
already signed off on using PyOxidizer for distributing Mercurial in
the future. So look for an <em>oxidized</em> Mercurial distribution in the
near future! (You could argue PyOxidizer is an epic yak shave to better
support Mercurial. But that's for another post.)</p>
<p>Then there's Windows support. A Python 3 powered Mercurial on Windows
still has a handful of known issues. It may require a few more releases
before we consider Python 3 on Windows to be stable.</p>
<p>Because we're still on a code base that must support Python 2, our
adoption of Python 3 features is very limited. The only Python 3
feature that Mercurial developers seem to almost universally get excited
about is type annotations. We already have some people playing around
with <code>pytype</code> using comment-based annotations and <code>pytype</code> has already
caught a few bugs. We're eager to go all in on type annotations and
uncover lots of dynamic typing bugs and poorly implemented APIs.
Beyond type annotations, I can't name any feature that people are screaming
to adopt and which makes a lot of sense for Mercurial. There's a long
tail of minor features I'm sure will get utilized. But none of the
marquee features that define major language releases seem that interesting
to us. Time will tell.</p>
<h2>Commentary on Python 3</h2>
<p>Having described Mercurial's ongoing journey to Python 3, I now want to
focus more on Python itself. Again, the opinions here are my own and
don't reflect those of the Mercurial Project.</p>
<p><strong>Succinctly, my experience porting Mercurial and other projects to
Python 3 has significantly soured my perceptions of Python. As much as
I have historically loved Python - from the language to the welcoming
community - I am still struggling to understand how Python could manage
to inflict so much hardship on the community by choosing the transition
plan that they did.</strong> I believe Python's choices represent a terrific
example of what not to do when managing a large project or ecosystem.
Maintainers of other largely-deployed systems would benefit from taking
the time to understand and reflect on Python's missteps.</p>
<p>Python 3.0 was released on December 3, 2008. And it took the better part of
a decade for the community to embrace it. <strong>This should be universally
recognized as a failure.</strong> While hindsight is 20/20, many of the issues
with Python 3 were obvious at the time and could have been mitigated had
the language maintainers been more accommodating - and dare I say
empathetic - to its users.</p>
<p>Initially, Python 3 had a rather cavalier attitude towards backwards and
forwards compatibility. In the early years of Python 3, the attitude of
Python's maintainers was <em>Python 3 is a new, better language: you should
target it explicitly</em>. There were some tools and methods to ease the
transition. But nothing super polished, especially in the early years.
Adoption of Python 3 in the overall community was slow. Python developers
in the wild justifiably complained that the value proposition of Python 3
was too weak to justify porting effort. Not helping was that the early
advice for targeting Python 3 was to rewrite the source code to become
Python 3 native. This is in contrast with using the same source to run on both
Python 2 and 3. For library and application maintainers, this potentially
meant maintaining separate versions of your code or forcing end-users to
make a giant leap, which would realistically orphan users on an old version,
fragmenting your user base. Neither of those were great alternatives, so
you can understand why many projects didn't bite.</p>
<p>For many projects of non-trivial size, flag day transitions from Python 2 to
3 were simply not viable: the pathway to Python 3 was to make code dual
Python 2/3 compatible and gradually switch over the runtime to Python 3.
But initial versions of Python 3 made this effectively impossible! Let me
give a few specific examples.</p>
<p>In Python 2, a string literal <code>''</code> is effectively an array of bytes. In
Python 3, it is a series of Unicode code points - a fundamentally different
type! In Python 2, you could write <code>b''</code> to be explicit that a string literal
was bytes or you could write <code>u''</code> to indicate a Unicode literal, mimicking
Python 3's behavior. In Python 3, you could write <code>b''</code> to create a <code>bytes</code>
instance. But for whatever reason, Python 3 initially removed the <code>u''</code> syntax,
meaning there wasn't as easy way to explicitly denote the type of each
string literal so that it was consistent between Python 2 and 3! Python 3.3
(released September 2012) restored <code>u''</code> support, making it more viable to
write Python source code that worked on both Python 2 and 3. <strong>For nearly 4
years, Python 3 took away the consistent syntax for denoting bytes/Unicode
string literals.</strong></p>
<p>Another feature was <code>%</code> formatting of strings. Python 2 allowed use of the
<code>%</code> formatting operator on both its string types. But Python 3 initially
removed the implementation of <code>%</code> from <code>bytes</code>. Why, I have no clue. It
is perfectly reasonable to splice byte sequences into a buffer via use of
a formatting string. But the Python language maintainers insisted otherwise.
And it wasn't until the community complained about its absence loudly enough
that this feature was
<a href="https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-461">restored in Python 3.5</a>,
which was released in September 2015. Fun fact: the lack of this feature was
once considered a blocker for Mercurial moving to Python 3 because
Mercurial uses <code>bytes</code> almost universally, which meant that nearly every use
of <code>%</code> would have to be changed to something else. And to this day, Python
3's <code>bytes</code> still doesn't have a <code>format()</code> method, so the alternative was
effectively string concatenation, which is a massive step backwards from the
expressiveness of <code>%</code> formatting.</p>
<p><strong>The initial approach of Python 3 mirrors a folly that many developers
and projects make: attempting a rewrite instead of performing incremental
evolution.</strong> For established projects, large scale rewrites often go poorly.
And Python 3 is no exception. Yes, from a code level, CPython (and likely
other Python implementations) were incremental changes over Python 2 using
the same code base. But from a language and standard library level, the
differences in Python 3 were significant enough that I - and even Python's
core maintainers - considered it a new language, and therefore a rewrite.
When your random project attempts a rewrite and fails, the blast radius of that is
often contained to that project. Maybe you don't publish a new release
as soon as you otherwise would. <strong>But when you are powering an ecosystem,
the ripple effects from a failed rewrite percolate throughout that ecosystem
and last for years and have many second order effects. We see this with
Python 3, where poor choices made in the late 2000s are inflicting significant
hardship still in 2020.</strong></p>
<p>From the initial restrained adoption of Python 3, it is obvious that the
Python ecosystem overwhelmingly rejected the initial boil the oceans approach
of Python 3. Python's maintainers eventually got the message and started
restoring features like <code>u''</code> and <code>bytes</code> <code>%</code> formatting back into the
language to placate the community. All the while Python 3 had been accumulating
new features and the cumulative sum of those features was compelling enough
to win over users.</p>
<p>For many projects (including Mercurial), Python 3.4/3.5 was the first viable
porting target for Python 3. Python 3.5 was released in September 2015, almost
7 years after Python 3.0 was released in December 2008. <strong>Seven. Years.</strong>
An ecosystem that falters for that long is generally not healthy. What may have
saved Python from total collapse here is that Python 2 was still going strong and
people were generally happy with it. I really do think Python dodged a bullet
here, because there was a massive window where the language could have
hemorrhaged a critical amount of its user base and been relegated to an
afterthought. One could draw an analogy to Perl, which lost out to PHP,
Python, and Ruby, and whose fall from grace aligned with a lengthy
transition from Perl 5 to 6.</p>
<p>If you look back at the early history of Python 3, <strong>I think you are forced
to conclude that Python effectively kneecapped itself for 5-7 years
through questionable implementation choices that prevented users from
incurring incremental transitions between the major language versions. 2008
to 2013-2015 should be known as the <em>lost years of Python</em> because so much
opportunity and energy was squandered.</strong> Yes, Python is still healthy today
and Python 3 is (finally) being adopted at scale. But had earlier versions
of Python 3 been more <em>empathetic</em> towards Python 2 users porting to it,
Python and Python 3 in 2020 would be even stronger than it is. The community
was artificially hindered for years. And we won't know until 2023-2025 what
things could have looked like in 2020 had the Python core language team
spent more time paving a smoother road between the major language versions.</p>
<p>To be clear, I do think Python 3 is generally a better language than Python 2.
It has fewer warts, more compelling features, and better performance (except
for startup time, which is still slower than Python 2). I am ecstatic the
community is finally rallying around Python 3! For my Python coding, it has
reached the point where I curse under my breath when I need to support
Python 2 or even older versions of Python 3, like 3.5 or 3.6: I just wish
the world would move on and adopt the future already!</p>
<p>But I would be remiss if I failed to mention some of my gripes with Python
3 beyond the transition shenanigans.</p>
<p>Perhaps my least favorite <em>feature</em> of Python 3 is its insistence that the
world is Unicode. In Python 2, the default string type was backed by
bytes. In Python 3, the default string type is backed by Unicode code
points. As part of that transition, large parts of the standard library
now operate in the Unicode space instead of the domain of bytes. I understand
why Python does this: they want <em>strings</em> to be Unicode and don't want
users to have to spend that much energy thinking about when to use
<code>str</code> versus <code>bytes</code>. This approach is admirable and somewhat defensible
because it takes a stand on a solution that is arguably <em>good enough</em> for
most users. However, <strong>the approach of assuming the world is Unicode is
flat out wrong and has significant implications for systems level
applications</strong> (like version control tools).</p>
<p>There are a myriad of places in Python's standard library where Python
insists on using the Unicode-backed <code>str</code> type and rejects <code>bytes</code>. For
example, various networking modules refuse to accept <code>bytes</code> for hostnames
or URLs. HTTP libraries won't accept <code>bytes</code> for HTTP header names or values.
Functions that are proxies to POSIX-defined functions won't accept <code>bytes</code>
even though the POSIX function it calls into is using <code>char *</code> and isn't
Unicode aware. Then there's filename handling, where Python assumes the
existence of a global encoding for filenames and uses this encoding to convert
between <code>str</code> and <code>bytes</code>. And it does this despite POSIX filesystem paths
being a bag of bytes where the only rules are that <code>\0</code> terminates the
filename and <code>/</code> is special.</p>
<p>In cases like Python refusing to accept <code>bytes</code> for things like HTTP
header names (which will just be spit out over the wire as bytes), Python's
pendulum has swung too far towards Unicode only. In my opinion, Python needs
to be more accommodating and allow <code>bytes</code> when it makes sense. I hope the
pendulum knocks some sense into people when it swings back towards a more
reasonable solution that better acknowledges the realities of the world we
live in.</p>
<p>For areas like filename handling, the world is more complicated. Python
is effectively an abstraction layer over the operating system APIs exposing
this functionality. And there is often an impedance mismatch between operating
systems. For example, POSIX (Linux) tends to use <code>char *</code> for everything
and doesn't care about encoding and Windows tends to use 16 bit character
types where the encoding is... a can of worms.</p>
<p><strong>The reality here is that it is impossible to abstract over differences
between operating system behavior without compromises that can result in data
loss, outright wrong behavior, or loss of functionality. But Python 3 attempts
to do it anyway, making Python 3 unsuitable (or at least highly undesirable) for
certain systems level applications that rely on it</strong> (like a version control
tool).</p>
<p>In fairness to Python, it isn't the only programming language that gets
this wrong. The only language I've seen <em>properly</em> implement higher-order
abstractions on top of operating system facilities is Rust, whose approach can
be generalized as <em>use Python 3's solution of normalizing to Unicode/UTF-8 by
default</em>, but expose <em>escape hatches</em> which allow access to the raw underlying
types and APIs used by the operating system for the advanced consumers who
require it. For example, Rust's <code>Path</code> type which represents a filesystem path
<a href="https://doc.rust-lang.org/std/path/struct.Path.html#method.as_os_str">allows access</a>
to the raw <a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html">OsStr</a> value
used by the operating system, not a normalization of it to bytes or Unicode,
which may be lossy. This allows consumers to e.g. create and retrieve
OS-native filesystem paths without data loss. This functionality is critical
in some domains. Python 3's awareness/insistence that the world is
Unicode (which it isn't universally) reduces Python's applicability in these
domains.</p>
<p>Speaking of Rust, at the Mercurial developer meetup in October 2019, we were
discussing the use of Rust in Mercurial and one of the core maintainers blurted
out something along the lines of <em>if Rust were at its current state 5 years ago,
Mercurial would have likely ported from Python 2 to Rust instead of Python 3</em>.
As crazy as it initially sounded, I think I agree with that assessment. With the
benefit of hindsight, having been a key player in the Python 3 porting effort,
seeing all the complications and headaches Python 3 is introducing, and
having learned Rust and witnessed its benefits for performance, control,
and correctness firsthand, porting to Rust would likely have been the correct
move for the project at that point in time. 2020 is not 2014, however, and I'm
not sure if I would opt for a rewrite in Rust today. (Most rewrites are follies
after all.) But I know one thing: I certainly wouldn't implement a new version
control tool in Python 3 and I would probably choose Rust as an implementation
language for most new projects in the systems level space or with an expected
shelf life of 10+ years. (I really should blog about how awesome Rust is.)</p>
<p>Back to the topic of Python itself, <strong>I'm really soured on Python at this
point in time. The effort required to port to Python 3 was staggering. For
Mercurial, Python 3 introduces a ton of problems and doesn't really solve
many. We effectively sludged through mud for several years only to wind
up in a state that feels strictly worse than where we started. I'm sure it will
be strictly better in a few years. But at that point, we're talking about a
5+ year transition. To call the Python 3 transition disruptive and
distracting for the project would be an understatement. As a project maintainer,
it's natural to ask what we could have accomplished if we weren't forced
to carry out this sideshow.</strong></p>
<p>I can't shake the feeling that a lot of the pain afflicted by the Python 3
transition could have been avoided had Python's language leadership made
a different set of decisions and more highly prioritized the transition
experience. (Like not initially removing features like <code>u''</code> and <code>bytes %</code>
and not introducing gratuitous backwards compatibility breaks, like with
<code>items()/iteritems()</code>. I would have also liked to see a feature like
<code>from __future__</code> - maybe <code>from __past__</code> - that would make it easier for
Python 3 code to target semantics in earlier versions in order to provide
a more turnkey on-ramp onto new versions.) I simultaneously see Python 3
losing its position as a justifiable tool in some domains (like systems
level tooling) due to ongoing design decisions and poor implementation (like
startup overhead problems). (In contrast, I see Rust excelling where Python
is faltering and find Rust code surprisingly expressive to write and maintain
given how low-level it is and therefore feel that Rust is a compelling
alternative to Python in a surprisingly large number of domains.)</p>
<p>Look, I know it is easy for me to armchair quarterback and critique with the
benefit of hindsight/ignorance. I'm sure there is a lot of nuance here. I'm
sure there was disagreement within the Python community over a lot of these
issues. Maintaining a large and successful programming language and community
like Python's is hard and you aren't going to please all the people all the
time. And speaking as a maintainer, I have mad respect for the people leading
such a large community. But niceties aside, everyone knows the Python 3
transition was rough and could have gone better. It should not have taken 11
years to get to where we are today.</p>
<p><strong>I'd like to encourage the Python Project to conduct a thorough postmortem on
the transition to Python 3.</strong> Identify what went well, what could have gone
better, and what should be done next time such a large language change is wanted.
Speaking as a Python user, a maintainer of a Python project, and as someone in
industry who is now skeptical about use of Python at work due to risks of
potentially company crippling high-effort migrations in the future, a postmortem
would help restore my confidence that Python's maintainers learned from the
various missteps on the road to Python 3 and these potentially ecosystem
crippling mistakes won't be made again.</p>
<p>Python had a wildly successful past few decades. And it can continue to
thrive for several more. But the Python 3 migration was painful for all
involved. And as much as we need to move on and leave Python 2 behind us,
there are some important lessons to be learned. I hope the Python community
takes the opportunity to reflect and am confident it will grow stronger by
taking the time to do so.</p>]]></content:encoded>
    </item>
    <item>
      <title>Problems with Pull Requests and How to Fix Them</title>
      <link>http://gregoryszorc.com/blog/2020/01/07/problems-with-pull-requests-and-how-to-fix-them</link>
      <pubDate>Tue, 07 Jan 2020 12:10:00 PST</pubDate>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Git]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2020/01/07/problems-with-pull-requests-and-how-to-fix-them</guid>
      <description>Problems with Pull Requests and How to Fix Them</description>
      <content:encoded><![CDATA[<p>You've probably used or at least heard of <em>pull requests</em>: the <em>pull
request</em> is the contribution workflow practiced on and made popular by
[code] collaboration sites like GitHub, GitLab, Bitbucket, and others.
Someone (optionally) creates a <em>fork</em>, authors some commits, pushes them
to a branch, then creates a <em>pull request</em> to track integrating those commits
into a target repository and branch. The <em>pull request</em> is then used as a
vehicle for code review, tracking automated checks, and discussion until
it is ready to be integrated. Integration is usually performed by a
project maintainer, often with the click of a <em>merge</em> button on the pull
request's web page.</p>
<p>It's worth noting that the term <em>pull request</em> is not universally used:
GitLab calls them <em>merge requests</em> for example. Furthermore I regard the
terms <em>pull request</em> and <em>merge request</em> to be poorly named, as the terms
can be conflated with terminology used by your version control tool (e.g.
<code>git pull</code> or <code>git merge</code>. And the implementations of a <em>pull</em> or <em>merge</em>
request may not even perform a <em>pull</em> or a <em>merge</em> (you can also <em>rebase</em> a
<em>pull</em>/<em>merge</em> request, but nobody is calling them <em>rebase requests</em>). A
modern day <em>pull request</em> is so much more than a version control tool
operation or even a simple request to <em>pull</em> or <em>merge</em> a branch: it is a
nexus to track the integration of a proposed change before during and after
that change is integrated. But alas. Because GitHub coined the term and is
the most popular collaboration platform implementing this functionality, I'll
refer to this general workflow as implemented on GitHub, GitLab, Bitbucket,
and others as <em>pull requests</em> for the remainder of this post.</p>
<p>Pull requests have existed in essentially their current form for over
a decade. The core workflow has remained mostly unchanged.
What is different are the addition of value-add features, such as integrating
status checks like CI results, the ability to rebase or squash commits
instead of merging, code review tooling improvements, and lots of UI
polish. GitLab deserves a call out here, as their implementation of
<em>merge requests</em> tracks so much more than other tools do. (This is a
side-effect of GitLab having more built-in features than comparable tools.)
I will also give kudos to GitLab for adding new features to pull requests
when GitHub was asleep at the wheel as a company a few years ago. (Not having
a CEO for clear product/company leadership really showed.) Fortunately,
both companies (and others) are now churning out new, useful features at a
terrific clip, greatly benefiting the industry!</p>
<p>While I don't have evidence of this, I suspect pull requests (and the forking
model used by services that implement them) came into existence when someone
thought <em>how do I design a collaboration web site built on top of Git's new and
novel distributed nature and branching features</em>. They then proceeded to invent
<em>forking</em> and <em>pull requests</em>. After all, the pull request as implemented by
GitHub was initially a veneer over a common Git workflow of <em>create a clone,
create a branch, and send it somewhere.</em> Without GitHub, you would run <code>git
clone</code>, <code>git branch</code>, then some other command like
<a href="https://git-scm.com/docs/git-request-pull">git request-pull</a> (where have I seen
those words before) to generate/send your branch somewhere. On GitHub, the
comparable steps are roughly <em>create a fork</em>, <em>create a branch to your fork</em>,
and <em>submit a pull request</em>. Today, you can even do all of this straight from
the web interface without having to run <code>git</code> directly! This means that GitHub
can conceptually be thought of as a purely server-side abstraction/implementation
of the Git feature branch workflow.</p>
<p><strong>At its core, the pull request is fundamentally a nice UI and feature layer
built around the common Git feature branch workflow.</strong> It was likely initially
conceived as polish and value-add features over this historically client-side
workflow. And this core property of pull requests from its very first days has
been copied by vendors like Bitbucket and GitLab (and in Bitbucket's case it
was implemented for Mercurial - not Git - as Bitbucket was initially Mercurial
only).</p>
<p>A decade is an eternity in the computer industry. As they say, if you
aren't moving forward, you are moving backward. <strong>I think it is time
for industry to scrutinize the pull request model and to evolve it into
something better.</strong></p>
<p>I know what you are thinking: you are thinking that pull requests
work great and that they are popular because they are a superior model
compared to what came before. These statements - aside from some nuance -
are true. But if you live in the version control space (like I do) or
are paid to deliver tools and workflows to developers to improve
productivity and code/product quality (which I am), the deficiencies
in the pull request workflow and implementation of that workflow among
vendors like GitHub, GitLab, Bitbucket, etc are obvious and begging to be
overhauled if not replaced wholesale.</p>
<p>So buckle in: you've started a ten thousand word adventure about everything
you didn't think you wanted to know about pull requests!</p>
<h2>Problems with Pull Requests</h2>
<p>To build a better workflow, we first have to understand what is
wrong/sub-optimal with pull requests.</p>
<p><strong>I posit that the foremost goal of an pull request is to foster the
incorporation of a high quality and desired change into a target
repository with minimal overhead and complexity for submitter,
integrator, and everyone in between.</strong> Pull requests achieve this
goal by fostering collaboration to discuss the change (including code
review), tracking automated checks against the change, linking to related
issues, etc. In other words, the way I see the world is that a specific
vendor's pull request implementation is just that: an implementation detail.
And like all implementation details, they should be frequently scrutinized
and changed, if necessary.</p>
<p>Let's start dissecting the problems with pull requests by focusing on
the size of review units. Research by
<a href="https://sback.it/publications/icse2018seip.pdf">Google</a>,
Microsoft <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/bosu2015useful.pdf">here</a>,
and <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2015/05/PID3556473.pdf">here</a>,
and others has shown an inverse correlation with review unit size
and defect rate. In Google's words (emphasis mine):</p>
<p>The size distribution of changes is an important factor in the
   quality of the code review process. <strong>Previous studies have found that
   the number of useful comments decreases and the review latency
   increases as the size of the change increases.</strong> Size also
   influences developers' perception of the code review process; a
   survey of Mozilla contributors found that <strong>developers feel that
   size-related factors have the greatest effect on review latency</strong>.
   A correlation between change size and review quality is
   acknowledged by Google and <strong>developers are strongly encouraged to
   make small, incremental changes</strong> (with the exception of large
   deletions and automated refactoring). These findings and our study
   support the value of reviewing small changes and the need for
   research and tools to help developers create such small,
   self-contained code changes for review.</p>
<p>Succinctly, larger changes result in fewer useful comments during
review (meaning quality is undermined) and make reviews take longer
(meaning productivity is undermined). <strong>Takeaway: if you care about
defect rate / quality and/or velocity, you should be authoring and
reviewing more, smaller changes as opposed to fewer, larger changes.</strong></p>
<p>I stronger agree with Google's opinion on this matter and wholeheartedly
endorse writing more, smaller changes. Having practiced both forms of
change authorship, I can say without a doubt that more, smaller changes
is superior: superior for authors, superior for code reviewers, and
superior for people looking at repository history later. The main downside
with this model is that it requires a bit more knowledge of your version
control tool to execute. And, it requires corresponding tooling to play
well with this change authorship model and to introduce as little
friction as possible along the way since the number of interactions
with tooling will increase as change size decreases, velocity
increases, and there are more distinct units of change being considered
for integration.</p>
<p>That last point is important and is germane to this post because the
common implementation of pull requests today is not very compatible
with the <em>many small changes</em> workflow. As I'll argue, <strong>the current
implementation of pull requests actively discourages the many smaller
changes workflow. And since smaller changes result in higher quality
and faster reviews, today's implementations of pull requests are
undermining quality and velocity.</strong></p>
<p>I don't mean to pick on them, but since they are the most popular and
the people who made pull requests popular, let's use GitHub's implementation
of pull requests to demonstrate my point.</p>
<p><strong>I posit that in order for us to author more, smaller changes, we must
either a) create more, smaller pull requests or b) have pull request
reviews put emphasis on the individual commits (as opposed to the
overall <em>merge diff</em>).</strong> Let's examine these individually.</p>
<p>If we were to author more, smaller pull requests, this would seemingly
necessitate the need for dependencies between pull requests in order
to maintain velocity. And dependencies between pull requests adds
a potentially prohibitive amount of overhead. Let me explain. We don't
want to sacrifice the overall rate at which authors and maintainers are
able to integrate proposed changes. If we were to split existing proposed
changes into more, smaller pull requests, we would have a lot more pull
requests. Without dependencies between them, authors could wait for each
pull request to be integrated before sending the next one. But this would
incur more round trips between author and integrator and would almost
certainly slow down the overall process. That's not desirable. The
obvious mitigation to that is to allow multiple, related pull requests
in flight simultaneously. But this would necessitate the invention of
dependencies between pull requests in order to track relationships so
one pull request doesn't integrate before another it logically depends on.
This is certainly technically doable. But it imposes considerable
overhead of its own. How do you define dependencies? Are dependencies
automatically detected or updated based on commits in a DAG? If yes,
what happens when you force push and it is ambiguous whether a <em>new</em>
commit is a logically new commit or a successor of a previous one? If
no, do you really want to impose additional hurdles on submitters to
define dependencies between every pull request? In the extreme case of
one pull request per commit, do you make someone submitting a series of
say twenty commits and pull requests really annotate nineteen dependencies?
That's crazy!</p>
<p>There's another, more practical issue at play: the interplay between
Git branches and pull requests. As implemented on GitHub, a pull request
is tracked by a Git branch. If we have N inter-dependent pull requests,
that means N Git branches. In the worst case, we have one Git branch for
every Git commit. Managing N in-flight Git branches would be absurd.
It would impose considerable overhead on pull request submitters. It
would perfectly highlight the inefficiency in Git's
<a href="/blog/2017/12/11/high-level-problems-with-git-and-how-to-fix-them/">game of refs</a>
branch management that I blogged about two years ago. (Succinctly,
once you are accustomed to workflows - like Mercurial's - which don't
require you to name commits or branches, Git's forced naming of branches
and all the commands requiring those branch names feels grossly inefficient
and a mountain of overhead.) Some tooling could certainly be implemented
to enable efficient submission of pull requests. (See
<a href="https://github.com/ezyang/ghstack">ghstack</a> for an example.) But I
think the interplay between Git branches and GitHub pull requests is
sufficiently complex that the tooling and workflow would be intractable
for anything but the most trivial and best-case scenarios. Keep in mind
that any sufficiently user-friendly solution to this problem would
also entail improving <code>git rebase</code> so it moves branches on rewritten
ancestor commits instead of leaving them on the old versions of
commits. (Seriously, someone should implement this feature: it arguably
makes sense as the default behavior for local branches.) In other
words, <strong>I don't think you can implement the multiple pull request model
reliably and without causing excessive burden on people without
fundamentally changing the requirement that a pull request be a Git
branch</strong>. (I'd love to be proven wrong.)</p>
<p>Therefore, <strong>I don't think the more, smaller changes workflow can be easily
practiced with multiple pull requests using the common GitHub model without
effectively moving the definition of a pull request away from
equivalence with a Git branch</strong> (more on this later). And I also
don't mean to imply that dependencies between pull requests can't be
implemented: they can and
<a href="https://docs.gitlab.com/ee/user/project/merge_requests/merge_request_dependencies.html">GitLab is evidence</a>.
But GitLab's implementation is somewhat simple and crude (possibly
because doing anything more complicated is really hard as I speculate).</p>
<p>So without fundamentally changing the relationship between a pull
request and a branch, that leaves us with our alternative of pull
requests putting more emphasis on the individual changes rather than
the <em>merge diff</em>. Let's talk about that now.</p>
<p>Pull requests have historically placed emphasis on the <em>merge diff</em>.
That is, GitHub (or another provider) takes the Git branch you have
submitted, runs a <code>git merge</code> against the target branch behind the
scenes, and displays that diff front and center for review as the main
proposed unit of change: if you click the <em>Files changed</em> tab to
commence review, you are seeing this overall <em>merge diff</em>. You can
click on the <em>Commits</em> tab then select an individual commit to review
just that commit. Or you can use the dropdown on the <em>Files changed</em>
tab to select an individual commit to review it. These (relatively
new) features are a very welcome improvement and do facilitate
performing a commit-by-commit review, which is a requirement to realize
the benefits of a more, smaller changes workflow. Unfortunately, they
are far from sufficient to fully realize the benefits of that workflow.</p>
<p>Defaults matter and GitHub's default is to show the <em>merge diff</em> when
conducting review. (I bet a large percentage of users don't even know
it is possible to review individual commits.) <strong>Since larger changes
result in a higher defect rate and slower review, GitHub's default
of showing the <em>merge diff</em> effectively means GitHub is defaulting to
lower quality, longer-lasting reviews.</strong> (I suppose this is good for
engagement numbers, as it inflates service usage both immediately and
in the long-term due to subsequent bugs driving further usage. But I
sincerely hope no product manager is thinking <em>let's design a product
that undermines quality to drive engagement</em>.)</p>
<p>Unfortunately, a trivial change of the default to show individual commits
instead of the <em>merge diff</em> is not so simple, as many authors and
projects don't practice clean commit authorship practices, where
individual commits are authored such that they can be reviewed in isolation.</p>
<p>(One way of classifying commit authorship styles is by whether a series
of commits is authored such that each commit is good in isolation or
whether the effect of applying the overall series is what matters. A
handful of mature projects - like the Linux kernel, Firefox, Chrome,
Git, and Mercurial - practice the <em>series of individually-good commits</em>
model, which I'll call a <em>commit-centric workflow</em>. I would wager the
majority of projects on GitHub and similar services practice the <em>we only
care about the final result of the series of commits</em> model. A litmus
test for practicing the latter model is whether pull requests contain commits
like <em>fixup foo</em> or if subsequent revisions to pull requests create new
commits instead of amending existing ones. I'm a strong proponent of
a clean commit history where each commit in the final repository history
stands as <em>good</em> in isolation. But I tend to favor more <em>grown-up</em>
software development practices and am a version control guru. That
being said, the subject/debate is fodder for another post.)</p>
<p>If GitHub (or someone else) switched the pull request default to a
per-commit review without otherwise changing the relationship between a
pull request and a Git branch, that would force a lot of less experienced
users to familiarize themselves with history rewriting in Git. This would
impose considerable pain and suffering on pull request authors, which
would in turn upset users, hurt engagement, etc. Therefore, I don't think
this is a feasible <em>global</em> default that can be changed. Maybe if Git's
user experience for history rewriting were better or we didn't have a
decade of behavior to undo we'd be in a better position... But pull
request implementations don't need to make a <em>global</em> change: <strong>they could
<em>right the ship</em> by offering projects that practice <em>clean commit
practices</em> an option to change the review default so it emphasizes
individual commits instead of the <em>merge diff</em>.</strong> This would go a long way
towards encouraging authoring and reviewing individual commits, which
should have positive benefits on review velocity and code quality
outcomes.</p>
<p>But even if these services did emphasize individual commits by default in
pull request reviews, there's still a handful of significant
deficiencies that would undermine the more, smaller changes workflow
that we desire.</p>
<p>While it is possible to review individual commits, all the review comments
are still funneled into a single per pull request <em>timeline</em> view of
activity. <strong>If submitter and reviewer make the effort to craft and
subsequently review individual commits, your reward is that all the feedback
for the discrete units of change gets lumped together into one massive pile
of feedback for the pull request as a whole.</strong> This unified pile of feedback
(currently) does a poor job of identifying which commit it applies to and
gives the author little assistance in knowing which commits need amending to
address the feedback. This undermines the value of commit-centric workflows
and effectively pushes commit authors towards the <em>fixup</em> style of commit
authorship. <strong>In order to execute per-commit review effectively, review
comments and discussion need to be bucketed by commit and not combined into a
unified pull request timeline.</strong> This would be a massive change to the pull
request user interface and would be a daunting undertaking, so it is
understandable why it hasn't happened yet. And such an undertaking would also
require addressing subtly complex issues like how to preserve reviews in the
face of force pushes. Today, GitHub's review comments can <em>lose context</em> when
force pushes occur. Things are better than they used to be, when review comments
left on individual commits would flat out be deleted (yes: GitHub really did
effectively lose code review comments for several years.) But even with tooling
improvements, problems still remain and should adoption of commit-level review
tracking occur, these technical problems would likely need resolution to
appease users of this workflow.</p>
<p>Even if GitHub (or someone else) implements robust per-commit review
for pull requests, there's still a problem with velocity. And that problem
is that <strong>if the pull request is your unit of integration (read: <em>merging</em>),
then you have to wait until every commit is reviewed before integration
can occur</strong>. This may sound tolerable (it's what we practice today after
all). But I argue this is less optimal than a world where a change
integrates as soon as it is ready to, without having to wait for the
changes after it. <strong>As an author and maintainer, if I see a change that
is ready to integrate, I prefer to integrate it as soon as possible, without
delay.</strong> The longer a ready-to-integrate change lingers, the longer it is
susceptible to bit rot (when the change is no longer valid/good due to
other changes in the system). Integrating a judged-good change sooner also
reduces the time to meaningful feedback: if there is a fundamental
problem early in a series of changes that isn't caught before integration,
integrating earlier changes sooner without waiting for the ones following
will expose problems sooner. This minimizes deltas in changed systems
(often making regression hunting easier), often minimizes the blast radius if
something goes wrong, and gives the author more time and less pressure to
amend subsequent commits that haven't been integrated yet. And in addition
to all of this, <strong>integrating more often just feels better</strong>.
<a href="https://hbr.org/2011/05/the-power-of-small-wins">The Progress Principle</a>
states that people feel better and perform better work when they are
making continuous progress. But setbacks more than offset the power of
small wins. While I'm not aware of any explicit research in this area,
my interpretation of the Progress Principle to change authorship and project
maintenance(which is supported by anecdotal observation) is
that a steady stream of integrated changes feels a hell of a lot better
than a single monolithic change lingering in review purgatory for what can
often seem like an eternity. <strong>While you need to be cognizant to not
confuse movement with meaningful progress, I think there is real power
to the Progress Principle and that we should aim to incorporate changes
as soon as they are ready and not any later.</strong> Applied to version control
and code review, this means integrating a commit as soon as author,
reviewer, and our machine overlords reporting status checks all agree it
is ready, without having to wait for a larger unit of work, like the
pull request. Succinctly, move forward as soon as you are able to!</p>
<p>This desire to <em>integrate faster</em> has significant implications for
pull requests. Again, looking at GitHub's implementation of pull
requests, I don't see how today's pull requests could adapt to this
desired end state without significant structural changes. For starters,
review <strong>must</strong> grow the ability to track per-commit state otherwise
integrating individual commits without the entirety of the parts makes
little sense. But this entails all the complexity I described above.
Then there's the problem of Git branches effectively defining a pull
request. What happens when some commits in a pull request are integrated
and the author rebases or merges their local branch against their new
changes? This may or may not <em>just work</em>. And when it doesn't <em>just work</em>,
the author can easily find themselves in <em>merge conflict hell</em>, where
one commit after the other fails to apply cleanly and their carefully
curated stack of commits quickly becomes a liability and impediment to
forward progress. (As an aside, the Mercurial version control tool has
a concept called <em>changeset evolution</em> where it tracks which commits -
changesets in Mercurial parlance - have been rewritten as other commits
and gracefully reacts in situations like a rebase. For example, if you
have commits <code>X</code> and <code>Y</code> and <code>X</code> is integrated via a rebase as <code>X'</code>, an
<code>hg rebase</code> of <code>Y</code> onto <code>X'</code> will see that <code>X</code> was rewritten as <code>X'</code> and
skip attempting to rebase <code>X</code> because it is already applied! This cleanly
sidesteps a lot of the problems with history rewriting - like merge
conflicts - and can make the end-user experience much more pleasant as
a result.) While it is certainly possible to integrate changes as soon
as they are <em>ready</em> with a pull request workflow, I think that it is
awkward and that by the time you've made enough changes to accommodate
the workflow, very little is left of the pull request workflow as we
know it and it is effectively a different workflow altogether.</p>
<p><strong>The above arguments overly hinge on the assumption that more smaller
changes is superior for quality and/or velocity and that we should
design workflows around this assertion.</strong> While I strongly believe
in the merits of smaller units of change, others may disagree. (If
you do disagree, you should ask yourself whether you believe the
converse: that larger units of change are better for quality and
velocity. I suspect most people can't justify this. But I do believe
there is merit to the argument that smaller units of change impose
additional per-unit costs or have second order effects that undermine
their touted quality or velocity benefits.)</p>
<p><strong>But even if you don't buy into the change size arguments, there's
still a very valid reason why we should think beyond pull requests as
they are implemented today: tool scalability.</strong></p>
<p>The implementation of pull requests today is strongly coupled with
how Git works out of the box. A pull request is initiated from a Git
branch pushed to a remote Git repository. When the pull request is
created, the server creates a Git branch/ref referring to that pull
request's <em>head</em> commits. On GitHub, these refs are
<a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/checking-out-pull-requests-locally">named</a>
<code>pull/ID/head</code> (you can fetch these from the remote Git repository but
they are not fetched by default). Also when a pull request is created
or updated, a <code>git merge</code> is performed to produce a diff for review.
On GitHub, the resulting merge commit is <em>saved</em> and pointed to on
the open pull request via a <code>pull/ID/merge</code> ref, which can also be
fetched locally. (The <em>merge</em> ref is deleted when the pull request is
closed.)</p>
<p>Herein resides our scalability problem: unbound growth of Git refs
and ever-increasing rate of a change for a growing project.
Each Git ref adds overhead to graph walking operations and data exchange.
While involved operations are continuously getting optimized (often through
the use of more advanced data structures or algorithms), there are
intrinsic scaling challenges with this unbound growth that - speaking as
a version control tool maintainer - I want no part of. Are technical
solutions enabling things to scale to millions of Git refs viable?
Yes'ish. But it requires high-effort solutions like
<a href="https://git.eclipse.org/r/#/c/146568/">JGit's Reftable</a>, which
required ~90 review rounds spanned across ~4 months to land. And that's
after design of the feature was first proposed at least as far back
as <a href="https://public-inbox.org/git/CAJo=hJtyof=HRy=2sLP0ng0uZ4=S-DpZ5dR1aF+VHVETKG20OQ@mail.gmail.com/">July 2017</a>.
Don't get me wrong: am I glad Reftable exists: yes. It is a fantastic
solution to a real problem and reading how it works will probably
make you a better engineer. But simultaneously, it is a solution to a
problem that does not need to exist. There is a space for scaling graph
data structures and algorithms to millions or even billions of nodes, edges,
and paths: your version control tool should not be it. Millions or billions
of commits and files: that's fine. But scaling the number of distinct paths
through that graph by introducing millions of DAG heads is insane given how much
complexity it introduces in random areas of the tool. In my opinion it
requires unjustifiably large amounts of investment to make work
at scale. As an engineer, my inclination when posed with problems like
these is to avoid them in the first place. The easiest problems to solve
are those you don't have.</p>
<p><strong>Unfortunately, the tight coupling of pull requests to Git branches/refs
introduces unbound growth and a myriad of problems associated with it.</strong>
Most projects may not grow to a size that experiences these problems. But
as someone who has experience with this problem space at multiple companies,
I can tell you the problem is very real and the performance and scalability
issues it creates undermines the viability of using today's implementation of
pull requests once you've reached a certain scale. Since we can likely fix the
underlying scaling issues with Git, I don't think the explosion of Git refs
is a long-term deal breaker for scaling pull requests. But it is today and
will remain so until Git and the tools built on top of it improve.</p>
<p>In summary, some high-level problems with pull requests are as follows:</p>
<ul>
<li>Review of <em>merge diff</em> by default encourages larger units of review,
  which undermines quality and velocity outcomes.</li>
<li>Inability to incrementally integrate commits within a pull request,
  which slows down velocity, time to meaningful feedback, and can
  lower morale.</li>
<li>Tight coupling of pull requests with Git branches adds rigidity to
  workflows and shoehorns into less flexible and less desired workflows.</li>
<li>Deficiencies in the Git user experience - particular around what happens
  when rewrites (including rebase) occur - significantly curtail what
  workflows can be safely practiced with pull requests.</li>
<li>Tight coupling of pull requests with Git branches can lead to performance
  issues at scale.</li>
</ul>
<p>We can invert language to arrive at a set of more ideal outcomes:</p>
<ul>
<li>Review experience is optimized for individual commits - not the <em>merge
  diff</em> - so review units are smaller and quality and velocity outcomes
  are improved.</li>
<li>Ability to incrementally integrate individual commits from a larger
  set so ready-to-go changes are incorporated sooner, improving velocity,
  time to meaningful feedback, and morale.</li>
<li>How you use Git branches does not impose significant restrictions on
  handling of pull requests.</li>
<li>You can use your version control tool how you want, without having to
  worry about your workflow being shoehorned by how pull requests
  work.</li>
<li>Pull request server can scale to the most demanding use cases with
  relative ease.</li>
</ul>
<p>Let's talk about how we could achieve these more desirable outcomes.</p>
<h2>Exploring Alternative Models</h2>
<p>A <em>pull request</em> is merely an implementation pattern for the general problem
space of <em>integrating a proposed change</em>. There are other patterns used by other
tools. Before I describe them, I want to coin the term <em>integration request</em> to
refer to the generic concept of requesting some change being <em>integrated</em>
elsewhere. GitHub pull requests and GitLab merge requests are implementations
of <em>integration requests</em>, for example.</p>
<p>Rather than describe alternative tools in detail, I will outline the key
areas where different tools differ from pull requests and assess the benefits
and drawbacks to the different approaches.</p>
<h3>Use of the VCS for Data Exchange</h3>
<p>One can classify implementations of <em>integration requests</em> by how they utilize
the underlying version control tools.</p>
<p>Before Git and GitHub came along, you were probably running a centralized version
control tool which didn't support offline commits or feature branches (e.g. CVS
or Subversion). In this world, the common mechanism for <em>integration requests</em>
was exchanging diffs or patches through various media - email, post to a web
service of a code review tool, etc. Your version control tool didn't speak
directly to a VCS server to initiate an <em>integration request</em>. Instead, you
would run a command which would export a text-based representation of the
change and then send it somewhere.</p>
<p>Today, we can classify <em>integration requests</em> by whether or not they speak
the version control tool's native protocol for exchanging data or whether
they exchange patches through some other mechanism. Pull requests speak the
VCS native protocol. Tools like Review Board and Phabricator exchange patches
via custom HTTP web services. Typically, tools using non-native exchange
will require additional client-side configuration, including potentially the
installation of a custom tool (e.g. <code>RBTools</code> for Review Board or <code>Arcanist</code>
for Phabricator). Although modern version control tools sometimes have
this functionality built-in. (e.g. Git and Mercurial fulfill
<a href="https://en.wikipedia.org/wiki/Jamie_Zawinski#Principles">Zawinski's law</a> and
Mercurial has a Phabricator extension in its official distribution).</p>
<p>An interesting outlier is Gerrit, which ingests its <em>integration requests</em> via
<code>git push</code>. (See
<a href="https://gerrit-review.googlesource.com/Documentation/user-upload.html">the docs</a>.)
But the way Gerrit's ingestion via <code>git push</code> works is fundamentally different
from how pull requests work! With pull requests, you are pushing your local
branch to a remote branch and a pull request is built around that remote branch.
With Gerrit, your push command is like <code>git push gerrit HEAD:refs/for/master</code>.
For the non-gurus, that <code>HEAD:refs/for/master</code> syntax means, <em>push the <code>HEAD</code>
commit (effectively the commit corresponding to the working directory) to the
<code>refs/for/master</code> ref on the <code>gerrit</code> remote</em> (the <code>SOURCE:DEST</code>
syntax specifies a mapping of local revision identifier to remote ref). The
wizard behind the curtain here is that Gerrit runs a special Git server that
implements non-standard behavior for the <code>refs/for/*</code> refs. When you push to
<code>refs/for/master</code>, Gerrit receives your Git push like a normal Git server would.
But instead of writing a ref named <code>refs/for/master</code>, it takes the incoming commits
and ingests them into a code review request! Gerrit will create Git refs for the
pushed commits. But it mainly does that for its internal tracking (Gerrit stores
all its data in Git - from Git data to review comments). And if
that functionality isn't too magical for you, you can also pass parameters to
Gerrit via the ref name! e.g. <code>git push gerrit HEAD refs/for/master%private</code>
will create a private review request that requires special permissions to see.
(It is debatable whether overloading the ref name for additional functionality
is a good user experience for average users. But you can't argue that this isn't
a cool hack!)</p>
<p>On the surface, it may seem like using the version control tool's native data
exchange is a superior workflow because it is <em>more native</em> and more modern.
(<em>Emailing patches is so old school.</em>) Gone are the days of having to configure
client-side tools to export and submit patches. Instead, you run <code>git push</code> and
your changes can be turned into an <em>integration request</em> automatically or with
a few mouse clicks. And from a technical level, this exchange methodology is
likely safer, as round-tripping a text-based representation of a change without
data loss is surprisingly finicky. (e.g. JSON's lack of lossless binary data
exchange without encoding to e.g. base64 first often means that many services
exchanging text-based patches are lossy, especially in the presence of content
which doesn't conform to UTF-8, which can be commonplace in tests. You would be
surprised how many tools experience data loss when converting version control
commits/diffs to text. But I digress). Having Git's wire protocol exchange
binary data is safer than exchanging text patches and probably easier to use
since it doesn't require any additional client-side configuration.</p>
<p>But despite being more native, modern, and arguably robust, exchange via the
version control tool may not be <em>better</em>.</p>
<p>For starters, use of the version control tool's native wire protocol inhibits
use of arbitrary version control tools on the client. When your <em>integration
request</em> requires the use of a version control tool's wire protocol, the client
likely needs to be running that version control tool. With other approaches like
exchange of text based patches, the client could be running any software it
wanted: as long as it could spit out a patch or API request in the format the
server needed, an <em>integration request</em> could be created! This meant there was
less potential for <em>lock-in</em>, as people could use their own tools on their
machines if they wanted and they (hopefully) wouldn't be inflicting their choice
on others. Case in point, a majority of Firefox developers use Mercurial - the
VCS of the canonical repository - but a large number use Git on the client. Because
Firefox is using Phabricator (Review Board and Bugzilla before that) for code
review and because Phabricator ingests text-based patches, the choice of the
VCS on the client doesn't matter that much and the choice of the server VCS
can be made without inciting a holy war among developers who would be forced
to use a tool they don't prefer. Yes, there are good reasons for using a
consistent tool (including organizational overhead) and sometimes mandates for
tool use are justified. But in many cases (such as random open source
contributions), it probably doesn't or shouldn't matter. And in cases like
Git and Mercurial, where tools like the fantastic
<a href="https://github.com/glandium/git-cinnabar">git-cinnabar</a> make it
possible to easily convert between the repositories without data loss and
acceptable overhead, adoption of the version control tool's native wire
protocol can exclude or inhibit the productivity of contributors since it can
mandate use of specific, undesired tooling.</p>
<p>Another issue with using the version control tool's wire protocol is that it
often forces or strongly encourages you to work a certain way. Take GitHub
pull requests for example. The pull request is defined around the remote Git
branch that you <code>git push</code>. If you want to update that branch, you need to know
its name. So that requires some overhead to either create and track that branch
or find its name when you want to update it. Contrast with Gerrit, where you
don't have an explicit remote branch you push to: you simply <code>git push gerrit
HEAD:refs/for/master</code> and it figures things out automatically (more on this
later). With Gerrit, I don't have to create a local Git branch to initiate an
<em>integration request</em>. With pull requests, I'm compelled to. And this can undermine
my productivity by compelling me to practice less-efficient workflows!</p>
<p>Our final point of comparison involves scalability. <strong>When you use the version
control tool wire protocol as part of <em>integration requests</em>, you have
introduced the problem of scaling your version control server.</strong> Take it from
someone who has had multiple jobs involving scaling version control servers
and who is intimately aware of the low-level details of both the
Git and Mercurial wire protocols: you don't want to be in the business of
scaling a version control server. The wire protocols for both Git and
Mercurial were designed in a now-ancient era of computing and weren't designed
by network protocol experts. They are fundamentally difficult to scale at
just the wire protocol level. I've heard stories that at one time, the
most expensive single server at Google was their Perforce or Perforce-derived
server (this was several years ago - Google has since moved on to a better
architecture).</p>
<p>The poor network protocols of version control tools have many side-effects,
including the inability or sheer difficulty of using distributed storage
on the server. So in order to scale compute horizontally, you need to invest
in expensive network storage solutions or devise a replication and
synchronization strategy. And take it from someone who worked on data
synchronization products (outside of the source control space) at three
companies: this is a problem you don't want to solve yourself. Data
synchronization is intrinsically difficult and rife with difficult trade-offs.
It's almost always a problem best avoided if you have a choice in the matter.</p>
<p>If creating Git refs is part of creating an <em>integration request</em>, you've
introduced a scaling challenge with the number of Git refs. Do these Git
refs live forever? What happens when you have thousands of developers -
possibly all working in the same repository - and the number of refs or ref
mutations grows to the hundreds of thousands or millions per year?</p>
<p>Can your version control server handle ingesting a push every second or two
with reasonable performance? Unless you are Google, Facebook, or a handful of
other companies I'm aware of, it can't. And before you cry that I'm talking
about problems that only plague the 0.01% of companies out there, I can name a
handful of companies under 10% the size of these behemoths where this is a
problem for them. And I also guarantee that many people don't have client-side
metrics for their <code>git push</code> P99 times or reliability and don't even realize
there is a problem! Scaling version control is probably not a core part of your
company's business. Unfortunately, it all too often becomes something companies
have to allocate resources for because of poorly designed or utilized tools.</p>
<p>Contrast the challenges of scaling <em>integration requests</em> with a native
version control server versus just exchanging patches. With the more
<em>primitive</em> approach, you are probably sending the patch over HTTP to a web
service. And with tools like Phabricator and Review Board, that patch gets
turned into rows in a relational database. <strong>I guarantee it will be easier
to scale an HTTP web service fronting a relational database than it will
be your version control server.</strong> If nothing else, it should be easier to manage
and debug, as there are tons more experts in these domains than in the
version control server domain!</p>
<p>Yes, it is true that many will not hit the scaling limits of the version
control server. And some nifty solutions for scaling do exist. But large
segments of this problem space - including the version control tool maintainers
having to support <em>crazy</em> scaling vectors in their tools - could be avoided
completely if <em>integration requests</em> didn't lean so heavily on the version
control tools's default mode of operation. Unfortunately, solutions like
GitHub pull requests and Gerrit's use of Git refs for storing <em>everything</em>
exert a lot of pressure on scaling the version control server and make this
a very real problem once you reach a certain scale.</p>
<p>Hopefully the above paragraphs enlightened you to some of the implications
that the choice of a data exchange mechanism has on <em>integration requests</em>!
Let's move on to another point of comparison.</p>
<h3>Commit Tracking</h3>
<p>One can classify implementations of <em>integration requests</em> by how they <em>track</em>
commits through their integration lifecycle. What I mean by this is how the
<em>integration request</em> follows the same logical change as it evolves. For
example, if you submit a commit then amend it, how does the system know that the
commit <em>evolved</em> from commit <code>X</code> to <code>X'</code>.</p>
<p>Pull requests don't track commits directly. Instead, a commit is part of a Git
branch and that branch is tracked as the entity the pull request is built
around. The review interface presents the <em>merge diff</em> front and center.
It is possible to view individual commits. But as far as I know, none of
these tools have smarts to explicitly track or map commits across new
submissions. Instead, they simply assume that the commit order will be the
same. If commits are reordered or added or removed in the middle of an
existing series, the tool can get confused quite easily. (With GitHub, it
was once possible for a review comment left on a commit to disappear entirely.
The behavior has since been corrected and if GitHub doesn't know where to
print a comment from a previous commit, it renders it as part of the pull
request's timeline view.)</p>
<p>If all you are familiar with is pull requests, you may not realize there are
alternatives to commit tracking! In fact, the most common alternative (which
isn't <em>do nothing</em>) predates pull requests entirely and is still practiced by
various tools today.</p>
<p>The way that Gerrit, Phabricator, and Review Board work is the commit message
contains a unique token identifying the <em>integration request</em> for that commit.
e.g. a commit message for a Phabricator review will contain the line
<code>Differential Revision: https://phab.mercurial-scm.org/D7543</code>. Gerrit will
have something like <code>Change-Id: Id9bfca21f7697ebf85d6a6fa7bac7de4358d7a43</code>.</p>
<p>The way this annotation appears in the commit message differs by tool.
Gerrit's web UI advertises a shell one-liner to clone repositories which
not only performs a <code>git clone</code> but also uses <code>curl</code> to download a shell
script from the Gerrit server and install it as Git's <code>commit-msg</code> hook in the
newly-cloned repositories. This Git hook will ensure that any newly-created
commit has a <code>Change-ID: XXX</code> line containing a randomly generated, hopefully
unique identifier. Phabricator and Review Board leverage client-side tooling
to rewrite commit messages after submission to their respective tool so
the commit message contains the URL of the code review. One can debate
which approach is <em>better</em> - they each have advantages and drawbacks.
Fortunately, this debate is not germane to this post, so we won't cover it here.</p>
<p>What is important is how this metadata in commit messages is used.</p>
<p>The commit message metadata comes into play when a commit is being ingested
into an <em>integration request</em>. If a commit message lacks metadata or references
an entity that doesn't exist, the receiving system assumes it is new. If the
metadata matches an entity on file, the incoming commit is often automatically
matched up to an existing commit, even if its Git SHA is different!</p>
<p>This approach of inserting a tracking identifier into commit messages works
surprisingly well for tracking the evolution of commits! Even if you amend,
reorder, insert, or remove commits, the tool can often figure out what matches
up to previous submissions and reconcile state accordingly. Although support
for this varies by tool. Mercurial's extension for submitting to Phabricator
is smart enough to take the local commit DAG into account and change dependencies
of review units in Phabricator to reflect the new DAG <em>shape</em>, for example.</p>
<p><strong>The tracking of commits is another one of those areas where the simpler and
more modern features of pull requests often don't work as well as the
solutions that came before.</strong> Yes, inserting an identifier into commit messages
feels hacky and can be brittle at times (some tools don't implement commit
rewriting very well and this can lead to a poor user experience). But you
can't argue with the results: <strong>using explicit, stable identifiers to track
commits is far more robust than the heuristics that pull requests rely on</strong>.
The false negative/positive rate is so much lower. (I know this from first hand
experience because we attempted to implement commit tracking heuristics for
a code review tool at Mozilla before Phabricator was deployed and there were
a surprising number of corner cases we couldn't handle properly. And this was
using Mercurial's <em>obsolescence markers</em>, which gave us commit evolution data
generated directly by the version control tool! If that didn't work well enough,
it's hard to imagine an heuristic that would. We eventually gave up and used
stable identifiers in commit messages, which fixed most of the annoying
corner cases.)</p>
<p>The use of explicit commit tracking identifiers may not seem like it makes a
meaningful difference. But it's impact is profound.</p>
<p>The obvious benefit of tracking identifiers is that they allow rewriting commits
without <em>confusing</em> the <em>integration request</em> tool. <strong>This means that people
can perform advanced history rewriting with near impunity as to how it would
affect the <em>integration request</em>.</strong> I am a heavy history rewriter. I like
curating a series of individually high-quality commits that can each stand
in isolation. When I submit a series like this to a GitHub pull request and
receive feedback on something I need to change, when I enact those changes I have
to think <em>will my rewriting history here make re-review harder</em>? (I try to be
empathetic with the reviewer and make their life easier whenever possible. I
ask what I would appreciate someone doing if I were reviewing their change and
tend to do that.) With GitHub pull requests, if I reorder commits or add or remove
a commit in the middle of a series, I realize that this may make review comments
left on those commits hard to find since GitHub won't be able to sort out the
history rewriting. And this may mean those review comments get <em>lost</em> and are
ultimately not acted upon, leading to bugs or otherwise deficient changes. <strong>This
is a textbook example of tooling deficiencies dictating a sub-optimal workflow
and outcome: because pull requests don't track commits explicitly, I'm
forced to adopt a non-ideal workflow or sacrifice something like commit
quality in order to minimize risks that the review tool won't get confused.</strong>
In general, tools should not externalize these kinds of costs or trade-offs onto
users: they should <em>just work</em> and optimize for generally agreed-upon ideal
outcomes.</p>
<p><strong>Another benefit to tracking identifiers is that they enable per-commit review
to be viable.</strong> Once you can track the logical evolution of a single commit,
you can start to associate things like review comments with individual commits
with a high degree of confidence. With pull requests (as they are implemented
today), you can attempt to associate comments with commits. But because you are
unable to track commits across rewrites with an acceptably high degree of
success, rewritten commits often <em>fall through the cracks</em>, orphaning data
like review comments with them. Data loss is bad, so you need a place to
collect this orphaned data. The main pull request activity timeline facilitates
this function.</p>
<p>But once you can track commits reliably (and tools like Gerrit and Phabricator
prove this is possible), you don't have this severe problem of data loss and
therefore don't need to worry about finding a place to collect orphaned data!
You are then able to create per-commit review units, each as loosely coupled
with other commits and an overall series as you want to make it!</p>
<p>It is interesting to note the different approaches in different tools here.
it is doubly interesting to note behavior that is possible with the review
tool itself and what it does by default!</p>
<p>Let's examine Phabricator. Phabricator's review unit is the
<em>Differential revision</em>. (<em>Differential</em> is the name of the code review tool
in Phabricator, which is actually a suite of functionality - like GitLab,
but not nearly as feature complete.) A <em>Differential revision</em> represents a
single diff. <em>Differential revisions</em> can have parent-child relationships
with others. Multiple revisions associated like this form a conceptual
<em>stack</em> in Phabricator's terminology. Go to
<a href="https://phab.mercurial-scm.org/D4414">https://phab.mercurial-scm.org/D4414</a>
and search for <em>stack</em> to see it in action. (<em>Stack</em> is a bit misleading name
because the parent-child relationships actually form a DAG and Phabricator is
capable of rendering things like multiple children in its graphical view.)
Phabricator's official client side tool for
submitting to Phabricator - Arcanist or <code>arc</code> - has default behavior
of collapsing all Git commits into a single <em>Differential revision</em>.</p>
<p>Phabricator can preserve metadata from the individual commits (it can render
at least the commit messages in the web UI so you can see where the <em>Differential
revision</em> came from). In other words, by default Arcanist does <em>not</em> construct
multiple <em>Differential revisions</em> for each commit and therefore does not construct
parent-child relationships for them. So there is no <em>stack</em> to render here.
To be honest, I'm not sure if modern versions of Arcanist even support doing
this. I do know both Mercurial and Mozilla authored custom client side
tools for submitting to Phabricator to work around deficiencies like this in
Arcanist. Mozilla's may or may not be generally suitable for users outside
of Mozilla - I'm not sure.</p>
<p>Another interesting aspect of Phabricator is that there is no concept of an
over-arching series. Instead, each <em>Differential revision</em> stands in isolation.
They can form parent-child relationships and constitute a <em>stack</em>. But there
is no primary UI or APIs for <em>stacks</em> (the last I looked anyway). This may seem
radical. You may be asking questions like <em>how do I track the overall state
of a series</em> or <em>how do I convey information pertinent to the series as a whole</em>.
These are good questions. But without diving into them, the answer is that
as radical as it sounds to not have an overall tracking entity for a series of
<em>Differential revisions</em>, it does work. And having used this workflow with the
Mercurial Project for a few years, I can say I'm not missing the functionality
that much.</p>
<p>Gerrit is also worth examining. Like Phabricator, Gerrit uses an identifier
in commit messages to track the commit. But whereas Phabricator rewrites
commit messages at initially submission time to contain the URL that was
created as part of that submission, Gerrit peppers the commit message with
a unique identifier at commit creation time. The server then maintains a
mapping of commit identifier to review unit. Implementation details aside,
the end result is similar: individual commits can be tracked more easily.</p>
<p>What distinguishes Gerrit from Phabricator is that Gerrit does have a stronger
grouping around multiple commits. Gerrit will track when commits are submitted
together and will render both a <em>relation chain</em> and <em>submitted together</em> list
automatically. While it lacks the visual beauty of Phabricator's implementation,
it is effective and is shown in the UI by default, unlike Phabricator.</p>
<p>Another difference from Phabricator is that Gerrit uses per-commit review
by default. Whereas you need a non-official client for Phabricator to submit
a series of commits to constitute a linked chain, Gerrit does this by default.
And as far as I can tell, there's no way to tell Gerrit to squash your local
commits down to a single diff for review: if you want a single review to appear,
you must first squash commits locally then push the squashed commit. (More
on this topic later in the post.) </p>
<p><strong>A secondary benefit of per-commit review is that this model enables incremental
integration workflows, where some commits in a series or set can integrate before
others, without having to wait for the entire batch.</strong> Incremental integration
of commits can drastically speed up certain workflows, as commits can integrate
as soon as they are <em>ready</em> and not any longer. The benefits of this model can
be incredible. But actually deploying this workflow can be tricky. One problem
is that your version control tool may get confused when you rebase or merge
partially landed state. Another problem is it can increase the overall change
rate of the repository, which may strain systems from version control to CI
to deployment mechanisms. Another potential problem involves communicating
review sign-off from integration sign-off. Many tools/workflows conflate <em>I
sign off on this change</em> and <em>I sign off on landing this change</em>. While they
are effectively identical in many cases, there are some valid cases where you
want to track these distinctly. And adopting a workflow where commits can
integrate incrementally will expose these corner cases. So before you go down
this path, you want to be thinking about who integrates commits and when
they are integrated. (You should probably be thinking about this anyway because
it is important.)</p>
<h2>Designing a Better Integration Request</h2>
<p>Having described some problems with pull requests and alternate ways of going
about solving the general problem of <em>integration requests</em>, it is time to answer
the million dollar problem: designing a better <em>integration request</em>. (When you
factor in the time people spend in pull requests and the cost of bugs / low
quality changes that slip through due to design of existing tooling, improving
integration requests industry wide would be a <strong>lot</strong> more valuable than $1M.)</p>
<p>As a reminder, the pull request is fundamentally a nice UI and set of features
built around the common Git feature branch workflow. This property is preserved
from the earliest days of pull requests in 2007-2008 and has been copied by
vendors like Bitbucket and GitLab in the years since. In my mind, pull requests
should be ripe for overhaul.</p>
<h3>Replace Forks</h3>
<p><strong>The first change I would make to pull requests is to move away from <em>forks</em>
being a required part of the workflow.</strong> This may seem radical. But it isn't!</p>
<p>A <em>fork</em> on services like GitHub is a fully fledged project - just like the
canonical project it was forked from. It has its own issues, wiki, releases,
pull requests, etc. Now show of hands: how often do you use these features
on a fork? Me neither. <strong>In the overwhelming majority of cases, a <em>fork</em>
exists solely as a vehicle to initiate a pull request against the repository
it was forked from.</strong> It serves little to no additional meaningful
functionality. Now, I'm not saying <em>forks</em> don't serve a purpose - they
certainly do! <strong>But in the case of someone wanting to propose a change to
a repository, a <em>fork</em> is not strictly required and its existence is imposed
on us by the current implementation of pull requests.</strong></p>
<p>I said <em>impose</em> in the previous sentence because <em>forks</em> introduce overhead
and confusion. The existence of a <em>fork</em> may confuse someone as to where a
canonical project lives. <em>Forks</em> also add overhead in the version control
tool. Their existence forces the user to manage an additional Git remote
and branches. It forces people to remember to keep their branches in sync on
their fork. As if remembering to keep your local repository in sync wasn't
hard enough! And if pushing to a <em>fork</em>, you need to re-push data that was
already pushed to the canonical repository, even though that data already
exists on the server (just in a different view of the Git repository). (I
believe Git is working on wire protocol improvements to mitigate this.)</p>
<p><strong>When merely used as a vehicle to initiate <em>integration requests</em>, I do not
believe <em>forks</em> offer enough value to justify their existence.</strong> Should forks
exist: yes. Should people be forced to use them in order to contribute
changes, no. (Valid use cases for a <em>fork</em> would be to perform a community
splinter of a project and to create an independent entity for reasons such as
better guarantees of data availability and integrity.)</p>
<p><em>Forks</em> are essentially a veneer on top of a server-side <code>git clone</code>. And the
reason why a separate Git repository is used at all is probably because the
earliest versions of GitHub were just a pile of abstractions over <code>git</code>
commands. The service took off in popularity, people copied its features
almost verbatim, and nobody ever looked back and thought <em>why are we doing
things like this in the first place.</em></p>
<p>To answer what we would replace <em>forks</em> with, we have to go back to first
principles and ask <em>what are we trying to do.</em> And that is <em>propose a unit
a change against an existing project</em>. And for version control tools, all
you need to propose a change is a patch/commit. So to replace <em>forks</em>, we
<em>just</em> need an alternate mechanism to submit patches/commits to an existing
project.</p>
<p><strong>My preferred alternative to forks is to use <code>git push</code> directly to the
canonical repository.</strong> This could be implemented like Gerrit where you push
to a special ref. e.g. <code>git push origin HEAD:refs/for/master</code>. Or - and this is
my preferred solution - version control servers could grow more smarts about
how <em>pushes</em> work - possibly even changing what commands like <code>git push</code> do if
the server is operating in special modes.</p>
<p>One idea would be for the Git server to expose different refs <em>namespaces</em>
depending on the authenticated user. For example, I'm <code>indygreg</code> on GitHub.
If I wanted to propose a change to a project - let's say <code>python/cpython</code> -
I would <code>git clone git@github.com:python/cpython</code>. I would create a branch -
say <code>indygreg/proposed-change</code>. I would then
<code>git push origin indygreg/proposed-change</code> and because the branch prefix matches
my authenticated username, the server lets it through. I can then open a
pull request without a fork! (Using branch prefixes is less than ideal, but
it should be relatively easy to implement on the server. A better approach
would rely on remapping Git ref names. But this may require a bit more
configuration with current versions of Git than users are willing to stomach.
An even better solution would be for Git to grow some functionality to make
this easier. e.g. <code>git push --workspace origin proposed-change</code> would push
<code>proposed-change</code> to a <em>workspace</em> on the <code>origin</code> remote, which Git would
know how to translate to a proper remote ref update.)</p>
<p>Another idea would be for the version control server to invent a new concept
for exchanging commits - one based on <em>sets of commits</em> instead of DAG
synchronization. Essentially, instead of doing a complicated discovery
dance to synchronize commits with the underlying Git repository, the server
would ingest and expose representations of <em>sets of commits</em> stored next
to - but not within - the repository itself. This way you are not scaling the
repository DAG to infinite heads - which is a hard problem! A concrete
implementation of this might have the client run a <code>git push --workspace
origin proposed-change</code> to tell the remote server to store your
<code>proposed-change</code> branch in your personal <em>workspace</em> (sorry for reusing the term
from the previous paragraph). The Git server would receive your commits,
generate a standalone blob to hold them, save that blob to a key-value
store like S3, then update a mapping of which commits/branches are in
which blobs in a data store such as a relational database somewhere. This
would effectively segment the core project data from the more transient
branch data, keeping the core repository clean and pure. It allows the server
to lean on easier-to-scale data stores such as key-value blob stores and
relational databases instead of the version control tool. I know this idea
is feasible because Facebook implemented it for Mercurial. The <code>infinitepush</code>
extension essentially siphons Mercurial <em>bundles</em> (standalone files holding
commit data) off to a blob store when pushes come in over the wire. At
<code>hg pull</code> time, if a requested revision is not present in the repository, the
server asks the database-backed blob index if the revision exists anywhere.
If it does, the blob/bundle is fetched, dynamically overlayed onto the
repository in memory, and served to the client. While the <code>infinitepush</code>
extension in the official Mercurial project is somewhat lacking (through no
fault of Facebook's), the core idea is solid and I wish someone would spend
the time to flush out the design a bit more because it really could lead
to logically scaling repositories to <em>infinite</em> DAG heads without the
complexities of actually scaling scaling DAG algorithms, repository storage,
and version control tool algorithms to <em>infinite</em> heads. Getting back to the
subject of <em>integration requests</em>, one could imagine having a <em>target</em> for
<em>workspace pushes</em>. For example, <code>git push --workspace=review origin</code> would
push to the <code>review</code> workspace, which would automatically initiate a code
review.</p>
<p>Astute readers of this blog may find these ideas familiar. I proposed
<em>user namespaces</em> in my
<a href="High-level problems with Git and how to fix them">/blog/2017/12/11/high-level-problems-with-git-and-how-to-fix-them/</a>
post a few years ago. So read there for more on implications of doing
away with <em>forks</em>.</p>
<p>Could <em>forks</em> be done away with as a requirement to submit pull requests?
Yes! Gerrit's <code>git push origin HEAD:refs/for/master</code> mechanism proves it.
Is Gerrit's approach too much magic or confusing for normal users? I'm not
sure. Could Git grow features to make the user experience much better so
users don't need to be burdened with complexity or magic and could
simply run commands like <code>git submit --for review</code>? Definitely!</p>
<h3>Shift Focus From Branches to Individual Commits</h3>
<p><strong>My ideal <em>integration request</em> revolves around individual commits, not
branches.</strong> While the client may submit a branch to initiate or update
an <em>integration request</em>, the <em>integration request</em> is composed of a set
of loosely coupled commits, where parent-child relationships can exist to
express a dependency between commits. Each commit is evaluated
individually. Although someone may need to inspect multiple commits to
gain a full understanding of the proposed change. And some UI enabling
operations against a group of related commits (such as mass deleting
abandoned commits) may be warranted.</p>
<p>In this world, the branch would not matter. Instead, commits are king.
Because we would be abandoning the branch name as a tracker for the
<em>integration request</em>, we would need something to replace it, otherwise we
have no way of knowing how to update an existing <em>integration request</em>!
We should do what tools like Phabricator, Gerrit, and Review Board do and
add a persistent identifier to commits which survive history rewriting.
(Branch-based pull requests should do this anyway so history rewrites don't
confuse the review tool and e.g. cause comments to get orphaned - see
above.)</p>
<p><strong>It's worth noting that a commit-centric <em>integration request</em> model does
not imply that everyone is writing or reviewing series of smaller commits!</strong>
While titans of industry and I strongly encourage the authorship of smaller
commits, commit-centric <em>integration requests</em> don't intrinsically force you
to do so. This is because commit-centric <em>integration requests</em> aren't forcing
you to change your local workflow! If you are the type of person who doesn't
want to curate a ton of small, good-in-isolation commits (it does take a bit
more work after all), nobody would be forcing you to do so. Instead, if this
is your commit authorship pattern, the submission of the proposed change
could <em>squash</em> these commits together as part of the submission, <em>optionally</em>
rewriting your local history in the process. If you want to keep dozens of
<em>fixup commits</em> around in your local history, that's fine: just have the
tooling collapse them all together on submission. While I don't think those
<em>fixup commits</em> are that valuable and shouldn't be seen by reviewers, if
we wanted, we could have tools continue to submit them and make them visible
(like they are in e.g. GitHub pull requests today). But they wouldn't be the
focus of review (again like GitHub pull requests today). <strong>Making <em>integration
requests</em> commit-centric doesn't force people to adopt a different commit
authorship workflow. But it does enable projects that wish to adopt more
<em>mature</em> commit hygiene to do so.</strong> That being said, hows tools are
implemented can impose restrictions. But that's nothing about commit-centric
review that fundamentally prohibits the use of <em>fixup commits</em> in local
workflows.</p>
<p>While I should create a dedicated post espousing the virtues of commit-centric
workflows, I'll state my case through proxy by noting that some projects aren't
using modern pull requests precisely because commit-centric workflows are not
viable. When I was at Mozilla, one of the blockers to <em>moving to GitHub</em> was
the pull request review tooling wasn't compatible with our world view that
review units should be small. (This view is generally shared by Google, Facebook,
and some prominent open source projects, among others.) And for reasons
outlined earlier in this post, I think that as long as pull requests revolve
around branches / <em>merge diffs</em> and aren't robust in the face of history rewriting
(due to the lack of robust commit tracking), projects that insist on more
<em>refined</em> practices will continue to eschew pull requests. Again, a link between
review size and quality has been established. And better quality - along
with its long-term effect of lowering development costs due to fewer bugs -
can tip the scales in its favor, even against all the benefits you receive
when using a product like GitHub, GitLab, or Bitbucket.</p>
<h2>The Best of What's Around</h2>
<p>Aspects of a better <em>integration request</em> exist in tools today. Unfortunately,
many of these features are not present on pull requests as implemented by
GitHub, GitLab, Bitbucket, etc. So to improve the pull request, these products
will need to borrow ideas from other tools.</p>
<p><em>Integration requests</em> not built around Git branches (Gerrit, Phabricattor,
Review Board, etc) use identifiers in commit messages to track commits.
This helps tracking commits across changes. There are compelling advantages
to this model. Robust commit tracking is a requirement for commit-centric
workflows. And it would even improve the functionality of branch-based pull
requests. A well-designed <em>integration request</em> would have a robust commit
tracking mechanism.</p>
<p>Gerrit has the best-in-class experience for commit-centric workflows. It is
the only popular implementation of <em>integration requests</em> I'm aware of that
supports and caters to this workflow by default. In fact, I don't think you
can change this! (This behavior is user hostile in some cases since it forces
users to know how to rewrite commits, which is often perilous in Git land. It
would be nice if you could have Gerrit squash commits into the same review unit
automatically on the server. But I understand the unwillingness to implement
this feature because this has its own set of challenges around commit tracking,
which I won't bore you with.) Gerrit also shows groups of related commits
front and center when viewing a proposed change.</p>
<p>Phabricator is the only other tool I know of where one can achieve a reasonable
commit-centric workflow without the pitfalls of orphaned comments, context
overload, etc mentioned earlier in this post. But this requires non-standard
submission tooling and commit series aren't featured prominently in the web UI.
So Phabricator's implementation is not as solid as Gerrit's.</p>
<p>Another Gerrit feature worth lauding is the submission mechanism. You simply
<code>git push</code> to a special ref. That's it. There's no fork to create. No need to
create a Git branch. No need to create a separate pull request after the push.
Gerrit just takes the commits you pushed and turns them into a request for
review. And it doesn't require any additional client-side tooling!</p>
<p>Using a single common <code>git</code> command to submit and update an <em>integration
request</em> is simpler and arguably more intuitive than other tools. Is Gerrit's
submission perfect? No. The <code>git push origin HEAD:refs/for/master</code> syntax is
not intuitive. And overloading submission options by effectively encoding URL
parameters on the ref name is a gross - albeit effective - hack. But users will
likely quickly learn the one-liner's or create more intuitive aliases.</p>
<p>The elegance of using just a <code>git push</code> to initiate an <em>integration request</em>
puts Gerrit in a league of its own. I would be ecstatic if the GitHubs of the
world reduced the complexity of submitting pull requests to simply <em>clone the
canonical repository, create some commits, and run a <code>git</code> command. The future
of submitting </em>integration requests* hopefully looks more like Gerrit than
other alternatives.</p>
<h2>What Needs Built</h2>
<p>Some aspects of the better <em>integration request</em> don't yet exist or need
considerable work before I consider them viable.</p>
<p>For tools which leverage the native version control tool for submission
(e.g. via <code>git push</code>), there needs to be some work to support submission
via a more generic, HTTP endpoint. I'm fine with leveraging <code>git push</code> as a
submission mechanism because it makes the end-user experience so
turnkey. But making it the only submission mechanism is a bit unfortunate.
There is some support for this: I believe you can cobble together a pull
request from scratch via GitHub's APIs, for example. But it isn't as simple
as <em>submit a patch to an endpoint</em>, which it arguably should be. Even
Gerrit's
<a href="https://gerrit-review.googlesource.com/Documentation/rest-api.html">robust HTTP API</a>,
does not seem to allow creating new commits/diffs via that API. Anyway, this
limitation not only excludes non-Git tools from using these tools, but also
limits other tooling from submitting without using Git. For example, you may
want to write a bot that proposes automated changes and it is much easier
to produce a diff than to use <code>git</code> since the former does not require a
filesystem (this matters in <em>serverless</em> environments for example).</p>
<p>A larger issue with many implementations is the over-reliance on Git for server
storage. This is most pronounced in Gerrit, where not only are your <code>git push</code>es
stored in a Git repository on the Gerrit server, but every code review comment
and reply is stored in Git as well! Git <em>is</em> a generic key-value store and you
can store any data you want in it if you shoehorn it properly. And it is cool
that all your Gerrit data can be replicated via <code>git clone</code> - this pretty much
eliminates the <em>we took a decentralized tool and centralized it via GitHub</em>
series of arguments. But if you apply this <em>store everything in Git</em> approach
at scale, it means you will be running a Git server at scale. And not just any
Git server - a write load heavy Git server! And if you have thousands of
developers possibly all working out of the same repository, then you are looking
at potentially millions of new Git refs per year. While the Git, Gerrit, and
JGit people have done some fantastic work making these tools scale, I'd feel
much better if we eschewed the <em>make Git scale to infinite pushes and refs</em>
problem and used a more scalable approach, like an HTTP ingestion endpoint
which writes data to key-value stores or relational databases. In order words,
use of a version control tool for servicing <em>integration requests</em> at scale
is a self-imposed footgun and could be avoided.</p>
<h2>Conclusion</h2>
<p>Congratulations on making it through my brain dump! As massive as the wall
of text is, there are still plenty of topics I could have covered but didn't.
This includes the more specific topic of code review and the various features
that entails. I also largely ignored some general topics like the value that
an <em>integration request</em> can serve on the overall development lifecycle:
<em>integration requests</em> are more than just code review - they serve as a nexus
to track the evolution of a change throughout time.</p>
<p>Hopefully this post gave you some idea at some of the structural issues at
play with the integration of pull requests and <em>integration requests</em>. And
if you are someone in a position to design or implement a better
<em>integration request</em> or tooling around them (including in version control
tools themselves), hopefully it gave you some good ideas or where to go next.</p>]]></content:encoded>
    </item>
    <item>
      <title>Absorbing Commit Changes in Mercurial 4.8</title>
      <link>http://gregoryszorc.com/blog/2018/11/05/absorbing-commit-changes-in-mercurial-4.8</link>
      <pubDate>Mon, 05 Nov 2018 09:25:00 PST</pubDate>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2018/11/05/absorbing-commit-changes-in-mercurial-4.8</guid>
      <description>Absorbing Commit Changes in Mercurial 4.8</description>
      <content:encoded><![CDATA[<p>Every so often a tool you use introduces a feature that is so useful
that you can't imagine how things were before that feature existed.
The recent 4.8 release of the
<a href="https://www.mercurial-scm.org/">Mercurial version control tool</a> introduces
such a feature: the <code>hg absorb</code> command.</p>
<p><code>hg absorb</code> is a mechanism to automatically and intelligently incorporate
uncommitted changes into prior commits. Think of it as <em><code>hg histedit</code> or
<code>git rebase -i</code> with auto squashing</em>.</p>
<p>Imagine you have a set of changes to prior commits in your working
directory. <code>hg absorb</code> figures out which changes map to which commits
and <em>absorbs</em> each of those changes into the appropriate commit. Using
<code>hg absorb</code>, you can replace cumbersome and often merge conflict ridden
history editing workflows with a single command that often <em>just works</em>.
Read on for more details and examples.</p>
<p>Modern version control workflows often entail having multiple <em>unlanded</em>
commits in flight. What this looks like varies heavily by the version
control tool, standards and review workflows employed by the specific
project/repository, and personal preferences.</p>
<p>A workflow practiced by a lot of projects is to author your commits
into a sequence of standalone commits, with each commit representing
a discrete, logical unit of work. Each commit is then
reviewed/evaluated/tested on its own as part of a larger series.
(This workflow is practiced by Firefox, the Git and Mercurial projects,
and the Linux Kernel to name a few.)</p>
<p>A common task that arises when working with such a workflow is the need
to incorporate changes into an old commit. For example, let's say we have
a stack of the following commits:</p>
<pre><code>$ hg show stack
  @  1c114a ansible/hg-web: serve static files as immutable content
  o  d2cf48 ansible/hg-web: synchronize templates earlier
  o  c29f28 ansible/hg-web: convert hgrc to a template
  o  166549 ansible/hg-web: tell hgweb that static files are in /static/
  o  d46d6a ansible/hg-web: serve static template files from httpd
  o  37fdad testing: only print when in verbose mode
 /   (stack base)
o  e44c2e (@) testing: install Mercurial 4.8 final
</code></pre>
<p>Contained within this stack are 5 commits changing the way that static
files are served by hg.mozilla.org (but that's not important).</p>
<p>Let's say I submit this stack of commits for review. The reviewer spots
a problem with the second commit (<em>serve static template files from httpd</em>)
and wants me to make a change.</p>
<p>How do you go about making that change?</p>
<p>Again, this depends on the exact tool and workflow you are using.</p>
<p>A common workflow is to not rewrite the existing commits at all: you simply
create a new <em>fixup</em> commit on top of the stack, leaving the existing commits
as-is. e.g.:</p>
<pre><code>$ hg show stack
  o  deadad fix typo in httpd config
  o  1c114a ansible/hg-web: serve static files as immutable content
  o  d2cf48 ansible/hg-web: synchronize templates earlier
  o  c29f28 ansible/hg-web: convert hgrc to a template
  o  166549 ansible/hg-web: tell hgweb that static files are in /static/
  o  d46d6a ansible/hg-web: serve static template files from httpd
  o  37fdad testing: only print when in verbose mode
 /   (stack base)
o  e44c2e (@) testing: install Mercurial 4.8 final
</code></pre>
<p>When the entire series of commits is incorporated into the repository,
the end state of the files is the same, so all is well. But this strategy
of using <em>fixup commits</em> (while popular - especially with Git-based tooling
like GitHub that puts a larger emphasis on the end state of changes rather
than the individual commits) isn't practiced by all projects.
<strong><code>hg absorb</code> will not help you if this is your workflow.</strong></p>
<p>A popular variation of this <em>fixup commit</em> workflow is to author a new commit
then <em>incorporate</em> this commit into a prior commit. This typically involves
the following actions:</p>
<pre><code>&lt;save changes to a file&gt;

$ hg commit
&lt;type commit message&gt;

$ hg histedit
&lt;manually choose what actions to perform to what commits&gt;

OR

&lt;save changes to a file&gt;

$ git add &lt;file&gt;
$ git commit
&lt;type commit message&gt;

$ git rebase --interactive
&lt;manually choose what actions to perform to what commits&gt;
</code></pre>
<p>Essentially, you produce a new commit. Then you run a history editing command.
You then tell that history editing command what to do (e.g. to <em>squash</em> or
<em>fold</em> one commit into another), that command performs work and produces a set
of rewritten commits.</p>
<p>In simple cases, you may make a simple change to a single file. Things are
pretty straightforward. You need to know which two commits to <em>squash</em> together.
This is often trivial. Although it can be cumbersome if there are several
commits and it isn't clear which one should be receiving the new changes.</p>
<p>In more complex cases, you may make multiple modifications to multiple files.
You may even want to <em>squash</em> your <em>fixups</em> into separate commits. And for some
code reviews, this <em>complex</em> case can be quite common. It isn't uncommon for me
to be incorporating dozens of reviewer-suggested changes across several commits!</p>
<p>These complex use cases are where things can get really complicated for version
control tool interactions. Let's say we want to make multiple changes to a file
and then incorporate those changes into multiple commits. To keep it simple,
let's assume 2 modifications in a single file <em>squashing</em> into 2 commits:</p>
<pre><code>&lt;save changes to file&gt;

$ hg commit --interactive
&lt;select changes to commit&gt;
&lt;type commit message&gt;

$ hg commit
&lt;type commit message&gt;

$ hg histedit
&lt;manually choose what actions to perform to what commits&gt;

OR

&lt;save changes to file&gt;

$ git add &lt;file&gt;
$ git add --interactive
&lt;select changes to stage&gt;

$ git commit
&lt;type commit message&gt;

$ git add &lt;file&gt;
$ git commit
&lt;type commit message&gt;

$ git rebase --interactive
&lt;manually choose which actions to perform to what commits&gt;
</code></pre>
<p>We can see that the number of actions required by users has already increased
substantially. Not captured by the number of lines is the effort that must go
into the interactive commands like <code>hg commit --interactive</code>,
<code>git add --interactive</code>, <code>hg histedit</code>, and <code>git rebase --interactive</code>. For
these commands, users must tell the VCS tool exactly what actions to take.
This takes time and requires some cognitive load. This ultimately distracts
the user from the task at hand, which is bad for concentration and productivity.
The user just wants to <em>amend</em> old commits: telling the VCS tool what actions
to take is an obstacle in their way. (A compelling argument can be made that
the work required with these workflows to produce a <em>clean</em> history is too much
effort and it is easier to make the trade-off favoring simpler workflows
versus cleaner history.)</p>
<p><strong>These kinds of <em>squash fixup</em> workflows are what <code>hg absorb</code> is designed to
make easier.</strong> When using <code>hg absorb</code>, the above workflow can be reduced to:</p>
<pre><code>&lt;save changes to file&gt;

$ hg absorb
&lt;hit y to accept changes&gt;

OR

&lt;save changes to file&gt;

$ hg absorb --apply-changes
</code></pre>
<p>Let's assume the following changes are made in the working directory:</p>
<pre><code>$ hg diff
diff --git a/ansible/roles/hg-web/templates/vhost.conf.j2 b/ansible/roles/hg-web/templates/vhost.conf.j2
--- a/ansible/roles/hg-web/templates/vhost.conf.j2
+++ b/ansible/roles/hg-web/templates/vhost.conf.j2
@@ -76,7 +76,7 @@ LimitRequestFields 1000
      # Serve static files straight from disk.
      &lt;Directory /repo/hg/htdocs/static/&gt;
          Options FollowSymLinks
 -        AllowOverride NoneTypo
 +        AllowOverride None
          Require all granted
      &lt;/Directory&gt;

@@ -86,7 +86,7 @@ LimitRequestFields 1000
      # and URLs are versioned by the v-c-t revision, they are immutable
      # and can be served with aggressive caching settings.
      &lt;Location /static/&gt;
 -        Header set Cache-Control "max-age=31536000, immutable, bad"
 +        Header set Cache-Control "max-age=31536000, immutable"
      &lt;/Location&gt;

      #LogLevel debug
</code></pre>
<p>That is, we have 2 separate uncommitted changes to
<code>ansible/roles/hg-web/templates/vhost.conf.j2</code>.</p>
<p>Here is what happens when we run <code>hg absorb</code>:</p>
<pre><code>$ hg absorb
showing changes for ansible/roles/hg-web/templates/vhost.conf.j2
        @@ -78,1 +78,1 @@
d46d6a7 -        AllowOverride NoneTypo
d46d6a7 +        AllowOverride None
        @@ -88,1 +88,1 @@
1c114a3 -        Header set Cache-Control "max-age=31536000, immutable, bad"
1c114a3 +        Header set Cache-Control "max-age=31536000, immutable"

2 changesets affected
1c114a3 ansible/hg-web: serve static files as immutable content
d46d6a7 ansible/hg-web: serve static template files from httpd
apply changes (yn)?
&lt;press "y"&gt;
2 of 2 chunk(s) applied
</code></pre>
<p><code>hg absorb</code> automatically figured out that the 2 separate uncommitted changes
<em>mapped</em> to 2 different changesets (Mercurial's term for <em>commit</em>). It
print a summary of what lines would be changed in what changesets and
prompted me to accept its <em>plan</em> for how to proceed. The human effort involved
is a quick review of the proposed changes and answering a prompt.</p>
<p>At a technical level, <code>hg absorb</code> finds all uncommitted changes and
attempts to map each changed line to an unambiguous prior commit. For
every change that can be mapped cleanly, the uncommitted changes are
<em>absorbed</em> into the appropriate prior commit. Commits impacted by the
operation are rebased automatically. If a change cannot be mapped to an
unambiguous prior commit, it is left uncommitted and users can fall back
to an existing workflow (e.g. using <code>hg histedit</code>).</p>
<p>But wait - there's more!</p>
<p>The automatic rewriting logic of <code>hg absorb</code> is implemented by following
the history of lines. This is fundamentally different from the approach
taken by <code>hg histedit</code> or <code>git rebase</code>, which tend to rely on <em>merge
strategies</em> based on the
<a href="https://stackoverflow.com/questions/4129049/why-is-a-3-way-merge-advantageous-over-a-2-way-merge">3-way merge</a>
to derive a new version of a file given multiple input versions. This
approach combined with the fact that <code>hg absorb</code> skips over changes with
an ambiguous application commit means that <strong><code>hg absorb</code> will never
encounter merge conflicts</strong>! Now, you may be thinking <em>if you ignore
lines with ambiguous application targets, the patch would always apply
cleanly using a classical 3-way merge</em>. This statement logically sounds
correct. But it isn't: <code>hg absorb</code> can avoid merge conflicts when the
merging performed by <code>hg histedit</code> or <code>git rebase -i</code> would fail.</p>
<p>The above example attempts to exercise such a use case. Focusing on the
initial change:</p>
<pre><code>diff --git a/ansible/roles/hg-web/templates/vhost.conf.j2 b/ansible/roles/hg-web/templates/vhost.conf.j2
--- a/ansible/roles/hg-web/templates/vhost.conf.j2
+++ b/ansible/roles/hg-web/templates/vhost.conf.j2
@@ -76,7 +76,7 @@ LimitRequestFields 1000
     # Serve static files straight from disk.
     &lt;Directory /repo/hg/htdocs/static/&gt;
         Options FollowSymLinks
-        AllowOverride NoneTypo
+        AllowOverride None
         Require all granted
     &lt;/Directory&gt;
</code></pre>
<p>This patch needs to be applied against the commit which introduced it. That
commit had the following diff:</p>
<pre><code>diff --git a/ansible/roles/hg-web/templates/vhost.conf.j2 b/ansible/roles/hg-web/templates/vhost.conf.j2
--- a/ansible/roles/hg-web/templates/vhost.conf.j2
+++ b/ansible/roles/hg-web/templates/vhost.conf.j2
@@ -73,6 +73,15 @@ LimitRequestFields 1000
         {% endfor %}
     &lt;/Location&gt;

+    # Serve static files from templates directory straight from disk.
+    &lt;Directory /repo/hg/hg_templates/static/&gt;
+        Options None
+        AllowOverride NoneTypo
+        Require all granted
+    &lt;/Directory&gt;
+
+    Alias /static/ /repo/hg/hg_templates/static/
+
     #LogLevel debug
     LogFormat "%h %v %u %t \"%r\" %&gt;s %b %D \"%{Referer}i\" \"%{User-Agent}i\" \"%{Cookie}i\""
     ErrorLog "/var/log/httpd/hg.mozilla.org/error_log"
</code></pre>
<p>But after that commit was another commit with the following change:</p>
<pre><code>diff --git a/ansible/roles/hg-web/templates/vhost.conf.j2 b/ansible/roles/hg-web/templates/vhost.conf.j2
--- a/ansible/roles/hg-web/templates/vhost.conf.j2
+++ b/ansible/roles/hg-web/templates/vhost.conf.j2
@@ -73,14 +73,21 @@ LimitRequestFields 1000
         {% endfor %}
     &lt;/Location&gt;

-    # Serve static files from templates directory straight from disk.
-    &lt;Directory /repo/hg/hg_templates/static/&gt;
-        Options None
+    # Serve static files straight from disk.
+    &lt;Directory /repo/hg/htdocs/static/&gt;
+        Options FollowSymLinks
         AllowOverride NoneTypo
         Require all granted
     &lt;/Directory&gt;

...
</code></pre>
<p>When we use <code>hg histedit</code> or <code>git rebase -i</code> to rewrite this history, the VCS
would first attempt to re-order commits before squashing 2 commits together.
When we attempt to reorder the <em>fixup</em> diff immediately after the commit that
introduces it, there is a good chance your VCS tool would encounter a merge
conflict. Essentially your VCS is thinking <em>you changed this line but the
lines around the change in the final version are different from the lines
in the initial version: I don't know if those other lines matter and therefore
I don't know what the end state should be, so I'm giving up and letting the
user choose for me</em>.</p>
<p>But since <code>hg absorb</code> operates at the line history level, it knows that this
individual line wasn't actually changed (even though the lines around it did),
assumes there is no conflict, and offers to <em>absorb</em> the change. So not only
is <code>hg absorb</code> significantly simpler than today's <code>hg histedit</code> or
<code>git rebase -i</code> workflows in terms of VCS command interactions, but it can
also avoid time-consuming merge conflict resolution as well!</p>
<p>Another feature of <code>hg absorb</code> is that all the rewriting occurs in memory
and the working directory is not touched when running the command. This means
that the operation is fast (working directory updates often account for a lot
of the execution time of <code>hg histedit</code> or <code>git rebase</code> commands). It also means
that tools looking at the last modified time of files (e.g. build systems
like GNU Make) won't rebuild extra (unrelated) files that were touched
as part of updating the working directory to an old commit in order to apply
changes. This makes <code>hg absorb</code> more friendly to edit-compile-test-commit
loops and allows developers to be more productive.</p>
<p>And that's <code>hg absorb</code> in a nutshell.</p>
<p>When I first saw a demo of <code>hg absorb</code> at a Mercurial developer meetup, my
jaw - along with those all over the room - hit the figurative floor. I thought
it was magical and too good to be true. I thought Facebook (the original authors
of the feature) were trolling us with an impossible demo. But it was all real.
And now <code>hg absorb</code> is available in the core Mercurial distribution for anyone
to use.  </p>
<p>From my experience, <code>hg absorb</code> <em>just works</em> almost all of the time: I run
the command and it maps all of my uncommitted changes to the appropriate
commit and there's nothing more for me to do! In a word, it is magical.</p>
<p>To use <code>hg absorb</code>, you'll need to activate the <code>absorb</code> extension. Simply
put the following in your <code>hgrc</code> config file:</p>
<pre><code>[extensions]
absorb =
</code></pre>
<p><code>hg absorb</code> is currently an experimental feature. That means there is
no commitment to backwards compatibility and some rough edges are
expected. I also anticipate new features (such as <code>hg absorb --interactive</code>)
will be added before the experimental label is removed. If you encounter
problems or want to leave comments, <a href="https://bz.mercurial-scm.org/enter_bug.cgi?product=Mercurial">file a bug</a>,
make noise in <code>#mercurial</code> on Freenode, or
<a href="https://www.mercurial-scm.org/wiki/ContributingChanges">submit a patch</a>.
But don't let the <em>experimental</em> label scare you away from using it:
<code>hg absorb</code> is being used by some large install bases and also by many
of the Mercurial core developers. The <em>experimental</em> label is mainly there
because it is a brand new feature in core Mercurial and the <em>experimental</em>
label is usually affixed to new features.</p>
<p>If you practice workflows that frequently require amending old commits, I
think you'll be shocked at how much easier <code>hg absorb</code> makes these workflows.
I think you'll find it to be a game changer: once you use <code>hg abosrb</code>, you'll
soon wonder how you managed to get work done without it.</p>]]></content:encoded>
    </item>
    <item>
      <title>Global Kernel Locks in APFS</title>
      <link>http://gregoryszorc.com/blog/2018/10/29/global-kernel-locks-in-apfs</link>
      <pubDate>Mon, 29 Oct 2018 14:20:00 PDT</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Apple]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2018/10/29/global-kernel-locks-in-apfs</guid>
      <description>Global Kernel Locks in APFS</description>
      <content:encoded><![CDATA[<p>Over the past several months, a handful of people had been complaining
that Mercurial's test harness was executing much slower on Macs. But
this slowdown seemingly wasn't occurring on Linux or Windows. And not
every Mac user experienced the slowness!</p>
<p>Before jetting off to the Mercurial 4.8 developer meetup in Stockholm
a few weeks ago, I sat down with a relatively fresh 6+6 core MacBook Pro
and experienced the problem firsthand: on my 4+4 core i7-6700K running
Linux, the Mercurial test harness completes in ~12 minutes, but on this
MacBook Pro, it was executing in ~38 minutes! On paper, this result
doesn't make any sense because there's no way that the MacBook Pro should
be ~3x slower than that desktop machine.</p>
<p>Looking at Activity Monitor when running the test harness with 12 tests
in parallel revealed something odd: the system was spending ~75% of overall
CPU time inside the kernel! When reducing the number of tests that ran in
parallel, the percentage of CPU time spent in the kernel decreased and
the overall test harness execution time also decreased. This kind of
behavior is usually a sign of something very inefficient in kernel land.</p>
<p>I sample profiled all processes on the system when running the Mercurial
test harness. Aggregate thread stacks revealed a common pattern:
<code>readdir()</code> being in the stack.</p>
<p>Upon closer examination of the stacks, <code>readdir()</code> calls into
<code>apfs_vnop_readdir()</code>, which calls into some functions with <code>bt</code> or
<code>btree</code> in their name, which call into <code>lck_mtx_lock()</code>,
<code>lck_mtx_lock_grab_mutex()</code> and various other functions with
<code>lck_mtx</code> in their name. And the caller of most <code>readdir()</code> appeared
to be Python 2.7's module importing mechanism (notably
<code>import.c:case_ok()</code>).</p>
<p>APFS refers to the
<a href="https://en.wikipedia.org/wiki/Apple_File_System">Apple File System</a>,
which is a filesystem that Apple introduced in 2017 and is the
default filesystem for new versions of macOS and iOS. If upgrading an
old Mac to a new macOS, its HFS+ filesystems would be automatically
converted to APFS.</p>
<p>While the source code for APFS is not available for me to confirm, the
profiling results showing excessive time spent in
<code>lck_mtx_lock_grab_mutex()</code> combined with the fact that execution time
decreases when the parallel process count decreases leads me to the
conclusion that <strong>APFS obtains a global kernel lock during read-only
operations such as <code>readdir()</code></strong>. In other words, APFS slows down when
attempting to perform parallel read-only I/O.</p>
<p>This isn't the first time I've encountered such behavior in a
filesystem: last year I
<a href="/blog/2017/12/08/good-riddance-to-aufs/">blogged about very similar behavior in AUFS</a>,
which was making Firefox CI significantly slower.</p>
<p>Because Python 2.7's module importing mechanism was triggering the
slowness by calling <code>readdir()</code>, I
<a href="https://mail.python.org/pipermail/python-dev/2018-October/155466.html">posted to python-dev</a>
about the problem, as I thought it was important to notify the larger
Python community. After all, this is a generic problem that affects
the performance of starting <em>any</em> Python process when running on APFS.
i.e. if your build system invokes many Python processes in parallel,
you could be impacted by this. As part of obtaining data for that post, I
discovered that Python 3.7 does not call <code>readdir()</code> as part of
module importing and therefore doesn't exhibit a severe slowdown. (Python's
module importing code was rewritten significantly in Python 3 and the <em>fix</em>
was likely introduced well before Python 3.7.)</p>
<p>I've <a href="https://gist.github.com/indygreg/a50e187f5372807cdcab5ac12bc2feea">produced a gist that can reproduce the problem</a>.
The script essentially performs a recursive directory walk. It exercises
the <code>opendir()</code>, <code>readdir()</code>, <code>closedir()</code>, and <code>lstat()</code> functions
heavily and is essentially a benchmark of the filesystem and filesystem
cache's ability to return file metadata.</p>
<p>When you tell it to walk a very large directory tree - say a Firefox
version control checkout (which has over 250,000 files) - the excessive
time spent in the kernel is very apparent on macOS 10.13 High Sierra:</p>
<pre><code>$ time ./slow-readdir.py -l 12 ~/src/firefox
ran 12 walks across 12 processes in 172.209s

real    2m52.470s
user    1m54.053s
sys    23m42.808s

$ time ./slow-readdir.py -l 12 -j 1 ~/src/firefox
ran 12 walks across 1 processes in 523.440s

real    8m43.740s
user    1m13.397s
sys     3m50.687s

$ time ./slow-readdir.py -l 18 -j 18 ~/src/firefox
ran 18 walks across 18 processes in 210.487s

real    3m30.731s
user    2m40.216s
sys    33m34.406s
</code></pre>
<p>On the same machine upgraded to macOS 10.14 Mojave, we see a bit of a
speedup!:</p>
<pre><code>$ time ./slow-readdir.py -l 12 ~/src/firefox
ran 12 walks across 12 processes in 97.833s

real    1m37.981s
user    1m40.272s
sys    10m49.091s

$ time ./slow-readdir.py -l 12 -j 1 ~/src/firefox
ran 12 walks across 1 processes in 461.415s

real    7m41.657s
user    1m05.830s
sys     3m47.041s

$ time ./slow-readdir.py -l 18 -j 18 ~/src/firefox
ran 18 walks across 18 processes in 140.474s

real    2m20.727s
user    3m01.048s
sys    17m56.228s
</code></pre>
<p>Contrast with my i7-6700K Linux machine backed by EXT4:</p>
<pre><code>$ time ./slow-readdir.py -l 8 ~/src/firefox
ran 8 walks across 8 processes in 6.018s

real    0m6.191s
user    0m29.670s
sys     0m17.838s

$ time ./slow-readdir.py -l 8 -j 1 ~/src/firefox
ran 8 walks across 1 processes in 33.958s

real    0m34.164s
user    0m17.136s
sys     0m13.369s

$ time ./slow-readdir.py -l 12 -j 12 ~/src/firefox
ran 12 walks across 12 processes in 25.465s

real    0m25.640s
user    1m4.801s
sys     1m20.488s
</code></pre>
<p>It is apparent that macOS 10.14 Mojave has received performance work
relative to macOS 10.13! Overall kernel CPU time when performing parallel
directory walks has decreased substantially - to ~50% of original on some
invocations! Stacks seem to reveal new code for lock acquisition, so this
might indicate generic improvements to the kernel's locking mechanism
rather than APFS specific changes. Changes to file metadata caching could
also be responsible for performance changes. Although it is difficult to tell
without access to the APFS source code. Despite those improvements, APFS
is still spending a lot of CPU time in the kernel. And the kernel CPU time
is still comparatively very high compared to Linux/EXT4, even for single
process operation.</p>
<p>At this time, I haven't conducted a comprehensive analysis of APFS to
determine what other filesystem operations seem to acquire global kernel
locks: all I know is <code>readdir()</code> does. A casual analysis of profiled
stacks when running Mercurial's test harness against Python 3.7 seems
to show <code>apfs_*</code> functions still on the stack a lot and that seemingly
indicates more APFS slowness under parallel I/O load. But HFS+ exhibited
similar problems (it appeared HFS+ used a single I/O thread inside the
kernel for many operations, making I/O on macOS pretty bad), so I'm
not sure if these could be considered <em>regressions</em> the way <code>readdir()</code>'s
new behavior is.</p>
<p>I've reported this issue to Apple at
<a href="https://bugreport.apple.com/web/?problemID=45648013">https://bugreport.apple.com/web/?problemID=45648013</a>
and on OpenRadar at <a href="https://openradar.appspot.com/radar?id=5025294012383232">https://openradar.appspot.com/radar?id=5025294012383232</a>.
I'm told that issues get more attention from Apple when there are many
duplicates of the same issue. So please reference this issue if you file your
own report.</p>
<p>Now that I've elaborated on the technical details, I'd like to add some
personal commentary. While this post is about APFS, this issue of global
kernel locks during common I/O operations is not unique to APFS. I
<a href="/blog/2017/12/08/good-riddance-to-aufs/">already referenced</a> similar
issues in AUFS. And I've encountered similar behaviors with Btrfs (although
I can't recall exactly which operations). And NTFS has its own
<a href="https://github.com/Microsoft/WSL/issues/873#issuecomment-425272829">bag of problems</a>.</p>
<p>This seeming pattern of global kernel locks for common filesystem operations
and slow filesystems is really rubbing me the wrong way. Modern NVMe SSDs
are capable of reading and writing well over 2 gigabytes per second and
performing hundreds of thousands of I/O operations per second. We even have
Intel soon producing
<a href="https://newsroom.intel.com/editorials/re-architecting-data-center-memory-storage-hierarchy/">persistent solid state storage that plugs into DIMM slots</a>
because it is that friggin fast.</p>
<p>Today's storage hardware is capable of ludicrous performance. It is fast enough
that you will likely saturate multiple CPU cores processing the read or written
data coming from and going to storage - especially if you are using higher-level,
non-JITed (read: slower) programming languages (like Python). There has also been
a trend that systems are growing more CPU cores faster than they are instructions
per second per core. And SSDs only achieve these ridiculous IOPS numbers if many
I/O operations are <em>queued</em> and can be more efficiently dispatched within the
storage device. What this all means is that it probably makes sense to use
parallel I/O across multiple threads in order to extract all potential
performance from your persistent storage layer.</p>
<p>It's also worth noting that we now have solid state storage that outperforms (in
some dimensions) what DRAM from ~20 years ago was capable of. Put another way I/O
APIs and even some filesystems were designed in an era when its RAM was slower than
what today's persistent storage is capable of! While I'm no filesystems or kernel
expert, it does seem a bit silly to be using APIs and filesystems designed for an
era when storage was multiple orders of magnitude slower and systems only had a
single CPU core.</p>
<p>My takeaway is I can't help but feel that systems-level software (including the
kernel) is severely limiting the performance potential of modern storage
devices. If we have e.g. global kernel locks when performing common I/O operations,
there's no chance we'll come close to harnessing the full potential of today's
storage hardware. Furthermore, the behavior of filesystems is woefully under
documented and software developers have little solid advice for how to achieve
optimal I/O performance. As someone who cares about performance, I want to
squeeze every iota of potential out of hardware. But the lack of documentation
telling me which operations acquire locks, which strategies are best for say
reading or writing 10,000 files using N threads, etc makes this extremely
difficult. And even if this documentation existed, because of differences in
behavior across filesystems and operating systems and the difficulty in
programmatically determining the characteristics of filesystems at run time,
it is practically impossible to design a <em>one size fits all</em> approach to
high performance I/O.</p>
<p>The filesystem is a powerful concept. I want to agree and use the <em>everything is a
file</em> philosophy. Unfortunately, filesystems don't appear to be scaling very well
to support the potential of modern day storage technology. We're probably at the
point where commodity priced solid state storage is far more capable than today's
software for the majority of applications. Storage hardware manufacturers will
keep producing faster and faster storage and their marketing teams will keep
convincing us that we need to buy it. But until software catches up, chances are
most of us won't come close to realizing the true potential of modern storage
hardware. And that's even true for specialized applications that do employ tricks
taking hundreds or thousands of person hours to implement in order to eek out every
iota of performance potential. The average software developer and application
using filesystems as they were designed to be used has little to no chance of
coming close to utilizing the performance potential of modern storage devices.
That's really a shame. </p>]]></content:encoded>
    </item>
    <item>
      <title>Benefits of Clone Offload on Version Control Hosting</title>
      <link>http://gregoryszorc.com/blog/2018/07/27/benefits-of-clone-offload-on-version-control-hosting</link>
      <pubDate>Fri, 27 Jul 2018 15:48:00 PDT</pubDate>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2018/07/27/benefits-of-clone-offload-on-version-control-hosting</guid>
      <description>Benefits of Clone Offload on Version Control Hosting</description>
      <content:encoded><![CDATA[<p>Back in 2015, I implemented a feature in Mercurial 3.6 that allows
servers to advertise URLs of pre-generated <em>bundle</em> files. When a
compatible client performs a <code>hg clone</code> against a repository leveraging
this feature, it downloads and applies the bundle from a URL then goes
back to the server and performs the equivalent of an <code>hg pull</code> to obtain
the changes to the repository made after the bundle was generated.</p>
<p>On <a href="https://hg.mozilla.org/">hg.mozilla.org</a>, we've been using this
feature since 2015. We host bundles in Amazon S3 and make them available
via the CloudFront CDN. We perform
<a href="https://hg.mozilla.org/hgcustom/version-control-tools/file/99f7164339ed/hgext/hgmo/__init__.py#l1022">IP filtering on the server</a>
so clients connecting from AWS IPs are served S3 URLs corresponding to
the closest region / S3 bucket where bundles are hosted. Most
Firefox build and test automation is run out of EC2 and automatically
clones high-volume repositories from an S3 bucket hosted in the same
AWS region. (Doing an intra-region transfer is very fast and clones
can run at &gt;50 MB/s.) Everyone else clones from a CDN. See our
<a href="https://mozilla-version-control-tools.readthedocs.io/en/latest/hgmo/bundleclone.html">official docs</a>
for more.</p>
<p>I <a href="/blog/2015/10/22/cloning-improvements-in-mercurial-3.6/">last reported</a>
on this feature in October 2015. Since then, Bitbucket also
<a href="https://developer.atlassian.com/blog/2017/02/bitbucket-CDN-cloning/">deployed this feature</a>
in early 2017.</p>
<p>I was reminded of this <em>clone bundles</em> feature this week when
kernel.org posted
<a href="https://www.kernel.org/best-way-to-do-linux-clones-for-your-ci.html">Best way to do linux clones for your CI</a>
and that post was making the rounds in my version control circles.
tl;dr git.kernel.org apparently suffers high load due to high
clone volume against the Linux Git repository and since Git doesn't
have an equivalent feature to clone bundles built in to Git itself,
they are asking people to perform equivalent functionality to mitigate
server load.</p>
<p>(A <em>clone bundles</em> feature has been discussed on the Git mailing list
before. I remember finding old discussions when I was doing research
for Mercurial's feature in 2015. I'm sure the topic has come up since.)</p>
<p>Anyway, I thought I'd provide an update on just how valuable the
<em>clone bundles</em> feature is to Mozilla. In doing so, I hope maintainers
of other version control tools see the obvious benefits and consider
adopting the feature sooner.</p>
<p>In a typical week, hg.mozilla.org is currently serving ~135 TB of
data. The overwhelming majority of this data is related to the Mercurial
wire protocol (i.e. not HTML / JSON served from the web interface).
Of that ~135 TB, ~5 TB is served from the CDN, ~126 TB is served from
S3, and ~4 TB is served from the Mercurial servers themselves. In other
words, <strong>we're offloading ~97% of bytes served from the Mercurial servers
to S3 and the CDN</strong>.</p>
<p>If we assume this offloaded ~131 TB is equally distributed throughout
the week, this comes out to ~1,732 Mbps on average. In reality, we do
most of our load from California's Sunday evenings to early Friday
evenings. And load is typically concentrated in the 12 hours when
the sun is over Europe and North America (where most of Mozilla's
employees are based). So the typical throughput we are offloading is
more than 2 Gbps. And at a lower level, automation tends to perform
clones soon after a push is made. So load fluctuates significantly
throughout the day, corresponding to when pushes are made.</p>
<p>By volume, most of the data being offloaded is for the
<a href="https://hg.mozilla.org/mozilla-unified">mozilla-unified</a> Firefox
repository. Without clone bundles and without the special <em>stream
clone</em> Mercurial feature (which we also leverage via clone bundles), the
servers would be generating and sending ~1,588 MB of zstandard level 3
compressed data for each clone of that repository. Each clone would
consume ~280s of CPU time on the server. And at ~195,000 clones per
month, that would come out to ~309 TB/mo or ~72 TB/week. In CPU time,
that would be ~54.6 million CPU-seconds, or ~21 CPU-months. I will
leave it as an exercise to the reader to attach a dollar cost to how
much it would take to operate this service without clone bundles. But
I will say the total AWS bill for our S3 and CDN hosting for this
service is under $50 per month. (It is worth noting that intra-region
data transfer from S3 to other AWS services is free. And we are
definitely taking advantage of that.)</p>
<p>Despite a significant increase in the size of the Firefox repository and
clone volume of it since 2015, our servers are still performing less
work (in terms of bytes transferred and CPU seconds consumed) than they
were in 2015. The ~97% of bytes and millions of CPU seconds offloaded
in any given week have given us a lot of breathing room and have
saved Mozilla several thousand dollars in hosting costs. The feature
has likely helped us avoid many operational incidents due to high server
load. It has made Firefox automation faster and more reliable.</p>
<p>Succinctly, Mercurial's <em>clone bundles</em> feature has successfully and
largely effortlessly offloaded a ton of load from the hg.mozilla.org
Mercurial servers. Other version control tools should implement this
feature because it is a game changer for server operators <strong>and</strong>
results in a better client-side experience (eliminates server-side CPU
bottleneck and may eliminate network bottleneck due to a geo-local CDN
typically being as fast as your Internet pipe). It's a win-win. And a
massive win if you are operating at scale.</p>]]></content:encoded>
    </item>
    <item>
      <title>High-level Problems with Git and How to Fix Them</title>
      <link>http://gregoryszorc.com/blog/2017/12/11/high-level-problems-with-git-and-how-to-fix-them</link>
      <pubDate>Mon, 11 Dec 2017 10:30:00 PST</pubDate>
      <category><![CDATA[Git]]></category>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2017/12/11/high-level-problems-with-git-and-how-to-fix-them</guid>
      <description>High-level Problems with Git and How to Fix Them</description>
      <content:encoded><![CDATA[<p>I have a... complicated relationship with Git.</p>
<p>When Git first came onto the scene in the mid 2000's, I was initially
skeptical because of its horrible user interface. But once I learned
it, I appreciated its speed and features - especially the ease at which
you could create feature branches, merge, and even create commits
offline (which was a big deal in the era when Subversion was the
dominant version control tool in open source and you needed to speak with
a server in order to commit code). When I started using Git day-to-day,
it was such an obvious improvement over what I was using before (mainly
Subversion and even CVS).</p>
<p>When I started working for Mozilla in 2011, I was exposed to the
Mercurial version control, which then - and still today - hosts the
canonical repository for Firefox. I didn't like Mercurial initially.
Actually, I despised it. I thought it was slow and its features lacking.
And I frequently encountered repository corruption.</p>
<p>My first experience learning the <em>internals</em> of both Git and Mercurial
came when I found myself hacking on
<a href="http://hg-git.github.io/]">hg-git</a> - a tool that allows you to convert
Git and Mercurial repositories to/from each other. I was hacking on hg-git
so I could improve the performance of converting Mercurial repositories
to Git repositories. And I was doing that because I wanted to use Git -
not Mercurial - to hack on Firefox. I was trying to enable an unofficial
Git mirror of the Firefox repository to synchronize faster so it would
be more usable. The ulterior motive was to demonstrate that Git is a
superior version control tool and that Firefox should switch its canonical
version control tool from Mercurial to Git.</p>
<p>In what is a textbook definition of <em>irony</em>, what happened instead was
I actually learned how Mercurial worked, interacted with the Mercurial
Community, realized that Mozilla's documentation and developer practices
were... lacking, and that Mercurial was actually a much, much more
pleasant tool to use than Git. It's an old post, but I
<a href="/blog/2013/05/12/thoughts-on-mercurial-(and-git)/">summarized my conversion</a>
four and a half years ago. This started a chain of events that somehow
resulted in me contributing a ton of patches to Mercurial, taking
stewardship of <em>hg.mozilla.org</em>, and becoming a member of the Mercurial
Steering Committee - the governance group for the Mercurial Project.</p>
<p>I've been an advocate of Mercurial over the years. Some would probably say
I'm a Mercurial fanboy. I reject that characterization because <em>fanboy</em> has
connotations that imply I'm ignorant of realities. I'm well aware of
Mercurial's faults and weaknesses. I'm well aware of Mercurial's relative
lack of popularity, I'm well aware that this lack of popularity almost
certainly turns away contributors to Firefox and other Mozilla projects
because people don't want to have to learn a new tool. I'm well aware that
there are changes underway to enable Git to scale to <em>very large
repositories</em> and that these changes could threaten Mercurial's scalability
advantages over Git, making choices to use Mercurial even harder to defend.
(As an aside, the party most responsible for pushing Git to adopt
architectural changes to enable it to scale these days is Microsoft.
Could anyone have foreseen that?!)</p>
<p>I've achieved mastery in both Git and Mercurial. I know their internals
and their command line interfaces extremely well. I understand the
architecture and principles upon which both are built. I'm also exposed
to some very experienced and knowledgeable people in the Mercurial
Community. People who have been around version control for much, much
longer than me and have knowledge of random version control tools you've
probably never heard of. This knowledge and exposure allows me to make
connections and see opportunities for version control that quite frankly
most do not. </p>
<p>In this post, I'll be talking about some high-level, high-impact problems
with Git and possible solutions for them. My primary goal of this post is
to foster positive change in Git and the services around it. While I
personally prefer Mercurial, improving Git is good for everyone. Put
another way, I want my knowledge and perspective from being part of
a version control community to be put to good wherever it can.</p>
<p>Speaking of Mercurial, as I said, I'm a heavy contributor and am somewhat
influential in the Mercurial Community. I want to be clear that my opinions
in this post are my own and I'm not speaking on behalf of the Mercurial
Project or the larger Mercurial Community. I also don't intend to claim
that Mercurial is <em>holier-than-thou</em>. Mercurial has tons of user interface
failings and deficiencies. And I'll even admit to being frustrated that some
systemic failings in Mercurial have gone unaddressed for as long as they
have. But that's for another post. This post is about Git. Let's get started.</p>
<h2>The Staging Area</h2>
<p>The staging area is a feature that should not be enabled in the default
Git configuration.</p>
<p>Most people see version control as an obstacle standing in the way of
accomplishing some other task. They just want to save their progress
towards some goal. In other words, they want version control to be a
<em>save file</em> feature in their workflow.</p>
<p>Unfortunately, modern version control tools don't work that way. For
starters, they require people to specify a <em>commit message</em> every time
they save. This in of itself can be annoying. But we generally accept
that as the price you pay for version control: that <em>commit message</em> has
value to others (or even your future self). So you must record it.</p>
<p>Most people want the barrier to saving changes to be effortless. A commit
message is already too annoying for many users! The Git staging area
establishes a <em>higher</em> barrier to saving. Instead of just saving your
changes, you must first <em>stage</em> your changes to be saved.</p>
<p>If you requested <em>save</em> in your favorite GUI application, text editor,
etc and it popped open a <em>select the changes you would like to
save dialog</em>, you would rightly think <em>just save all my changes already,
dammit.</em> But this is exactly what Git does with its staging area! Git
is saying <em>I know all the changes you made: now tell me which changes
you'd like to save.</em> To the average user, this is infuriating because
it works in contrast to how the <em>save</em> feature works in almost every
other application.</p>
<p>There is a counterargument to be made here. You could say that the
editor/application/etc is complex - that it has multiple <em>contexts</em>
(files) - that each context is independent - and that the user should
have full control over which contexts (files) - and even changes within
those contexts - to save. I agree: this is a compelling feature. However,
it isn't an appropriate <em>default</em> feature. The ability to pick which
changes to save is a power-user feature. Most users just want to save all
the changes all the time. So that should be the default behavior. And
the Git staging area should be an opt-in feature.</p>
<p>If intrinsic workflow warts aren't enough, the Git staging area has a
horrible user interface. It is often referred to as the <em>cache</em>
<a href="https://stackoverflow.com/questions/6716355/why-staging-directory-is-also-called-index-git-index/6718135#6718135">for historical reasons</a>.
<em>Cache</em> of course means something to anyone who knows anything about
computers or programming. And Git's use of <em>cache</em> doesn't at all align
with that common definition. Yet the the terminology in Git persists.
You have to run commands like <code>git diff --cached</code> to examine the state
of the <em>staging area</em>. Huh?!</p>
<p>But Git also refers to the <em>staging area</em> as the <em>index</em>. And this
terminology also appears in Git commands! <code>git help commit</code> has numerous
references to the <em>index</em>. Let's see what <code>git help glossary</code> has to say::</p>
<pre><code>index
    A collection of files with stat information, whose contents are
    stored as objects. The index is a stored version of your working tree.
    Truth be told, it can also contain a second, and even a third
    version of a working tree, which are used when merging.

index entry
    The information regarding a particular file, stored in the index.
    An index entry can be unmerged, if a merge was started, but not
    yet finished (i.e. if the index contains multiple versions of that
    file).
</code></pre>
<p>In terms of end-user documentation, this is a train wreck. It tells the
lay user absolutely nothing about what the <em>index</em> actually is. Instead,
it casually throws out references to <em>stat information</em> (requires the user
know what the <code>stat()</code> function call and struct are) and <em>objects</em> (a Git
term for a piece of data stored by Git). It even undermines its own credibility
with that <em>truth be told</em> sentence. This definition is so bad that it
would probably improve user understanding if it were deleted!</p>
<p>Of course, <code>git help index</code> says <em>No manual entry for gitindex</em>. So
there is literally no hope for you to get a concise, understandable
definition of the <em>index</em>. Instead, it is one of those concepts that you
think you learn from interacting with it all the time. <em>Oh, when I
<code>git add</code> something it gets into this state where <code>git commit</code> will
actually save it.</em></p>
<p>And even if you know what the Git staging area/index/cached is, it can
still confound you. Do you know the interaction between uncommitted
changes in the staging area and working directory when you <code>git rebase</code>?
What about <code>git checkout</code>? What about the various <code>git reset</code> invocations?
I have a confession: I can't remember all the edge cases either. To play
it safe, I try to make sure all my outstanding changes are committed
before I run something like <code>git rebase</code> because I <em>know</em> that will be
safe.</p>
<p>The Git staging area doesn't have to be this complicated. A <em>re-branding</em>
away from <em>index</em> to <em>staging area</em> would go a long way. Adding an alias
from <code>git diff --staged</code> to <code>git diff --cached</code> and removing references
to the <em>cache</em> from common user commands would make a lot of sense and
reduce end-user confusion.</p>
<p>Of course, the Git staging area doesn't really need to exist at all!
The staging area is essentially a <em>soft commit</em>. It performs the
<em>save progress</em> role - the basic requirement of a version control tool.
And in some aspects it is actually a better <em>save progress</em> implementation
than a <em>commit</em> because it doesn't require you to type a commit message!
Because the <em>staging area</em> is a soft commit, all workflows using it can
be modeled as if it were a real commit and the <em>staging area</em> didn't
exist at all! For example, instead of <code>git add --interactive</code> +
<code>git commit</code>, you can run <code>git commit --interactive</code>. Or if you wish
to incrementally add new changes to an in-progress commit, you can
run <code>git commit --amend</code> or <code>git commit --amend --interactive</code> or
<code>git commit --amend --all</code>. If you actually understand the various modes
of <code>git reset</code>, you can use those to <em>uncommit</em>. Of course, the user
interface to performing these actions in Git today is a bit convoluted.
But if the <em>staging area</em> didn't exist, new high-level commands like
<code>git amend</code> and <code>git uncommit</code> could certainly be invented. </p>
<p>To the average user, the <em>staging area</em> is a complicated concept. I'm
a power user. I understand its purpose and how to harness its power. Yet
when I use Mercurial (which doesn't have a <em>staging area</em>), I don't miss
the <em>staging area</em> at all. Instead, I learn that all operations involving
the <em>staging area</em> can be modeled as other fundamental primitives (like
<em>commit amend</em>) that you are likely to encounter anyway. The <em>staging
area</em> therefore constitutes an unnecessary burden and cognitive load on
users. While powerful, its complexity and incurred confusion does not
justify its existence in the default Git configuration. The <em>staging
area</em> is a power-user feature and should be opt-in by default. </p>
<h2>Branches and Remotes Management is Complex and Time-Consuming</h2>
<p>When I first used Git (coming from CVS and Subversion), I thought
branches and remotes were incredible because they enabled new workflows
that allowed you to easily track multiple lines of work across many
repositories. And ~10 years later, I still believe the workflows they
enable are important. However, having amassed a broader perspective, I
also believe their implementation is poor and this unnecessarily confuses
many users and wastes the time of <em>all</em> users.</p>
<p>My initial <em>zen moment</em> with Git - the time when Git finally clicked for me -
was when I understood Git's object model: that Git is just a
content indexed key-value store consisting of a different object types
(blobs, trees, and commits) that have a particular relationship with
each other. <em>Refs</em> are symbolic names pointing to Git commit objects. And
Git <em>branches</em> - both local and remote - are just <em>refs</em> having a
well-defined naming convention (<code>refs/heads/&lt;name&gt;</code> for local branches and
<code>refs/remotes/&lt;remote&gt;/&lt;name&gt;</code> for remote branches). Even <em>tags</em> and
<em>notes</em> are defined via <em>refs</em>.</p>
<p><em>Refs</em> are a necessary primitive in Git because the Git storage model is
to throw all <em>objects</em> into a single, key-value namespace. Since the store
is content indexed and the key name is a cryptographic hash of the object's
content (which for all intents and purposes is random gibberish to
end-users), the Git store by itself is unable to locate objects. If all you
had was the key-value store and you wanted to <em>find all commits</em>, you would
need to walk every object in the store and read it to see if it is a commit
object. You'd then need to buffer metadata about those objects in memory so
you could reassemble them into say a DAG to facilitate looking at commit
history. This approach obviously doesn't scale. <em>Refs</em> short-circuit this
process by providing pointers to objects of importance. It may help to
think of the set of <em>refs</em> as an <em>index</em> into the Git store.  </p>
<p><em>Refs</em> also serve another role: as guards against garbage collection.
I won't go into details about loose objects and packfiles, but it's worth
noting that Git's key-value store also behaves in ways similar to
a generational garbage collector like you would find in programming languages
such as Java and Python. The important thing to know is that Git will
garbage collect (read: delete) objects that are unused. And the mechanism
it uses to determine which objects are unused is to iterate through <em>refs</em>
and walk all transitive references from that initial pointer. If there is
an object in the store that can't be traced back to a <em>ref</em>, it is
<em>unreachable</em> and can be deleted.</p>
<p><em>Reflogs</em> maintain the history of a value for a <em>ref</em>: for each <em>ref</em> they
contain a log of what <em>commit</em> it was pointing to, when that pointer
was established, who established it, etc. <em>Reflogs</em> serve two purposes:
facilitating <em>undoing</em> a previous action and holding a reference to <em>old</em>
data to prevent it from being garbage collected. The two use cases are
related: if you don't care about undo, you don't need the old reference
to prevent garbage collection.</p>
<p>This design of Git's store is actually quite sensible. It's not perfect
(nothing is). But it is a solid foundation to build a version control tool
(or even other data storage applications) on top of.</p>
<p>The title of this section has to do with sub-optimal branches and
remotes management. But I've hardly said anything about branches or remotes!
And this leads me to my main complaint about Git's branches and remotes:
that they are very thin veneer over <em>refs</em>. The properties of Git's
underlying key-value store unnecessarily bleed into user-facing concepts
(like branches and remotes) and therefore dictate sub-optimal practices.
This is what's referred to as a <em>leaky abstraction</em>.</p>
<p>I'll give some examples.</p>
<p>As I stated above, many users treat version control as a <em>save file</em>
step in their workflow. I believe that any step that interferes with users
saving their work is user hostile. This even includes writing a commit
message! I already argued that the <em>staging area</em> significantly interferes
with this critical task. Git <em>branches</em> do as well.</p>
<p>If we were designing a version control tool from scratch (or if you were
a new user to version control), you would probably think that a sane
feature/requirement would be to update to <em>any</em> revision and start making
changes. In Git speak, this would be something like
<code>git checkout b201e96f</code>, make some file changes, <code>git commit</code>. I think
that's a pretty basic workflow requirement for a version control tool.
And the workflow I suggested is pretty intuitive: choose the thing to
start working on, make some changes, then save those changes.</p>
<p>Let's see what happens when we actually do this:</p>
<pre><code>$ git checkout b201e96f
Note: checking out 'b201e96f'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b &lt;new-branch-name&gt;

HEAD is now at b201e96f94... Merge branch 'rs/config-write-section-fix' into maint

$ echo 'my change' &gt;&gt; README.md
$ git commit -a -m 'my change'
[detached HEAD aeb0c997ff] my change
 1 file changed, 1 insertion(+)

$ git push indygreg
fatal: You are not currently on a branch.
To push the history leading to the current (detached HEAD)
state now, use

    git push indygreg HEAD:&lt;name-of-remote-branch&gt;

$ git checkout master
Warning: you are leaving 1 commit behind, not connected to
any of your branches:

  aeb0c997ff my change

If you want to keep it by creating a new branch, this may be a good time
to do so with:

 git branch &lt;new-branch-name&gt; aeb0c997ff

Switched to branch 'master'
Your branch is up to date with 'origin/master'.
</code></pre>
<p>I know what all these messages mean because I've mastered Git. But if
you were a newcomer (or even a seasoned user), you might be very confused.
Just so we're on the same page, here is what's happening (along with
some commentary).</p>
<p>When I run <code>git checkout b201e96f</code>, Git is trying to tell me that I'm
potentially doing something that could result in the loss of my data. A
golden rule of version control tools is <em>don't lose the user's data</em>. When
I run <code>git checkout</code>, Git should be stating the risk for data loss very
clearly. But instead, the <em>If you want to create a new branch</em> sentence is
hiding this fact by instead phrasing things around <em>retaining commits you
create</em> rather than the possible loss of data. It's up to the user
to make the connection that <em>retaining commits you create</em> actually means
<em>don't eat my data</em>. Preventing data loss is critical and Git should not
mince words here!</p>
<p>The <code>git commit</code> seems to work like normal. However, since we're in a
<em>detached HEAD</em> state (a phrase that is likely gibberish to most users),
that commit isn't referred to by any <em>ref</em>, so it can be <em>lost</em> easily.
Git <em>should</em> be telling me that I just committed something it may not
be able to find in the future. But it doesn't. Again, Git isn't being
as protective of my data as it needs to be.</p>
<p>The failure in the <code>git push</code> command is essentially telling me I need
to give things a name in order to <em>push</em>. <em>Pushing</em> is effectively <em>remote
save</em>. And I'm going to apply my reasoning about version control tools
not interfering with <em>save</em> to <em>pushing</em> as well: Git is adding an
extra barrier to <em>remote save</em> by refusing to push commits without a
<em>branch</em> attached and by doing so is being user hostile.</p>
<p>Finally, we <code>git checkout master</code> to move to another commit. Here, Git
is actually doing something halfway reasonable. It is telling me I'm
leaving commits behind, which commits those are, and the command to
use to <em>keep</em> those commits. The warning is good but not great. I think
it needs to be stronger to reflect the risk around data loss if that
suggested Git commit isn't executed. (Of course, the <em>reflog</em> for <code>HEAD</code>
will ensure that data isn't immediately deleted. But users shouldn't
need to involve <em>reflogs</em> to not lose data that wasn't rewritten.)</p>
<p>The point I want to make is that Git doesn't allow you to just <em>update
and save</em>. Because its <em>dumb</em> store requires pointers to relevant commits
(<em>refs</em>) and because that requirement isn't abstracted away or paved over
by user-friendly features in the frontend, Git is effectively requiring
end-users to define names (<em>branches</em>) for all commits. If you fail to
define a name, it gets a lot harder to find your commits, exchange them,
and Git may delete your data. While it is technically possible to not
create branches, the version control tool is essentially unusable without
them.</p>
<p>When local branches are exchanged, they appear as <em>remote branches</em> to
others. Essentially, you give each instance of the repository a name
(the <em>remote</em>). And branches/refs fetched from a named <em>remote</em> appear
as a <em>ref</em> in the <em>ref namespace</em> for that <em>remote</em>. e.g.
<em>refs/remotes/origin</em> holds <em>refs</em> for the <em>origin</em> <em>remote</em>. (Git allows
you to not have to specify the <em>refs/remotes</em> part, so you can refer
to e.g. <em>refs/remotes/origin/master</em> as <em>origin/master</em>.)</p>
<p>Again, if you were designing a version control tool from scratch or you
were a new Git user, you'd probably think <em>remote refs</em> would make
good starting points for work. For example, if you know you should be
saving new work on top of the <em>master</em> branch, you might be inclined
to begin that work by running <code>git checkout origin/master</code>. But like
our specific-commit checkout above:</p>
<pre><code>$ git checkout origin/master
Note: checking out 'origin/master'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b &lt;new-branch-name&gt;

HEAD is now at 95ec6b1b33... RelNotes: the eighth batch
</code></pre>
<p>This is the same message we got for a direct checkout. But we did
supply a <em>ref</em>/<em>remote branch</em> name. What gives? Essentially, Git tries
to enforce that the <em>refs/remotes/</em> namespace is read-only and only
updated by operations that exchange data with a remote, namely <code>git fetch</code>,
<code>git pull</code>, and <code>git push</code>.</p>
<p>For this to work correctly, you need to create a new <em>local branch</em>
(which initially points to the commit that <code>refs/remotes/origin/master</code>
points to) and then switch/activate that <em>local branch</em>.</p>
<p>I could go on talking about all the subtle nuances of how Git branches
are managed. But I won't.</p>
<p>If you've used Git, you know you need to use branches. You may or may
not recognize just how frequently you have to type a branch name into
a <code>git</code> command. I guarantee that if you are familiar with version control
tools and workflows that aren't based on having to manage <em>refs</em> to
track data, you will find Git's forced usage of <em>refs</em> and <em>branches</em>
a bit absurd. I half jokingly refer to Git as <em>Game of Refs</em>. I say that
because coming from Mercurial (which doesn't require you to name things),
Git workflows feel to me like all I'm doing is typing the names of branches
and <em>refs</em> into <code>git</code> commands. I feel like I'm wasting my precious
time telling Git the names of things only because this is necessary to
placate the leaky abstraction of Git's storage layer which requires
references to relevant commits.</p>
<p>Git and version control doesn't have to be this way.</p>
<p>As I said, my Mercurial workflow doesn't rely on naming things. Unlike
Git, Mercurial's store has an explicit (not shared) storage location
for commits (<em>changesets</em> in Mercurial parlance). And this data structure
is ordered, meaning a changeset <em>later</em>  always occurs after its
parent/predecessor. This means that Mercurial can open a single
file/index to quickly find all <em>changesets</em>. Because Mercurial doesn't
need pointers to commits of relevance, names aren't required.</p>
<p>My <em>Zen of Mercurial</em> moment came when I realized you didn't have
to name things in Mercurial. Having used Git before Mercurial, I
was conditioned to always be naming things. This is the Git way
after all. And, truth be told, it is common to name things in Mercurial
as well. Mercurial's <em>named branches</em> were the way to do <em>feature
branches</em> in Mercurial for years. Some used the <em>MQ</em> extension (essentially
a port of <a href="https://en.wikipedia.org/wiki/Quilt_(software)">quilt</a>), which
also requires naming individual patches. Git users coming to Mercurial
were missing Git branches and Mercurial's <em>bookmarks</em> were a poor
<em>port</em> of Git branches.</p>
<p>But recently, more and more Mercurial users have been coming to the
realization that names aren't really necessary. If the tool doesn't
actually require naming things, why force users to name things? As long
as users can find the commits they need to find, do you actually need
names?</p>
<p>As a demonstration, my Mercurial workflow leans heavily on the <code>hg show work</code>
and <code>hg show stack</code> commands. You will need to enable the <em>show</em> extension
by putting the following in your hgrc config file to use them:</p>
<pre><code>[extensions]
show =
</code></pre>
<p>Running <code>hg show work</code> (I have also set the config
<code>commands.show.aliasprefix=s</code>to enable me to type <code>hg swork</code>) finds all
in-progress changesets and other likely-relevant changesets (those
with names and DAG heads). It prints a concise DAG of those changesets:</p>
<p><img alt="hg show work output" src="/images/hg-show-work.png" /></p>
<p>And <code>hg show stack</code> shows just the current line of work and its
relationship to other important heads:</p>
<p><img alt="hg show stack output" src="/images/hg-show-stack.png" /></p>
<p>Aside from the <code>@</code> bookmark/name set on that top-most changeset, there are
no names! (That <code>@</code> comes from the remote repository, which has set that name.)</p>
<p>Outside of code archeology workflows, <code>hg show work</code> shows the changesets I
care about 95% of the time. With all I care about (my in-progress work and
possible rebase targets) rendered concisely, I don't have to name things
because I can just find whatever I'm looking for by running <code>hg show work</code>!
Yes, you need to run <code>hg show work</code>, visually scan for what you are looking
for, and copy a (random) hash fragment into a number of commands. This
sounds like a lot of work. But I believe it is far less work than naming
things. Only when you practice this workflow do you realize just how much
time you actually spend finding and then typing names in to <code>hg</code> and -
especailly - <code>git</code> commands! The ability to just <code>hg update</code> to a changeset
and commit without having to name things is just so liberating. It feels
like my version control tool is putting up fewer barriers and letting me
work quickly.</p>
<p>Another benefit of <code>hg show work</code> and <code>hg show stack</code> are that they present
a concise DAG visualization to users. This helps educate users about the
underlying <em>shape</em> of repository data. When you see connected nodes on a
graph and how they change over time, it makes it a lot easier to understand
concepts like <em>merge</em> and <em>rebase</em>. </p>
<p>This <em>nameless</em> workflow may sound radical. But that's because we're all
conditioned to naming things. I initially thought it was crazy as well. But
once you have a mechanism that gives you rapid access to data you care
about (<code>hg show work</code> in Mercurial's case), names become very optional. Now,
a pure <em>nameless</em> workflow isn't without its limitations. You want names
to identify the main <em>targets</em> for work (e.g. the <em>master</em> branch). And when
you exchange work with others, names are easier to work with, especially
since names survive rewriting. But in my experience, most of my commits
are only exchanged with me (synchronizing my in-progress commits across
devices) and with code review tools (which don't really need names and
can operate against raw commits). My most frequent use of names comes
when I'm in <em>repository maintainer mode</em> and I need to ensure commits
have names for others to reference.</p>
<p>Could Git support <em>nameless</em> workflows? In theory it can.</p>
<p>Git needs <em>refs</em> to find relevant commits in its store. And the wire
protocol uses <em>refs</em> to exchange data. So <em>refs</em> have to exist for Git
to function (assuming Git doesn't radically change its storage and
exchange mechanisms to mitigate the need for <em>refs</em>, but that would be
a massive change and I don't see this happening).</p>
<p>While there is a fundamental requirement for <em>refs</em> to exist, this
doesn't necessarily mean that user-facing names must exist. The reason
that we need <em>branches</em> today is because <em>branches</em> are little more than
a <em>ref</em> with special behavior. It is theoretically possible to invent a
mechanism that transparently maps <em>nameless</em> commits onto <em>refs</em>. For
example, you could create a <em>refs/nameless/</em> namespace that was
automatically populated with DAG heads that didn't have names attached.
And Git could exchange these <em>refs</em> just like it can <em>branches</em> today.
It would be a lot of work to think through all the implications and to
design and implement support for <em>nameless</em> development in Git. But I
think it is possible.</p>
<p>I encourage the Git community to investigate supporting <em>nameless</em> workflows.
Having adopted this workflow in Mercurial, Git's workflow around naming
branches feels heavyweight and restrictive to me. Put another way, <em>nameless</em>
commits are actually lighter-weight branches than Git branches! To the
common user who just wants version control to be a <em>save</em> feature,
requiring names establishes a barrier towards that goal. So removing the
naming requirement would make Git simpler and more approachable to new
users.</p>
<h2>Forks aren't the Model You are Looking For</h2>
<p>This section is more about hosted Git services (like GitHub, Bitbucket, and
GitLab) than Git itself. But since hosted Git services are synonymous
with <em>Git</em> and interaction with a hosted Git services is a regular
part of a common Git user's workflow, I feel like I need to cover it.
(For what it's worth, my experience at Mozilla tells me that a large
percentage of people who say <em>I prefer Git</em> or <em>we should use Git</em>
actually mean <em>I like GitHub</em>. Git and GitHub/Bitbucket/GitLab are
effectively the same thing in the minds of many and anyone finding
themselves discussing version control needs to keep this in mind because
<em>Git</em> is more than just the command line tool: it is an ecosystem.)</p>
<p>I'll come right out and say it: I think <em>forks</em> are a relatively poor
model for collaborating. They are light years better than what
existed before. But they are still so far from the turn-key experience
that should be possible. The <em>fork</em> hasn't really changed much since
the current implementation of it was made popular by GitHub many years
ago. And I view this as a general failure of hosted services to
innovate.</p>
<p>So we have a shared understanding, a <em>fork</em> (as implemented on GitHub,
Bitbucket, GitLab, etc) is essentially a complete copy of a repository
(a <code>git clone</code> if using Git) and a fresh workspace for additional
value-added services the hosting provider offers (pull requests, issues,
wikis, project tracking, release tracking, etc). If you open the main
web page for a <em>fork</em> on these services, it looks just like the main
project's. You know it is a fork because there are cosmetics somewhere
(typically next to the project/repository name) saying <em>forked from</em>.</p>
<p>Before service providers adopted the <em>fork</em> terminology, <em>fork</em> was
used in open source to refer to a splintering of a project. If
someone or a group of people didn't like the direction a project was
taking, wanted to take over ownership of a project because of
stagnation, etc, they would <em>fork it</em>. The <em>fork</em> was based on the
original (and there may even be active collaboration between the
fork and original), but the intent of the <em>fork</em> was to create
distance between the original project and its new incantation. A
new entity that was sufficiently independent of the original.</p>
<p><em>Forks</em> on service providers mostly retain this <em>old school</em> <em>fork</em>
model. The <em>fork</em> gets a new copy of issues, wikis, etc. And anyone
who <em>forks</em> establishes what looks like an independent incantation
of a project. It's worth noting that the execution varies by service
provider. For example, GitHub won't enable <em>Issues</em> for a fork by
default, thereby encouraging people to file issues against the
<em>upstream</em> project it was forked from. (This is good default behavior.)</p>
<p>And I know why service providers (initially) implemented things this
way: it was easy. If you are building a product, it's simpler to just
say <em>a user's version of this project is a <code>git clone</code> and they get
a fresh database</em>. On a technical level, this meets the traditional
definition of <em>fork</em>. And rather than introduce a new term into the
vernacular, they just re-purposed <em>fork</em> (albeit with <em>softer</em>
connotations, since the traditional <em>fork</em> commonly implied there
was some form of strife precipitating a <em>fork</em>).</p>
<p>To help differentiate flavors of <em>forks</em>, I'm going to define the
terms <em>soft fork</em> and <em>hard fork</em>. A <em>soft fork</em> is a <em>fork</em> that
exists for purposes of collaboration. The differentiating feature
between a <em>soft fork</em> and <em>hard fork</em> is whether the <em>fork</em> is
intended to be used as its own project. If it is, it is a
<em>hard fork</em>. If not - if all changes are intended to be <em>merged</em>
into the <em>upstream</em> project and be consumed from there - it is a
<em>soft fork</em>.</p>
<p>I don't have concrete numbers, but I'm willing to wager that the vast
majority of <em>forks</em> on Git service providers which have changes are
<em>soft forks</em> rather than <em>hard forks</em>. In other words, these <em>forks</em>
exist purely as a conduit to collaborate with the canonical/upstream
project (or to facilitate a short-lived one-off change).</p>
<p>The current implementation of <em>fork</em> - which borrows a lot from its
predecessor of the same name - is a good - but not great - way to
facilitate collaboration. It isn't great because it technically
resembles what you'd expect to see for <em>hard fork</em> use cases even
though it is used predominantly with <em>soft forks</em>. This mismatch
creates problems.</p>
<p>If you were to take a step back and invent your own version control
hosted service and weren't tainted by exposure to existing services
and were willing to think a bit beyond making it a glorified frontend
for the <code>git</code> command line interface, you might realize that the problem
you are solving - the product you are selling - is collaboration as
a service, not a Git hosting service. And if your product is
collaboration, then implementing your collaboration model around the
<em>hard fork</em> model with strong barriers between the original project and
its <em>forks</em> is counterproductive and undermines your own product.
But this is how GitHub, Bitbucket, GitLab, and others have implemented
their product!</p>
<p>To improve collaboration on version control hosted services, the concept
of a <em>fork</em> needs to significantly curtailed. Replacing it should be
a UI and workflow that revolves around the central, canonical repository.</p>
<p>You shouldn't need to create your own <em>clone</em> or <em>fork</em> of a repository
in order to contribute. Instead, you should be able to clone the
canonical repository. When you create commits, those commits should
be stored and/or more tightly affiliated with the original project - not
inside a <em>fork</em>.</p>
<p>One potential implementation is doable today. I'm going to call it
<em>workspaces</em>. Here's how it would work.</p>
<p>There would exist a namespace for <em>refs</em> that can be controlled by
the user. For example, on GitHub (where my username is <em>indygreg</em>),
if I wanted to contribute to some random project, I would <code>git push</code>
my refs somewhere under <code>refs/users/indygreg/</code> directly to that
project's. No <em>forking</em> necessary. If I wanted to contribute to a
project, I would just clone its repo then push to my <em>workspace</em> under
it. You could do this today by configuring your Git <em>refspec</em> properly.
For pushes, it would look something like
<code>refs/heads/*:refs/users/indygreg/*</code> (that tells Git to map local <em>refs</em>
under <code>refs/heads/</code> to <code>refs/users/indygreg/</code> on that <em>remote</em> repository).
If this became a popular feature, presumably the Git wire protocol could
be taught to advertise this feature such that Git clients automatically
configured themselves to push to user-specific <em>workspaces</em> attached to
the original repository.</p>
<p>There are several advantages to such a <em>workspace</em> model. Many of them
revolve around eliminating <em>forks</em>.</p>
<p>At initial contribution time, no server-side <em>fork</em> is necessary in order
to contribute. You would be able to <em>clone and contribute</em> without waiting
for or configuring a <em>fork</em>. Or if you can create commits from the web
interface, the clone wouldn't even be necessary! Lowering the barrier to
contribution is a good thing, especially if collaboration is the product
you are selling.</p>
<p>In the web UI, <em>workspaces</em> would also revolve around the source project
and not be off in their own world like <em>forks</em> are today. People could
more easily see what others are up to. And fetching their work would
require typing in their username as opposed to configuring a whole new
remote. This would bring communities closer and hopefully lead to better
collaboration.</p>
<p>Not requiring <em>forks</em> also eliminates the need to synchronize your <em>fork</em>
with the upstream repository. I don't know about you, but one of the things
that bothers me about the <em>Game of Refs</em> that Git imposes is that I have
to keep my <em>refs</em> in sync with the upstream <em>refs</em>. When I fetch from
<em>origin</em> and pull down a new <em>master</em> branch, I need to <code>git merge</code>
that branch into my local <em>master</em> branch. Then I need to push that new
<em>master</em> branch to my fork. This is quite tedious. And it is easy to merge
the wrong branches and get your <em>branch</em> state out of whack. There are
better ways to map remote <em>refs</em> into your local names to make this far
less confusing.</p>
<p>Another win here is not having to push and store data multiple times.
When working on a <em>fork</em> (which is a separate repository), after you
<code>git fetch</code> changes from upstream, you need to eventually <code>git push</code> those
into your <em>fork</em>. If you've ever worked on a large repository and didn't
have a super fast Internet connection, you may have been stymied by
having to <code>git push</code> large amounts of data to your <em>fork</em>. This is quite
annoying, especially for people with slow Internet connections. Wouldn't
it be nice if that <code>git push</code> only pushed the data that was truly new and
didn't already exist somewhere else on the server? A <em>workspace</em> model
where development all occurs in the original repository would fix this.
As a bonus, it would make the storage problem on servers easier because
you would eliminate thousands of forks and you probably wouldn't have to
care as much about data duplication across repos/clones because the
version control tool solves a lot of this problem for you, courtesy of
having all data live alongside or in the original repository instead of
in a <em>fork</em>.</p>
<p>Another win from <em>workspace</em>-centric development would be the potential to
do more user-friendly things after <em>pull/merge requests</em> are incorporated
in the official project. For example, the <em>ref</em> in your workspace could
be deleted automatically. This would ease the burden on users to clean up
after their submissions are accepted. Again, instead of mashing keys to
play the <em>Game of Refs</em>, this would all be taken care of for you
automatically. (Yes, I know there are scripts and shell aliases to
make this more turn-key. But user-friendly behavior shouldn't have to
be opt-in: it should be the default.)</p>
<p>But <em>workspaces</em> aren't all rainbows and unicorns. There are access
control concerns. You probably don't want users able to mutate the
<em>workspaces</em> of other users. Or do you? You can make a compelling
case that project <em>administrators</em> should have that ability. And what if
someone pushes bad or illegal content to a workspace and you receive
a cease and desist? Can you take down just the offending workspace while
complying with the order? And what happens if the original project is
deleted? Do all its workspaces die with it? These are not trivial
concerns. But they don't feel impossible to tackle either.</p>
<p><em>Workspaces</em> are only one potential alternative to <em>forks</em>. And I can
come up with multiple implementations of the <em>workspace</em> concept. Although
many of them are constrained by current features in the Git wire protocol.
But Git is (finally) getting a more extensible wire protocol, so hopefully
this will enable <em>nice things</em>.</p>
<p>I challenge Git service providers like GitHub, Bitbucket, and GitLab to
think outside the box and implement something better than how <em>forks</em>
are implemented today. It will be a large shift. But I think users will
appreciate it in the long run.</p>
<h2>Conclusion</h2>
<p>Git is an ubiquitous version control tool. But it is
<a href="http://stevelosh.com/blog/2013/04/git-koans/">frequently lampooned</a> for
its <a href="https://stevebennett.me/2012/02/24/10-things-i-hate-about-git/">poor usability</a>
and <a href="https://git-man-page-generator.lokaltog.net/">documentation</a>.
We even have
<a href="https://spderosso.github.io/onward13.pdf">research</a>
<a href="https://spderosso.github.io/oopsla16.pdf">papers</a> telling us which parts
are bad. Nobody I know has had a pleasant initial experience with Git.
And it is clear that few people actually understand Git: most just know
the command incantations they need to know to accomplish a small set of
common activities. (If you are such a person, there is nothing to be
ashamed about: Git is a <em>hard</em> tool.)</p>
<p>Popular Git-based hosting and collaboration services (such as GitHub,
Bitbucket, and GitLab) exist. While they've made strides to make it
easier to commit data to a Git repository (I purposefully avoid saying
<em>use Git</em> because the most usable tools seem to avoid the <code>git</code> command
line interface as much as possible), they are often a thin veneer over
Git itself (see <em>forks</em>). And Git is a thin veneer over a content
indexed key-value store (see forced usage of bookmarks).</p>
<p>As an industry, we should be concerned about the lousy usability of Git
and the tools and services that surround it. Some may say that Git -
with its near monopoly over version control mindset - is a success. I
have a different view: I think it is a failure that a tool with a user
experience this bad has achieved the success it has.</p>
<p>The cost to Git's poor usability can be measured in tens if not hundreds
of millions of dollars in time people have wasted because they couldn't
figure out how to use Git. Git should be viewed as a source of
embarrassment, not a success story.</p>
<p>What's really concerning is that the usability problems of Git have been
known for years. Yet it is as popular as ever and there have been few
substantial usability improvements. We do have some
<a href="http://gitless.com/">alternative frontends</a> floating around. But these
haven't caught on.</p>
<p>I'm at a loss to understand how an open source tool as popular as Git
has remained so mediocre for so long. The source code is out there.
Anybody can submit a patch to fix it. Why is it that so many people get
tripped up by the same poor usability issues years after Git became
the common version control tool? It certainly appears that as an
industry we have been unable or unwilling to address systemic deficiencies
in a critical tool. Why this is, I'm not sure.</p>
<p>Despite my pessimism about Git's usability and its poor track record of
being attentive to the needs of people who aren't power users, I'm
optimistic that the future will be brighter. While the ~7000 words in this
post pale in comparison to the aggregate word count that has been
written about Git, hopefully this post strikes a nerve and causes
positive change. Just because one generation has toiled with the
usability problems of Git doesn't mean the next generation has to
suffer through the same. Git can be improved and I encourage that change
to happen. The three issues above and their possible solutions would
be a good place to start.</p>]]></content:encoded>
    </item>
    <item>
      <title>from __past__ import bytes_literals</title>
      <link>http://gregoryszorc.com/blog/2017/03/13/from-__past__-import-bytes_literals</link>
      <pubDate>Mon, 13 Mar 2017 09:55:00 PDT</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2017/03/13/from-__past__-import-bytes_literals</guid>
      <description>from __past__ import bytes_literals</description>
      <content:encoded><![CDATA[<p>Last year, I simultaneously committed one of the ugliest and
impressive hacks of my programming <em>career</em>. I haven't had time
to write about it. Until now.</p>
<p>In summary, the hack is a
<a href="https://www.mercurial-scm.org/repo/hg/rev/1c22400db72d">source-transforming module loader</a>
for Python. It can be used by Python 3 to import a Python 2 source
file while translating certain primitives to their Python 3 equivalents.
It is kind of like <a href="https://docs.python.org/3.6/library/2to3.html">2to3</a>
except it executes at run-time during <code>import</code>. The main goal of the
hack was to facilitate porting Mercurial to Python 3 while deferring
having to make the most invasive - and therefore most annoying -
elements of the port in the canonical source code representation.</p>
<p>For the technically curious, it works as follows.</p>
<p>The <code>hg</code> Python executable registers a custom
<a href="https://docs.python.org/3.6/library/sys.html#sys.meta_path">meta path finder</a>
instance. This entity is invoked during <code>import</code> statements to try
to find the module being imported. It tells a later phase of the
import mechanism how to <em>load</em> that module from wherever it is
(usually a <code>.py</code> or <code>.pyc</code> file on disk) to a Python module object.
The custom finder only responds to requests for modules known
to be managed by the Mercurial project. For these modules, it tells
the next stage of the import mechanism to invoke a custom
<a href="https://docs.python.org/3.6/library/importlib.html#importlib.abc.SourceLoader">SourceLoader</a>
instance. Here's where the real magic is: when the custom <em>loader</em>
is invoked, it tokenizes the Python source code using the
<a href="https://docs.python.org/3.6/library/tokenize.html">tokenize</a> module,
iterates over the token stream, finds specific patterns, and
rewrites them to something <em>more appropriate</em>. It then <em>untokenizes</em>
back to Python source code then falls back to the built-in loader
which does the heavy lifting of compiling the source to Python code
objects. So, we have Python 2 source files on disk that magically get
transformed to be Python compatible when they are loaded by Python 3.
Oh, and there is no performance penalty for the token transformation
on subsequence loads because the transformed bytecode is cached in
the <code>.pyc</code> file (using a custom header so we know it was transformed
and can be invalidated when the transformation logic changes).</p>
<p>At the time I wrote it, the token stream manipulation converted most
string literals (<code>''</code>) to bytes literals (<code>b''</code>). In other words, it
restored the Python 2 behavior of string literals being <code>bytes</code> and
not <code>unicode</code>. We jokingly call it
<code>from __past__ import bytes_literals</code> (a play on Python 2's
<code>from __future__ import unicode_literals</code> special syntax which
changes string literals from Python 2's <code>str</code>/<code>bytes</code> type to
<code>unicode</code> to match Python 3's behavior).</p>
<p>Since I implemented the first version, others have implemented:</p>
<ul>
<li><a href="https://www.mercurial-scm.org/repo/hg/rev/178c89e8519a">Automatically inserting</a>
  a <code>from mercurial.pycompat import ...</code> statement to the top of the
  source. This statement is the Mercurial equivalent of importing
  common wrapper types similar to what
  <a href="https://pythonhosted.org/six/">six</a> provides.</li>
<li>More robust
  <a href="https://www.mercurial-scm.org/repo/hg/rev/423377290a3a">function argument parsing support</a>.
  (Because going from a token stream to a higher-level primitive like a
  function call is difficult.)</li>
<li><a href="https://www.mercurial-scm.org/repo/hg/rev/eaaedad68011">Automatically rewriting</a>
  <code>.iteritems()</code> to <code>.items()</code>.</li>
</ul>
<p>As one can expect, when I tweeted a link to this commit, many Python
developers (including a few CPython core developers) expressed a mix
of intrigue and horror. But mostly horror.</p>
<p>I fully concede that what I did here is a gross hack. And, it is the
intention of the Mercurial project to undo this hack and perform a
proper port once Python 3 support in Mercurial is more mature. But, I
want to lay out my defense on why I did this and why the Mercurial
project is tolerant of this ugly hack.</p>
<p>Individuals within the Mercurial project have wanted to port to Python
3 for years. Until recently, it hasn't been a project priority
because a port was too much work for too little end-user gain. And, on
the technical front, a port was just not practical until Python 3.5.
(Two main blockers were no <code>u''</code> literals - restored in Python 3.3 -
and no <code>%</code> formatting for <code>b''</code> literals - restored in 3.5. And as I
understand it, senior members of the Mercurial project had to lobby
Python maintainers pretty hard to get features like <code>%</code> formatting of
<code>b''</code> literals restored to Python 3.)</p>
<p>Anyway, after a number of failed attempts to initiate the Python 3
port over the years, the Mercurial project started making some
positive steps towards Python 3 compatibility, such as switching
to <a href="https://www.python.org/dev/peps/pep-0328/">absolute imports</a> and
addressing syntax issues that allowed modules to be parsed into
an AST and even compiled and loadable. These may seem like small
steps, but for a larger project, it was a lot of work.</p>
<p>The porting effort hit a large wall when it came time to actually
make the AST-valid Python code run on Python 3. Specifically, we had
a strings problem.</p>
<p>When you write software that exchanges data between machines -
sometimes machines running different operating systems or having
different encodings - and there is an expectation that things work
the same and data roundtrips accordingly, trying to force text
encodings is essentially impossible and inevitably breaks something or
someone. It is much easier for Mercurial to operate <em>bytes first</em> and
only take text encoding into consideration when absolutely necessary
(such as when emitting bytes to the terminal in the wanted encoding
or when emitting JSON). That's not to say Mercurial ignores the
existence of encodings. Far from it: Mercurial does attempt to
normalize some data to Unicode. But it often does so with a special
Python type that internally stores the raw byte sequence of the
source so that a consumer can choose to operate at the bytes or
Unicode level. </p>
<p>Anyway, this means that practically every string variable in Mercurial
is a <code>bytes</code> type (or something that acts like a <code>bytes</code> type). And
since string literals in Python 3 are the <code>str</code> type (which represents
Unicode), that would mean having to prefix almost every <code>''</code> string
literal in Mercurial with <code>b''</code> in order to placate Python 3. Having
to update every occurrence of simple primitives that could be statically
transformed automatically felt like busy work. <strong>We wanted to spend time
on the meaningful parts of the Python 3 port so we could find
interesting problems and challenges, not toil with mechanical
conversions that add little to no short-term value while simultaneously
increasing cognitive dissonance and quite possibly increasing the odds
of introducing a bug in Python 2.</strong> In other words, why should humans
do the work that machines can do for us? Thus, the source-transforming
module importer was born.</p>
<p>While I concede what Mercurial did is a giant hack, I maintain it was
the correct thing to do. It has allowed the Python 3 port to move
forward without being blocked on the more tedious and invasive
transformations that could introduce subtle bugs (including performance
regressions) in Python 2. Perfect is the enemy of good. People time is
valuable. The source-transforming module importer allowed us to unblock
an important project without sinking a lot of people time into it. I'd
make that trade-off again.</p>
<p>While I won't encourage others to take this approach to porting to
Python 3, if you want to, Mercurial's source is available under a GPL
license and the custom module importer could be adapted to any project
with minimal modifications. If someone does extract it as reusable code,
please leave a comment and I'll update the post to link to it.</p>]]></content:encoded>
    </item>
    <item>
      <title>Better Compression with Zstandard</title>
      <link>http://gregoryszorc.com/blog/2017/03/07/better-compression-with-zstandard</link>
      <pubDate>Tue, 07 Mar 2017 09:55:00 PST</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2017/03/07/better-compression-with-zstandard</guid>
      <description>Better Compression with Zstandard</description>
      <content:encoded><![CDATA[<p>I think I first heard about the <a href="http://facebook.github.io/zstd/">Zstandard</a>
compression algorithm at a Mercurial developer sprint in 2015.
At one end of a large table a few people were uttering expletives out
of sheer excitement. At developer gatherings, that's the universal signal
for <em>something is awesome</em>. Long story short, a Facebook engineer shared
a link to the
<a href="http://fastcompression.blogspot.com/">RealTime Data Compression blog</a>
operated by Yann Collet (then known as the author of LZ4 - a compression
algorithm known for its insane speeds) and people were completely
nerding out over the excellent articles and the data within showing the
beginnings of a new general purpose lossless compression algorithm named
Zstandard. It promised better-than-deflate/zlib compression ratios <strong>and</strong>
performance on both compression and decompression. This being a Mercurial
meeting, many of us were intrigued because zlib is used by Mercurial
for various functionality (including on-disk storage and compression over
the wire protocol) and zlib operations frequently appear as performance hot
spots.</p>
<p>Before I continue, if you are interested in low-level performance and
software optimization, I highly recommend perusing the
<a href="http://fastcompression.blogspot.com/">RealTime Data Compression blog</a>.
There are some absolute nuggets of info in there.</p>
<p>Anyway, over the months, the news about Zstandard (zstd) kept getting
better and more promising. As the 1.0 release neared, the Facebook
engineers I interact with (Yann Collet - Zstandard's author - is now
employed by Facebook) were absolutely ecstatic about Zstandard and its
potential. I was toying around with pre-release versions and was
absolutely blown away by the performance and features. I believed
the hype.</p>
<p>Zstandard 1.0 was
<a href="https://code.facebook.com/posts/1658392934479273/smaller-and-faster-data-compression-with-zstandard">released on August 31, 2016</a>.
A few days later, I started the
<a href="https://github.com/indygreg/python-zstandard">python-zstandard</a> project to
provide a fully-featured and Pythonic interface to the underlying zstd C
API while not sacrificing safety or performance. The ulterior motive was
to leverage those bindings in Mercurial so Zstandard could be a first class
citizen in Mercurial, possibly replacing zlib as the default compression
algorithm for all operations.</p>
<p>Fast forward six months and I've achieved many of those goals.
python-zstandard has a nearly complete interface to the zstd C API.
It even exposes some primitives not in the C API, such as batch
compression operations that leverage multiple threads and use minimal
memory allocations to facilitate insanely fast execution. (Expect a
dedicated post on python-zstandard from me soon.)</p>
<p>Mercurial 4.1 ships with the python-zstandard bindings. Two Mercurial
4.1 peers talking to each other will exchange Zstandard compressed
data instead of zlib. For a Firefox repository clone, transfer size is
reduced from ~1184 MB (zlib level 6) to ~1052 MB (zstd level 3) in the
default Mercurial configuration while using ~60% of the CPU that zlib
required on the compressor end. When cloning from hg.mozilla.org, the
pre-generated zstd <em>clone bundle</em> hosted on a CDN using maximum
compression is ~707 MB - ~60% the size of zlib! And, work is ongoing
for Mercurial to support Zstandard for on-disk storage, which should
bring considerable performance wins over zlib for local operations.</p>
<p>I've learned a lot working on python-zstandard and integrating Zstandard
into Mercurial. My primary takeaway is <strong>Zstandard is awesome</strong>.</p>
<p>In this post, I'm going to extol the virtues of Zstandard and provide
reasons why I think you should use it.</p>
<h2>Why Zstandard</h2>
<p>The main objective of lossless compression is to spend one resource
(CPU) so that you may reduce another (I/O). This trade-off is usually
made because data - either at rest in storage or in motion over a
network or even through a machine via software and memory - is a
limiting factor for performance. So if compression is needed for your
use case to mitigate I/O being the limiting resource and you can swap
in a different compression algorithm that magically reduces both CPU
and I/O requirements, that's pretty exciting. At scale, better
and more efficient compression can translate to substantial cost
savings in infrastructure. It can also lead to improved application
performance, translating to better end-user engagement, sales,
productivity, etc. This is why companies like Facebook (Zstandard),
Google (brotli, snappy, zopfli), and
<a href="https://www.crunchbase.com/organization/pied-piper">Pied Piper</a>
(middle-out) invest in compression.</p>
<p>Today, the most widely used compression algorithm in the world is
likely <a href="https://en.wikipedia.org/wiki/DEFLATE">DEFLATE</a>. And, software
most often interacts with DEFLATE via what is likely the most widely
used software library in the world, <a href="http://www.zlib.net/">zlib</a>.</p>
<p>Being at least 27 years old, DEFLATE is getting a bit long in the
tooth. Computers are completely different today than they were in 1990.
The Pentium microprocessor debuted in 1993. If memory serves (pun
intended), it used PC66 DRAM, which had a transfer rate of 533 MB/s.
For comparison, a modern NVMe M.2 SSD (like the Samsung 960 PRO)
can read at 3000+ MB/s and write at 2000+ MB/s. In other words,
persistent storage today is faster than the RAM from the era when
DEFLATE was invented. And of course CPU and network speeds have
increased as well. We also have completely different instruction
sets on CPUs for well-designed algorithms and software to take
advantage of. What I'm trying to say is the market is ripe for
DEFLATE and zlib to be dethroned by algorithms and software that
take into account the realities of modern computers.</p>
<p>(For the remainder of this post I'll use <em>zlib</em> as a stand-in for
<em>DEFLATE</em> because it is simpler.)</p>
<p>Zstandard initially piqued my attention by promising better-than-zlib
compression and performance in both the compression and decompression
directions. That's impressive. But it isn't unique. Brotli achieves
the same, for example. But what kept my attention was Zstandard's rich
feature set, tuning abilities, and therefore versatility.</p>
<p>In the sections below, I'll describe some of the benefits of Zstandard
in more detail.</p>
<p>Before I do, I need to throw in an obligatory disclaimer about data
and numbers that I use. Benchmarking is hard. Benchmarks should not
be trusted. There are so many variables that can influence performance
and benchmarks. (A recent example that surprised me is the
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1323106">CPU frequency/power ramping properties of Xeon versus non-Xeon Intel CPUs</a>.
tl;dr a Xeon won't hit max CPU frequency if only a core or two
is busy, meaning that any single or low-threaded benchmark is
likely misleading on Xeons unless you change power settings to
mitigate its conservative power ramping defaults. And if you change
power settings, does that reflect real-life usage?)</p>
<p>Reporting useful and accurate performance numbers for compression is
hard because there are so many variables to care about. For example:</p>
<ul>
<li>Every corpus is different. Text, JSON, C++, photos, numerical data,
  etc all exhibit different properties when fed into compression and
  could cause compression ratios or speeds to vary significantly.</li>
<li>Few large inputs versus many smaller inputs (some algorithms work
  better on large inputs; some libraries have high per-operation
  overhead).</li>
<li>Memory allocation and use strategy. Performance can vary
  significantly depending on how a compression library allocates,
  manages, and uses memory. This can be an implementation specific
  detail as opposed to a core property of the compression algorithm.</li>
</ul>
<p>Since Mercurial is the driver for my work in Zstandard, the data and
numbers I report in this post are mostly Mercurial data. Specifically,
I'll be referring to data in the
<a href="https://hg.mozilla.org/mozilla-unified">mozilla-unified Firefox repository</a>.
This repository contains over 300,000 commits spanning almost 10 years.
The data within is a good mix of text (mostly C++, JavaScript, Python,
HTML, and CSS source code and other free-form text) and binary (like
PNGs). The Mercurial layer adds some binary structures to e.g. represent
metadata for deltas, diffs, and patching. There are two Mercurial-specific
pieces of data I will use. One is a Mercurial <em>bundle</em>. This is essentially
a representation of all data in a repository. It stores a mix of raw,
fulltext data and deltas on that data. For the mozilla-unified repo, an
uncompressed bundle (produced via <code>hg bundle -t none-v2 -a</code>) is ~4457 MB.
The other piece of data is <em>revlog chunks</em>. This is a mix of fulltext
and delta data for a specific item tracked in version control. I
frequently use the <em>changelog</em> corpus, which is the fulltext data
describing changesets or commits to Firefox. The numbers quoted and
used for charts in this post
<a href="https://docs.google.com/spreadsheets/d/1PHhGxsQR3zDE-2Eeu5Hn2t-UKw4oGV-7LQTMGEdBh9U/edit?usp=sharing">are available in a Google Sheet</a>.</p>
<p>All performance data was obtained on an i7-6700K running Ubuntu 16.10
(Linux 4.8.0) with a mostly stock config. Benchmarks were performed in
memory to mitigate storage I/O or filesystem interference. Memory used
is DDR4-2133 with a cycle time of 35 clocks.</p>
<p>While I'm pretty positive about Zstandard, it isn't perfect. There are
corpora for which Zstandard performs worse than other algorithms, even
ones I compare it directly to in this post. So, your mileage may vary.
Please enlighten me with your counterexamples by leaving a comment.</p>
<p>With that (rather large) disclaimer out of the way, let's talk about
what makes Zstandard awesome.</p>
<h2>Flexibility for Speed Versus Size Trade-offs</h2>
<p>Compression algorithms typically contain parameters to control how
much work to do. You can choose to spend more CPU to (hopefully)
achieve better compression or you can spend less CPU to sacrifice
compression. (OK, fine, there are other factors like memory usage at
play too. I'm simplifying.) This is commonly exposed to
end-users as a compression <em>level</em>. (In reality there are often
multiple parameters that can be tuned. But I'll just use <em>level</em>
as a stand-in to represent the concept.)</p>
<p>But even with adjustable compression levels, the performance of many
compression algorithms and libraries tend to fall within a relatively
narrow window. In other words, many compression algorithms focus on
niche markets. For example, LZ4 is super fast but doesn't yield great
compression ratios. LZMA yields terrific compression ratios but is
extremely slow.</p>
<p>This can be visualized in the following chart showing results when
compressing a mozilla-unified Mercurial bundle:</p>
<p><img alt="bundle compression with common algorithms" src="/images/compression-bundle-common.png" /></p>
<p>This chart plots the logarithmic compression speed in megabytes per
second against achieved compression ratio. The further right a data
point is, the better the compression and the smaller the output.
The higher up a point is, the faster compression is.</p>
<p>The ideal compression algorithm lives in the top right, which means
it compresses well and is fast. But the powers of mathematics push
compression algorithms away from the top right.</p>
<p>On to the observations.</p>
<p>LZ4 is highly vertical, which means its compression ratios are
limited in variance but it is extremely flexible in speed. So for
this data, you might as well stick to a lower compression level
because higher values don't buy you much.</p>
<p>Bzip2 is the opposite: a horizontal line. That means it is consistently
the same speed while yielding different compression ratios. In other
words, you might as well crank bzip2 up to maximum compression because
it doesn't have a significant adverse impact on speed.</p>
<p>LZMA and zlib are more interesting because they exhibit more variance
in both the compression ratio and speed dimensions. But let's be frank,
they are still pretty narrow. LZMA looks pretty good from a shape
perspective, but its top speed is just too slow - only ~26 MB/s!</p>
<p>This small window of flexibility means that you often have to choose
a compression algorithm based on the speed versus size trade-off you are
willing to make at that time. That choice often gets baked into
software. And as time passes and your software or data gains popularity,
changing the software to swap in or support a new compression algorithm
becomes harder because of the cost and disruption it will cause. That's
technical debt.</p>
<p>What we really want is a single compression algorithm that occupies
lots of <em>space</em> in both dimensions of our chart - a curve that has
high variance in both compression speed and ratio. Such an algorithm
would allow you to make an easy decision choosing a compression
algorithm without locking you into a narrow behavior profile. It would
allow you make a completely different size versus speed trade-off in
the future by only adjusting a config knob or two in your application -
no swapping of compression algorithms needed!</p>
<p>As you can guess, Zstandard fulfills this role. This can clearly be seen
in the following chart (which also adds brotli for comparison).</p>
<p><img alt="bundle compression with modern algorithms" src="/images/compression-bundle-modern.png" /></p>
<p>The advantages of Zstandard (and brotli) are obvious. Zstandard's
compression speeds go from ~338 MB/s at level 1 to ~2.6 MB/s at
level 22 while covering compression ratios from 3.72 to 6.05. On one
end, <strong>zstd level 1 is ~3.4x faster than zlib level 1 while achieving
better compression than zlib level 9!</strong> That fastest speed is only 2x
slower than LZ4 level 1. On the other end of the spectrum, zstd
level 22 runs ~1 MB/s slower than LZMA at level 9 and produces a
file that is only 2.3% larger.</p>
<p>It's worth noting that zstd's C API exposes several knobs for tweaking
the compression algorithm. Each compression level maps to a pre-defined
set of values for these knobs. It is possible to set these values beyond
the ranges exposed by the default compression levels 1 through 22. I've
done some basic experimentation with this and have made compression even
faster (while sacrificing ratio, of course). This covers the gap between
Zstandard and brotli on this end of the tuning curve.</p>
<p>The wide span of compression speeds and ratios is a game changer
for compression. Unless you have special requirements such as
lightning fast operations (which LZ4 can provide) or special
corpora that Zstandard can't handle well, Zstandard is a very safe and
flexible choice for general purpose compression.</p>
<h2>Multi-threaded Compression</h2>
<p>Zstd 1.1.3 contains a multi-threaded compression API that allows a
compression operation to leverage multiple threads. The output from
this API is compatible with the Zstandard frame format and doesn't require
any special handling on the decompression side. <strong>In other words, a
compressor can switch to the multi-threaded API and decompressors won't
care.</strong></p>
<p>This is a big deal for a few reasons. First, today's advancements in
computer processors tend to yield more capacity from more cores not
from faster clocks and better cycle efficiency (although many cases
do benefit greatly from modern instruction sets like AVX and therefore
better cycle efficiency). Second, so many compression libraries are
only single-threaded and require consumers to invent their own framing
formats or storage models to facilitate multi-threading. (See
<a href="http://blosc.org/">Blosc</a> for such a library.) Lack of a
multi-threaded API in the compression library means trusting another
piece of software or writing your own multi-threaded code.</p>
<p>The following chart adds a plot of Zstandard multi-threaded compression
with 4 threads.</p>
<p><img alt="multi-threaded compression" src="/images/compression-bundle-multithreaded.png" /></p>
<p>The existing curve for Zstandard basically shifted straight up. Nice!</p>
<p>The ~338 MB/s speed for single-threaded compression on zstd level 1
increases to ~1,376 MB/s with 4 threads. That's ~4.06x faster. And,
it is ~2.26x faster than the previous fastest entry, LZ4 at level 1!
The output size only increased by ~4 MB or ~0.3% over single-threaded
compression.</p>
<p>The scaling properties for multi-threaded compression on this input
are terrific: all 4 cores are saturated and the output size barely
changed.</p>
<p>Because Zstandard's multi-threaded compression API produces data compatible
with any Zstandard decompressor, it can logically be considered an extension
of <em>compression levels</em>. This means that the already extremely flexible
speed vs ratio curve becomes even wider in the speed axis. Zstandard
was already a justifiable choice with its extreme versatility. But when
you throw in native multi-threaded compression API support, the
flexibility for tuning compression performance is just absurd. With
enough cores, you are likely to run into I/O limits long before you
exhaust the CPU, at which point you can crank up the compression
level and sacrifice as much CPU as you are willing to burn. That's
a good position to be in.</p>
<h2>Decompression Speed</h2>
<p>Compression speed and ratios only tell half the story about a compression
algorithm. Except for archiving scenarios where you write once and
read rarely, you probably care about decompression performance.</p>
<p>Popular compression algorithms like zlib and bzip2 have less than stellar
decompression speeds. On my i7-6700K, zlib decompression can deliver many
decompressed data sets at the output end at 200+ MB/s. However, on the
input/compressed end, it frequently fails to reach 100 MB/s or even
80 MB/s. This is significant because if your application is reading data
over a 1 Gbps network or from a local disk (modern SSDs can read at several
hundred MB/s or more), then your application has a CPU bottleneck at
decoding the data - and that's before you actually do anything useful
with the data in the application layer! (Remember: the idea behind
compression is to spend CPU to mitigate an I/O bottleneck. So if
compression makes you CPU bound, you've undermined the point of
compression!) And if my Skylake CPU running at 4.0 GHz is CPU -
not I/O - bound, A Xeon in a data center will be even slower and
even more CPU bound (Xeons tend to run at much lower clock speeds -
the laws of thermodynamics require that in order to run more cores in
the package). In short, <strong>if you are using zlib for high throughput
scenarios, there's a good chance it is a bottleneck and slowing down
your application</strong>.</p>
<p>We again measure the speed of algorithms using a Firefox Mercurial
bundle. The following charts plot decompression speed versus ratio
for this file. The first chart measures decompression speed on the
input end of the decompressor. The second measures speed at the
output end.</p>
<p><img alt="decompression input" src="/images/decompression-bundle-input.png" /></p>
<p><img alt="decompression output" src="/images/decompression-bundle-output.png" /></p>
<p>Zstandard matches its great compression speed with great decompression
speed. Zstandard can deliver decompressed output at 1000+ MB/s while
consuming input at 200-275MB/s. Furthermore, decompression speed is
mostly independent of the compression level. (Although higher
compression levels require more memory in the decompressor.) So, <strong>if
you want to throw more CPU at re-compression later so data at rest takes
less space, you can do that without sacrificing read performance.</strong>
I haven't done the math, but there is probably a break-even point
where having dedicated machines re-compress terabytes or petabytes
of data at rest offsets the costs of those machine through reduced
storage costs.</p>
<p>While Zstandard is not as fast decompressing as LZ4 (which can consume
compressed input at 500+ MB/s), its performance is often ~4x faster
than zlib. On many CPUs, this puts it well above 1 Gbps, which is
often desirable to avoid a bottleneck at the network layer.</p>
<p>It's also worth noting that while Zstandard and brotli were comparable
on the compression half of this data, Zstandard has a clear advantage
doing decompression.</p>
<p>Finally, you don't appear to pay a price for multi-threaded Zstandard
compression on the decompression side (<code>zstdmt</code> in the chart).</p>
<h2>Dictionary Support</h2>
<p>The examples so far in this post have used a single 4,457 MB piece of
input data to measure behavior. Large data can behave completely
differently from small data. This is because so much of what
compression algorithms do is find patterns that came before so incoming
data can be <em>referenced</em> to old data instead of uniquely stored. And if
data is small, there isn't much of it that came before to reference!</p>
<p>This is often why many small, independent chunks of input compress
poorly compared to a single large chunk. This can be demonstrated by
comparing the widely-used <em>zip</em> and <em>tar</em> archive formats. On the
surface, both do the same thing: they are a container of files. But
they employ compression at different phases. A <em>zip</em> file will zlib
compress each entry independently. However, a <em>tar</em> file doesn't use
compression internally. Instead, the tar file itself is fed into a
compression algorithm and compressed as a whole.</p>
<p>We can observe the difference on real world data. Firefox
ships with a file named <code>omni.ja</code>. Despite the weird extension, this
is a <em>zip</em> file. The file contains most of the assets for non-compiled
code used by Firefox. This includes the JavaScript, HTML, CSS, and
images that power many parts of the Firefox frontend. The file weighs
in at 9,783,749 bytes for the 64-bit Windows Firefox Nightly from
2017-03-06. (Or 9,965,793 bytes when using <code>zip -9</code> - the code for
generating <code>omni.ja</code> is smarter than <code>zip</code> and creates smaller
files.) But a zlib level 9 compressed <code>tar.gz</code> file of that directory
is 8,627,155 bytes. That 1,156KB / 13% size difference is significant
when you are talking about delivering bits to end users! (In this
case, the content within the archive needs to be individually
addressable to facilitate fast access to any item without having
to decompress the entire archive: this matters for performance.)</p>
<p>A more extreme example of the differences between <em>zip</em> and <em>tar</em>
is the files in the Firefox source checkout. On revision
a08ec245fa24 of the Firefox Mercurial repository, a <em>zip</em> file of
all files in version control is 430,446,549 bytes versus
322,916,403 bytes for a <em>tar.gz</em> file (1,177,430,383 bytes uncompressed
spanning 180,912 files). Using Zstandard, compressing each file
discretely at compression level 3 yields 391,387,299 bytes of
compressed data versus 294,926,418 as a single stream (without the
<em>tar</em> container). Same compression algorithm. Different application
method. Drastically different results. That's the impact of input
size on compression performance.</p>
<p>While the compression ratio and speed of a single large stream is
often better than multiple smaller chunks, there are still
use cases that either don't have enough data or prefer independent
access to each piece of input (like Firefox's <code>omni.ja</code> file). So
a robust compression algorithm should handle small inputs as well
as it does large inputs.</p>
<p>Zstandard helps offset the inherent inefficiencies of small inputs
by supporting <em>dictionary compression</em>. A <em>dictionary</em> is
essentially data used to seed the compressor's state. If the
compressor sees data that exists in the dictionary, it references
the dictionary instead of storing new data in the compressed output
stream. This results in smaller output sizes and better compression
ratios. One drawback to this is the dictionary has to be used to
decompress data, which means you need to figure out how to
distribute the dictionary and ensure it remains in sync with all
data producers and consumers. This isn't always trivial.</p>
<p>Dictionary compression only works if there is enough repeated data
and patterns in the inputs that can be extracted to yield a
useful dictionary. Examples of this include markup languages, source
code, or pieces of similar data (such as JSON payloads from HTTP API
requests or telemetry data), which often have many repeated keywords
and patterns.</p>
<p>Dictionaries are typically produced by <em>training</em> them on existing
data. Essentially, you feed a bunch of samples into an algorithm
that spits out a meaningful and useful dictionary. The more coherency
in the data that will be compressed, the better the dictionary and
the better the compression ratios.</p>
<p>Dictionaries can have a significant effect on compression ratios and
speed.</p>
<p>Let's go back to Firefox's <code>omni.ja</code> file. Compressing each file
discretely at zstd level 12 yields 9,177,410 bytes of data. But if
we produce a 131,072 byte dictionary by training it on all files
within <code>omni.ja</code>, the total size of each file compressed discretely
is 7,942,886 bytes. Including the dictionary, the total size is
8,073,958 bytes, 1,103,452 bytes smaller than non-dictionary
compression! (The zlib-based <code>omni.ja</code> is 9,783,749 bytes.) So
Zstandard plus dictionary compression would likely yield a
meaningful ~1.5 MB size reduction to the <code>omni.ja</code> file. This would
make the Firefox distribution smaller and <em>may</em> improve startup
time (since many files inside <code>omni.ja</code> are accessed at
startup), which would make a number of people very happy. (Of
course, Firefox doesn't yet contain the zstd C library. And adding
it just for this use case may not make sense. But Firefox does ship
with the brotli library and brotli supports dictionary compression
and has similar performance characteristics as Zstandard, so, uh,
someone may want to look into transitioning <code>omni.jar</code> to
<em>not zlib</em>.)</p>
<p>But the benefits of dictionary compression don't end at compression
ratios: operations with dictionaries can be faster as well!</p>
<p>The following chart shows performance when compressing Mercurial
<em>changeset</em> data (describes a Mercurial commit) for the Firefox
repository. There are 382,530 discrete inputs spanning 221,429,458
bytes (mean: 579 bytes, median: 306 bytes). (Note: measurements were
conducted in Python and therefore may introduce some overhead.)</p>
<p><img alt="dictionary compression performance" src="/images/decompression-dictionary-changeset.png" /></p>
<p>Aside from zstd level 3 dictionary compression, Zstandard is faster
than zlib level 6 across the board (I suspect this one-off is an
oddity with the zstd compression parameters at this level and this
corpus because zstd level 4 is faster than level 3, which is weird).</p>
<p>It's also worth noting that non-dictionary zstandard compression
has similar compression ratios to zlib. Again, this demonstrates
the intrinsic difficulties of compressing small inputs.</p>
<p>But the real takeaway from this data are the speed differences with
dictionary compression enabled. Dictionary decompression is
2.2-2.4x <em>faster</em> than non-dictionary decompression. Already
respectable ~240 MB/s decompression speed (measured at the output
end) becomes ~530 MB/s. Zlib level 6 was ~140 MB/s, so swapping
in dictionary compression makes things ~3.8x faster. It takes ~1.5s
of CPU time to zlib decompress this corpus. So if Mercurial can
be taught to use Zstandard dictionary compression for changelog data,
certain operations on this corpus will complete ~1.1s faster. That's
significant.</p>
<p>It's worth stating that Zstandard isn't the only compression algorithm
or library to support dictionary compression. Brotli and zlib do as
well, for example. But, Zstandard's support for dictionary compression
seems to be more polished than other libraries I've seen. It has multiple
APIs for training dictionaries from sample data. (Brotli has none nor
does brotli's documentation say how to generate dictionaries as far as
I can tell.)</p>
<p>Dictionary compression is definitely an advanced feature, applicable
only to certain use cases (lots of small, similar data). But there's
no denying that if you can take advantage of dictionary compression,
you may be rewarded with significant performance wins.</p>
<h2>A Versatile C API</h2>
<p>I spend a lot of my time these days in higher-level programming
languages like Python and JavaScript. By the time you interact with
compression in high-level languages, the low-level compression APIs
provided by the compression library are most likely hidden from you
and bundled in a nice, friendly abstraction, suitable for a
higher-level language. And more often than not, many features of
that low-level API are not exposed for you to call. So, you don't
get an appreciation for how good (or bad) or feature rich (or
lacking) the low-level API is.</p>
<p>As part of writing
<a href="https://github.com/indygreg/python-zstandard">python-zstandard</a>, I've
spent a lot of time interfacing with the zstd C API. And, as part
of evaluating other compression libraries for use in Mercurial, I've
been looking at C APIs for other libraries and the Python bindings to
them. A takeaway from this is an appreciation for the quality of
zstd's C API.</p>
<p>Many compression library APIs are either too simple or too complex.
Zstandard's is in the Goldilocks zone. Aside from a few minor missing
features, its C API was more than adequate in its 1.0 release.</p>
<p>What I really appreciate about the zstd C API is that it provides
high, medium, and low-level APIs. From the highest level, you throw
it pointers to input and output buffers and it does an operation.
From the medium level, you use a reusable <em>context</em> holding state
and other parameters and it does an operation. From the low-level,
you are calling multiple functions and shuffling bytes around,
maintaining your own state and potentially bypassing the Zstandard
<em>framing</em> format in the process. The different levels give you
almost total control over everything. This is critical for performance
optimization and when writing bindings for higher-level languages that
may have different expectations on the behavior of software. The
performance I've achieved in python-zstandard just isn't (easily)
possible with other compression libraries because of their lacking
API design.</p>
<p>Oftentimes when interacting with a C library I think <em>if only there
were a function to let me do X my life would be much easier</em>. I
rarely have this experience with Zstandard. The C API is well thought out,
has almost all the features I want/need, and is pretty easy to use.
While most won't notice this difference, it should be a significant
advantage for Zstandard in the long run, as more bindings are
written and more people have a high-quality experience with it
because the C API allows them to.</p>
<h2>Zstandard Isn't Perfect</h2>
<p>I've been pretty positive about Zstandard so far in this post.
In fear of sounding like a fanboy who is so blinded by admiration
that he can't see faults and because nothing is perfect, I need to
point out some negatives about Zstandard. (Aside: put little faith
in the words uttered by someone who can't find a fault in something
they praise.)</p>
<p>First, the <a href="https://github.com/facebook/zstd/blob/3bee41a70eaf343fbcae3637b3f6edbe52f35ed8/doc/zstd_compression_format.md#zstandard-frames">framing format</a>
is a bit heavyweight in some scenarios. The frame header is at <em>least</em>
6 bytes. For input of 256-65791 bytes, recording the original source
size and its checksum will result in a 12 byte frame. Zlib, by contrast,
is only 6 bytes for this scenario. When storing tens of thousands of
compressed records (this is a use case in Mercurial), the frame overhead
can matter and this can make it difficult for compressed Zstandard
data to be as small as zlib for very small inputs. (It's worth noting
that zlib doesn't store the decompressed size in its header. There are
pros and cons to this, which I'll discuss in my eventual post about
python-zstandard and how it achieves optimal performance.) If the frame
overhead matters to you, the zstd C API does expose a <em>block</em> API that
operates at a level below the framing format, allowing you to roll your
own framing protocol. I also
<a href="https://github.com/facebook/zstd/issues/591">filed a GitHub issue</a> to
make the 4 byte magic number optional, which would go a long way to
cutting down on frame overhead.</p>
<p>Second, the C API is not yet fully stabilized. There are a number of
functions marked as <em>experimental</em> that aren't exported from the shared
library and are only available via static linking. There's a ton of
useful functionality in there, including low-level compression parameter
adjustment, digested dictionaries (for reusing computed dictionaries
across multiple <em>contexts</em>), and the multi-threaded compression API.
python-zstandard makes heavy use of these <em>experimental</em> APIs. This
requires bundling zstd with python-zstandard and statically linking
with this known version because functionality could change at any time.
This is a bit annoying, especially for distro packagers.</p>
<p>Third, the low-level compression parameters are under-documented. I
think I understand what a lot of them do. But it isn't obvious when
I should consider adjusting what. The default compression levels
seem to work pretty well and map to reasonable compression parameters.
But a few times I've noticed that tweaking things slightly can result
in desirable improvements. I wish there were a guide of sorts to
help you tune these parameters.</p>
<p>Fourth, dictionary compression is still a bit too complicated and
hand-wavy for my liking. I can measure obvious benefits when using it
largely out of the box with some corpora. But it isn't always a win
and the cost for training dictionaries is too high to justify using
it outside of scenarios where you are pretty sure it will be beneficial.
When I do use it, I'm not sure which compression levels it works best
with, how many samples need to be fed into the dictionary trainer,
which training algorithm to use, etc. If that isn't enough, there is
also the concept of <em>content-only dictionaries</em> where you use a
fulltext as the dictionary. This can be useful for delta-encoding
schemes (where compression effectively acts like a diff/delta
generator instead of using something like Myers diff). If this topic
interests you, there is a
<a href="https://www.mercurial-scm.org/pipermail/mercurial-devel/2017-January/092186.html">thread on the Mercurial developers list</a>
where Yann Collet and I discuss this.</p>
<p>Fifth, the patent rights grant. (This paragraph is outdated as of August
2017, when Facebook updated the license.) There is some
<a href="https://github.com/facebook/zstd/blob/4ded9e591cbed57c54fc8f7a50412af5980e23a7/PATENTS#L14">wording in the PATENTS file</a>
in the Zstandard project that may... concern lawyers. While Zstandard
is covered by the standard BSD 3-Clause license, that supplemental
<code>PATENTS</code> file may scare some lawyers enough that you won't be able
to use Zstandard. You may want to talk to a lawyer before using
Zstandard, especially if you or your company likes initiating patent
lawsuits against companies (or wishes to reserve that right - as many
companies do), as that is the condition upon which the license
terminates. Note that there is a long history between Facebook and
consumers of its open source software regarding this language in the
<code>PATENTS</code> file. Do a search for <code>React patent grant</code> to read more.</p>
<p>Sixth and finally, Zstandard is still relatively new. I can totally
relate to holding off until something new and shiny proves itself.
That being said, the Zstandard framing protocol has some escape
hatches for future needs. And, the project proved during its pre-1.0
days that it knows how to handle backwards and future compatibility
issues. And considering Facebook and others are using Zstandard in
production, I wouldn't be too worried. I think the biggest risk is
to people (like me) who are writing code against the <em>experimental</em>
C APIs. But even then, the changes to the experimental APIs in the
past several months have been minor. I'm not losing sleep over it.</p>
<p>That may seem like a long and concerning list. Most of the issues are
relatively minor. The language in the <code>PATENTS</code> file may be a
showstopper to some. From my perspective, the biggest thing Zstandard has
going against it is its youth. But that will only improve with age.
While I'm usually pretty conservative about adopting new technology
(I've gotten burned enough times that I prefer the neophytes do the
field testing for me), the upside to using Zstandard is potentially
drastic performance and efficiency gains. And that can translate to
success versus failure or millions of dollars in saved infrastructure
costs and productivity gains. I'm willing to take my chances.</p>
<h2>Conclusion</h2>
<p>For the corpora I've thrown at it, Zstandard handily outperforms zlib
in almost every dimension. And, it even manages to best other <em>modern</em>
compression algorithms like brotli in many tests.</p>
<p>The underlying algorithm and techniques used by Zstandard are highly
parameterized, lending themselves to a variety of use cases from embedded
hardware to massive data crunching machines with hundreds of gigabytes
of memory and dozens of CPU cores.</p>
<p>The C API is well-designed and facilitates high performance and
adaptability to numerous use cases. It is <em>batteries included</em>,
providing functions to train dictionaries and perform multi-threaded
compression.</p>
<p>Zstandard is backed by Facebook and seems to have a healthy open source
culture <a href="https://github.com/facebook/zstd">on Github</a>. My interactions
with Yann Collet have been positive and he seems to be a great
project maintainer.</p>
<p>Zstandard is an exciting advancement for data compression and therefore
for the entire computing field. As someone who has lived in the world
of zlib for years, was a casual user of compression, and thought zlib
was <em>good enough</em> for most use cases, I can attest that Zstandard is
game changing. After being enlightened to all the advantages of
Zstandard, I'll never casually use zlib again: it's just too slow and
inflexible for the needs of modern computing. If you use compression,
I highly recommend investigating Zstandard.</p>
<p><em>(I updated the post on 2017-03-08 to include a paragraph about the
supplemental license in the <code>PATENTS</code> file.)</em></p>]]></content:encoded>
    </item>
    <item>
      <title>Mercurial, SHA-1, and Trusting Version Control</title>
      <link>http://gregoryszorc.com/blog/2017/02/28/mercurial,-sha-1,-and-trusting-version-control</link>
      <pubDate>Tue, 28 Feb 2017 12:40:00 PST</pubDate>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2017/02/28/mercurial,-sha-1,-and-trusting-version-control</guid>
      <description>Mercurial, SHA-1, and Trusting Version Control</description>
      <content:encoded><![CDATA[<p>The Internet went crazy on Thursday when Google
<a href="https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html">announced a SHA-1 collision</a>.
This has spawned a lot of talk about the impact of SHA-1 in version
control. Linus Torvalds (the creator of Git) weighed in on the
<a href="http://marc.info/?l=git&amp;m=148787047422954">Git mailing list</a> and on
<a href="https://plus.google.com/+LinusTorvalds/posts/7tp2gYWQugL">Google+</a>.
There are also posts like
<a href="http://www.metzdowd.com/pipermail/cryptography/2017-February/031623.html">SHA1 collisions make Git vulnerable to attakcs by third-parties, not just repo maintainers</a>
outlining the history of Git and SHA-1. On the Mercurial side,
Matt Mackall (the creator of Mercurial) authored a
<a href="https://www.mercurial-scm.org/wiki/mpm/SHA1">SHA-1 and Mercurial security article</a>.
(If you haven't read Matt's article, please do so now before
continuing.)</p>
<p>I'd like to contribute my own take on the problem with a slant towards
Mercurial and while also comparing Mercurial's exposure to SHA-1
collisions to Git's. Since this is a security topic, I'd like to
explicitly state that I'm not a cryptographer. However, I've worked on
a number of software components that do security/cryptography (like
Firefox Sync) and I'm pretty confident saying that my grasp on
cryptographic primitives and security techniques is better than the
average developer's.</p>
<p>Let's talk about Mercurial's exposure to SHA-1 collisions on a technical
level.</p>
<p>Mercurial, like Git, is <em>vulnerable</em> to SHA-1 collisions. Mercurial is
vulnerable because its logical storage mechanism (like Git's) indexes
tracked content by SHA-1. If two objects with differing content have the
same SHA-1, content under version control could be changed and detecting
that would be difficult or impossible. That's obviously bad.</p>
<p>But, Mercurial's exposure to SHA-1 collisions isn't as severe as Git's.
To understand why, we have to understand how each stores data.</p>
<p>Git's logical storage model is a content-addressable key-value store.
Values (<em>objects</em> in Git parlance) consist of a header identifying the
object type (commit, tree, blob, or tag), the size of the data (as a
string), and the raw content of the thing being stored. Common content
types are file content (blob), a list of files (tree), and a description
of a commit (commit). Keys in this blob store are SHA-1 hashes of objects.
All Git objects go into a single <em>namespace</em> in the Git repository's
<em>store</em>. A beneficial side-effect of this is data de-duplication: if the
same file is added to a Git repository, it's <em>blob</em> object will be
identical and it will only be stored once by Git. A detrimental
side-effect is that hash collisions are possible between any two objects,
irregardless of their type or location in the repository.</p>
<p>Mercurial's logical storage model is also content-addressable. However,
it is significantly different from Git's approach. Mercurial's logical
storage model allocates a separate sub-store for each tracked <em>path</em>.
If you run <code>find .hg/store -name '*.i'</code> inside a Mercurial repository,
you'll see these files. There is a separate file for each path
that has committed data. If you <code>hg add foo.txt</code> and <code>hg commit</code>, there
will be a <code>data/foo.txt.i</code> file holding data for <code>foo.txt</code>.
There are also special files <code>00changelog.i</code> and <code>00manifest.i</code> holding
data for commits/changesets and file lists, respectively. Each of these
<code>.i</code> files - a <a href="https://www.mercurial-scm.org/repo/hg/file/a185b903bda3/mercurial/help/internals/revlogs.txt">revlog</a> -
is roughly equivalent to an ordered collection of Git objects for a
specific tracked path. This means that Mercurial's store consists of
N discrete and independent namespaces for data. Contrast with Git's
single namespace.</p>
<p>The benefits and drawbacks are the opposite of those pointed out for
Git above: Mercurial doesn't have automatic content-based de-duplication
but it does provide some defense against hash collisions. Because each
logical path is independent of all others, a Mercurial repository will
happily commit two files with different content but same hashes. This
is more robust than Git because a hash collision is isolated to a single
logical path / revlog. In other words, a random file added to the
repository in directory <code>X</code> that has a hash collision with a file in
directory <code>Y</code> won't cause problems.</p>
<p>Mercurial also differs significantly from Git in terms of how the hash
is obtained. Git's hash is computed from raw content preceded by a header
derived directly from the object's role and size. (Takeaway: the header is
static and can be derived trivially.) Mercurial's hash is computed from
raw content preceded by a header. But that header consists of the 20 byte
SHA-1 hash(es) of the parent revisions in the revlog to which the content
is being added. This <em>chaining</em> of hashes means that the header is not
always static nor always trivially derived. This means that the same
content can be stored in the revlog under multiple hashes. It also means
that it is possible to store differing content having a hash collision
within the same revlog! But only under some conditions - Mercurial will
still barf in some scenarios if there is a hash collision within content
tracked by the revlog. This is different from Git's behavior, where the
same content <em>always</em> results in the same Git object hash. (It's worth
noting that a SHA-1 collision on data with a Git object header has not
yet been encountered in the wild.)</p>
<p>The takeaway from the above paragraphs is Mercurial's storage model
is slightly more robust against hash collisions than Git's because there
are multiple, isolated namespaces for storing content and because all
hashes are chained to previous content. So, when SHA-1 collisions
are more achievable and someone manages to create a collision for a
hash used by version control, Mercurial's storage layer will be able
to cope with that better than Git's.</p>
<p>But the concern about SHA-1 weakness is more about security than storage
robustness. The disaster scenario for version control is that an
attacker could replace content under version control, possibly
undetected. If one can generate a hash collision, then this is
possible. Mercurial's chaining of content provides some defense, but
it isn't sufficient.</p>
<p>I agree with <a href="https://www.mercurial-scm.org/wiki/mpm/SHA1">Matt Mackall</a>
that at the present time there are bigger concerns with content
safety than SHA-1 collisions. Namely, if you are an attacker, it is
much easier to introduce a subtle bug that contains a security
vulnerability than to introduce a SHA-1 collision. It is also
much easier to hack the canonical version control server (or any
user or automated agent that has permissions to push to the server)
and add a <em>bad</em> commit. Many projects don't have adequate defenses
to detect such <em>bad</em> commits. Ask yourself: if a bad actor pushed
a <em>bad</em> commit to my repository, would it be detected? Keep in mind
that spoofing author and committer metadata in commits is trivial.
<strong>The current state of Mercurial and Git rely primarily on trust -
not SHA-1 hashes - as their primary defense against malicious
actors.</strong></p>
<p>The desire to move away from SHA-1 has been on the radar of the
Mercurial project for years. For 10+ years, the <em>revlog</em> data
structure has allocated 32 bytes for hashes while only using 20 bytes
for SHA-1. And, the topic of SHA-1 weakness and desire to move to
something stronger has come up at the developer <em>sprints</em> for the
past several years. However, it has never been pressing enough to act
on because <em>there are bigger problems</em>. If it were easy to change, then
Mercurial likely would have done it already. But changing is not easy.
As soon as you introduce a new hash format in a repository, you've
potentially locked out all legacy versions of the Mercurial software
from accessing the repository (unless the repository stores multiple
hashes and allows legacy clients to access the legacy SHA-1 hashes).
There are a number of concerns from legacy compatibility (something
Mercurial cares deeply about) to user experience to even performance
(SHA-1 hashing even at 1000+MB/s floats to the top of performance
profiling for some Mercurial operations). I'm sure the topic will be
discussed heavily at the upcoming developers sprint in a few weeks.</p>
<p>While Mercurial should (and will eventually) replace SHA-1, I think
the biggest improvement Mercurial (or Git for that matter) can make
to repository <em>security</em> is providing a better mechanism for tracking
and auditing trust. Existing mechanisms for GPG signing every commit
aren't practical or are a non-starer for many workflows. And, they
rely on GPG, which has notorious end-user usability problems. (I would
prefer my version control tool not subject me to toiling with GPG.)
I've thought about this topic considerably, authoring a
<a href="https://www.mercurial-scm.org/wiki/CommitSigningPlan">proposal for easier and more flexible commit signing</a>.
There is also a related proposal to establish a
<a href="https://www.mercurial-scm.org/wiki/CommitCustodyConcept">cryptographically meaningful chain-of-custody for a patch</a>.
There are some good ideas there. But, like all user-facing
cryptography, the devil is in the details. There are some hard
problems to solve, like how to manage/store public keys that were
used for signatures. While there is some prior art in version control
tools (see Monotone), it is far from a solved problem. And at the
end of the day, you are still left having to trust a set of keys
used to produce signatures.</p>
<p>While version control can keep using cryptographically strong hashes
to mitigate collisions within its storage layer to prevent content
swapping and can employ cryptographic signatures of tracked data,
there is still the issue of trust. Version control can give you the
tools for establishing and auditing trust. Version control can also
provide tools for managing trust relationships. But at the end of the
day, the actual act of trusting trust boils down to people making
decisions (possibly through corporate or project policies). This
will always be a weak link. Therefore, it's what malicious actors
will attack. The best your version control tool can do is give its
users the capability and tools to run a secure and verifiable
repository so that when bad content is inevitably added you can't
blame the version control tool for having poor security.</p>]]></content:encoded>
    </item>
  </channel>
</rss>
