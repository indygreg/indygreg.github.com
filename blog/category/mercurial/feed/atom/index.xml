<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">Gregory Szorc's Digital Home</title>
  <subtitle type="text">Rambling on</subtitle>

  <updated>2014-06-23T18:49:18Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog" />
  <id>http://gregoryszorc.com/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://gregoryszorc.com/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Please Stop Using MQ]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2014/06/23/please-stop-using-mq" />
    <id>http://gregoryszorc.com/blog/2014/06/23/please-stop-using-mq</id>
    <updated>2014-06-23T11:50:00Z</updated>
    <published>2014-06-23T11:50:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Please Stop Using MQ]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2014/06/23/please-stop-using-mq"><![CDATA[<p>Are you a <a href="http://mercurial.selenic.com/">Mercurial</a> user?</p>
<p>Do you use the <a href="http://mercurial.selenic.com/wiki/MqExtension">mq</a>
extension? If so, please don't.</p>
<p>Why, you ask? Good question. The short version is that mq is a
solution spawned from version control techniques that were popular
over a decade ago. We have better tools now. mq is technologically
obsolete.</p>
<p>But if you want to know the full answer, keep reading.</p>
<h2>A history of Mercurial and mq</h2>
<p>The mq extension is just that: an extension to Mercurial's core
capabilities. (Mercurial consists of a core/basic feature set
supplemented by
<a href="http://www.selenic.com/hg/help/extensions">built-in</a> and
<a href="http://mercurial.selenic.com/wiki/UsingExtensions">3rd party</a>
extensions that provide more advanced or lesser used, niche
features.) Modern versions of Mercurial (if you aren't
running version 3.0+, please upgrade ASAP) are significantly
different from the Mercurial that necessitated the existence and
usage of the mq extension.</p>
<p>In the early days of Mercurial (Mercurial was
<a href="http://lkml.iu.edu//hypermail/linux/kernel/0504.2/0670.html">announced</a>
in April 2005), your choices for <em>branching</em> were not spectacular.
Your option in the core of Mercurial was to use Mercurial <em>branches</em>.
Mercurial branches are very heavy beasts. Branches are permanent.
If you change the branch a changeset (Mercurial's term for a commit)
is assciated with, the SHA-1 of that changeset changes. The takeaway
is Mercurial branches aren't very user friendly. That's why modern
versions of Mercurial print a warning when you create one:</p>
<pre><code>$ hg branch my-new-feature
marked working directory as branch my-new-feature
(branches are permanent and global, did you want a bookmark?)
</code></pre>
<p>Branches were and still are a relatively poor user experience
inside Mercurial, especially when compared to Git branches
(comparing Git and Mercurial branches is an apples to oranges
comparison: Mercurial branches are more synonymous with CVS or
Subversion branches). In defense of branches, they are good for
some roles, such as tracking release branches.
(Mozilla's <a href="https://hg.mozilla.org/releases/mozilla-aurora/">aurora</a>,
<a href="https://hg.mozilla.org/releases/mozilla-beta/">beta</a>,
<a href="https://hg.mozilla.org/releases/mozilla-release/">release</a>, etc
Firefox repositories should arguably be modeled as branches
instead of separate repositories.)</p>
<p>Further complicating the usability of branches in early versions
of Mercurial was the lack of commands to rewrite history.
Concepts such as rebasing or reordering patches were not
always available in Mercurial (or if they were there were
significant limitations). Today, this seems like an obvious
shortcoming of a version control system. But keep in mind the
state of version control around 2005-2007. CVS and Subversion
were the big players. Perforce, SourceSafe, TFS, etc were popular
in corporate settings. While I'm sure there were version control
systems at the time that supported rewriting history,
my recollection is that rewriting history did not <em>become a
thing</em> until Git rose in popularity (which I think was around
2008 or 2009). At that time, the concept of mutating past commits
was alien, if not absurd. Why would you want to lose data on what
you've already done? Isn't that the antithesis of a version control
system?! Git - and many of its concepts, including history
rewriting - were perceived as radical. It doesn't matter if they
borrowed the ideas from other tools: Git's newfound popularity
made them common and a new necessity. If you went from Git to
Subversion (or even Mercurial), the superiority of Git's
flexibility was obvious (although the UI was not so great, but
people can - and do - still cope).</p>
<p>It was under this renaissance of modern version control tools
in the late 2000's where mq became popular. But its popularity
was not because of the strength of mq: it was because of its
necessity.</p>
<p>mq was added to Mercurial in February 2006 and released as part of
Mercurial 0.8.1 in April 2006. As far as I can tell, at the time of
mq's release, mq was the only tolerable way to perform history
rewriting in Mercurial (<em>hg qref</em> and <em>hg qpush --move</em> are a
very crude method of history rewriting). Now, you could leverage
multiple Mercurial commands to give the illusion of history
rewriting, but it was very cumbersome. No sane person wanted to
deal with that. So mq was used.</p>
<p>The introduction of the <em>transplant</em> extension in the
Mercurial 0.9.2 release in December 2006 added another history
rewriting facility to Mercurial. The <em>transplant</em> command
effectively copies changesets between branches or heads.</p>
<p>The Mercurial 0.9.5 release in September 2007 introduced the
<em>record</em> extension. The <em>record</em> command provides interactive
and incremental commit support, similar to <em>git add -i</em>.
While <em>record</em> isn't strictly history rewriting, it provides
a very useful functionality for helping to produce separate,
smaller commits from a larger ongoing change.</p>
<p>The release of Mercurial 1.1 in December 2008 was - on paper at
least - an milestone for Mercurial. This release added the
<em>rebase</em> extension.  This introduced the <em>rebase</em> command,
which moves changesets (as opposed to <em>transplant</em>, which merely
copies them). Rebasing allowed you to pull remote changes and
then easily move your local changesets on top of the new changes,
among other things.</p>
<p>An even bigger feature added in Mercurial 1.1 was the <em>bookmarks</em>
extension. <a href="http://mercurial.selenic.com/wiki/Bookmarks">Bookmarks</a>
are Mercurial's lightweigh branches. Instead of permanent
association with a changeset, a bookmark is a movable label
attached to a changeset. They are very similar to Git branches.</p>
<p>The initial bookmarks feature was far from robust. You couldn't
push bookmarks and share them with others until Mercurial 1.6
in June 2010. It's worth noting that bookmarks became part of the
Mercurial core (as opposed to existing in an extension that must
be enabled) in Mercurial 1.8, released in March 2011.</p>
<p>Bookmarks, record, and rebase provided a decent framework for
history editing in Mercurial. But there were still some rough
edges, notably around making it easier to edit history: mq
was still easier to use for doing tasks like reordering patches.</p>
<p>It wasn't until Mercurial 2.2 in May 2012 that Mercurial
gained the ability to easily reorder patches using something
other than mq. It came via the <em>histedit</em> extension, which
provides the <em>histedit</em> command. This command provides a mechanism
to interactively edit history. It is very similar to <em>git rebase
--interactive</em>.</p>
<p>With the introduction of the <em>histedit</em> extension, you could
(finally) perform most of the more advanced repository
interaction workflows that mq allowed without using mq. Continue
reading the next section to learn why not using mq is important.</p>
<p>For Mozillians reading, it's worth noting that the conversion of
the Firefox source repository from CVS to Mercurial
<a href="http://soberbuildengineer.com/blog/2007/04/version-control-system-shootout-redux-redux/">occurred in March 2007</a>.
At that time, Mercurial had <em>mq</em> and <em>transplant</em> for
performing history rewriting. mq was thus the most convenient
method for rewriting history and managing individual patches
(a process Firefox development largely maintains to this day).
Thus, mq effectively became a de facto requirement for developing
Firefox patches. Despite mq being arguably unnecessary since
Mercurial 2.2's release in May 2012, mq is still widely used within
Mozilla. My perception is that most developers continue to use
mq. Furthermore, even new developers are still picking it up
instead of utilizing Mercurial's other commands for managing
changesets. FWIW, I believe many are so turned off by mq or
don't want to learn Mercurial or mq that they do their
day-to-day development in Git and only involve Mercurial
when doing the final push to the canonical Firefox Mercurial
repository.</p>
<p>Now that we learned why mq is popular, let's talk about why it
shouldn't be used any more.</p>
<h2>The hack that is mq</h2>
<p>In terms of architecture, mq is a giant hack: a wart on top of
Mercurial. The goal of every version control system is to track
changes over time. mq actively works against that.</p>
<p>At the core of every Mercurial repository is a <em>store</em> that
contains the repository data. The changesets in the repository
are logically represented as a directed acyclic graph (DAG).
When you run <em>hg commit</em>, <em>hg pull</em>, <em>hg import</em>, or any
command that introduces new changesets, new data is added to
the DAG and written to the store.</p>
<p>One of the most important properties of the store is that it is
supposed to be append-only: once data is added, it is never
removed. This property allows Mercurial to fulfill the <em>contract</em>
of version control systems, which is to keep track of data without
losing anything.</p>
<p>This append-only property is important because it means Mercurial
can know about all of the history for all of time. If you need to
perform a merge, Mercurial knows exactly what came before and thus
the most effective way to perform that merge. (It's worth noting
that merging can be quite complicated. All this extra data helps
do the merge correctly the first time, which means you can spend
your time writing code instead of resolving merge conflicts.)</p>
<p>The <em>"mq is a hack"</em> statement derives from how mq interacts with
Mercurial's store. Your mq <em>patch queue</em> is effectively an overlay
over Mercurial's built-in store that is in an ever-changing state
of partial application. When you <em>hg qpush</em> to apply a patch from
the <em>patch queue</em>, you effectively do an <em>hg import</em> to <em>import</em>
a Mercurial changeset file into the core Mercurial store. That's
mostly fine. But when you <em>hg qpop</em> (unapply a patch from mq), you
are effectively asking Mercurial to delete a changeset and all
data associated with it from the core Mercurial store. In other
words, <em>qpop</em> breaks the ideal append-only property of the
Mercurial store: <em>qpop</em> forces Mercurial to delete data and lose
track of history. This makes Mercurial very sad.</p>
<p>Because you are throwing away repository data, merges become much
harder. This means you spend more of your time dealing with
resolving conflicts. To further complicate that, the mq code paths
for performing merges and conflict resolution aren't as robust as
those used by, say, <em>hg rebase</em> and <em>hg histedit</em>. So if you use mq,
you are pretty much guaranteed a poorer conflict resolution process.
This means you spend more of your time wrestling with tools instead
of, you know, actually doing something productive.</p>
<p>Deleting repository data by unapplying patches via mq also has
negative performance implications. Given a large enough repository
(such as Firefox's - it currently has ~200,000 changesets), these
performance issues can result in severely degraded performance.
An extreme example of this is Mozilla's
<a href="https://hg.mozilla.org/try/">Try repository</a>. The
<a href="http://bke.ro/?p=386">runaway process/CPU issues leading to outages</a>
is due to a
<a href="http://bz.selenic.com/show_bug.cgi?id=4255">known Mercurial issue</a>
dealing with inefficient handling of stores that aren't append-only.
When you use mq, you risk running into the same issues. Although the
performance implication should hopefully be a magnitude or two less
pronounced than what Mozilla's Try repository experiences.</p>
<p>In theory, mq could compensate for deletion of data from Mercurial's
core store by retaining that data itself. But it doesn't. This leads
to yet more reasons why you shouldn't use mq.</p>
<p>mq throws away perfectly fine history data. When you <em>hg qrefresh</em>,
your current patch is overwritten with the new one. The old version
is discared. This actively works against the goal of a version
control system to record history. Have you ever started down a path
and realized a few commits later that you need to throw it away and
backtrack to a few commits back? I do that all the time. If you
<em>qrefresh</em>, tough luck: you've lost your history. If only the
history store was append-only.</p>
<p>(In fairness to mq, the patch queue maintained by mq is itself a
Mercurial repository and can be committed to, preventing history
loss. The <a href="https://hg.mozilla.org/hgcustom/version-control-tools/file/36eb33f9058d/hgext/mqext/README.txt">mqext extension</a>
even provides a mechanism for automatically committing the patch
queue repo during <em>qrefresh</em> and other mutation events. But as we
will see, even with this, mq is not perfect.)</p>
<p>mq also fails to adequately update patches when they are moved
around. Little known fact: mq patches have their parent changeset
encoded in them. If you run <em>hg qpush --exact</em>, Mercurial will apply
the patch against the parent changeset it was actually created
against, as opposed to the current work directory changeset. In
theory, you should never encounter conflicts when
applying patches this way. Because Mercurial's changeset SHA-1s
are dependent on content (like Git), if 23d165967da3 is the
child of d5741ada659d, then there should be absolutely no way
that 23d165967da3 should fail to apply directly to d5741ada659d.
The problem is that mq fails to update the parent changeset when
you push patches on top of a new parent! e.g.</p>
<div class="pygments_murphy"><pre># Let&#39;s create a root commit.
$ echo &#39;foo&#39; &gt; foo
$ hg commit -A -m &#39;initial commit&#39;
adding foo
$ hg log
changeset:   0:23d165967da3
user:        Gregory Szorc &lt;gps@mozilla.com&gt;
date:        Sun Jun 22 13:48:05 2014 -0700
summary:     initial commit
</pre></div>

<p>Notice the changeset of that commit. <em>023d165...</em>.</p>
<p>Now let's create a new mq patch.</p>
<div class="pygments_murphy"><pre>$ echo &#39;patch 1&#39; &gt; foo
$ hg qnew -m &#39;make mq patch 1&#39; p1

# Creating an mq patch creates a file in .hg/patches.
$ cat .hg/patches/p1
# HG changeset patch
# Parent 23d165967da39e5846976eb6ed967f1058827ffa
# User Gregory Szorc &lt;gps@mozilla.com&gt;
make p1

diff --git a/foo b/foo
--- a/foo
+++ b/foo
@@ -1,1 +1,1 @@
-foo
+patch 1
</pre></div>

<p>Notice how the parent is listed as the changeset in Mercurial's core
store.</p>
<p>Now let's pop that patch, create a new commit, and push the old mq
patch.</p>
<div class="pygments_murphy"><pre>$ hg qpop
popping p1
patch queue now empty

$ echo &#39;bar&#39; &gt; bar
$ hg commit -A -m &#39;second commit&#39;
adding bar

$ hg log
changeset:   1:d5741ada659d
tag:         tip
user:        Gregory Szorc &lt;gps@mozilla.com&gt;
date:        Sun Jun 22 13:48:37 2014 -0700
summary:     second commit

changeset:   0:23d165967da3
user:        Gregory Szorc &lt;gps@mozilla.com&gt;
date:        Sun Jun 22 13:48:05 2014 -0700
summary:     initial commit

$ hg qpush
applying p1
now at: p1

$ hg log --graph
@ changeset:   2:64851294d038
| tag:         p1
| tag:         qbase
| tag:         qtip
| tag:         tip
| user:        Gregory Szorc &lt;gps@mozilla.com&gt;
| date:        Sun Jun 22 14:27:55 2014 -0700
| summary:     make mq patch 1
|
o changeset:   1:d5741ada659d
| tag:         qparent
| user:        Gregory Szorc &lt;gps@mozilla.com&gt;
| date:        Sun Jun 22 13:48:37 2014 -0700
| summary:     second commit
|
o changeset:   0:23d165967da3
  user:        Gregory Szorc &lt;gps@mozilla.com&gt;
  date:        Sun Jun 22 13:48:05 2014 -0700
  summary:     initial commit
</pre></div>

<p>We see our mq patch is now applied on top of the second commit,
<em>d5741ada659d</em> because it was pushed while the working directory
was sitting at <em>d5741ada659d</em>.</p>
<p>But let's see what mq says:</p>
<div class="pygments_murphy"><pre>$ hg cat .hg/patches/p1
# HG changeset patch
# Parent 23d165967da39e5846976eb6ed967f1058827ffa
# User Gregory Szorc &lt;gps@mozilla.com&gt;
make p1

diff --git a/foo b/foo
--- a/foo
+++ b/foo
@@ -1,1 +1,1 @@
-foo
+patch 1
</pre></div>

<p>mq still says <em>23d165967da3</em> is the parent, even though we changed the
parent! mq is lying to us! Now, we
can rectify the situation by running <em>hg qrefresh</em>. That will cause mq
to regenerate the patch file, which will pick up the new parent. But
who does that? Unless you need to qrefresh to resolve conflicts or
other changes, nobody. This means that if you distribute the patch -
say you are uploading it for review - the parent changeset may not
be accurate and anyone applying that patch may apply it to the wrong
changeset and get unexpected results. That's no good.</p>
<p>For what it's worth, this behavior of not auto refreshing patches
is by design. We don't necessarily want application to be a mutating
operation, especially since mq repositories aren't automatically
versioned. This is partially because mq was effectively designed to be
<a href="https://savannah.nongnu.org/projects/quilt">quilt</a> built into
Mercurial. And <em>quilt</em> is a tool that was invented before the modern
version control tools era. mq's behavior is influenced more from
emulating <em>quilt</em> than from the desire to facilitate a sane
patch/stack/feature based workflow. If you ever wanted to know why
mq works the way it does and not like something more modern, that's
why.</p>
<p>Another huge reason to not use mq is because its concepts and
workflows are alien to modern and well-understood practices. While
I'm a huge fan of Mercurial and prefer it over Git (read my
<a href="/blog/2013/05/12/thoughts-on-mercurial-%28and-git%29/">thoughts on the topic</a>),
I don't pretend that Git isn't the most widely used version control
software right now (at least in the open source world).
It got that way despite its horrible
<a href="http://stevelosh.com/blog/2013/04/git-koans/">UI shortcomings</a>.
I argue its rise was because people enjoy workflows such
as lightweight branches and fast, often-simple merging.
(GitHub and its fairly good web UI certainly helped the cause.)
People today know Git. They know lightweight branches. I think
they largely understand the concept of repositories with multiple
heads and grok how a distributed version control system means you can
commit locally without affecting a remote (server). They grok
how can you push local commits to a remote (sometimes in the
form of a pull request). mq doesn't work this way - the way that
people have come to expect from Git. There are
<a href="https://en.wikipedia.org/wiki/List_of_cognitive_biases">cognitive biases</a>
that lead us to believe that because mq is different (from Git)
that it is inferior. Why should someone apply and unapply
individual patches on a temporary queue (or stack depending on how
you think about it) instead of working with <em>branches</em>? If someone
groks Git and multiple heads/branches/bookmarks, why should they
go through all the trouble of learning mq? The fact that mq
doesn't work as well as non-mq mechanisms is icing on the
figurative cake.</p>
<p>If the reasons I've listed are not enough, know this: mq users
will not able to fully utilize the game-changing
<a href="http://mercurial.selenic.com/wiki/ChangesetEvolution">Changeset Evolution</a>
feature of Mercurial. Remember in the late 2000's when people
thought Git was crazy for allowing you to mutate history - the
antithesis of version control because it threw away data? Changeset
Evolution and obsolescence markers - the mechanism used to enable
Changeset Evolution - are Mercurial's answer to that. They enable
Mercurial to retain metadata about previous changesets and how they
<em>evolved</em> into newer changesets. That criticism about history
rewriting deleting history: Changeset Evolution makes it largely
go away. A light version of the history of past commits is preserved
and propagated during push and pull operations.</p>
<p>Changeset Evolution changes the game much like Git changed the
landscape of version control in the late 2000's. So much of our
notions of how modern version control work are based on the
<em>current</em> behavior of tools. For example, any Git user will tell
you, <em>never git push --force</em>.
<a href="https://groups.google.com/forum/#!searchin/jenkinsci-dev/force$20push/jenkinsci-dev/-myjRIPcVwU/mrwn8VkyXagJ">Bad things will happen</a>.
Why do they say that? They say that because the user experience of
distributed history rewriting in Git can be horrible and error prone.
And it is like this because Git's implementation of history rewriting
burns the old books of history once they are translated to the
new world order. (OK, to be fair to Git it does have a reflog that
can kinda sorta be used to recover in disaster scenarios. But it's
far from robust and there are numerous caveats, notably that the
reflog is not part of data distributed with push/fetch and therefore
susceptible to single/few points of failure.) Mercurial's
obsolescence markers, by contrast, leave footnotes in our history
books and transfer these annotations as part of the distributed
repository data. Changeset Evolution uses these footnotes to
reconstruct the pages of history, even if they differ
from our own perspective. For example, you can force push rewritten
history and other clients can recover from that automagically. Want
to do complex history rewriting and force push?
Go right ahead: Mercurial and Changeset Evolution will
enable you to work without imposing as many (practical)
restrictions on your workflow as other tools. Good tools are flexible
and impose fewer restrictions. This is why Mercurial and Changeset
Evolution have the potential to change the world of version control
much like Git changed things half a decade ago.</p>
<p>Are you still not convinced mq is a bad idea? Know this: a
Mercurial core developer
<a href="http://www.selenic.com/pipermail/mercurial-devel/2014-June/059535.html">recently proposed marking mq as deprecated</a>.
That's right: there's very little love for mq within the Mercurial
Project. Maintainers generally think what I've stated in this post:
mq is yesterday's solution to yesterday's problem and it should
be cast aside.</p>
<p>If you are a mq user, I hope you are now convinced that mq is a bad
idea and you should transition away from it as soon as possible. In
the next section, I'll talk about moving off mq.</p>
<h2>Moving away from mq</h2>
<p>I completely abandonded mq in December 2013 and am never using it
again. In hindsight, I should have made the transition much sooner.</p>
<p>I could write an entire post about my workflow. Since this post is
already a bit long, I'm going to describe it with mostly command
line examples.</p>
<p>I use bookmarks for managing my <em>feature branches</em>. I use one
bookmark per logical feature. This workflow is very similar to
using Git branches.</p>
<div class="pygments_murphy"><pre># Create a new bookmark for the new feature I&#39;m developing.
$ hg bookmark gps/my-new-feature

# make changes to files
(gps/my-new-feature) $ hg commit
# make more changes)
(gps/my-new-feature) $ hg commit
# keep making small changes
(gps/my-new-features) $ hg commit

# I decide I want to reorder or merge a few commits. I look at the
# DAG to see which changeset to rewrite.
(gps/my-new-features) $ hg log --graph

(gps/my-new-feature) $ hg histedit 5e907ed10e22
# this opens an editor where I can say what changes to make)

# Let&#39;s start a new feature.
(gps/my-new-feature) $ hg up central
(leaving bookmark gps/my-new-feature)
$ hg bookmark gps/feature2
# Make some changes
(gps/feature2) $ hg commit

# I got review on my original feature. Let&#39;s push it.
(gps/feature2) $ hg up gps/my-new-feature
(activating bookmark gps/marionette-restart)

(gps/my-new-feature) $ hg pull gecko
pulling from http://hg.stage.mozaws.net/gecko
searching for changes
adding changesets
adding manifests
adding file changes
added 118 changesets with 543 changes to 328 files (+1 heads)
OBSEXC: pull obsolescence markers
OBSEXC: looking for common markers in 215590 nodes
OBSEXC: no unknown remote markers
OBSEXC: DONE
updating bookmark aurora
updating bookmark b2g28
updating bookmark b2ginbound
updating bookmark beta
updating bookmark central
updating bookmark esr24
updating bookmark fx-team
updating bookmark inbound
updating bookmark release
(run &#39;hg heads .&#39; to see heads, &#39;hg merge&#39; to merge)

(gps/my-new-feature) $ hg rebase -d fx-team

# Verify I&#39;m about to push what I want to push.
(gps/my-new-feature) $ hg out -r . fx-team

# And push the changes.
(gps/my-new-feature) $ hg push -r . fx-team

# And delete the bookmark that I don&#39;t need any more.
(gps/my-new-feature) $ hg bookmark -d gps/my-new-feature
</pre></div>

<p>That's how bookmarks work. If you upgrade to Mercurial 3.0 or newer,
Mercurial will print messages when you enter and leave bookmarks. This
is a great UI improvement!</p>
<p>I also have the
<a href="http://mercurial.selenic.com/wiki/PromptExtension">prompt extension</a>
installed and configured so my shell prompt contains the active
bookmark. This helps me keep track of what head I'm committing to.</p>
<p>I'm also a user of the experimental
<a href="http://mercurial.selenic.com/wiki/EvolveExtension">evolve extension</a>.
This is the extension that is implementing the <em>Changeset Evolution</em>
feature. Eventually the functionality will be merged into core
Mercurial. One such workflow with <em>evolve</em> is as follows.</p>
<div class="pygments_murphy"><pre># Create a bookmark for a new feature
$ hg bookmark gps/my-new-feature

# Make some changes.
(gps/my-new-feature) $ hg commit -m &#39;first commit&#39;

# Make some more changes.
(gps/my-new-feature) $ hg commit -m &#39;second commit&#39;

# Submit code for review. (Exact commands excluded.)

# Wait for review comments. There is a nit on the first commit.
$ hg previous
[204142] first commit

# Make changes
$ hg amend
1 new unstable changesets

# (amend is provided by evolve. It is equivalent to hg commit --amend)

# evolve is the command that looks at the history rewriting markers
# and knows how to rebase, etc other changesets in the face of
# rewriting.
$ hg evolve
move:[204143] second commit
atop:[204144] first commit
merging foo
warning: conflicts during merge.
merging foo incomplete! (edit conflicts, then use &#39;hg resolve --mark&#39;)
evolve failed!
fix conflict and run &quot;hg evolve --continue&quot;
abort: unresolved merge conflicts (see hg help resolve)

# Manually address conflict markers in file &quot;foo&quot;
$ hg resolve -m foo
no more unresolved files

$ hg evolve --continue
grafting revision 204143

# And I&#39;m ready to push.
</pre></div>

<p>If you really love the concept of mq and patch queues and absolutely
must do development that way (as opposed to bookmarks/branches), then
you should consider using the
<a href="http://mercurial.selenic.com/wiki/ShelveExtension">shelve extension</a>
instead of mq. While shelve is still a bit hacky in that it violates the
append-only goal of the Mercurial store, it does so in a way that
integrates much better than mq. For example, when you <em>unshelve</em>,
the changesets will only apply to the parent changeset they were
last attached to. You will get no merge conflicts during <em>unshelve</em>. If
you want to rebase, you will need to use the <em>rebase</em> command, which
will go through Mercurial's more robust merging code paths, leaving
conflict markers instead of <em>.rej</em> files
(assuming you are using the <em>internal</em>
<a href="http://mercurial.selenic.com/wiki/MergeToolConfiguration">merge tool</a>).
Shelve also groups multiple changesets together. Contrast with
mq's default behavior of a flat list of patches (my mq queue grew
to over 100 patches with patches belonging to dozens of bugs).
Shelve is all around a better mq and is a good compromise between
the stack/queue based development workflow of mq with the more modern
development workflow of bookmarks. If nothing else, shelve integrates
much better into the Mercurial core. As a quantitative measurement
of this, mq weighs in
at <a href="http://selenic.com/repo/hg/file/cd3c79392056/hgext/mq.py">3461</a>
lines. Shelve, by comparison, is a svelt
<a href="http://selenic.com/repo/hg/file/cd3c79392056/hgext/shelve.py">704 lines</a>.
Considering they do nearly the same thing (shelve offloads functionality
like folding and reordering to core Mercurial commands that didn't
exist at the time of mq's inception), I trust shelve with its reduced
surface area to be more robust and bug free.</p>
<p>But as good as shelve is, it's still not as integrated as bookmarks
or branches. If you can, try to stick to the Mercurial core
features and avoid shelve. But whatever you do, try to avoid mq!</p>
<h2>Conclusion</h2>
<p>I never used Mercurial before becoming an employee of Mozilla
and a contributor to Firefox. I was a mq user for my first two plus
years of Mercurial use. I blindly followed the Mozilla
documentation and advice of my fellow Mozillians to use mq.
It wasn't until I truly invested in learning Mercurial (as
opposed to learning merely the command line interface - the
minimum required for me to contribute to Firefox) that I
realized how wrong the common Mozilla mindset about Mercurial
and mq was. I was incorrectly associating mq with <em>"The Mercurial
Way"</em> and thought Mercurial was inherently lacking. I knew
about branches and bookmarks, but didn't realize I could use
them as an alternative to mq.</p>
<p>Only after learning Mercurial's internals, contributing patches to
the Mercurial core, and reading the changelog of the Mercurial
project itself did I realize the truth: <strong>mq's popularity is a
result of historical necessity that no longer exists; and, continued
usage of mq represents a general failure in user eduction about
mq's drawbacks and Mercurial's modern features.</strong> In other words,
the more informed I became, the more I learned what a bad idea
mq is and why it should be avoided.</p>
<p>At Mozilla, we happened to switch to Mercurial at a time (2007) when
mq was the only reasonable solution available to Mercurial. The
procedures and documentation developed in 2007 have persisted to
2014, largely ignoring advancements in Mercurial over that time.
To be fair to my fellow Mozillians and Mercurial users everywhere,
Mercurial wasn't truly ready to jettison mq until the <em>histedit</em>
extension came into existence a few years ago. But that was
<em>years</em> ago. We all should have had time to switch, but we haven't.
Or if we have, we've switched to Git. (And I can't blame anyone for
switching to Git - both its mind share and the network effect of
GitHub are <em>very</em> compelling reasons.)</p>
<p>I hope you now know why mq is a bad idea. Please join me in realizing
that mq was a solution for yesterday's problems. mq is a legacy tool
that loses data and makes your life harder. It's time to let go of
the past and embrace the future. Please join me in shaving the mq
neck beard that has been growing since CVS was a popular version
control system.</p>
<h2>Addendum on Code Review</h2>
<p>While I've wanted to write this post for a while, the trigger for me
finally writing it is my work on integrating Mercurial with the
<a href="http://www.reviewboard.org/">Review Board</a> code
review software. The Bugzilla Team at Mozilla is working on a project
to integrate Review Board into Bugzilla for code review, supplementing
the antiquated-by-comparison Splinter code review feature.
Instead of uploading patches to Bugzilla - how Mozilla and Firefox
development has done it for over a decade - you will push changesets
to a Mercurial repository and pushed
changesets will automatically turn into code reviews on Review
Board and get cross-posted to referenced Bugzilla bugs.</p>
<p>This is all part of a larger goal to make it easier for patches to be
submitted and landed consistently and centrally. This should lead to
various automation and tooling improvements, such as bots conducting
aspects of code review and automatically landing reviewed patches.</p>
<p>These things are very difficult to do in a Bugzilla-only and patch-based
world because it is difficult to first aggregate patches and second
process them in a unified manner. Patches come in many different
flavors. You have Mercurial style diffs.
You have plain patches, and patches with Git or Mercurial style
annotation.  You have different lines of context in the patch.
You have different handling of binary content. You have mq lying
about the parent changeset. All these contribute
to a massive impedance mismatch of sorts that makes it extremely
difficult to roll out any kind of automation. Any tools built on
top must first solve a very difficult data normalization and
distribution problem. These are problems that should not exist and
drastically raise the barrier to forward progress.</p>
<p>Contrast this with pushing to Mercurial (or Git) repositories. The
repository is the data, not the patch file. Clients are able to
extract variations of that data however they see fit. Commit
data is centralized, distributable, and unified. There are dozens
of existing tools and services that already know how to speak
with repositories. Our data problem not only goes away, but
many solutions have already been invented for us.</p>
<p>Back to Review Board.</p>
<p>I've written an <a href="https://hg.mozilla.org/hgcustom/version-control-tools/file/default/hgext/reviewboard">extension</a>
that pushes review-specific metadata to the Mercurial server. This
effectively allows Mercurial to <em>speak</em> code review and interact
with the code review server. For Mercurial clients that are writing
obsolescence markers, we are able to <em>track</em> the changesets
undergoing review against their logical successors. For example,
if you pull and rebase, this will rewrite changeset X to changeset Y
(because the SHA-1 changes). Mercurial knows that a) changeset X was
under review and b) Y is the new version of X. So, when you push
Y for code review, the review associated with X is updated
automagically. You could accomplish this with heuristic-based
matching or user prompting, but these are error prone (you wouldn't
believe the number of corner cases) or require excessive user
time, especially when complex history rewriting is involved.
Mercurial's obsolescence markers allow the matching to <em>just work</em>
in most scenarios and for people to spend more time writing and
reviewing code as opposed to telling the code review tool what
and how to review.</p>
<p>As I was implementing this extension, I realized that mq users
(most Mercurial users at Mozilla I reckon) would be unable to reap the
benefits of all this magic because, well, they are using mq. I care
passionately about developer productivity. Good tools are the tools
that don't require constant massaging. I want everyone to get the
full benefits of Mozilla's new code review system when it launches.
And the only way that happens is if people stop using mq. And the
only way that happens is if people learn why mq is a bad idea. So
if nothing else has convinced you to stop using mq yet, maybe the
lure of an amazing and automagical code review and collaboration
experience will sway you.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Using Mercurial for Status Reports]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2014/04/01/using-mercurial-for-status-reports" />
    <id>http://gregoryszorc.com/blog/2014/04/01/using-mercurial-for-status-reports</id>
    <updated>2014-04-01T12:30:00Z</updated>
    <published>2014-04-01T12:30:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Using Mercurial for Status Reports]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2014/04/01/using-mercurial-for-status-reports"><![CDATA[<p>Mercurial has a pair of amazing features called
<a href="http://www.selenic.com/hg/help/revsets">Revisions Sets</a>
and <a href="http://www.selenic.com/hg/help/templates">Templates</a>. Combined,
they allow you to query Mercurial like a database and to generate custom
reports from obtained data.</p>
<p>As I've <a href="/blog/2013/11/08/using-mercurial-to-query-mozilla-metadata/">demonstrated</a>,
you can write Mercurial extensions to provide custom revision set
queries and template functions and keywords. My
<a href="https://hg.mozilla.org/hgcustom/version-control-tools/file/default/hgext/mozext">mozext</a>
extension aggregates Mozilla's <em>pushlog</em> data into a local SQLite
database and makes this data available to revision sets and templates.</p>
<p>My hack of the day is to use revision sets and templates to create a
weekly status report:</p>
<div class="pygments_murphy"><pre>hg log -r &#39;public() and me() and firstpushdate(&quot;-7&quot;)&#39; \
--template &#39;* {ifeq(reviewer, &quot;gps&quot;, &quot;Review: &quot;, &quot;Landing: &quot;)}{firstline(desc)}\n&#39;
</pre></div>

<p>When I run this, I get the output:</p>
<div class="pygments_murphy"><pre>* Review: Bug 957241 - Don&#39;t package the full sdk when we don&#39;t need it. r=gps
* Review: Bug 987146 - Represent SQL queries more efficiently. r=gps.
* Review: Bug 987984 - VirtualenvManager.call_setup() should use self.python_path instead of sys.executable, r=gps
* Landing: Bug 987398 - Part 1: Run mochitests from manifests with mach; r=ahal
* Landing: Bug 987398 - Part 2: Handle install-to-subdir in TestResolver; r=ahal
* Landing: Bug 987414 - Pass multiple test arguments to mach testing commands; r=ahal
* Review: Bug 988141 - Clean up config/recurse.mk after bug 969164. r=gps
* Landing: Bug 973992 - Support experiments add-ons; r=Unfocused
* Review: Bug 927672 - Force pymake to fall back to mozmake when run on build slaves. r=gps
* Review: Bug 989147 - Use new sccache for Linux and Android builds. r=gps
* Review: Bug 989147 - Add missing part of the patch from rebase conflict. r=gps
* Landing: Bug 975000 - Disable updating and compatibility checking for Experiments; r=Unfocused
* Landing: Bug 985084 - Experiment add-ons should be disabled by default; r=Unfocused
* Landing: Backed out changeset 4834a3833639 and c580afddd1cb (bug 985084 and bug 97500)
* Landing: Bug 975000 - Disable updating and compatibility checking for Experiments; r=Unfocused
* Landing: Bug 985084 - Experiment add-ons should be disabled by default; r=Unfocused
* Landing: Bug 989137 - Part 1: Uninstall unknown experiments; r=Unfocused
* Landing: Bug 989137 - Part 2: Don&#39;t use a global logger; r=gfritzsche
* Landing: Bug 989137 - Part 3: Log.jsm API to get a Logger that prefixes messages; r=bsmedberg
* Landing: Bug 989137 - Part 4: Use a prefixing logger for Experiments logging; r=gfritzsche
* Landing: Bug 989137 - Part 5: Prefix each log message with the instance of the object; r=gfritzsche
* Review: Bug 988849 - Add mach target for jit tests; r=gps
* Landing: Bug 989137 - Part 6: Create experiment XPIs during the build; r=bsmedberg
* Landing: Bug 989137 - Part 7: Remove unncessary content from test experiments; r=Unfocused
* Landing: Bug 985084 - Part 2: Properly report userDisabled in the API; r=Unfocused
</pre></div>

<p>Which I can then copy and paste directly into the
<a href="http://benjamin.smedbergs.us/weekly-updates.fcgi/">status tool</a> to
capture all my weekly code contributions! That takes a few seconds to
run and saves me a few minutes of typing.</p>
<p>For the curious, let's break that Mercurial command down.</p>
<ul>
<li>public() selects all <em>public</em> changesets. These are changesets in the
  repository that have been pushed to a publishing repository. In other
  words, patches that landed in Firefox.</li>
<li>me() is a custom revset from my <em>mozext</em> extension that parses the
  commit message and selects changesets that I authored or reviewed.</li>
<li>firstpushdate("-7") is a custom revset from my <em>mozext</em> extension. It
  selects changesets that were first pushed in the last 7 days (using
  pushlog data stored in a local SQLite database).</li>
</ul>
<p>The template piece should be easy to read. I have a simple branch
testing whether the changeset is a review or not, then output a label
followed by the first line of the commit message.</p>
<p>I have this command saved under the <em>[alias]</em> section of my <em>~/.hgrc</em>
file so I can just type <em>hg statusreport</em>.</p>
<p>While there is room to improve the tool (stripping <em>r=</em> lines from
commit messages for example), I think it's a pretty cool hack and shows
how Mercurial can grow to solve problems you don't think your version
control system knows how to solve.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[New Repository for Mozilla Version Control Tools]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2014/02/05/new-repository-for-mozilla-version-control-tools" />
    <id>http://gregoryszorc.com/blog/2014/02/05/new-repository-for-mozilla-version-control-tools</id>
    <updated>2014-02-05T19:15:00Z</updated>
    <published>2014-02-05T19:15:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Git" />
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[New Repository for Mozilla Version Control Tools]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2014/02/05/new-repository-for-mozilla-version-control-tools"><![CDATA[<p>Version control systems can be highly useful tools.</p>
<p>At Mozilla, we've made numerous improvements and customizations to our
version control tools. We have <a href="https://hg.mozilla.org/hgcustom/hghooks/">custom hooks</a>
that run on the server. We have a <a href="https://hg.mozilla.org/hgcustom/hg_templates/">custom skin</a>
for Mercurial's web interface. Mozillians have written a handful of
Mercurial extensions to aid with common developer tasks, such as
<a href="https://bitbucket.org/sfink/trychooser">pushing to try</a>,
<a href="https://hg.mozilla.org/users/tmielczarek_mozilla.com/bzexport">interacting with Bugzilla</a>,
<a href="https://bitbucket.org/sfink/mqext">making mq more useful</a>, and more.</p>
<p>These have all come into existence in an organic manner, one after the
other. Individuals have seen an itch and scratched it. Good for them.
Good for Mozilla.</p>
<p>Unfortunately, the collection of amassed tools has become quite large.
They have become difficult to discover and keep up to date. The
consistency in quality and style between the tools varies. Each tool has
separate processes for updating and changing.</p>
<p>I contacted the maintainers of the popular version control tools at
Mozilla with a simple proposal: let's maintain all our tools under one
repo. This would allow us to increase cohesion, share code, maintain a
high quality bar, share best practices, etc. There were no major
objections, so we now have a <a href="https://hg.mozilla.org/hgcustom/version-control-tools/">unified repository</a>
containing our version control tools!</p>
<p>Currently, we only have a few Mercurial extensions in there. A goal is
to accumulate as much of the existing Mercurial infrastructure into
that repository as possible. Client code. Server code. All of the code.
I want developers to be able to install the same hooks on their clients
as what's running on the server: why should your local repo let you
commit something that the server will reject? I want developers to be
able to reasonably reproduce Mozilla's canonical version control server
configuration locally. That way, you can test things locally with a high
confidence that your changes will work the same way on production. This
allows deployments to move faster and with less friction.</p>
<p>The immediate emphasis will be on moving extensions into this repo and
deprecating the old homes on user repositories. Over time, we'll move
into consolidating server code and getting hg.mozilla.org and
git.mozilla.org to use this repository. But that's a lower priority: the
most important goal right now is to make it easier and friendlier for
people to run productivity-enhancing tools.</p>
<p>So, if you see your Mercurial extensions alerting you that they've been
moved to a new repository, now you know what's going on.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[The Mercurial Revlog]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2014/02/05/the-mercurial-revlog" />
    <id>http://gregoryszorc.com/blog/2014/02/05/the-mercurial-revlog</id>
    <updated>2014-02-05T16:26:00Z</updated>
    <published>2014-02-05T16:26:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[The Mercurial Revlog]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2014/02/05/the-mercurial-revlog"><![CDATA[<p>Mercurial stores lots of its data in append-only,
intended-to-be-immutable data structures called <em>revlogs</em>. Each revlog is
backed by a file on the filesystem. The main component of a revlog
is a <em>revision</em>. When a new revision arrives, its content is compared
against the previous revision in the file and a zlib-compressed
delta/diff is generated. If the delta is smaller than the entry
itself, the delta is appended to the revlog. If the compressed delta
itself or the stream of deltas that must be applied to recreate the
original text is larger than the source text, the compressed full content
is appended to the revlog. In other words, Mercurial tries to maintain
a balance between file size/growth rate and read times in terms of
both I/O and CPU.</p>
<p>The <em>changelog</em> is a <em>revlog</em> that holds information about every
changeset/commit in the repository. The <em>manifest</em> is a <em>revlog</em> that
holds details about which files are present in every changeset. There
exist a separate <em>revlog</em> for each file/path ever present in the
repository. These are called <em>filelogs</em>.</p>
<p>When you commit a change touching a single file, Mercurial will append
a revision to the changelog describing the commit, a revision to the
manifest describing the set of files active in that specific commit,
and a new revision to a filelog.</p>
<p>You can poke around your repository's revlogs by running some debug
commands. For example:</p>
<pre><code># Show high-level information about the manifest revlog
$ hg debugrevlog -m

# Show details about each entry in the manifest revlog (this
# actually reads data from an index to the data revlog - pretend
# there aren't index files for now)
$ hg debugindex -m

# Dump the content of a single entry in the changelog.
$ hg debugdata -c 2
</code></pre>
<p>I'm generally a big fan of append-only data structures because I love
the beneficial caching properties and linear I/O performance.
Mercurial and the revlog can take advantage of these properties for
some performance wins under key scenarios, especially server
operation (pushing commits doesn't necessarily invalidate cached revlog
entries, allowing the page cache to service many reads).</p>
<h2>Edge cases and deficiencies</h2>
<p>As with any system trying to solve a complex problem, the revlog
storage format doesn't always work as well as intended.</p>
<p>Let's start by taking by looking at how revlogs do delta storage. I said
earlier that revlogs try to store a compressed delta against the
previous entry. Well, that previous entry is the previous physical
revision in the file/revlog, not the parent revision. You see,
entries/revisions in revlogs have a numeric index (0, 1, 2, 3, ...),
a SHA-1 hash of their content, and a link to the logical <em>parent</em> of
the entry. e.g. say you have two commits in your repo, one made after
the other:</p>
<pre><code>0:8ba995b74e18
1:9b2a99adc05e
</code></pre>
<p>The revlog has entries at indexes 0 and 1. They are also accessible
by their hash/node values of 8ba995b74e18 and 9b2a99adc05e. The parent
of 1 is 0. The entry for 0 is the full, compressed content of 0. The
entry for 1 is likely a compressed delta from 0 to 1. As we commit,
we keep appending new entries. These exist as compressed deltas until
the sizes of 0..n is greater than n by itself. At that time, a
compressed version of n is stored.</p>
<p>This model works great for linear histories, as changes from n to n+1
are usually small. Mercurial can store a very small delta for each
entry. The world is good.</p>
<p>This model works great when entries in revlogs are small. By having
small entries (and small changes), the number of deltas required to
eclipse the size of a single entry remains small, in effect keeping the length
of a <em>delta chain</em> in check. Limiting the length of delta chains is good
because it keeps the cost of looking up a single revision's content low.
If you have a delta chain of 1000, for example, Mercurial will need to read
1000 revlog entries and apply 1000 deltas to obtain the original value.
That can get expensive computationally. Since reads are linear, I/O
should remain in check. But you do need to scan a lot of bytes to read
in all the deltas and you need to perform a lot of the same computations
(such as zlib decompression).</p>
<p>Let's talk a little about where the revlog starts to break down.</p>
<p>First, there's the issue of multiple, interleaved branches in the
revlog. Say we have a repository with many branches/heads. We alternate
committing between all the heads. This can play havoc with the default
revlog delta compression. Since revlogs compress against the previous
<em>physical</em> entry in the revlog, if there is lots of alternating between
branches and the contents of those branches diverges significantly, the
deltas can grow quite large and full revisions will be stored with
higher frequency. This means more storage space and more CPU tasked
with resolving deltas (since deltas are larger). Although, CPU is kept
in check since delta chains tend to be smaller since full revisions are
stored with higher frequency.</p>
<p>Second, we have an issue with delta chain explosion of large entries
with small turnover. If your base content is large and it isn't changing
that much, it will take hundreds or even thousands of revisions before
the sum of the delta sizes outgrows that of an entry. This means delta
chains can be very long and Mercurial will have to spend a lot of CPU
to resolve a single entry.</p>
<p>Third, revlogs are using zlib for compression. As many
<a href="http://pokecraft.first-world.info/wiki/Quick_Benchmark:_Gzip_vs_Bzip2_vs_LZMA_vs_XZ_vs_LZ4_vs_LZO">benchmarks</a>
have shown, zlib isn't the fastest or most efficient compression
algorithm in the world. It's likely justified as a reasonable default.
But alternatives exist. The choice of zlib has implications, especially
when other factors (such as excessively long delta chains) come into
play.</p>
<p>Let's talk about mitigation strategies.</p>
<h2>True parent deltas</h2>
<p>While I wasn't around for the original design decisions of revlogs, I'm
guessing they were strongly influenced by the fact that sequential I/O
on magnetic disks is much, much faster than random I/O. With SSDs and
flash storage growing in popularity - a medium that offers random I/O
commonly over 100 MB/s - this buys us the luxury of asking <em>do revlogs
need to be optimized for sequential I/O</em> and <em>how can revlogs change to
take advantage of fast random I/O</em>.</p>
<p>One of the ways revlogs can adapt to fast random I/O is to store the
delta against the logical parent, not the physical. The delta chain will
thus <em>skip</em> revisions in the revlog. e.g. the chain could be 1, 2, 5, 6,
10, not n, n+1, n+2, .... This would keep deltas small and would reduce
the overall size of the revlog. Although, it would likely increase the
length of delta chains, especially when dealing with non-linear
histories.</p>
<p>It turns out Mercurial has a setting that enables this -
<strong>format.generaldelta</strong>. To create a repository with this enabled, run:</p>
<pre><code>$ hg --config format.generaldelta=true init path/to/repo
</code></pre>
<p>The revlogs in that repository with now have deltas computed against the
logical parent!</p>
<p>To verify you are using general delta, look for <strong>generaldelta</strong> in the
<em>.hg/requires</em> file. If it isn't there, you probably don't have
generaldelta enabled. <strong>Please note that cloning a generaldelta repo
won't necessarily give your repo generaldelta. You need to have the
custom config option set on the client or the client will likely use the
defaults.</strong></p>
<p>On repositories with lots of interleaved heads, this can make a huge
difference. As a pathalogical example, Mozilla's
<a href="https://hg.mozilla.org/try/">Try</a> repository (where people push heads
to trigger test/automation runs) has over 22,000 heads. The on-disk
size of the repository is 3117 MB with the standard settings and 2139 MB
with generaldelta! The bulk of this difference comes from the manifest
revlog, which is 954 MB smaller with generaldelta.</p>
<h2>Alternate compression format</h2>
<p>Mercurial uses zlib for revlog compression by default. This is a safe
choice. It's relatively fast and yields relatively good compression.</p>
<p>Since Mercurial is highly extensible, it's possible to plug in a custom
compression format for revlogs. Facebook's
<a href="https://bitbucket.org/facebook/lz4revlog/">lz4revlog extension</a> will
use lz4 for compression. lz4 is faster than zlib, but compression isn't
as good. Repositories with lz4 are commonly ~1.5x larger. But CPU bound
tasks can be significantly faster.</p>
<p>In theory, any compression format can be used. However, it's not
trivially selectable in Mercurial (yet), so someone will need to provide
an extension that implements your desired compression format.</p>
<h2>Alternate storage backends</h2>
<p>In theory, Mercurial revlogs can be backed by anything. This is the
extensibility of Mercurial at work. There's just a Mercurial extension
sitting between using SQL, S3, Cassandra, or any other storage backend
for revlogs.</p>
<p>It's also possible to write custom revlog implementations that change
the file layout for interesting scaling possibilities. For example,
modern filesystems like ZFS and btrfs support block-level deduplication
and transparent compression. If you had block-aligned revlog entries
with deduplication enabled, servers could in theory only store each
revision at most once. Another idea is to let the filesystem handle
the compression. This would cause compression to occur in kernel space
(rather than inside Python userspace). This may have beneficial
performance properties. It may not. It may depend on the repository.
These would be interesting experiments to conduct!</p>
<h2>Caveat with alternate revlog implementations</h2>
<p>Before you go experimenting with alternative revlog implementations,
be forewarned that wall time performance for push and pull operations
may suffer!</p>
<p>Currently, Mercurial isn't as smart as it could be when it comes to
transferring <em>bundles</em> of changeset data between repositories. Let me
explain.</p>
<p>When Mercurial transfers changeset data between repositories, it often
uses an encoding format called a <a href="http://mercurial.selenic.com/wiki/BundleFormat">bundle</a>.
A bundle is effectively a custom archive format for revlog data. If
you've ever used <em>hg bundle</em> or <em>hg unbundle</em> to transfer repository
data, you've explicitly interacted with bundles. But what's lesser known
is that the <em>hg push</em> and <em>hg pull</em> operations also transfer bundles.
The only major difference is that they are created on the fly and their
existence is hidden from view.</p>
<p>In theory, bundles can be encoded a number of different ways. The most
common tunable is the compression format. Over the wire, bundles are
zlib (or even uncompressed). If you run <em>hg bundle</em>, you'll likely
produce a bzip2 bundle. (This is why <em>hg unbundle</em> can be slower than
<em>hg clone</em> - the CPU time spent for bzip2 is much greater than for
zlib.) But a problem with bundles as they exist today is that the format
is rather static when it comes to what's transferred over the wire.
Unless you've mucked about with settings, the client and server will
send a zlib-compressed bundle using the physical revlog order. In other
words, the bundle format is the Mercurial defaults.</p>
<p>If Mercurial were completely dumb, transferring bundles would involve
1) determining the full text of a revlog entry 2) compressing that entry
into a bundle 3) sending that data to a peer 4) decompressing that entry
5) appending that entry to the appropriate revlog (which involves
recompression). Fortunately, Mercurial is a bit smarter than that:
Mercurial can detect when compressed bits in a bundle will match what
is on disk and will avoid the unncessary compression operations.</p>
<p>Anyway, the current bundle transfer mechanism falls apart when there is
a mismatch between client and server configurations or even when the
server or client is using non-defaults. You can think of this as a
revlog impedance mismatch. Essentially, when the client and server are
operating with different or uncommon types of revlogs, Mercurial tends
to default to the lowest common denominator, or zlib deltas against the
physical parent. If, for example, a client wants to use generaldelta
with a server employing defaults, the client will have to convert the
server's deltas into generaldelta deltas. This requires a non-trivial
amount of CPU and pull operations become slower. I believe the opposite
is also true: generaldelta clients will emit generaldelta bundles,
causing the server to recompute the deltas.</p>
<p><strong>When it comes to custom revlog formats today, essentially nobody
wins.</strong></p>
<p>The good news is this will be fixed. There is an
<a href="http://mercurial.selenic.com/wiki/BundleFormat2">effort</a> to improve the
bundle format and wire protocols to make matters better. A little
protocol negotiation can go a long way to make the situation a lot
better. That said, there is still the underlying problem that some
clients may want settings that differ from the server's. e.g. clients
with SSDs likely want generaldelta because they don't need sequential
I/O and SSD space is more expensive, so the smaller repository sizes
achieved with generaldelta are appreciated. But a server operator may
not want to force generaldelta on all clients because it would make
clients on mechanical hard drives slower! The point is revlog impedance
mismatch will occur and someone needs to spend the CPU cycles to rectify
the matter. I suspect this will be pushed to clients since distributed
CPU load is easier to deal with than centralized on the server. But, I
wouldn't be surprised if Mercurial allowed server operators to configure
the behavior. It's a hard problem. Time will tell.</p>
<p>In the mean time, just know that if you experiment with custom revlog
settings, push and pull operations will likely be slower. You may not
notice this on day-to-day operations. But on things like initial clone,
you could experience a massive slow-down.</p>
<p>Here's some timings with
<a href="https://hg.mozilla.org/mozilla-central">mozilla-central</a> with a
Mercurial 1.9 server and client on the same SSD-backed multi-core machine:</p>
<ul>
<li>clone default settings - 4:25</li>
<li>clone --uncompressed - 0:49</li>
<li>clone from generaldelta - 14:11</li>
<li>clone from generaldelta to generaldelta - 16:49</li>
<li>clone from generaldelta --uncompressed - 0:50</li>
<li>pull 2250 changesets, default from default - 6.7s</li>
<li>pull 2250 changesets, default from generaldelta - 17.9s</li>
<li>pull 2250 changesets, generaldelta from default - 28.5s</li>
<li>pull 2250 changesets, generaldelta from generaldelta - 20.0s</li>
</ul>
<p>As you can see, anything involving compression and generaldelta is
much slower. Once <em>bundle format 2</em> is fully implemented, I expect the
situation to improve.  Until then, know that you'll get a ~2.5-4x
slowdown from using generaldelta. You'll have to measure other
revlog formats for their impact.</p>
<p>In conclusion, Mercurial's revlog file format is an interesting and
tunable data structure. It works pretty well for most repositories. But
if you are the 1%, you might want to spend some time to investigate
changing its default configuration.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Aggregating Version Control Info at Mozilla]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2014/01/21/aggregating-version-control-info-at-mozilla" />
    <id>http://gregoryszorc.com/blog/2014/01/21/aggregating-version-control-info-at-mozilla</id>
    <updated>2014-01-21T10:50:00Z</updated>
    <published>2014-01-21T10:50:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Git" />
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Python" />
    <summary type="html"><![CDATA[Aggregating Version Control Info at Mozilla]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2014/01/21/aggregating-version-control-info-at-mozilla"><![CDATA[<p>Over the winter break, I set out on an ambitious project to create
a service to help developers and others manage the flury
of patches going into Firefox. While the project is far from complete,
I'm ready to unleash the first part of the project upon the world.</p>
<p>If you point your browsers to
<a href="http://moztree.gregoryszorc.com/">moztree.gregoryszorc.com</a>, you'll
hopefully see some documentation about what I've built.
<a href="https://bitbucket.org/indygreg/moz-tree-utopia">Source code</a> is
available and free, of course. Patches very welcome.</p>
<p>Essentially, I built a centralized indexing service for version
control repositories with Mozilla's extra metadata thrown in.
I tell it what repositories to mirror, and it clones everything,
fetches data such as the pushlog and Git SHA-1 mappings, and
stores everything in a central database. It then exposes this
aggregated data through world-readable web services.</p>
<p>Currently, I have the service indexing the popular project branches
for Firefox (central, aurora, beta, release, esr, b2g, inbound, fx-team,
try, etc). You can view the
<a href="http://moztree.gregoryszorc.com/api/repos">full list</a> via the web
service. As a bonus, I'm also serving these repositories via
<a href="http://hg.gregoryszorc.com/">hg.gregoryszorc.com</a>. My server appears
to be significantly faster than
<a href="https://hg.mozilla.org">hg.mozilla.org</a>. If you want to use it for
your daily needs, go for it. I make no SLA guarantees, however.</p>
<p>I'm also using this service as an opportunity to experiment with
alternate forms of Mercurial hosting. I have mirrors of mozilla-central
and the try repository with generaldelta and lz4 compression enabled.
I may blog about what those are eventually. The teaser is that they can
make Mercurial perform a lot faster under some conditions. I'm also
using ZFS under the hood to manage repositories. Each repository is a
ZFS filesystem. This means I can create repository copies on the server
(user repositories anyone?) at a nearly free cost. Contrast this to the
traditional method of full clones, which take lots of time, memory, CPU,
and storage.</p>
<p>Anyway, some things you can do with the existing web service:</p>
<ul>
<li>Obtain metadata about Mercurial changesets.
  <a href="http://moztree.gregoryszorc.com/api/changeset/940b2974f35b">Example</a>.</li>
<li>Look up metadata about Git commits.
  <a href="http://moztree.gregoryszorc.com/api/git-sha1/40438af67c321">Example</a>.</li>
<li>Obtain a <a href="http://moztree.gregoryszorc.com/api/spore">SPORE descriptor</a>
  describing the web service endpoints. This allows you to auto-generate
  clients from descriptors. Yay!</li>
</ul>
<p>Obviously, that's not a lot. But adding new endpoints is relatively
straightforward. See the <a href="https://bitbucket.org/indygreg/moz-tree-utopia/src/tip/repodata/web/app.py">source</a>.
It's literally as easy as defining a URL mapping and writing a
database query.</p>
<p>The performance is also not the best. I just haven't put in the effort
to tune things yet. All of the querying hits the database, not
Mercurial. So, making things faster should merely be a matter of
database and hosting optimization. Patches welcome!</p>
<p>Some ideas that I haven't had time to implement yet:</p>
<ul>
<li>Return changests in a specific repository</li>
<li>Return recently pushed changesets</li>
<li>Return pushes for a given user</li>
<li>Return commits for a given author</li>
<li>Return commits referencing a given bug</li>
<li>Obtain TBPL URLs for pushes with changeset</li>
<li>Integrate bugzilla metadata</li>
</ul>
<p>Once those are in place, I foresee this service powering a number of
dashboards. Patches welcome.</p>
<p>Again, this service is only the tip of what's possible. There's a lot
that could be built on this service. I have ideas. Others have ideas.</p>
<p>The project includes a Vagrant file and Puppet
manifests for provisioning the server. It's a one-liner to get a
development environment up and running. It should be really easy to
contribute to this project. Patches welcome.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Things Mozilla Could Do with Mercurial]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2014/01/17/things-mozilla-could-do-with-mercurial" />
    <id>http://gregoryszorc.com/blog/2014/01/17/things-mozilla-could-do-with-mercurial</id>
    <updated>2014-01-17T15:00:00Z</updated>
    <published>2014-01-17T15:00:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Things Mozilla Could Do with Mercurial]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2014/01/17/things-mozilla-could-do-with-mercurial"><![CDATA[<p>As I've <a href="/blog/category/mercurial/">written before</a>, Mercurial is a
highly extensible version control system. You can do things with
Mercurial you can't do in other version control systems.</p>
<p>In this post, I'll outline some of the cool things Mozilla could do with
Mercurial. But first, I want to outline some features of Mercurial that
many don't know exist.</p>
<h2>pushkey and listkeys command</h2>
<p>The Mercurial wire protocol (how two Mercurial peer repositories
talk to each other over a network) contains two very useful commands:
<em>pushkey</em> and <em>listkeys</em>. These commands allow the storage and listing
of arbitrary key-value pair metadata in the repository.</p>
<p>This generic storage mechanism is how Mercurial stores and synchronizes
bookmarks and phases information, for example.</p>
<p>By implementing a Mercurial extension, you can have Mercurial store
key-value data for any arbitrary data namespace. You can then write
a simple extension that synchronizes this data as part of the push
and pull operations.</p>
<h2>Extending the wire protocol</h2>
<p>For cases where you want to transmit arbitrary data to/from Mercurial
servers and where the <em>pushkey</em> framework isn't robust enough, it's
possible to implement custom commands in the Mercurial wire protocol.</p>
<p>A server installs an extension making the commands available. A client
installs an extension knowing how to use the commands. Arbitrary data
is transferred or custom actions are performed.</p>
<p>When it comes to custom commands, the sky is really the limit. You
could do pretty much anything from transfer extra data types (this
is how the <a href="http://mercurial.selenic.com/wiki/LargefilesExtension">largefiles extension</a>
works) to writing commands that interact with remote agents.</p>
<h2>Custom revision set queries and templating</h2>
<p>Mercurial offers a rich framework for querying repository data and
for formatting data. The querying is called <em>revision sets</em> and the
later <em>templates</em>. If you are unfamiliar with the feature, I
encourage you to run <em>hg help revset</em> and <em>hg help templates</em> right
now to discover the awesomeness.</p>
<p>As I've <a href="/blog/2013/11/08/using-mercurial-to-query-mozilla-metadata/">demonstrated</a>,
you can do some very nifty things with custom revision sets and
templating!</p>
<h2>The possibilities</h2>
<p>Now that you know some ways Mercurial can be extended, let's talk about
some cool use cases at Mozilla. I want to be clear that I'm not
advocating we do these things, just that they are possible and maybe
they are a little cool.</p>
<h3>Storing pushlog data</h3>
<p>Mozilla records information about who pushed what changesets where and
when in what's called the <em>pushlog</em>. The pushlog data is currently
stored in a SQLite database inside the repository on the server. The
data is made available via a HTTP+JSON API.</p>
<p>We could go a step further and make the pushlog data available via
<em>listkeys</em> so Mercurial clients could download pushlog data with the
same channel used to pull core repository data. (Currently, we have
to open a new TCP connection and talk to the HTTP+JSON API.) This
would make fetching of pushlog data faster, especially for clients
on slow connections.</p>
<p>I concede this is an iterative improvement and adds little value beyond
what we currently have. But if I were designing pushlog storage from
scratch, this is how I'd do it.</p>
<h3>Storing a changeset's automation results</h3>
<p>The <em>pushkey</em> framework could be used to mark specific changesets
as passing automation. When release automation or a sheriff determines
that a changeset/push is green, they could issue an authenticated
<em>pushkey</em> command to the Mercurial server stating such. Clients
could then easily obtain a list of all changesets that are green.</p>
<p>Why stop there? We could also record automation failures in Mercurial as
well. Depending on how complex this gets, we may outgrow <em>pushkey</em>
and require a separate command. But that's all doable.</p>
<p>Anyway, clients could download automation results for a specific
changeset as part of the repository data. The same extension that
pulls down that data could also monkeypatch the bisection algorithm used
by <em>hg bisect</em> to automatically skip over changesets that didn't pass
automation. You'll never bisect a backed out changeset again!</p>
<p>If this automation data were stored on the Try repository, the autoland
tool would just need to query the Mercurial repo to see which changesets
are candidates for merging into mainline - there would be no need for
a separate database and web service!</p>
<h3>Marking a changeset as reviewed</h3>
<p>Currently, Mozilla's review procedure is very patch and Bugzilla
centric. But it doesn't have to be that way. (I argue it shouldn't be
that way.)</p>
<p>Imagine a world where code review is initiated by pushing changesets
to a special server, kind of like how Try magically turns pushes into
automation jobs.</p>
<p>In this world, reviews could be initiated by issuing a <em>pushkey</em>
or custom command to the server. This could even initiate
server-side static analysis that would hold off publishing the review
unless static analysis checks passed!</p>
<p>Granted review could be recorded by having someone issue a
<em>pushkey</em> command to mark a changeset as reviewed. The channel to the
Mercurial server is authenticated via SSH, so the user behind the
current SSH key is the reviewer. The Mercurial server could store this
username as part of the repository data. The autoland tool could then
pull down the reviewer data and only consider changesets that have an
appropriate reviewer.</p>
<p>It <em>might</em> also be possible to integrate crypto magic into this
workflow so reviewers could digitally sign a changeset as reviewed.
This could help with the verification of the Firefox source code
that Brendan Eich <a href="https://brendaneich.com/2014/01/trust-but-verify/">recently outlined</a>.</p>
<p>Like the automation data above, no separate
database would be required: all data would be part of the repository.
All you need to build is a Mercurial extension.</p>
<h3>Encouraging best practices</h3>
<p>Mozillians have written a handful of useful Mercurial extensions to
help people become more productive. We have also noticed that many
developers are still (unknowingly?) running old, slow, and buggy
Mercurial releases. We want people to have the best experience possible.
How do we do that?</p>
<p>One idea is to install an extension on the server that strongly
recommands or even requires users follow best practices (minimal HG
version, installed extensions, etc).</p>
<p>I have developed a <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=941856">proof-of-concept</a>
that does just this.</p>
<h3>Rich querying of metadata</h3>
<p>When you start putting more metadata into Mercurial (or at least write
Mercurial extensions to aggregate this metadata), all kinds of
interesting query opportunities open up. Using revsets and templates,
you can do an awful lot to use Mercurial as a database of sorts
to extract useful reports.</p>
<p>I dare say reports like
<a href="http://oduinn.com/blog/2013/12/03/infrastructure-load-for-november-2013/">John O'duinn's Monthly Infrastructure Load</a>
posts could be completely derived from Mercurial. I've
<a href="/blog/2013/11/08/using-mercurial-to-query-mozilla-metadata/">demonstrated</a>
this ability previously. That's only the tip of the iceburg.</p>
<h2>Summary</h2>
<p>We could enable a lot of new and useful scenarios by extending
Mercurial. We could accomplish this without introducing new
services and tools into our already complicated infrastructure
and workflows.</p>
<p>The possibilities I've suggested are by no means exhaustive. I encourage
others to dream up new and interesting ideas. Who knows, maybe some of
them may actually happen.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Importance of Hosting Your Version Control Server]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/11/13/importance-of-hosting-your-version-control-server" />
    <id>http://gregoryszorc.com/blog/2013/11/13/importance-of-hosting-your-version-control-server</id>
    <updated>2013-11-13T09:25:00Z</updated>
    <published>2013-11-13T09:25:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Git" />
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Importance of Hosting Your Version Control Server]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/11/13/importance-of-hosting-your-version-control-server"><![CDATA[<p>The subject of where to host version control repositories comes up a lot
at Mozilla. It takes many forms:</p>
<ul>
<li>We should move the Firefox repository to GitHub</li>
<li>I should be allowed to commit to GitHub</li>
<li>I want the canonical repository to be hosted by Bitbucket</li>
</ul>
<p>When Firefox development is concerned, Release Engineerings puts down
their foot and insists the canonical repository be hosted by Mozilla,
under a Mozilla hostname. When that's not possible, they set up a mirror
on Mozilla infrastructure.</p>
<p>I think a
<a href="https://groups.google.com/d/topic/jenkinsci-dev/-myjRIPcVwU/discussion">recent issue with the Jenkins project</a>
demonstrates why hosting your own version control server is important.
The gist is someone force pushed to a bunch of repos hosted on GitHub.
They needed to involve GitHub support to recover from the issue. While
it appears they largely recovered (and GitHub support deserves kudos - I
don't want to take away from their excellence), this problem would have
been avoided or the response time significantly decreased if the Jenkins
people had direct control over the Git server: they either could have
installed a custom hook that would have prevented the pushes or had
access to the reflog so they could have easily seen the last pushed
revision and easily forced pushed back to it. GitHub doesn't have a
mechanism for defining pre-* hooks, doesn't allow defining custom
hooks (a security and performance issue for them), and doesn't
expose the reflog data.</p>
<p>Until repository hosting services expose full repository data (such as
reflogs) and allow you to define custom hooks, accidents like these will
happen and the recovery time will be longer than if you hosted the repo
yourself.</p>
<p>It's possible repository hosting services like GitHub and Bitbucket will
expose these features or provide a means to quickly recover. If so,
kudos to them. But larger, more advanced projects will likely employ
custom hooks and considering custom hooks are a massive security and
performance issue for any hosted service provider, I'm not going to
hold my breath this particular feature is rolled out any time soon.
This is unfortunate, as it makes projects seemingly choose between
low risk/low convenience and GitHub's vibrant developer community.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Mercurial 2.8 released]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/11/08/mercurial-2.8-released" />
    <id>http://gregoryszorc.com/blog/2013/11/08/mercurial-2.8-released</id>
    <updated>2013-11-08T14:30:00Z</updated>
    <published>2013-11-08T14:30:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Mercurial 2.8 released]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/11/08/mercurial-2.8-released"><![CDATA[<p><a href="http://mercurial.selenic.com/">Mercurial</a> 2.8 has been released.</p>
<p>The <a href="http://mercurial.selenic.com/wiki/WhatsNew#Mercurial_2.8_.282013-11-1.29">changes</a>
aren't as sexy as previous releases. But there are a handful of bug
fixes that seem useful to pull in. People may also find the new <em>shelve</em>
extension useful.</p>
<p>I encourage Mozillians to keep their Mercurial up to date. I once went
around the San Francisco office and stood behind people as they
upgraded to a modern Mercurial. For the next few weeks I was hearing a
lot of "OMG Mercurial is so much better now." Don't handicap yourself by
running an older, buggy Mercurial.</p>
<p>If you don't yet feel comfortable running 2.8, 2.7 should be safe.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Using Mercurial to query Mozilla metadata]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/11/08/using-mercurial-to-query-mozilla-metadata" />
    <id>http://gregoryszorc.com/blog/2013/11/08/using-mercurial-to-query-mozilla-metadata</id>
    <updated>2013-11-08T09:42:00Z</updated>
    <published>2013-11-08T09:42:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Using Mercurial to query Mozilla metadata]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/11/08/using-mercurial-to-query-mozilla-metadata"><![CDATA[<p>I have updated my
<a href="https://hg.mozilla.org/hgcustom/version-control-tools/file/default/hgext/mozext">Mercurial extension tailored for Gecko/Firefox development</a>
with features that support rich querying of Mozilla/Gecko-development
specific metadata!</p>
<p>The extension now comes with a bug full of
<a href="http://www.selenic.com/hg/help/revsets">revision set</a> selectors and
<a href="http://www.selenic.com/hg/help/templates">template keywords</a>. You can
use them to query and format Mozilla-central metadata from the
repository.</p>
<h2>Revision set selectors</h2>
<p>You can now select changesets referencing a specific bug number:</p>
<pre><code>hg log -r 'bug(931383)'
</code></pre>
<p>Or that were reviewed by a specific person:</p>
<pre><code>hg log -r 'reviewer(gps)'
</code></pre>
<p>Or were reviewed or not reviewed:</p>
<pre><code>hg log -r 'reviewed()'
hg log -r 'not reviewed()'
</code></pre>
<p>You can now select changesets that are present in a specific tree:</p>
<pre><code>hg log -r 'tree(central)'
</code></pre>
<p>I've also introduced support to query changesets <em>you</em> influenced:</p>
<pre><code>hg log -r 'me()'
</code></pre>
<p>(This finds changesets you authored or reviewed.)</p>
<p>You can select changesets that initially landed on a specific tree:</p>
<pre><code>hg log -r 'firstpushtree(central)'
</code></pre>
<p>You can select changesets marked as <em>DONTBUILD</em>:</p>
<pre><code>hg log -r 'dontbuild()'
</code></pre>
<p>You can select changesets that don't reference a bug:</p>
<pre><code>hg log -r 'nobug()'
</code></pre>
<p>You can select changesets that were <em>push heads</em> for a tree:</p>
<pre><code>hg log -r 'pushhead(central)'
</code></pre>
<p>(This would form the basis of a push-aware bisection tool - an excellent
idea for a future feature in this extension.)</p>
<p>You can combine these revset selector functions with other revset
selectors to do some pretty powerful things.</p>
<p>To select all changesets on inbound but not central:</p>
<pre><code>hg log -r 'tree(inbound) - tree(central)'
</code></pre>
<p>To find all your contributions on beta but not release:</p>
<pre><code>hg log -r 'me() &amp; (tree(beta) - tree(release))'
</code></pre>
<p>To find all changesets referencing a specific bug that have landed in
Aurora:</p>
<pre><code>hg log -r 'bug(931383) and tree(aurora)'
</code></pre>
<p>To find all changesets marked <em>DONTBUILD</em> that landed directly on central:</p>
<pre><code>hg log -r 'dontbuild() and firstpushtree(central)'
</code></pre>
<p>To find all non-merge changesets that don't reference a bug:</p>
<pre><code>hg log -r 'not merge() and nobug()'
</code></pre>
<p>Neato!</p>
<h2>Template keywords</h2>
<p>You can also now print some Mozilla information when using templates.</p>
<p>To print the main bug of a changeset, use:</p>
<pre><code>{bug}
</code></pre>
<p>To retrieve all referenced bugs:</p>
<pre><code>{bugs} {join(bugs, ', ')}
</code></pre>
<p>To print the reviewers:</p>
<pre><code>{reviewer} {join(reviewers, ', ')}
</code></pre>
<p>To print the first version a changeset appeared in a specific channel:</p>
<pre><code>{firstrelease} {firstbeta} {firstaurora} {firstnightly}
</code></pre>
<p>To print the <strong>estimated</strong> first Aurora and Nightly date for a
changeset, use:</p>
<pre><code>{auroradate} {nightlydate}
</code></pre>
<p>(Getting the exact first Aurora and Nightly dates requires consulting
3rd party services, which we don't currently do. I'd like to
eventually integrate these into the extension. For now, it just
estimates dates from the pushlog data.)</p>
<p>You can also print who and where pushed a changeset:</p>
<pre><code>{firstpushuser} {firstpushtree}
</code></pre>
<p>You can also print the TBPL URL with the results of the first push:</p>
<pre><code>{firstpushtbpl}
</code></pre>
<p>Here is an example that prints channel versions and dates for each
changesets:</p>
<pre><code>hg log --template '{rev} Nightly: {firstnightly} {nightlydate}; Aurora {firstaurora} {auroradate}; Beta: {firstbeta}; Release: {firstrelease}\n'
</code></pre>
<h2>Putting it all together</h2>
<p>Of course, you can combine selectors and templates to create some
mighty powerful queries.</p>
<p>To look at your impact on Mozilla, do something like:</p>
<pre><code>hg log --template '{rev} Bug {bug}; Release {firstrelease}\n' -r 'me()'
</code></pre>
<p>You can easily forumate a status report for your activity in the past
week:</p>
<pre><code>hg log --template '{firstline(desc)}\n' -r 'firstpushdate(-7) and me()'
</code></pre>
<p>You can also query Mercurial to see where changesets have been landing
in the past 30 days:</p>
<pre><code>hg log --template '{firstpushtree}\n' -r 'firstpushdate(-30)' | sort | uniq -c
</code></pre>
<p>You can see who has been reviewing lots of patches lately:</p>
<pre><code>hg log --template '{join(reviewers, "\n")}\n' -r 'firstpushdate(-30)' | sort | uniq -c | sort -n
</code></pre>
<p>(smaug currently has the top score, edging out my 116 reviews with 137.)</p>
<p>If you want to reuse templates (instead of having to type them on the
command line), you can save them as <em>style files</em>. Search
<a href="https://www.google.com/search?q=mercurial+style+files">the Internets</a>
to learn how to use them. You can even change your default style so
the default output from <em>hg log</em> contains everything you'd ever want to
know about a changeset!</p>
<h2>Keeping it running</h2>
<p>Many of the queries rely on data derived from multiple repositories and
pushlog data that is external to the repository.</p>
<p>To get best results, you'll need to be running a monolithic/unified
Mercurial repository. You can either assemble one locally with this
extension by periodically pulling from the separate repos:</p>
<pre><code>hg pull releases
hg pull integration
</code></pre>
<p>Or, you can pull from
<a href="http://hg.gregoryszorc.com/gecko">my personal unified repo</a>.</p>
<p>You will also need to ensure the pushlog data is current. If you pull
directly from the official repos, this will happen automatically. To be
sure, run:</p>
<pre><code>hg pushlogsync
</code></pre>
<p>Finally, you can force a repopulation of cached bug data by running:</p>
<pre><code>hg buginfo --reset
</code></pre>
<p>Over time, I want all this to automagically work. Stay tuned.</p>
<h2>Comments and future improvements</h2>
<p>I implemented this feature to save myself from having to go troving
through Bugzilla and repository history to answer questions and to
obtain metrics. I can now answer many questions via simple Mercurial
one-liners.</p>
<p>Custom revision set selectors and template keywords are a pretty nifty
feature of Mercurial. They demonstrate how you can extend Mercurial to
be aware of more than just tracking commits and files. As I've
<a href="/blog/2013/05/12/thoughts-on-mercurial-%28and-git%29/">said before</a>
and will continue to say, the extensibility of Mercurial is
really its killer feature, especially for organizations with
well-defined processes (like Mozilla). The kind of extensibility I
achieved with this extension with custom queries and formatting
functions is just not possible with Git (at least not with the reference
C implementation that the overwhelming majority of Git users use).</p>
<p>There are numerous improvements that can be made to the extension.
Obviously more revision set selectors and template keywords can be
added. The parsing routine to extract bugs and reviewers isn't the most
robust in the world. I copied some existing Mozilla code. It does well
at detecting string patters but doesn't cope well with extracting lists.</p>
<p>I'd also love to better integrate Mercurial with automation
results so you can do things like expose a <em>greenpush()</em> selector and do
things like <em>hg up -r 'last(tree(inbound)) and greenpush()'</em> (which
of course could be exposed as <em>lastgreen(inbound)</em>. Wouldn't
that be cool! (This would be possible if we had better APIs for querying
individual push results.) It would also be possible to have the
Mercurial server expose this data as repository data so clients pull it
automatically. That would prevent clients from all needing to query the
same 3rd party services. Just a crazy thought.</p>
<p>Speed can be an issue. Calculating the release information
(<em>{firstnightly}</em> etc) is currently slower than I'd like. This is mostly
due to me using inefficient algorithms and not caching things where I
should. Speed issues should be fixed in due time.</p>
<p>Please let me know if you run into any problems or have suggestions for
improvements. If you want to implement your own revision set selectors
or template keywords, it's <a href="https://hg.mozilla.org/users/gszorc_mozilla.com/hgext-gecko-dev/file/35bb3c96d786/__init__.py#l705">easier</a>
than you think! I will happily accept patches. Keep in mind that
Mercurial can integrate with 3rd party services. So if you want to
supplement repository data with data from a HTTP+JSON web service,
that's very doable. The sky is the limit.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Alternate Mercurial Server for Firefox Development]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/10/17/alternate-mercurial-server-for-firefox-development" />
    <id>http://gregoryszorc.com/blog/2013/10/17/alternate-mercurial-server-for-firefox-development</id>
    <updated>2013-10-17T07:30:00Z</updated>
    <published>2013-10-17T07:30:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Alternate Mercurial Server for Firefox Development]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/10/17/alternate-mercurial-server-for-firefox-development"><![CDATA[<p>I have <a href="/blog/2013/05/13/the-state-of-mercurial-at-mozilla/">long opined</a>
about the sad state of Mercurial at Mozilla. The short version is
Mozilla has failed to use Mercurial optimally, at least for Firefox
development. It's easy to see why so many Mozillians are quick to
discredit Mercurial when compared to Git!</p>
<p>I have a <a href="/blog/category/mercurial/">history</a> attempting to address the
deficiencies. Up to this point, I've been able to make things better
through local tooling. But, for my next set of tricks, I reached an
impasse with the Mercurial server at
<a href="https://hg.mozilla.org/">hg.mozilla.org</a>. So, I stood up my own
Mercurial server at
<a href="http://hg.gregoryszorc.com">hg.gregoryszorc.com/</a>!</p>
<p>This server is running Mercurial 2.7 and has a few nice features the
official Mercurial server at hg.mozilla.org does not.</p>
<h2>The repositories</h2>
<p><a href="http://hg.gregoryszorc.com/gecko">http://hg.gregoryszorc.com/gecko</a> is
a read-only unified Mercurial repository containing the commits for the
major Firefox/Gecko repositories. If you look at its
<a href="http://hg.gregoryszorc.com/gecko/bookmarks">bookmarks</a>, you'll see
something special: the heads of all the separate Mercurial repos it is
aggregating are being stored as bookmarks! (Bookmarks are effectively
Git branches.) The tip of mozilla-central is at the bookmark
<strong>central/default</strong>. The tip of Beta is at <strong>beta/default</strong>.
You get the idea. Once you clone this repo, you can easily switch
between <em>project branches</em> by running e.g. <strong>hg up central/default</strong>.
When you pull the repo, you get changesets for all repos by connecting
to one server, not several (this reduces load on Mozilla's servers and
is faster for clients).</p>
<p>This repository shares the same changesets/SHA-1's as the official
repositories. It just has everything under one roof. You can work out of
this repository and push to the official repositories. Although, you may
want to use the <em>pushtree</em> command from my
<a href="/blog/2013/07/22/mercurial-extension-for-gecko-development/">custom extension</a>
to make your life easier (<em>hg push</em> with no arguments will attempt to
push all changesets, which you definitely don't want when pushing to
e.g. mozilla-central).</p>
<p><a href="http://hg.gregoryszorc.com/gecko-collab">http://hg.gregoryszorc.com/gecko-collab</a>
is an offshoot of the <em>gecko</em> repo that you can push to. Changesets from
the <em>gecko</em> repo are pulled into it automatically.</p>
<p>What makes the <em>gecko-collab</em> repository special is that it has
<em>obsolescence</em> enabled. That is the core Mercurial feature enabling
<a href="http://mercurial.selenic.com/wiki/ChangesetEvolution">changeset evolution</a>.
More on that feature and why it is amazing in a future blog post. Stay tuned.</p>
<h2>Cloning</h2>
<p>If you would like to clone one of these unified repos, please do my
paltry EC2 server a favor and bootstrap your clone from an existing
clone. e.g. if you have a copy of mozilla-central sitting around but
don't want my repo's changesets to <em>pollute</em> it, do the following:</p>
<div class="pygments_murphy"><pre>hg clone mozilla-central gecko
<span class="nb">cd </span>gecko
hg pull http://hg.gregoryszorc.com/gecko
</pre></div>

<p>Or, if you are OK with your clone accumulating the extra changesets from
all the project branches, just run:</p>
<div class="pygments_murphy"><pre>hg pull http://hg.gregoryszorc.com/gecko
</pre></div>

<p>Don't forget to update the <em>[paths]</em> section in your <em>.hg/hgrc</em> file
to point to hg.gregoryszorc.com! e.g.</p>
<div class="pygments_murphy"><pre>[paths]
gecko = http://hg.gregoryszorc.com/gecko
collab = http://hg.gregoryszorc.com/gecko-collab
</pre></div>

<h2>Setting up push support and SSH keys</h2>
<p>If you would like to push to the
<a href="http://hg.gregoryszorc.com/gecko-collab">gecko-collab</a> repository,
you'll need to give me your SSH public key. But don't give me your key -
give an automated process your key!</p>
<p>Head on over to
<a href="http://phabricator.gregoryszorc.com">http://phabricator.gregoryszorc.com/</a>
and log in (look for the Persona button). Once you've logged in, go to your
settings by clicking the wrench icon in the top right. Then look for
<em>SSH Public Keys</em> to add your key(s). If you can't find it, just go to
<a href="http://phabricator.gregoryszorc.com/settings/panel/ssh/">http://phabricator.gregoryszorc.com/settings/panel/ssh/</a>.</p>
<p>Once your SSH public key is added, it will take up to a minute for it to
be added to my system. It's all automatic. You don't need to wait for
any manual action.</p>
<p>To connect to my server over SSH, you'll need to log in as the <em>hgssh</em>
user. e.g. in your <em>hgrc</em> file, add:</p>
<pre><code>[paths]
gecko = ssh://hgssh@hg.gregoryszorc.com/gecko
collab = ssh://hgssh@hg.gregoryszorc.com/gecko-collab
</code></pre>
<p>Then, you should be able to pull and push over SSH!</p>
<h2>Other Notes</h2>
<p>This server is running on an EC2 instance that isn't as powerful as I'd
like. Expect some operations to be slower than desired.</p>
<p>I don't guarantee an SLA for this service. It could go down at any
moment. However, Mercurial being a distributed version control system,
there should be little to no data loss assuming people pull frequently.
I know I have a backup on all my machines now.</p>
<p>I'm running this server for two main reasons.</p>
<p>First, I want to demonstrate the utility of a unified Mercurial server
for Firefox development in hopes we can run one officially. I've been
running a unified repo locally for a few months and I have little doubt
I'm more productive because of it. I want others to realize the
awesomeness.</p>
<p>Second, I needed a server that supported
<a href="http://mercurial.selenic.com/wiki/ChangesetEvolution">changeset evolution</a>
so I could play around with it. I <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=925383">asked</a>
the powers at be to enable it on hg.mozilla.org and didn't get a
response that met my timeline. So, I figured setting up my own server
was easier.</p>
<p>Please let me know if you have any questions or issues with this server.
I'd also love to hear whether people like the unified repo approach!</p>]]></content>
  </entry>
</feed>
