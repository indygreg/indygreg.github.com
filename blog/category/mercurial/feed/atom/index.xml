<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">Gregory Szorc's Digital Home</title>
  <subtitle type="text">Rambling on</subtitle>

  <updated>2014-01-09T18:56:25Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog" />
  <id>http://gregoryszorc.com/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://gregoryszorc.com/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Importance of Hosting Your Version Control Server]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/11/13/importance-of-hosting-your-version-control-server" />
    <id>http://gregoryszorc.com/blog/2013/11/13/importance-of-hosting-your-version-control-server</id>
    <updated>2013-11-13T09:25:00Z</updated>
    <published>2013-11-13T09:25:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Git" />
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Importance of Hosting Your Version Control Server]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/11/13/importance-of-hosting-your-version-control-server"><![CDATA[<p>The subject of where to host version control repositories comes up a lot
at Mozilla. It takes many forms:</p>
<ul>
<li>We should move the Firefox repository to GitHub</li>
<li>I should be allowed to commit to GitHub</li>
<li>I want the canonical repository to be hosted by Bitbucket</li>
</ul>
<p>When Firefox development is concerned, Release Engineerings puts down
their foot and insists the canonical repository be hosted by Mozilla,
under a Mozilla hostname. When that's not possible, they set up a mirror
on Mozilla infrastructure.</p>
<p>I think a
<a href="https://groups.google.com/d/topic/jenkinsci-dev/-myjRIPcVwU/discussion">recent issue with the Jenkins project</a>
demonstrates why hosting your own version control server is important.
The gist is someone force pushed to a bunch of repos hosted on GitHub.
They needed to involve GitHub support to recover from the issue. While
it appears they largely recovered (and GitHub support deserves kudos - I
don't want to take away from their excellence), this problem would have
been avoided or the response time significantly decreased if the Jenkins
people had direct control over the Git server: they either could have
installed a custom hook that would have prevented the pushes or had
access to the reflog so they could have easily seen the last pushed
revision and easily forced pushed back to it. GitHub doesn't have a
mechanism for defining pre-* hooks, doesn't allow defining custom
hooks (a security and performance issue for them), and doesn't
expose the reflog data.</p>
<p>Until repository hosting services expose full repository data (such as
reflogs) and allow you to define custom hooks, accidents like these will
happen and the recovery time will be longer than if you hosted the repo
yourself.</p>
<p>It's possible repository hosting services like GitHub and Bitbucket will
expose these features or provide a means to quickly recover. If so,
kudos to them. But larger, more advanced projects will likely employ
custom hooks and considering custom hooks are a massive security and
performance issue for any hosted service provider, I'm not going to
hold my breath this particular feature is rolled out any time soon.
This is unfortunate, as it makes projects seemingly choose between
low risk/low convenience and GitHub's vibrant developer community.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Mercurial 2.8 released]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/11/08/mercurial-2.8-released" />
    <id>http://gregoryszorc.com/blog/2013/11/08/mercurial-2.8-released</id>
    <updated>2013-11-08T14:30:00Z</updated>
    <published>2013-11-08T14:30:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Mercurial 2.8 released]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/11/08/mercurial-2.8-released"><![CDATA[<p><a href="http://mercurial.selenic.com/">Mercurial</a> 2.8 has been released.</p>
<p>The <a href="http://mercurial.selenic.com/wiki/WhatsNew#Mercurial_2.8_.282013-11-1.29">changes</a>
aren't as sexy as previous releases. But there are a handful of bug
fixes that seem useful to pull in. People may also find the new <em>shelve</em>
extension useful.</p>
<p>I encourage Mozillians to keep their Mercurial up to date. I once went
around the San Francisco office and stood behind people as they
upgraded to a modern Mercurial. For the next few weeks I was hearing a
lot of "OMG Mercurial is so much better now." Don't handicap yourself by
running an older, buggy Mercurial.</p>
<p>If you don't yet feel comfortable running 2.8, 2.7 should be safe.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Using Mercurial to query Mozilla metadata]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/11/08/using-mercurial-to-query-mozilla-metadata" />
    <id>http://gregoryszorc.com/blog/2013/11/08/using-mercurial-to-query-mozilla-metadata</id>
    <updated>2013-11-08T09:42:00Z</updated>
    <published>2013-11-08T09:42:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Using Mercurial to query Mozilla metadata]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/11/08/using-mercurial-to-query-mozilla-metadata"><![CDATA[<p>I have updated my
<a href="https://hg.mozilla.org/users/gszorc_mozilla.com/hgext-gecko-dev">Mercurial extension tailored for Gecko/Firefox development</a>
with features that support rich querying of Mozilla/Gecko-development
specific metadata!</p>
<p>The extension now comes with a bug full of
<a href="http://www.selenic.com/hg/help/revsets">revision set</a> selectors and
<a href="http://www.selenic.com/hg/help/templates">template keywords</a>. You can
use them to query and format Mozilla-central metadata from the
repository.</p>
<h2>Revision set selectors</h2>
<p>You can now select changesets referencing a specific bug number:</p>
<pre><code>hg log -r 'bug(931383)'
</code></pre>
<p>Or that were reviewed by a specific person:</p>
<pre><code>hg log -r 'reviewer(gps)'
</code></pre>
<p>Or were reviewed or not reviewed:</p>
<pre><code>hg log -r 'reviewed()'
hg log -r 'not reviewed()'
</code></pre>
<p>You can now select changesets that are present in a specific tree:</p>
<pre><code>hg log -r 'tree(central)'
</code></pre>
<p>I've also introduced support to query changesets <em>you</em> influenced:</p>
<pre><code>hg log -r 'me()'
</code></pre>
<p>(This finds changesets you authored or reviewed.)</p>
<p>You can select changesets that initially landed on a specific tree:</p>
<pre><code>hg log -r 'firstpushtree(central)'
</code></pre>
<p>You can select changesets marked as <em>DONTBUILD</em>:</p>
<pre><code>hg log -r 'dontbuild()'
</code></pre>
<p>You can select changesets that don't reference a bug:</p>
<pre><code>hg log -r 'nobug()'
</code></pre>
<p>You can select changesets that were <em>push heads</em> for a tree:</p>
<pre><code>hg log -r 'pushhead(central)'
</code></pre>
<p>(This would form the basis of a push-aware bisection tool - an excellent
idea for a future feature in this extension.)</p>
<p>You can combine these revset selector functions with other revset
selectors to do some pretty powerful things.</p>
<p>To select all changesets on inbound but not central:</p>
<pre><code>hg log -r 'tree(inbound) - tree(central)'
</code></pre>
<p>To find all your contributions on beta but not release:</p>
<pre><code>hg log -r 'me() &amp; (tree(beta) - tree(release))'
</code></pre>
<p>To find all changesets referencing a specific bug that have landed in
Aurora:</p>
<pre><code>hg log -r 'bug(931383) and tree(aurora)'
</code></pre>
<p>To find all changesets marked <em>DONTBUILD</em> that landed directly on central:</p>
<pre><code>hg log -r 'dontbuild() and firstpushtree(central)'
</code></pre>
<p>To find all non-merge changesets that don't reference a bug:</p>
<pre><code>hg log -r 'not merge() and nobug()'
</code></pre>
<p>Neato!</p>
<h2>Template keywords</h2>
<p>You can also now print some Mozilla information when using templates.</p>
<p>To print the main bug of a changeset, use:</p>
<pre><code>{bug}
</code></pre>
<p>To retrieve all referenced bugs:</p>
<pre><code>{bugs} {join(bugs, ', ')}
</code></pre>
<p>To print the reviewers:</p>
<pre><code>{reviewer} {join(reviewers, ', ')}
</code></pre>
<p>To print the first version a changeset appeared in a specific channel:</p>
<pre><code>{firstrelease} {firstbeta} {firstaurora} {firstnightly}
</code></pre>
<p>To print the <strong>estimated</strong> first Aurora and Nightly date for a
changeset, use:</p>
<pre><code>{auroradate} {nightlydate}
</code></pre>
<p>(Getting the exact first Aurora and Nightly dates requires consulting
3rd party services, which we don't currently do. I'd like to
eventually integrate these into the extension. For now, it just
estimates dates from the pushlog data.)</p>
<p>You can also print who and where pushed a changeset:</p>
<pre><code>{firstpushuser} {firstpushtree}
</code></pre>
<p>You can also print the TBPL URL with the results of the first push:</p>
<pre><code>{firstpushtbpl}
</code></pre>
<p>Here is an example that prints channel versions and dates for each
changesets:</p>
<pre><code>hg log --template '{rev} Nightly: {firstnightly} {nightlydate}; Aurora {firstaurora} {auroradate}; Beta: {firstbeta}; Release: {firstrelease}\n'
</code></pre>
<h2>Putting it all together</h2>
<p>Of course, you can combine selectors and templates to create some
mighty powerful queries.</p>
<p>To look at your impact on Mozilla, do something like:</p>
<pre><code>hg log --template '{rev} Bug {bug}; Release {firstrelease}\n' -r 'me()'
</code></pre>
<p>You can easily forumate a status report for your activity in the past
week:</p>
<pre><code>hg log --template '{firstline(desc)}\n' -r 'firstpushdate(-7) and me()'
</code></pre>
<p>You can also query Mercurial to see where changesets have been landing
in the past 30 days:</p>
<pre><code>hg log --template '{firstpushtree}\n' -r 'firstpushdate(-30)' | sort | uniq -c
</code></pre>
<p>You can see who has been reviewing lots of patches lately:</p>
<pre><code>hg log --template '{join(reviewers, "\n")}\n' -r 'firstpushdate(-30)' | sort | uniq -c | sort -n
</code></pre>
<p>(smaug currently has the top score, edging out my 116 reviews with 137.)</p>
<p>If you want to reuse templates (instead of having to type them on the
command line), you can save them as <em>style files</em>. Search
<a href="https://www.google.com/search?q=mercurial+style+files">the Internets</a>
to learn how to use them. You can even change your default style so
the default output from <em>hg log</em> contains everything you'd ever want to
know about a changeset!</p>
<h2>Keeping it running</h2>
<p>Many of the queries rely on data derived from multiple repositories and
pushlog data that is external to the repository.</p>
<p>To get best results, you'll need to be running a monolithic/unified
Mercurial repository. You can either assemble one locally with this
extension by periodically pulling from the separate repos:</p>
<pre><code>hg pull releases
hg pull integration
</code></pre>
<p>Or, you can pull from
<a href="http://hg.gregoryszorc.com/gecko">my personal unified repo</a>.</p>
<p>You will also need to ensure the pushlog data is current. If you pull
directly from the official repos, this will happen automatically. To be
sure, run:</p>
<pre><code>hg pushlogsync
</code></pre>
<p>Finally, you can force a repopulation of cached bug data by running:</p>
<pre><code>hg buginfo --reset
</code></pre>
<p>Over time, I want all this to automagically work. Stay tuned.</p>
<h2>Comments and future improvements</h2>
<p>I implemented this feature to save myself from having to go troving
through Bugzilla and repository history to answer questions and to
obtain metrics. I can now answer many questions via simple Mercurial
one-liners.</p>
<p>Custom revision set selectors and template keywords are a pretty nifty
feature of Mercurial. They demonstrate how you can extend Mercurial to
be aware of more than just tracking commits and files. As I've
<a href="/blog/2013/05/12/thoughts-on-mercurial-%28and-git%29/">said before</a>
and will continue to say, the extensibility of Mercurial is
really its killer feature, especially for organizations with
well-defined processes (like Mozilla). The kind of extensibility I
achieved with this extension with custom queries and formatting
functions is just not possible with Git (at least not with the reference
C implementation that the overwhelming majority of Git users use).</p>
<p>There are numerous improvements that can be made to the extension.
Obviously more revision set selectors and template keywords can be
added. The parsing routine to extract bugs and reviewers isn't the most
robust in the world. I copied some existing Mozilla code. It does well
at detecting string patters but doesn't cope well with extracting lists.</p>
<p>I'd also love to better integrate Mercurial with automation
results so you can do things like expose a <em>greenpush()</em> selector and do
things like <em>hg up -r 'last(tree(inbound)) and greenpush()'</em> (which
of course could be exposed as <em>lastgreen(inbound)</em>. Wouldn't
that be cool! (This would be possible if we had better APIs for querying
individual push results.) It would also be possible to have the
Mercurial server expose this data as repository data so clients pull it
automatically. That would prevent clients from all needing to query the
same 3rd party services. Just a crazy thought.</p>
<p>Speed can be an issue. Calculating the release information
(<em>{firstnightly}</em> etc) is currently slower than I'd like. This is mostly
due to me using inefficient algorithms and not caching things where I
should. Speed issues should be fixed in due time.</p>
<p>Please let me know if you run into any problems or have suggestions for
improvements. If you want to implement your own revision set selectors
or template keywords, it's <a href="https://hg.mozilla.org/users/gszorc_mozilla.com/hgext-gecko-dev/file/35bb3c96d786/__init__.py#l705">easier</a>
than you think! I will happily accept patches. Keep in mind that
Mercurial can integrate with 3rd party services. So if you want to
supplement repository data with data from a HTTP+JSON web service,
that's very doable. The sky is the limit.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Alternate Mercurial Server for Firefox Development]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/10/17/alternate-mercurial-server-for-firefox-development" />
    <id>http://gregoryszorc.com/blog/2013/10/17/alternate-mercurial-server-for-firefox-development</id>
    <updated>2013-10-17T07:30:00Z</updated>
    <published>2013-10-17T07:30:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Alternate Mercurial Server for Firefox Development]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/10/17/alternate-mercurial-server-for-firefox-development"><![CDATA[<p>I have <a href="/blog/2013/05/13/the-state-of-mercurial-at-mozilla/">long opined</a>
about the sad state of Mercurial at Mozilla. The short version is
Mozilla has failed to use Mercurial optimally, at least for Firefox
development. It's easy to see why so many Mozillians are quick to
discredit Mercurial when compared to Git!</p>
<p>I have a <a href="/blog/category/mercurial/">history</a> attempting to address the
deficiencies. Up to this point, I've been able to make things better
through local tooling. But, for my next set of tricks, I reached an
impasse with the Mercurial server at
<a href="https://hg.mozilla.org/">hg.mozilla.org</a>. So, I stood up my own
Mercurial server at
<a href="http://hg.gregoryszorc.com">hg.gregoryszorc.com/</a>!</p>
<p>This server is running Mercurial 2.7 and has a few nice features the
official Mercurial server at hg.mozilla.org does not.</p>
<h2>The repositories</h2>
<p><a href="http://hg.gregoryszorc.com/gecko">http://hg.gregoryszorc.com/gecko</a> is
a read-only unified Mercurial repository containing the commits for the
major Firefox/Gecko repositories. If you look at its
<a href="http://hg.gregoryszorc.com/gecko/bookmarks">bookmarks</a>, you'll see
something special: the heads of all the separate Mercurial repos it is
aggregating are being stored as bookmarks! (Bookmarks are effectively
Git branches.) The tip of mozilla-central is at the bookmark
<strong>central/default</strong>. The tip of Beta is at <strong>beta/default</strong>.
You get the idea. Once you clone this repo, you can easily switch
between <em>project branches</em> by running e.g. <strong>hg up central/default</strong>.
When you pull the repo, you get changesets for all repos by connecting
to one server, not several (this reduces load on Mozilla's servers and
is faster for clients).</p>
<p>This repository shares the same changesets/SHA-1's as the official
repositories. It just has everything under one roof. You can work out of
this repository and push to the official repositories. Although, you may
want to use the <em>pushtree</em> command from my
<a href="/blog/2013/07/22/mercurial-extension-for-gecko-development/">custom extension</a>
to make your life easier (<em>hg push</em> with no arguments will attempt to
push all changesets, which you definitely don't want when pushing to
e.g. mozilla-central).</p>
<p><a href="http://hg.gregoryszorc.com/gecko-collab">http://hg.gregoryszorc.com/gecko-collab</a>
is an offshoot of the <em>gecko</em> repo that you can push to. Changesets from
the <em>gecko</em> repo are pulled into it automatically.</p>
<p>What makes the <em>gecko-collab</em> repository special is that it has
<em>obsolescence</em> enabled. That is the core Mercurial feature enabling
<a href="http://mercurial.selenic.com/wiki/ChangesetEvolution">changeset evolution</a>.
More on that feature and why it is amazing in a future blog post. Stay tuned.</p>
<h2>Cloning</h2>
<p>If you would like to clone one of these unified repos, please do my
paltry EC2 server a favor and bootstrap your clone from an existing
clone. e.g. if you have a copy of mozilla-central sitting around but
don't want my repo's changesets to <em>pollute</em> it, do the following:</p>
<div class="pygments_murphy"><pre>hg clone mozilla-central gecko
<span class="nb">cd </span>gecko
hg pull http://hg.gregoryszorc.com/gecko
</pre></div>

<p>Or, if you are OK with your clone accumulating the extra changesets from
all the project branches, just run:</p>
<div class="pygments_murphy"><pre>hg pull http://hg.gregoryszorc.com/gecko
</pre></div>

<p>Don't forget to update the <em>[paths]</em> section in your <em>.hg/hgrc</em> file
to point to hg.gregoryszorc.com! e.g.</p>
<div class="pygments_murphy"><pre>[paths]
gecko = http://hg.gregoryszorc.com/gecko
collab = http://hg.gregoryszorc.com/gecko-collab
</pre></div>

<h2>Setting up push support and SSH keys</h2>
<p>If you would like to push to the
<a href="http://hg.gregoryszorc.com/gecko-collab">gecko-collab</a> repository,
you'll need to give me your SSH public key. But don't give me your key -
give an automated process your key!</p>
<p>Head on over to
<a href="http://phabricator.gregoryszorc.com">http://phabricator.gregoryszorc.com/</a>
and log in (look for the Persona button). Once you've logged in, go to your
settings by clicking the wrench icon in the top right. Then look for
<em>SSH Public Keys</em> to add your key(s). If you can't find it, just go to
<a href="http://phabricator.gregoryszorc.com/settings/panel/ssh/">http://phabricator.gregoryszorc.com/settings/panel/ssh/</a>.</p>
<p>Once your SSH public key is added, it will take up to a minute for it to
be added to my system. It's all automatic. You don't need to wait for
any manual action.</p>
<p>To connect to my server over SSH, you'll need to log in as the <em>hgssh</em>
user. e.g. in your <em>hgrc</em> file, add:</p>
<pre><code>[paths]
gecko = ssh://hgssh@hg.gregoryszorc.com/gecko
collab = ssh://hgssh@hg.gregoryszorc.com/gecko-collab
</code></pre>
<p>Then, you should be able to pull and push over SSH!</p>
<h2>Other Notes</h2>
<p>This server is running on an EC2 instance that isn't as powerful as I'd
like. Expect some operations to be slower than desired.</p>
<p>I don't guarantee an SLA for this service. It could go down at any
moment. However, Mercurial being a distributed version control system,
there should be little to no data loss assuming people pull frequently.
I know I have a backup on all my machines now.</p>
<p>I'm running this server for two main reasons.</p>
<p>First, I want to demonstrate the utility of a unified Mercurial server
for Firefox development in hopes we can run one officially. I've been
running a unified repo locally for a few months and I have little doubt
I'm more productive because of it. I want others to realize the
awesomeness.</p>
<p>Second, I needed a server that supported
<a href="http://mercurial.selenic.com/wiki/ChangesetEvolution">changeset evolution</a>
so I could play around with it. I <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=925383">asked</a>
the powers at be to enable it on hg.mozilla.org and didn't get a
response that met my timeline. So, I figured setting up my own server
was easier.</p>
<p>Please let me know if you have any questions or issues with this server.
I'd also love to hear whether people like the unified repo approach!</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Mercurial setup wizard for Firefox development]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/07/29/mercurial-setup-wizard-for-firefox-development" />
    <id>http://gregoryszorc.com/blog/2013/07/29/mercurial-setup-wizard-for-firefox-development</id>
    <updated>2013-07-29T17:45:00Z</updated>
    <published>2013-07-29T17:45:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Mercurial setup wizard for Firefox development]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/07/29/mercurial-setup-wizard-for-firefox-development"><![CDATA[<p>I'm a big fan of tools that encourage and/or enforce the following of
best practices and that help people become more productive.</p>
<p>One of the tools that Firefox developers interact with nearly daily is
Mercurial. As I've observed from coworkers and from community
contributors, many don't have Mercurial configured for optimal
development. For first-time contributors, this can manifest in patch
rejection - an experience that can be embarassing and demotivating. This
is frustrating to me because most issues are easily identifiable and
correctable. And, when addressed, everyone wins.</p>
<p>Anyway, I'm pleased to announce that there is now a configuration wizard
in the Firefox source tree to help with configuring Mercurial. To run it,
just type:</p>
<pre><code>./mach mercurial-setup
</code></pre>
<p>Currently, it's aimed for first-time contributors. So, it's missing
things that more seasoned developers rely on. But you need to start
somewhere, right?</p>
<p>Currently, the tool isn't advertised anywhere other than <em>mach help</em>.
Please run it and report issues in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=794580">bug 794580</a> or
file a new report. Once things have baked in, I'd like to add some kind
of notification/tips system to mach where it will encourage you to do
things like automatically run <em>mach mercurial-setup</em>. Until then, I
recommend trying to remember to run <em>mach mercurial-setup</em> every few
weeks to ensure your Mercurial environment is up to date and properly
configured.</p>
<p>I'd like to thank Nick Alexander for sharing my enthusiasm for helping
contributors and for taking the time to review this work.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Track pushes and train riding with Mercurial]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/07/25/track-pushes-and-train-riding-with-mercurial" />
    <id>http://gregoryszorc.com/blog/2013/07/25/track-pushes-and-train-riding-with-mercurial</id>
    <updated>2013-07-25T13:10:00Z</updated>
    <published>2013-07-25T13:10:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Track pushes and train riding with Mercurial]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/07/25/track-pushes-and-train-riding-with-mercurial"><![CDATA[<p>My <a href="https://hg.mozilla.org/users/gszorc_mozilla.com/hgext-gecko-dev">Mercurial extension for Firefox development</a>
now has an initial implementation of pushlog aggregation and searching.</p>
<p>You first start by synchronizing the pushlog data on Mozilla's servers
with the local client:</p>
<pre><code>hg pushlogsync
</code></pre>
<p>This takes a while the first time you run it because it has to download
all the data. On subsequent runs, it only downloads new data, so it
should be much faster.</p>
<p>Then, you can search for the push history of a changeset:</p>
<div class="pygments_murphy"><pre>$ hg changesetpushes -a b968708558b9
133967:b968708558b9 Bug 839809:  Make counter-increments and list counting that would go past our internal (int32_t) limit keep the counter at its current value rather than wrapping.  r=dholbert

Per CSS WG resolution regarding counter-styles-3, afternoon of 2013-02-05:
http://krijnhoetmer.nl/irc-logs/css/20130205#l-1590
http://lists.w3.org/Archives/Public/www-style/2013Feb/0392.html

Note that this patch depends on signed integer overflow behavior in C++,
which I believe is portable despite being unspecified.
Tree      Date                Username              Build Info
inbound   2013-02-21T18:12:57 dbaron@mozilla.com    https://tbpl.mozilla.org/?tree=Mozilla-Inbound&amp;rev=85b91048c1cd
central   2013-02-22T09:43:12 ryanvm@gmail.com      https://tbpl.mozilla.org/?tree=Mozilla-Central&amp;rev=3a7d4085787e
build     2013-02-22T14:31:42 gszorc@mozilla.com    https://tbpl.mozilla.org/?tree=Build-System&amp;rev=3a7d4085787e
fx-team   2013-02-25T01:04:44 ttaubert@mozilla.com  https://tbpl.mozilla.org/?tree=Fx-Team&amp;rev=31466fd86eb7
graphics  2013-02-25T20:02:57 mwoodrow@mozilla.com  https://tbpl.mozilla.org/?tree=Graphics&amp;rev=dcf53b7140cd
ash       2013-02-26T13:50:41 armenzg@mozilla.com   https://tbpl.mozilla.org/?tree=Ash&amp;rev=201b64ad48d8
services  2013-02-28T09:42:45 Ms2ger@gmail.com      https://tbpl.mozilla.org/?tree=Services-Central&amp;rev=31466fd86eb7
aurora    2013-04-01T13:50:56 bbajaj@mozilla.com    https://tbpl.mozilla.org/?tree=Mozilla-Aurora&amp;rev=60a3f369ccf0
beta      2013-05-13T09:59:38 lsblakk@mozilla.com   https://tbpl.mozilla.org/?tree=Mozilla-Beta&amp;rev=60a3f369ccf0
release   2013-06-17T15:53:19 akeybl@mozilla.com    https://tbpl.mozilla.org/?tree=Mozilla-Release&amp;rev=c54e3363712e
</pre></div>

<p>(The <em>-a</em> argument prints all trees instead of just the release trees).</p>
<p>I'd like to integrate bug tracking into the mix to facilitate
answering questions like <em>when did bug 123456 ride the trains</em>.</p>
<p>I'd also like to integrate release versions and build IDs into the mix.
For example, when I look up a changeset, I want to know the first build
on the Nightly, Aurora, Beta, and Release channels that change was
included in.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Mercurial Extension for Gecko Development]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/07/22/mercurial-extension-for-gecko-development" />
    <id>http://gregoryszorc.com/blog/2013/07/22/mercurial-extension-for-gecko-development</id>
    <updated>2013-07-22T10:27:00Z</updated>
    <published>2013-07-22T10:27:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Mercurial Extension for Gecko Development]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/07/22/mercurial-extension-for-gecko-development"><![CDATA[<p>My weekend was spent hacking on Mercurial extensions. First, I worked on
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=827123">porting the pushlog extension off SQLite</a>.
This will eventually enable Mozilla to move Mercurial hosting off NFS
and should make <a href="https://hg.mozilla.org/">hg.mozilla.org</a> much faster as
a result!</p>
<p>But the main purpose of this blog post is to introduce a new Mercurial
extension I wrote this weekend!</p>
<p>Gecko developers perform a number of common tasks with Mercurial, so I
thought it would be handy to package them up in an extension.</p>
<p>To install the extension:</p>
<pre><code>hg clone https://hg.mozilla.org/users/gszorc_mozilla.com/hgext-gecko-dev
</code></pre>
<p>Then add this extension to your hgrc file (either the global or
per-repository will suffice):</p>
<pre><code>[extensions]
mozext = /path/to/hgext-gecko-dev
</code></pre>
<p>Since I believe tools should be self-documenting, run the following for
usage info:</p>
<pre><code>$ hg help mozext
</code></pre>
<p>Here are some examples:</p>
<div class="pygments_murphy"><pre><span class="c"># Clone mozilla-central into the mc directory.</span>
hg clone central mc
hg clone mc mc

<span class="c"># Create a unified Mercurial repository containing changesets</span>
<span class="c"># from all the release repositories.</span>
hg cloneunified gecko

<span class="c"># Pull changes from the central and inbound repositories.</span>
hg pull central
hg pull inbound

<span class="c"># Update the working tree to the tip of inbound.</span>
hg up inbound/default

<span class="c"># View the tree open/closed status.</span>
hg treestatus

<span class="c"># Show a list of all known trees and their aliases.</span>
hg moztrees

<span class="c"># Open TBPL for the push containing a changeset.</span>
hg tbpl inbound 821e984ef423
hg tbpl inbound inbound/default

<span class="c"># Push the tip of inbound to mozilla-central</span>
hg pushtree -r inbound/default central
</pre></div>

<p>I've only tested this extension with Mercurial 2.6 (which every Mozilla
developer should be running). I'm not willing to support older versions.
Upgrade already!</p>
<p>There are a number of features I'd like to implement:</p>
<ul>
<li><strong>hg importtry</strong> - Automatically import changesets for a Try push into
  the repository.</li>
<li><strong>hg land</strong> - Automatically land patches on an integration tree (like
  inbound). Will handle rebasing automatically.</li>
<li><strong>hg critic</strong> - Perform stlye checking and other analysis on a
  changeset or group of changesets.</li>
<li>Ability to integrate build status into changeset info. This will allow
  things such as <em>pull only the last green changeset</em>. I'd also like a
  <em>build status</em> field to appear in the log output. Unfortunately, I
  believe the latency of the build lookup API is prohibitively high to
  perform the kind of tight integration I'd like.</li>
<li>Move <em>mozautomation</em> Python package into a standalone package or
  integrate already existing code (did I reinvent the wheel?).</li>
<li>Log fetching. Specify a changeset and fetch build/test logs.</li>
<li>Possibly move code into mozilla-central.</li>
<li>Possibly add mach commands for some of this functionality.</li>
</ul>
<p>There's no bug component for this extension (yet). If you find any
issues or wish to add a feature, just email a patch to me at gps@mozilla.com.</p>
<p>Please let me know if you find this useful or if you have any questions.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[The State of Mercurial at Mozilla]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/05/13/the-state-of-mercurial-at-mozilla" />
    <id>http://gregoryszorc.com/blog/2013/05/13/the-state-of-mercurial-at-mozilla</id>
    <updated>2013-05-13T13:25:00Z</updated>
    <published>2013-05-13T13:25:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[The State of Mercurial at Mozilla]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/05/13/the-state-of-mercurial-at-mozilla"><![CDATA[<p>I have an opinion on the usage of Mercurial at Mozilla: it stinks.</p>
<p>Here's why.</p>
<h2>The server is configured poorly</h2>
<p>Our Mozilla server, hg.mozilla.org, is currently running Mercurial 2.0.2.
In terms of Mercurial features, stability, and performance, we are light
years behind.</p>
<p>You know that annoying phases configuration you need to set when pushing
to Try? That's because the server isn't new enough to tell the client the
same thing the configuration option does. It
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=725362">will be fixed</a>
when the server is upgraded to 2.1+.</p>
<p>Furthermore, we are running the server over NFS, which introduces known
badness, including slowness.</p>
<p>I believe we blame Mercurial for issues that would go away if we
configured the Mercurial server properly.</p>
<p>Fortunately, it appears the
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=781012">upgrade to 2.5</a>
is near and I've heard we're moving from NFS to local disk storage as
part of that. This should go a long way to making the server better.
The upgrade can't happen soon enough.</p>
<h2>User education is poor</h2>
<p>I think a lot of people are ignorant on the features and abilities of
Mercurial.</p>
<p>I commonly hear people are dissatisfied with the behavior of their
Mercurial client. They encounter performance issues, bugs, corruption,
etc. Nine times out of ten this is due to running an old Mercurial
release. Just last Friday someone on my team asked me about
weird behavior involving file case. My first question: <em>what version
of Mercurial are you using?</em> He was running 2.0.2. I told him to
upgrade to 2.5+. It fixed his problem. <strong>If you aren't running
Mercurial 2.5 or newer, upgrade immediately.</strong></p>
<p>I've heard people say we should switch to Git because Git has feature X.
Most of the time, Mercurial has these features. Unfortunately, people
just don't realize it. When I point them at
<a href="http://mercurial.selenic.com/wiki/UsingExtensions">Mercurial's extensions list</a>
their eyes light up and they thank me for making their lives easier.</p>
<p>I think a problem is a lot of new Mozilla contributors knew Git
before and only pick up the bare essentials of Mercurial that allow them
to land patches. They prefer Git because it is familiar and just don't
bother to pick up Mercurial. The potential of Mercurial is thus lost on
them.</p>
<p>Perhaps we should have a brown bag and/or better documentation on
getting the most out of Mercurial?</p>
<h2>The branching model is far from ideal</h2>
<p>For Gecko/Firefox development, we maintain separate repositories for the
trunk and release branches. This introduces all kinds of annoying.</p>
<p>We should not have separate repositories for <em>central</em>, <em>inbound</em>,
<em>aurora</em>, <em>beta</em>, <em>release</em>, etc. We should be using some combination of
branches and bookmarks and have all the release heads in one
repository, just like how the
<a href="https://github.com/mozilla/mozilla-central/">GitHub mirror</a> is
configured.</p>
<p>As an experiment, I created a
<a href="https://hg.mozilla.org/users/gszorc_mozilla.com/gecko">unified Mercurial repository</a>.
Each current repository is tracked as a bookmark (there are
<a href="https://developer.mozilla.org/en-US/docs/Developer_Guide/Source_Code/Mercurial">instructions</a>
for reproducing this). Unfortunately, the web interface isn't showing
bookmarks (perhaps because the version of Mercurial is too old?), so
you'll have to clone the repository to play around. Just run
<em>hg bookmarks</em> and e.g. <em>hg up aurora</em> after cloning.
<em>Warning: I'm not actively synchronizing this repository, so don't rely
on it being up to date</em>.</p>
<p>A Mercurial contributor (who is familiar with Mozilla's
development model) suggested we use Mercurial branches for every Gecko
release (20, 21, 22, etc). I think this and other uses of branches and
bookmarks are ideas worth exploring.</p>
<h2>We're failing to harness the extensibility</h2>
<p>Gecko/Firefox has a complicated code lifecycle and landing process.
This could be significantly streamlined if we fully harnessed and
embraced the extensibility of Mercurial. While there are some
Mozilla-centric extensions (details in my
<a href="/blog/2013/05/12/thoughts-on-mercurial-%28and-git%29/">recent post</a>),
I don't think they are well known nor used.</p>
<p>I think Mozilla should embrace the functionality of extensions like
these (whether they be for Mercurial, Git, or something else) and invest
resources in improving the workflows for all developers. Until these
tools are obviously superior and advertised, I believe many developers
will unknowingly continue to toil without them. And, it's likely hurting
our ability to attract and retain new contributors as well.</p>
<h2>Conclusion</h2>
<p>Mozilla's current usage of Mercurial is far from ideal. It's no wonder
people don't like Mercurial (and why some want to switch to Git).</p>
<p>Fortunately, little has to do with shortcomings of Mercurial itself (at
least with newer versions). If you want to know why Mercurial isn't
working too well for Gecko/Firefox development, most of the problems
are self-inflicted or the solutions reside within each of us. Time
will tell if we as a community have the will to address these issues.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Thoughts on Mercurial (and Git)]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/05/12/thoughts-on-mercurial-(and-git)" />
    <id>http://gregoryszorc.com/blog/2013/05/12/thoughts-on-mercurial-(and-git)</id>
    <updated>2013-05-12T12:00:00Z</updated>
    <published>2013-05-12T12:00:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Git" />
    <summary type="html"><![CDATA[Thoughts on Mercurial (and Git)]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/05/12/thoughts-on-mercurial-(and-git)"><![CDATA[<p>My first experience with Mercurial (Firefox development)
was very unpleasant. Coming from Git, I thought Mercurial was slow
and perhaps even more awkward to use than Git. I frequently
encountered repository corruption that required me to reclone. I thought
the concept of a patch queue was silly compared to Git branches. It
was all extremely frustrating and I dare say a hinderance to my
productivity. It didn't help that I was surrounded by a bunch of people
who had previous experience with Git and opined about every minute
difference.</p>
<p>Two years later and I'm on much better terms with Mercurial. I initially
thought it might be Stockholm Syndrome, but after reflection I can point
at specific changes and enlightenments that have reshaped my opinions.</p>
<h2>Newer versions of Mercurial are much better</h2>
<p>I first started using Mercurial in the 1.8 days and thought it was
horrible. However, modern releases are much, much better. I've noticed
a steady improvement in the quality and speed of Mercurial in the last
few years.</p>
<p><strong>If you aren't running 2.5 or later (Mercurial 2.6 was released earlier
this month), you should take the time to upgrade today.</strong> When you upgrade,
you should of course read the
<a href="http://mercurial.selenic.com/wiki/WhatsNew">changelog</a> and
<a href="http://mercurial.selenic.com/wiki/UpgradeNotes">upgrade notes</a> so you
can make the most of the new features.</p>
<h2>Proper configuration is key</h2>
<p>For <em>my</em> workflow, the default configuration of Mercurial out of the box
is... far from optimal. There are a number of basic changes that need to
be made to satisfy <em>my</em> expectations for a version control tool.</p>
<p>I used to think this was a shortcoming with Mercurial: why not ship a
powerful and useful environment out of the box? But, after talking to a
Mercurial core contributor, this is mostly by design. Apparently a
principle of the Mercurial project is that the CLI tool (<em>hg</em>) should be
simple by default and should minimize foot guns. They view actions like
rebasing and patch queues as advanced and thus don't have them enabled
by default. Seasoned developers may scoff at this. But, I see where
Mercurial is coming from. I only need to refer everyone to her first
experience with Git as an example of what happens when you don't aim for
simplicity. (I've never met a Git user who didn't think it overly
complicated at first.)</p>
<p>Anyway, to get the most out of Mercurial, it is essential to configure
it to your liking, much like you install plugins or extensions in your
code editor.</p>
<p><strong>Every person running Mercurial should go to
<a href="http://mercurial.selenic.com/wiki/UsingExtensions">http://mercurial.selenic.com/wiki/UsingExtensions</a>
and take the time to find extensions that will make your life better</strong>.
You should also run <em>hg help hgrc</em> to view all the configuration
options. There is a mountain of productivity wins waiting to be realized.</p>
<p>For reference, my <a href="https://gist.github.com/indygreg/5511712">~/.hgrc</a>.
Worth noting are some of the built-in externsions I've enabled:</p>
<ul>
<li>color - Colorize terminal output. Clear UX win.</li>
<li>histedit - Provides  <em>git rebase --interactive</em> behavior.</li>
<li>pager - Feed command output into a pager (like <em>less</em>). Clear UX win.</li>
<li>progress - Draw progress bars on long-running operations. Clear UX
  win.</li>
<li>rebase - Ability to easily rebase patches on top of other heads.
  This is a basic feature of patch management.</li>
<li>transplant - Easily move patches between repositories, branches, etc.</li>
</ul>
<p>If I were on Linux, I'd also use the <em>inotify</em> extension, which installs
filesystem watchers so operations like <em>hg status</em> are instantaneous.</p>
<p>In addition to the built-in extensions, there are a number of 3rd party
extensions that improve my Mozilla workflow:</p>
<ul>
<li><a href="https://bitbucket.org/sfink/mqext">mqext</a> - Automatically commit to
  your patch queue when you qref, etc. This is a lifesaver. If that's
  not enough, it suggests reviewers for your patch, suggests a bug
  component, and let's you find bugs touching the files you are
  touching.</li>
<li><a href="https://github.com/pbiggar/trychooser">trychooser</a> - Easily push
  changes to Mozilla's Try infrastructure.</li>
<li><a href="https://hg.mozilla.org/users/robarnold_cmu.edu/qimportbz">qimportbz</a> -
  Easily import patches from Bugzilla.</li>
<li><a href="https://hg.mozilla.org/users/tmielczarek_mozilla.com/bzexport">bzexport</a> -
  Easily export patches to Bugzilla.</li>
</ul>
<p>I'm amazed more developers don't use these simple productivity wins.
Could it be that people simply don't realize they are available?</p>
<p>Mozilla has a <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=794580">bug</a>
tracking easier configuration of the user's Mercurial environment. My
hope is one day people simply run a single command and get a
Mozilla-optimized Mercurial environment that <em>just works</em>. Along the same
vein, if your extensions are out of date, it prompts you to update them.
This is one of the benefits of a unified developer tool like mach: you
can put these checks in one place and everyone can reap the benefits
easily.</p>
<h2>Mercurial is extensible</h2>
<p>The major differentiator from almost every other version control system
(especially Git) is the ease and degree to which Mercurial can be
extended and contorted. <strong>If you take anything away from this
post it should be that Mercurial is a flexible and agile tool.</strong></p>
<p>If you want to change the behavior of a built-in command, you can write
an extension that monkeypatches that command. If you want to write a new
command, you can of course do that easily. You can have extensions
interact with one another - all natively. You can even override the wire
protocol to provide new <em>capabilities</em> to extend how peers communicate
with one another. You can leverage this to transfer additional metadata
or data types. This has nearly infinite potential. If that's not enough,
it's possible to create a new branching/development primitive through
just an extension alone! If you want to invent Git-style branches with
Mercurial, you could do that! It may require client and server support,
but it's possible.</p>
<p>Mercurial accomplishes this by being written (mostly) in Python (as
opposed to C) and by having a clear API on which extensions can be
built. Writing extensions in Python is huge. You can easily drop into
the debugger to learn the API and your write-test loop is much smaller.</p>
<p>By contrast, most other version control systems (including Git) require
you to parse output of commands (this is the UNIX piping principle).
Mercurial supports this too, but the native Python API is so much more
powerful. Instead of parsing output, you can just read the raw values
from a Python data structure. Yes please.</p>
<p>Since I imagine a lot of people at Mozilla will be reading this, here
are some ways Mozilla could leverage the extensibility of Mercurial:</p>
<ul>
<li>Command to create try pushes (it exists - see above).</li>
<li>Record who pushed what when (we have this - it's called the pushlog).</li>
<li>Command to land patches. If inbound1 is closed,
  automatically rebase on inbound2. etc. This could even be
  monkeypatched into <em>hg push</em> so pushes to inbound are automatically
  intercepted and magic ensues.</li>
<li>Record the automation success/fail status against individual
  revisions and integrate with commands (e.g. only pull up to the most
  recent stable changeset).</li>
<li>Command to create a review request for a patch or patch queue.</li>
<li>Command to assist with reviews. Perhaps a reviewer wants to make minor
  changes. Mercurial could download and apply the patch(es), wait for
  your changes, then reupload to Bugzilla (or the review tool)
  automatically.</li>
<li>Annotating commits or pushes with automation info (which jobs to
  run, etc).</li>
<li>Find Bugzilla component for patch (it exists - see above).</li>
<li>Expose custom protocol for configuring automation settings for a
  repository or a head. e.g. clients (with access) could reconfigure
  PGO scheduling, coalescing, etc without having to involve RelEng -
  useful for twigs and lesser used repositories.</li>
<li>So much more.</li>
</ul>
<p>Essentially, Mercurial itself could become the CLI tool code development
centers around. Whether that is a good idea is up for
debate. But, it can. And that says a lot about the flexibility of
Mercurial.</p>
<h2>Future potential of Mercurial</h2>
<p>When you consider the previous three points, you arrive at a new one:
Mercurial has a ton of future potential. The fact that extensions can
evolve vanilla Mercurial into something that resembles Mercurial in
name only is a testament to this.</p>
<p>When I sat down with a Mercurial core contributor, they reinforced this.
To them, Mercurial is a core library with a limited set of user-facing
commands forming the stable API. Since core features (like storage) are
internal APIs (not public commands - like Git), this means they aren't
bound to backwards compatibility and can refactor internals as needed
and evolve over time without breaking the world. That is a terrific
luxury.</p>
<p>An example of this future potential is
<a href="http://mercurial.selenic.com/wiki/ChangesetEvolution">changeset evolution</a>.
If you don't know what that is, you should because it's awesome. One of
the things they figured out is how to propagate rebasing between
clones!</p>
<h2>Comparing to Git</h2>
<p>Two years ago I would have said I would never opt to use Mercurial over
Git. I cannot say that today.</p>
<p>I do believe Git still has the advantage over Mercurial in a few areas:</p>
<ul>
<li>Branch management. Mercurial branches are a non-starter for
  light-weigh work. Mercurial bookmarks are kinda-sorta like Git
  branches, but not quite. I <em>really</em> like aspects of Git branches.
  Hopefully changeset evolution will cover the remaining gaps and more.</li>
<li>Patch conflict management. Git seems to do a better job of resolving
  patch conflicts. But, I think this is mostly due to Mercurial's patch
  queue extension not using the same merge code as built-in commands
  (this is a fixable problem).</li>
<li>Developer mind share and GitHub. The GitHub ecosystem makes up for
  many of Git's shortcomings. Bitbucket isn't the same.</li>
</ul>
<p>However, I believe Mercurial has the upper hand for:</p>
<ul>
<li>Command line friendliness. Git's command line syntax is notoriously
  awful and the concepts can be difficult to master.</li>
<li>Extensibility. It's so easy to program custom workflows and commands
  with Mercurial. If you want to hack your version control system,
  Mercurial wins hands down. Where Mercurial embraces extensibility, I
  couldn't even find a page listing all the useful Git <em>extensions</em>!</li>
<li>Open source culture. Every time I've popped into the Mercurial IRC
  channel I've had a good experience. I get a response quickly and
  without snark. Git by contrast, well, let's just say I'd rather be
  affiliated with the Mercurial crowd.</li>
<li>Future potential. Git is a content addressable key-value store with a
  version control system bolted on top. Mercurial is designed to be a
  version control system. Furthermore, Mercurial's code base is much
  easier to hack on than Git's. While Git has largely maintained feature
  parity in the last few years, Mercurial has grown new features. I see
  Mercurial evolving faster than Git and in ways Git cannot.</li>
</ul>
<p>It's worth calling out the major detractors for each.</p>
<p>I think Git's major weakness is its lack of extensibility and inability
to evolve (at least currently). Git will need to grow a better
extensibility model with better abstractions to compete with Mercurial
on new features. Or, the Git community will need to be receptive to
experimental features living in the core. All of this will require
some major API breakage. Unfortunately, I see little evidence this will
occur. I'm unable to find a <em>vision</em> document for the future of Git, a
branch with major new features, or interesting threads on the mailing
list. I tried to ask in their IRC channel and got crickets.</p>
<p>I think Mercurial's greatest weakness is lack of developer mindshare.
Git and GitHub are where it's at. This is huge, especially for projects
wanting collaboration.</p>
<p>Of all those points, I want to stress the extensibility and future
potential of Mercurial. If hacking your tools to maximize potential
and awesomeness is your game, Mercurial wins. End of debate. However,
if you don't want to harness these advantages, then I think Git and
Mercurial are mostly on equal footing. But given the rate of
development in the Mercurial project and relative stagnation of Git
(I can't name a major new Git feature in years), I wouldn't be
surprised if Mercurial's feature set obviously overtakes Git's in
the next year or two. Mind share will of course take longer and will
likely depend on what hosting sites like GitHub and Bitbucket do
(I wouldn't be surprised if GitHub rebranded as <em>CodeHub</em> or
something some day). Time will tell.</p>
<h2>Extending case study</h2>
<p><em>I have removed the case study that appeared in the original article
because as Mike Hommey observed in the comments, it wasn't a totally
accurate comparison. I don't believe the case study significantly added
much to the post, so I likely won't write a new one.</em></p>
<h2>Conclusion</h2>
<p>From where I started with Mercurial, I never thought I'd say this. But
here it goes: I like Mercurial.</p>
<p>I started warming up when it became faster and more robust in recent
versions in the last few years. When I learned about its flexibility and
the fundamentals of the project and thus its future potential, I became
a true fan.</p>
<p>It's easy to not like Mercurial if you are a new user coming
from Git and are forced to use a new tool. But, once you take the time to
properly configure it and appreciate it for what it is and what it
can be, Mercurial is easy to like.</p>
<p>I think Mercurial and Git are both fine version control systems. I would
happily use either one for a new project. If the social aspects of
development (including encouraging new contributors) were important to
me, I would likely select Git and GitHub. But, if I wanted something
just for me or I was a large project looking for a system that scales
and is flexible or was looking to the future, I'd go with Mercurial.</p>
<p>Mercurial is a rising star in the version control world. It's getting
faster and better and enabling others to more easily innovate through
powerful extensions. The future is bright for this tool.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Making hg-git Faster]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/04/14/making-hg-git-faster" />
    <id>http://gregoryszorc.com/blog/2013/04/14/making-hg-git-faster</id>
    <updated>2013-04-14T21:45:00Z</updated>
    <published>2013-04-14T21:45:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Git" />
    <summary type="html"><![CDATA[Making hg-git Faster]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/04/14/making-hg-git-faster"><![CDATA[<p>When enterprising individuals at Mozilla
<a href="http://bluishcoder.co.nz/2011/02/10/git-conversion-of-mozilla-central.html">started maintaining</a>
a Git mirror of Firefox's main source repository (hosted in Mercurial),
they ran into a significant problem: conversion was slow. The initial
conversion apparently took over 6 days and used a lot of memory.
Furthermore, each subsequent commit took many seconds, even on modern
hardware. This meant that the they could only maintain a Git mirror of
a few project branches and that updates would be slow. Furthermore,
the slowness of the conversion significantly discouraged people
from using the tool locally as part of regular development.</p>
<p>I thought this was unacceptable. I wanted to enable people to use
their tool of choice (Git) to develop Firefox. So, I did what annoyed
engineers do when confronted with an itch: I scratched it.</p>
<h2>Diagnosing the Problem</h2>
<p>When I started tackling this problem, I had little knowledge of the
problem space other than the problem statement: <em>converting from
Mercurial to Git is prohibitively slow</em> and that the slow tool was
<a href="http://hg-git.github.io/">hg-git</a>. My challenge was thus to make
hg-git faster.</p>
<p>When confronted with a performance problem, one of the first things you
do is identify the source of the bad performance. Then, you need to
acertain whether that is something you have the ability to change.</p>
<p>This often starts by answering some high-level questions then drilling
down into more detail as necessary. For a long-running system tool like
hg-git, I start with the <em>top test</em>: how much CPU, memory, and I/O is
the process utilizing?</p>
<p>In the case of hg-git, we were CPU bound. The Python process was
consistently pegging a single CPU core while periodically incurring I/O
(but not nearly enough to saturate a magnetic disk). This told me a few
things. First, I should look for bottlenecks inside Python. Second, I
should investigate whether parallel execution would be possible. The
latter is especially important these days because the trend in
processors is towards more cores rather than higher clock speeds. It's
no longer acceptable to let increases in clock speed or cycle efficiency
bail you out: if you want a CPU bound process to run as fast as
possible, it's often necessary to involve all available CPU cores.</p>
<p>Once I diagnosed CPU as the limiting factor, I pulled out the next tool
in the arsenal: a code profiler. I quickly discovered exactly where the
conversion was taking the most CPU time. As feared, it was in the
<em>export Mercurial changeset to Git commit</em> function.
Specifically, profiling had flagged the conversion of Mercurial
manifests to Git trees and blobs. Furthermore, most of the time was
spent in functions in Mercurial itself (Mercurial is implemented in
Python and hg-git calls into it natively) and Dulwich (a pure Python
implementation of Git). So, I was either looking at deficiencies or
Mercurial and/or Dulwich, a bad conversion algorithm in hg-git, or both.
To know which, I would need a better grasp on the internal storage
models of Mercurial and Git.</p>
<h2>Learning about Mercurial's and Git's internal storage models</h2>
<p>To understand why conversion from Mercurial to Git was slow, I needed to
understand how each stored data internally. My hope was that if attained
better understanding I could apply the knowledge to assess the algorithm
hg-git was using and optimize it, hopefully introducing parallel
execution along the way.</p>
<h3>Git's internals</h3>
<p>I already had a fairly good understanding of how Git works internally.
And, it's quite simple really. The <a href="http://git-scm.com/book/en/Git-Internals">Git Internals</a>
chapter of the <em>Pro Git</em> is extremely useful. While I encourage readers
to read all of the <a href="http://git-scm.com/book/en/Git-Internals-Git-Objects">Git Objects</a>
section, the gist is:</p>
<ul>
<li>Git's core storage is a key-value data store. Keys are SHA-1 checksums
  of content. Each entity is storage in a <em>Git object</em>.</li>
<li>A <em>blob</em> is an object holding the raw content of a file.</li>
<li>A <em>tree</em> is an object holding a list of <em>tree entries</em>. Each tree entry
  defines a blob, another tree object, etc. A tree is essentially a
  directory listing.</li>
<li>A <em>commit</em> object holds metadata about an individual Git commit. Each
  commit object refers to a specific <em>tree</em> object.</li>
</ul>
<p>When you introduce a new file that hasn't been seen before, a new <em>blob</em>
is added to storage. That blob is referenced by a <em>tree</em>. When you
update a file, a new <em>tree</em> is created referring to the new <em>blob</em> that
was created.</p>
<p>Things get a little complicated when you consider directories. If you
update the file <em>foo/bar/baz.c</em>, the tree for <em>foo/bar</em> changes (because
the SHA-1 of <em>baz.c</em> changed). And, the SHA-1 for the <em>foo/bar</em> tree
changes, so the <em>bar</em> entry in <em>foo</em>'s tree changes, changing the SHA-1
for the root tree.</p>
<p>That's essentially how Git addresses commits, directories, and files. If
you don't grok this, please, please read the aforementioned page on it -
it may even help you better grok Git!</p>
<h3>Mercurial's internals</h3>
<p>Unlike Git, I didn't really have a clue how Mercurial worked internally.
So, I needed to do some self-education here.</p>
<p>The best resource for Mercurial's storage model I've found is the
<a href="http://hgbook.red-bean.com/read/behind-the-scenes.html">Behind the Scenes</a>
chapter from <em>Mercurial: The Definitive Guide</em>. The gist is:</p>
<ul>
<li>History for an individual file is stored in a <em>filelog</em>. Each
  <em>filelog</em> contains the history of a single file. Each file revision
  has a hash based on the file contents.</li>
<li>The <em>manifest</em> lists every file, its permissions, and its file
  revision for each changeset in the repository.</li>
<li>The <em>changelog</em> contains information about each changeset, including
  the revision of the <em>manifest</em> to use.</li>
<li>Each of these logs contain <em>revisions</em> and you can address an
  individual revision within the log.</li>
</ul>
<p>From a high level, Mercurial's storage model is very similar to Git's.
They both address files by hashing their content. Where Git uses
multiple tree objects to define every file in a commit, Mercurial has a
single manifest containing a flat list. Aside from that, the
differences are mostly in implementation details. These are important,
as we'll soon see.</p>
<h2>Analyzing hg-git's conversion algorithm</h2>
<p>Armed with knowledge of how Git and Mercurial internally store data, I
was ready to analyze how hg-git was performing conversion from Mercurial
to Git. Since profiling revealed it was the <em>convert a single changeset
into Git commit</em> function that was taking all the time, I started there.</p>
<p>In Python (but not the actual Python), the algorithm was essentially:</p>
<div class="pygments_murphy"><pre><span class="k">def</span> <span class="nf">export_changeset_to_git</span><span class="p">(</span><span class="n">changeset</span><span class="p">,</span> <span class="n">git</span><span class="p">,</span> <span class="n">already_converted</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Receives the Mercurial changeset and a handle on a Git object storre.&quot;&quot;&quot;</span>
    <span class="c"># This is an entity that helps us build Git tree objects from</span>
    <span class="c"># paths and blobs. The logic is at</span>
    <span class="c"># https://github.com/jelmer/dulwich/blob/2a8548be3b1fd4a1ae7d0436dce91611112c47c2/dulwich/index.py#L298</span>
    <span class="n">tree_builder</span> <span class="o">=</span> <span class="n">TreeBuilder</span><span class="p">()</span>

    <span class="k">for</span> <span class="nb">file</span> <span class="ow">in</span> <span class="n">changeset</span><span class="o">.</span><span class="n">manifest</span><span class="p">:</span>
        <span class="n">blob_id</span> <span class="o">=</span> <span class="n">already_converted</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">blob_id</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">blob</span> <span class="o">=</span> <span class="n">Blob</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">data</span><span class="p">())</span>
            <span class="n">git</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">blob</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">blob</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>
            <span class="n">already_converted</span><span class="p">[</span><span class="nb">file</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">blob</span><span class="o">.</span><span class="n">id</span>
            <span class="n">blob_id</span> <span class="o">=</span> <span class="n">blob</span><span class="o">.</span><span class="n">id</span>

        <span class="n">tree_builder</span><span class="o">.</span><span class="n">add_file</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">path</span><span class="p">,</span> <span class="n">blob_id</span><span class="p">,</span> <span class="nb">file</span><span class="o">.</span><span class="n">mode</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">tree_builder</span><span class="o">.</span><span class="n">all_trees</span><span class="p">():</span>
        <span class="n">git</span><span class="o">.</span><span class="n">store</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">tree</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>

    <span class="n">root_tree</span> <span class="o">=</span> <span class="n">tree_builder</span><span class="o">.</span><span class="n">root_tree</span>

    <span class="c"># And proceed to build the Git commit and insert it.</span>
</pre></div>

<p>On the face of it, this code doesn't seem too bad. If I were writing the
functionality from scratch, I'd likely do something very similar. So,
why is it so slow?</p>
<p>As I mentioned earlier, profiling results had identified Mercurial and
Dulwich as the hot spots. The Mercurial hotspot was in iteration over
the files in the manifest. And the Dulwich offender with Git <em>tree</em>
object construction. By why?</p>
<p>First, it turns out that iterating a manifest the way hg-git was isn't
exactly performant. I never traced all the gory details, but I'm pretty
sure every time it accessed the file context through the change context
there was I/O involved. Not good, especially if you may not need the
information contained if it was already cached!</p>
<p>Second, it turns out that creating Git <em>tree</em> objects in Dulwich is
rather slow. And, the problem is magnified when converting large
repositories - like mozilla-central (Firefox's canonical repository).</p>
<p>So, I was faced with a decision: make Mercurial and/or Dulwich faster or
change hg-git. Since improving these would have benefits outside of
hg-git, I initially went down those roads. However, I eventually
abandonded the effort because of effort involved. And, in the case of
Dulwich, improving things would likely require rewriting some pieces in
C - not something I cared to do nor something that the Dulwich people
would likely accept since Dulwich is all about being a pure Python
implementation of Git! And in hindsight, this was the right call.
Mercurial and Dulwich are fast enough - it's hg-git that was being
suboptimal.</p>
<p>I was faced with two problems: don't mass iterate over manifests and
don't mass generate Git trees. Both were seemingly impossible to avoid
because both are critical to converting a Mercurial changeset to Git.</p>
<p>I thought about this problem for a while. I experimented with numerous
micro benchmarks. I engaged the very helpful Mercurial developers on IRC
(thanks everyone!). And, I eventually arrived at what I think is an
elegant solution.</p>
<p>When I took a step back and looked at the larger problem of exporting
Mercurial changesets to Git, I realized it would be beneficial in terms
of efficiency for the conversion to be more aware of what had occurred
before. Before I came along, hg-git was asking Mercurial for the full
state of each changeset for each changeset conversion. When you think
about it in low-level operations, this is extremely inefficient. Let's
take Git trees as an example.</p>
<p>When you perform a commit, only the trees - and
their parents - that had modified files will change. All the
other trees will be identical across commits. For large repositories (in
terms of files and directories) like mozilla-central, the number of
<em>static</em> trees across small commits is quite significant compared to
changed trees. The overhead of computing all these trees is not
insignificant!</p>
<p>Instead of throwing away all the trees and file context information
between changeset exports, what if I preserved it and reused it for the
next changeset? I think I'm on to something...</p>
<h2>Implementing incremental changeset export</h2>
<p>To minimize the work performed when exporting Mercurial changesets to
Git, I <a href="https://github.com/indygreg/hg-git/commit/aef6eacf86fb08101ea98a7787f3b20dd67287c2">implemented</a>
a standalone class that can emit Mercurial changeset deltas in terms of
Git objects. Essentially, it caches a Git tree representation of a
Mercurial manifest. When you feed a new Mercurial changeset into it, it
asks Mercurial to compare those changesets using the same API used by
<em>hg status</em>. This API is efficient and returns the information I care
about: the paths that changed. Once we have the changed files, we
<em>simply</em> reflect those changes in terms of updating Git trees.</p>
<p>If a file changes or is added, we emit a <em>blob</em>. If a <em>tree</em> changes, we
emit the new <em>tree</em> object. When the consumer has finished writing the
set of new objects to Git, it asks for the SHA-1 of the root tree. (Up
until this point the consumer is not aware of what any of the emitted
objects actually are - just that they likely need to be added to
storage.) It then uses the SHA-1 of the root tree to construct the
commit. Then it moves on to the next changeset.</p>
<p>The impact of this change is significant. On my computer, converting
Mercurial's own Mercurial repository Git went from <strong>21:07</strong> to <strong>8:14</strong>
on my i7-2600k. mozilla-central is even more drastic. The first 200
commits (the first commit was a large dump from CVS) took <strong>8:17</strong>
before and now take <strong>2:32</strong>. I don't have exact numbers from newer
commits, but I do know they were at least twice as slow as the initial
commits and showed an even more drastic speedup.</p>
<p>But I was just getting started.</p>
<p>The initial implementation wasn't very efficient in terms of reducing
tree object calculations. I changed that earlier today when I
<a href="https://groups.google.com/d/msg/hg-git/I5w_FscF6lw/LAc0pw1iilQJ">submitted a patch for consideration</a>
that only calculates tree changes for trees that actually changed. I
also removed some needless sorting on the order of export operations.
This second patch reduced conversion of Mercurial's repository down to
<strong>5:33</strong>. Even more impressive is that <strong>mozilla-central's changesets are
now exporting almost 4x faster</strong> with this patch alone. The first 200
changesets now export in <strong>42s</strong> (down from <strong>2:32</strong> which is down from
<strong>8:17</strong>). This is mostly due to the overhead of reprocessing
non-dirty trees on every export.</p>
<p>And I'm not through.</p>
<p>As part of building the standalone incremental changeset exporter, one
of the goals in the back of my mind was to eventually have things
execute in parallel.</p>
<p>In my <a href="https://github.com/indygreg/hg-git/tree/performance-next">personal development branch</a>
I have a <a href="https://github.com/indygreg/hg-git/commit/e74641284fecc928b0b8f8dcc01ef9b99e09c3cc">patch</a>
to perform Mercurial changeset export on multiple cores. Essentially
hg-git fires up a bunch of worker processes and asks each to export a
consecutive range of changesets. The workers writes new Git objects into
Git and then tells the coordinator process the root tree SHA-1
corresponding to each Mercurial changeset. The coordinator process then
uses these root tree SHA-1's to derive Git commit objects (you can't
create the commit object until you know the SHA-1 of the commit's
parents).</p>
<p>The blob and tree exporting on separate processes makes Mercurial to Git
export scale out to however many cores you feel like throwing at it.
When 32 core machines come around, you can convert using all available
cores and the speedup should roughly be linear with the number of cores.</p>
<p>I'm still working out some kinks in the multiple processes patch
(the <em>multiprocessing</em> module is very difficult to get working on all
platforms and I don't want to break hg-git when it lands). But,
<a href="http://ehsanakhgari.org/">Ehsan Akhgari</a> has been using it to power the
<a href="https://github.com/mozilla/mozilla-central/">GitHub mirror</a> of
mozilla-central for months without issue. (His use of these patches
freed up the CPU required to support conversion of more project branches
on the Git mirror. And, he's still not using the 4x improvement patch I
wrote today - he will shortly - so who knows what improvements will stem
from that.)</p>
<p>With all the patches applied, hg-git now feels like a Ferrari when
exporting Mercurial changesets to Git. Conversion of Mercurial's
repository now takes <strong>1:25</strong> (down from <strong>21:07</strong>). <strong>Conversion of
mozilla-central has gone from 6+ days to about 3 hours!</strong> More
importantly, ongoing conversions feel somewhat snappy now.</p>
<h2>Making Git export even faster</h2>
<p>With the patch today, I'd say optimization of exporting Mercurial
changesets is nearing its limits. There are a few things I could try
that may net another 2 or 3x improvement. But, I think the ~50x
improvement I've already attained (at least for mozilla-central) is
pretty damn good and good enough for most users. (Part of performance
optimization is knowing when is good enough and stopping before you
invest excessive time in the long tail.)</p>
<p>There is one giant refactor that could likely net a significant win for
Git export. However, it requires optimizing for initial export over
recurring incremental export (which is why I have little interest in
it). Incremental export incurs a lot of <em>random</em> I/O accessing Mercurial
filelogs and extracting specific file revisions as they are needed. An
optimal export would iterate over the filelogs and export Git blobs from
each filelog in the sequence they occur in within the filelogs. It would
cache the file node to blob SHA-1. After all blobs are exported, the
mappings would be combined and distributed to all workers. Then, tree
export would occur in parallel largely under the existing model modulo
blob writing. This would minimize overall I/O and work in Mercurial and
would likely be significantly faster. However, it's mostly useful for
initial export and IMO not worth implementing. (It's possible to employ
a variation for incremental export that iterates over filelogs and
exports not-yet-seen revisions. Perhaps I will investigate this some
day.)</p>
<h2>What about converting Git to Mercurial?</h2>
<p>Now that I've tackled Mercurial to Git conversion, it's very tempting to
work magic on the inverse: converting Git commits to Mercurial
changesets. While I haven't looked at this problem in detail, I already
know it will be at least slightly more challenging.</p>
<p>The reason is parallelization. With Mercurial export, I have each child
process reading directly from Mercurial and writing directly to Git.
There are no locks involved. There is just a coordinator that ensures
minimum redundant work among workers. There is some redundant
work, sure. But, the alternative would be lots of locking and/or
exchange of state across processes - not cheap operations! Furthermore,
the writes into Git can occur in any order (since Git is just a
key-value store). The only hard requirement is a child commit must
come after its parent (because you need the parent commit's SHA-1).
And, single-threaded insert of commit objects isn't a big deal because
you can crank through hundreds of them per second (it might even be over
1000/s on my machine).</p>
<p>Mercurial's storage implementation does not afford me the same
<em>carelessness</em> with regards to writing into storage. Since Mercurial
uses shared files for individual file and manifest history, we have
a contention problem. We <em>could</em> lock files when writing to them.
However, these files (<em>revlogs</em> in Mercurial speak) also use
transparent delta compression. You get the best performance/compression
when changes are written in the order they actually occured in (at
least in the typical case).</p>
<p>To optimally write to Mercurial you need to order inserts. This means
parallel reads from Git (in separate worker processes) would be very
difficult to implement. Doable, sure, but you're looking at a lot of
transferred state and ordering. This likely involves a lot more memory
and CPU usage.</p>
<p>The best idea I've come up with so far is a single process
that reads off Git commits and iterates trees. It hashes the paths of
seen files to a consistent worker process which then pulls the blob from
Git's storage and inserts it into the filelog. You don't need to lock
filelogs because only one worker owns a specific path. Workers report
the blob's corresponding file node to another process which then
assembles manifests, writes manifests in order, and finally creates
and writes changesets. Unfortunately, the worker processes are just
doing blob I/O. There is no parallel processing of Git tree calculation
or Mercurial manifests. Given this was a significant source of slowness
exporting <em>to</em> Git, I worry the inverse will be true. Although, the
problem with Git was tree <em>creation</em> and it was due to the volume. Since
there is only 1 manifest per changeset, perhaps it won't be as bad.</p>
<p>While I've brainstormed a solution, I have no concrete plans to work on
Git to Mercurial conversion. The impetus for me working on Mercurial to
Git speedups was that I and a number of other Mozilla people were
personally impacted. If the same is true for Git to Mercurial slowness,
I could invest a few hours the next time I'm sick and bored over the
weekend.</p>
<h2>Conclusion</h2>
<p>Converting Mercurial repositories to Git with hg-git is now
significantly faster. If you thought it was too slow before, grab the
latest code (from either the official repository or my personal branch)
and enjoy.</p>]]></content>
  </entry>
</feed>
