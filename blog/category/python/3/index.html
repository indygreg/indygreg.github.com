


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
Design by Free CSS Templates
http://www.freecsstemplates.org
Released for free under a Creative Commons Attribution 2.5 License

Name       : Pollinating  
Description: A two-column, fixed-width design with dark color scheme.
Version    : 1.0
Released   : 20101114

-->
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    
  <title>Gregory Szorc's Digital Home
</title>
<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
<link rel="alternate" type="application/atom+xml" title="Atom 1.0"
href="/blog/feed/atom" />
<link rel="stylesheet" href="/style/style.css" type="text/css" />
<link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />


  </head>
  <body>
    <div id="wrapper">
      
  <div id="menu">
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="/blog/">Blog</a></li>
    <li><a href="/notes">Notes</a></li>
    <li><a href="/work.html">Work</a></li>
    <li><a href="/skills.html">Skills</a></li>
    <li><a href="/thoughts.html">Thoughts</a></li>
    <li><a href="/resume.pdf">Resume</a></li>
  </ul>
</div>


      <div id="page">
        <div id="page-bgtop">
          <div id="page-bgbtm">
              <div id="content">
                
  
<div class="blog_post">
  <a name="faster-in-memory-python-module-importing"></a>
  <h2 class="blog_post_title"><a href="/blog/2018/12/28/faster-in-memory-python-module-importing" rel="bookmark" title="Permanent Link to Faster In-Memory Python Module Importing">Faster In-Memory Python Module Importing</a></h2>
  <small>December 28, 2018 at 12:40 PM | categories: 

<a href='/blog/category/python'>Python</a>, <a href='/blog/category/pyoxidizer'>PyOxidizer</a>, <a href='/blog/category/rust'>Rust</a>
</small><p/>
  <div class="post_prose">
    
  <p>I <a href="/blog/2018/12/18/distributing-standalone-python-applications/">recently blogged about</a>
distributing standalone Python applications. In that post, I announced
<a href="https://github.com/indygreg/PyOxidizer">PyOxidizer</a> - a tool which
leverages Rust to produce standalone executables embedding Python. One of the
features of PyOxidizer is the ability to import Python modules embedded
within the binary using zero-copy.</p>
<p>I also recently blogged about
<a href="/blog/2018/10/29/global-kernel-locks-in-apfs/">global kernel locks in APFS</a>,
which make filesystem operations slower on macOS. This was the latest wrinkle in
a long battle against Python's slow startup times, which I've posted about
on the official python-dev mailing list
<a href="https://mail.python.org/pipermail/python-dev/2014-May/134528.html">over</a>
<a href="https://mail.python.org/pipermail/python-dev/2018-May/153296.html">the</a>
<a href="https://mail.python.org/pipermail/python-dev/2018-October/155466.html">years</a>.</p>
<p>Since I announced PyOxidizer a few days ago, I've had some productive holiday
hacking sessions!</p>
<p>One of the reached milestones is PyOxidizer now supports macOS.</p>
<p>With that milestone reached, I thought it would be interesting to compare
the performance of a PyOxidizer executable versus a standard CPython build.</p>
<p>I produced a <a href="https://gist.github.com/indygreg/be1c229fa41ced5c76d912f7073f9de6">Python script</a>
that imports almost the entirety of the Python standard library - at least the
modules implemented in Python. That's 508 <code>import</code> statements. I then
executed this script using a typical <code>python3.7</code> binary (with the standard
library on the filesystem) and PyOxidizer-produced standalone executables
with a module importer that loads Python modules from memory using zero copy.</p>
<pre><code># Homebrew installed CPython 3.7.2

# Cold disk cache.
$ sudo purge
$ time /usr/local/bin/python3.7 &lt; import_stdlib.py
real   0m0.694s
user   0m0.354s
sys    0m0.121s

# Hot disk cache.
$ time /usr/local/bin/python3.7 &lt; import_stdlib.py
real   0m0.319s
user   0m0.263s
sys    0m0.050s

# PyOxidizer with non-PGO/non-LTO CPython 3.7.2
$ time target/release/pyapp &lt; import_stdlib.py
real   0m0.223s
user   0m0.201s
sys    0m0.017s

# PyOxidizer with PGO/non-LTO CPython 3.7.2
$ time target/release/pyapp &lt; import_stdlib.py
real   0m0.234s
user   0m0.210s
sys    0m0.019

# PyOxidizer with PTO+LTO CPython 3.7.2
$ sudo purge
$ time target/release/pyapp &lt; import_stdlib.py
real   0m0.442s
user   0m0.252s
sys    0m0.059s

$ time target/release/pyall &lt; import_stdlib.py
real   0m0.221s
user   0m0.197s
sys    0m0.020s
</code></pre>
<p>First, the PyOxidizer times are all relatively similar regardless of whether
PGO or LTO is used to build CPython. That's not too surprising, as I'm
exercising a very limited subset of CPython (and I suspect the benefits
of PGO/LTO aren't as pronounced due to the nature of the CPython API).</p>
<p>But the bigger result is the obvious speedup with PyOxidizer and its
in-memory importing: <strong>PyOxidizer can import almost the entirety of the
Python standard library ~100ms faster - or ~70% of original - than a
typical standalone CPython install</strong> with a hot disk cache! This comes
out to ~0.19ms per <code>import</code> statement. If we run <code>purge</code> to clear out
the disk cache, the performance delta increases to 252ms, or ~64% of
original. All these numbers are on a 2018 6-core 2.9 GHz i9 MacBook Pro,
which has a pretty decent SSD.</p>
<p>And on Linux on an i7-6700K running in a Hyper-V VM:</p>
<pre><code># pyenv installed CPython 3.7.2

# Cold disk cache.
$ time ~/.pyenv/versions/3.7.2/bin/python &lt; import_stdlib.py
real   0m0.405s
user   0m0.165s
sys    0m0.065s

# Hot disk cache.
$ time ~/.pyenv/versions/3.7.2/bin/python &lt; import_stdlib.py
real   0m0.193s
user   0m0.161s
sys    0m0.032s

# PyOxidizer with PGO CPython 3.7.2

# Cold disk cache.
$ time target/release/pyapp &lt; import_stdlib.py
real   0m0.227s
user   0m0.145s
sys    0m0.016s

# Hot disk cache.
$ time target/release/pyapp &lt; import_stdlib.py
real   0m0.152s
user   0m0.136s
sys    0m0.016s
</code></pre>
<p>On a hot disk cache, the run-time improvement of PyOxidizer is ~41ms, or
~78% of original. This comes out to ~0.08ms per <code>import</code> statement. When
flushing caches by writing <code>3</code> to <code>/proc/sys/vm/drop_caches</code>, the delta
increases to ~178ms, or ~56% of original.</p>
<p>Using <code>dtruss -c</code> to execute the binaries, the breakdown in system calls
occurring &gt;10 times is clear:</p>
<pre><code># CPython standalone
fstatfs64                                      16
read_nocancel                                  19
ioctl                                          20
getentropy                                     22
pread                                          26
fcntl                                          27
sigaction                                      32
getdirentries64                                34
fcntl_nocancel                                106
mmap                                          114
close_nocancel                                129
open_nocancel                                 130
lseek                                         148
open                                          168
close                                         170
read                                          282
fstat64                                       403
stat64                                        833

# PyOxidizer
lseek                                          10
read                                           12
read_nocancel                                  14
fstat64                                        16
ioctl                                          22
munmap                                         31
stat64                                         33
sysctl                                         33
sigaction                                      36
mmap                                          122
madvise                                       193
getentropy                                    315
</code></pre>
<p>PyOxidizer avoids hundreds of <code>open()</code>, <code>close()</code>, <code>read()</code>,
<code>fstat64()</code>, and <code>stat64()</code> calls. And by avoiding these calls,
PyOxidizer not only avoids the userland-kernel overhead intrinsic to them,
but also any additional overhead that APFS is imposing via its global
lock(s).</p>
<p>(Why the PyOxidizer binary is making hundreds of calls to <code>getentropy()</code>
I'm not sure. It's definitely coming from Python as a side-effect of a
module import and it is something I'd like to fix, if possible.)</p>
<p>With this experiment, we finally have the ability to better isolate the
impact of filesystem overhead on Python module importing and preliminary
results indicate that the overhead is not insignificant - at least on the
tested systems (I'll get data for Windows when PyOxidizer supports it).
While the test is somewhat contrived (I don't think many applications import
the entirety of the Python standard library), some Python applications do
import hundreds of modules. And as I've
<a href="https://mail.python.org/pipermail/python-dev/2018-May/153296.html">written before</a>,
milliseconds matter. This is especially true if you are invoking Python
processes hundreds or thousands of times in a build system, when running
a test suite, for scripting, etc. Cumulatively you can be importing tens
of thousands of modules. So I think shaving even fractions of a
millisecond from module importing is important.</p>
<p>It's worth noting that in addition to the system call overhead, CPython's
path-based importer runs
<a href="https://github.com/python/cpython/blob/804a5d94b6b7f8cb8546112aee2bc3af362f28f5/Lib/importlib/_bootstrap_external.py">substantially more</a>
Python code
<a href="https://github.com/indygreg/PyOxidizer/blob/c50e63338abd08ebac86746a33d750756d622edc/pyrepackager/src/memoryimporter.py">than PyOxidizer</a>
and this likely contributes several milliseconds of overhead as well. Because
PyOxidizer applications are static, the importer can remain simple (finding a
module in PyOxidizer is essentially a Rust <code>HashMap&lt;String, Vec&lt;u8&gt;</code> lookup).
While it might be useful to isolate the filesystem overhead from Python code
overhead, the thing that end-users care about is overall execution time: they
don't care where that overhead is coming from. So I think it is fair to compare
PyOxidizer - with its intrinsically simpler import model - with what Python
typically does (scan <code>sys.path</code> entries and looking for modules on the
filesystem).</p>
<p>Another difference is that PyOxidizer is almost completely statically linked.
By contrast, a typical CPython install has compiled extension modules as
standalone shared libraries and these shared libraries often link against
other shared libraries (such as libssl). From <code>dtruss</code> timing information,
I don't believe this difference contributes to significant overhead, however.</p>
<p>Finally, I haven't yet optimized PyOxidizer. I still have a few tricks up
my sleeve that can likely shave off more overhead from Python startup. But
so far the results are looking <em>very</em> promising. I dare say they are looking
promising enough that Python distributions themselves might want to look
into the area more thoroughly and consider distribution defaults that rely
less on the every-Python-module-is-a-separate-file model.</p>
<p>Stay tuned for more <a href="https://github.com/indygreg/PyOxidizer">PyOxidizer</a>
updates in the near future!</p>
<p><em>(I updated this post a day after initial publication to add measurements
for Linux.)</em></p>

  </div>
</div>



  <hr class="interblog" />
  
<div class="blog_post">
  <a name="distributing-standalone-python-applications"></a>
  <h2 class="blog_post_title"><a href="/blog/2018/12/18/distributing-standalone-python-applications" rel="bookmark" title="Permanent Link to Distributing Standalone Python Applications">Distributing Standalone Python Applications</a></h2>
  <small>December 18, 2018 at 03:35 PM | categories: 

<a href='/blog/category/python'>Python</a>, <a href='/blog/category/pyoxidizer'>PyOxidizer</a>, <a href='/blog/category/rust'>Rust</a>
</small><p/>
  <div class="post_prose">
    
  <h2>The Problem</h2>
<p>Packaging and application distribution is a hard problem on multiple
dimensions. For Python, large aspects of this problem space are more or
less solved if you are distributing open source Python libraries and your
target audience is developers (<em>use pip and PyPI</em>). But if you are distributing
Python <em>applications</em> - standalone executables that use Python - your
world can be much more complicated.</p>
<p>One of the primary reasons why distributing Python applications is difficult
is because of the complex and often sensitive relationship between a Python
application and the environment it runs in.</p>
<p>For starters we have the Python interpreter itself. If your application doesn't
distribute the Python interpreter, you are at the whims of the Python
interpreter provided by the host machine. You may want to target Python 3.7
only. But because Python 3.5 or 3.6 is the most recent version installed by
many Linux distros, you are forced to support older Python versions and all
their quirks and lack of features.</p>
<p>Going down the rabbit hole, even the presence of a supposedly compatible
version of the Python interpreter isn't a guarantee for success! For example,
the Python interpreter could have a built-in extension that links against
an old version of a library. Just last week I was encountering weird SQlite
bugs in Firefox's automation because Python was using an old version of
SQLite with known bugs. Installing a modern SQLite fixed the problems. Or
the interpreter could have modifications or extra installed packages
interfering with the operation of your application. There are never-ending
corner cases. And I can tell you from my experience with having to support
the Firefox build system (which uses Python heavily) that you will encounter
these corner cases given a broad enough user base.</p>
<p>And even if the Python interpreter on the target machine is fully compatible,
getting your code to run on that interpreter could be difficult! Several
Python applications leverage compiled extensions linking against Python's
C API. Distributing the precompiled form of the extension can be challenging,
especially when your code needs to link against 3rd party libraries, which
may conflict with something on the target system. And, the precompiled
extensions need to be built in a very delicate manner to ensure they can
run on as many target machines as possible. But not distributing pre-built
binaries requires the end-user be able to compile Python extensions. Not
every user has such an environment and forcing this requirement on them is
not user friendly.</p>
<p><strong>From an application developer's point of view, distributing a copy of the
Python interpreter along with your application is the only reliable way of
guaranteeing a more uniform end-user experience.</strong> Yes, you will still
have variability because every machine is different. But you've eliminated
the the Python interpreter from the set of unknowns and that is a huge win.
(Unfortunately, distributing a Python interpreter comes with a host of other
problems such as size bloat, security/patching concerns, poking the OS
packaging bears, etc. But those problems are for another post.)</p>
<h2>Existing Solutions</h2>
<p>There are tons of existing tools for <em>solving</em> the Python application
distribution problem.</p>
<p>The approach that tools like <a href="https://shiv.readthedocs.io/en/latest/">Shiv</a>
and <a href="https://github.com/pantsbuild/pex">PEX</a> take is to leverage Python's
built-in support for <em>running</em> zip files. Essentially, if there is a zip
file containing a <code>__main__.py</code> file and you execute <code>python file.zip</code>
(or have a zip file with a <code>#!/usr/bin/env python</code> shebang), Python
can load modules in that zip file and execute an application within. Pretty
cool!</p>
<p>This approach works great if your execution environment supports shebangs
(Windows doesn't) and the Python interpreter is suitable. But if you need
to support Windows or don't have control over the execution environment
and can't guarantee the Python interpreter is <em>good</em>, this approach isn't
suitable.</p>
<p>As stated above, we want to distribute the Python interpreter with our
application to minimize variability. Let's talk about tools that do that.</p>
<p><a href="https://github.com/facebookincubator/xar/">XAR</a> is a pretty cool offering
from Facebook. XAR files are executables that contain
<a href="https://en.wikipedia.org/wiki/SquashFS">SquashFS</a> filesystems. Upon running
the executable, SquashFS filesystems are created. For Python applications,
the XAR contains a copy of the Python interpreter and all your Python modules.
At run-time, these files are <em>extracted</em> to SquashFS filesystems and the
Python interpreter is executed. If you squint hard enough, it is kind of
like a pre-packaged, executable virtualenv which also contains the Python
interpreter.</p>
<p>XARs are pretty cool (and aren't limited to Python). However, because XARs
rely on SquashFS, they have a run-time requirement on the target machine.
This is great if you only need to support Linux and macOS and your target
machines support FUSE and SquashFS. But if you need to support Windows or
a general user population without SquashFS support, XARs won't help you.</p>
<p>Zip files and XARs are great for enterprises that have tightly controlled
environments. But for a general end-user population, we need something
more robust against variance among target machines.</p>
<p>There are a handful of tools for packaging Python applications along with
the Python interpreter in more resilient manners.</p>
<p><a href="http://nuitka.net/pages/overview.html">Nuitka</a> <em>converts</em> Python source
to C code then compiles and links that C code against libpython. You can
perform a static link and compile everything down to a single executable.
If you do the compiling properly, that executable should <em>just work</em> on
pretty much every target machine. That's pretty cool and is exactly the
kind of solution application distributors are looking for: you can't get
much simpler than a self-contained executable! While I'd love to vouch
for Nuitka and recommend using it, I haven't used it so can't. And I'll
be honest, the prospect of compiling Python source to C code kind of
terrifies me. That effectively makes Nuitka a new Python implementation
and I'm not sure I can (yet) place the level of trust in Nuitka that I
have for e.g. CPython and PyPy.</p>
<p>And that leads us to our final category of tools:
<a href="https://docs.python-guide.org/shipping/freezing/">freezing your code</a>. There
are a handful of tools like <a href="https://www.pyinstaller.org/">PyInstaller</a>
which automate the process of building your Python application (often via
standard <code>setup.py</code> mechanisms), assembling all the requisite bits of
the Python interpreter, and producing an artifact that can be distributed
to end users. There are even tools that produce Windows installers, RPMs,
DEBs, etc that you can sign and distribute.</p>
<p>These <em>freezing</em> tools are arguably the state of the art for Python
application distribution to general user populations. On first glance
it seems like all the needed tools are available here. But there are
cracks below the surface.</p>
<h2>Issues with Freezing</h2>
<p>A common problem with freezing is it often relies on the Python interpreter
used to build the frozen application. For example, when building a frozen
application on Linux, it will bundle the system's Python interpreter with
the frozen application. And that interpreter may link against libraries
or libc symbol versions not available on all target machines. So, the
build environment has to be <em>just right</em> in order for the binaries to
run on as many target systems as possible. This isn't an insurmountable
problem. But it adds overhead and complexity to application maintainers.</p>
<p>Another limitation is how these frozen applications handle importing
Python modules.</p>
<p>Multiple tools take the approach of embedding an archive (usually a zip file)
in the executable containing the Python <em>standard library</em> bits not part of
libpython. This includes C extensions (compiled to <code>.so</code> or <code>.pyd</code> files)
and Python source (<code>.py</code>) or bytecode (<code>.pyc</code>) files. There is typically
a step - either at application start time or at module import time - where a
file is extracted to the filesystem such that Python's filesystem-based
importer can load it from there.</p>
<p>For example, PyInstaller <a href="https://pyinstaller.readthedocs.io/en/stable/operating-mode.html#how-the-one-file-program-works">extracts the standard library to a temporary directory
at application start time</a>
(at least when running in single file mode). This can add significant overhead
to the startup time of applications - more than enough to blow through people's
ability to perceive something as <em>instantaneous</em>. This is acceptable for
long-running applications. But for applications (like CLI tools or support
tools for build systems), the overhead can be a non-starter. And, the mere
fact that you are doing filesystem write I/O establishes a requirement that
the application have write access to the filesystem and that write I/O can
perform reasonably well lest application performance suffer. These can be
difficult pills to swallow!</p>
<p>Another limitation is that these tools often assume the executable being
produced is only a Python application. Sometimes Python is <em>part of</em> a
larger application. It would be useful to produce a library that can
easily be embedded within a larger application.</p>
<h2>Improving the State of the Art</h2>
<p>Existing Python application distribution mechanisms don't tick all the
requirements boxes for me. We have tools that are suitable for internal
distribution in well-defined <em>enterprise</em> environments. And we have tools
that target general user populations, albeit with a burden on application
maintainers and often come with a performance hit and/or limited flexibility.</p>
<p>I want something that allows me to produce a standalone, single file executable
containing a Python interpreter, the Python standard library (or a subset of
it), and all the custom code and resources my application needs. That
executable should not require any additional library dependencies beyond what is
already available on most target machines (e.g. libc). That executable should
not require any special filesystem providers (e.g. FUSE/SquashFS) nor should
it require filesystem write access nor perform filesystem write I/O at run-time.
I should be able to embed a Python interpreter within a larger application,
without the overhead of starting the Python interpreter if it isn't needed.</p>
<p>No existing solution ticks all of these boxes.</p>
<p>So I set out to build one.</p>
<p>One problem is producing a Python interpreter that is portable and
fully-featured. You can't punt on this problem because if the core Python
interpreter isn't produced in just the right way, your application will
depend on libraries or symbol versions not available in all environments.</p>
<p>I've created the <a href="https://github.com/indygreg/python-build-standalone">python-build-standalone</a>
project for automating the process of building Python interpreters suitable
for use with standalone, distributable Python applications. The project
produces (and has available for download) binary artifacts including a
pre-compiled Python interpreter and object files used for compiling that
interpreter. The Python interpreter is compiled with PGO/LTO using a modern
Clang, helping to ensure that Python code runs as fast as it can. All of
Python's dependencies are compiled from source with the modern toolchain and
everything is aggressively statically linked to avoid external dependencies.
The toolchain and pre-built distribution are available for downstream
consumers to compile Python extensions with/against.</p>
<p>It's worth noting that use of a modern Clang toolchain is likely sufficiently
different from what you use today. When producing <em>manylinux</em> wheels, it is
recommended to use the <a href="https://github.com/pypa/manylinux">pypa/manylinux</a>
Docker images. These Docker images are based on CentOS 5 (for maximum libc
and other system library compatibility). While they do install a custom
toolchain, Python and any extensions compiled in that environment are compiled
with GCC 4.8.2 (as of this writing). That's a GCC from 2013. A lot has
changed in compilers since 2013 and building Python and extensions with a
compiler released in 2018 should result in various benefits (faster code,
better warnings, etc).</p>
<p>If producing custom CPython builds for standalone distribution interests
you, you should take a look at how I coerced CPython to statically link
all extensions. Spoiler: it involves producing a custom-tailored
<code>Modules/Setup.local</code> file that bypasses <code>setup.py</code>, along with some
<code>Makefile</code> hacks. Because the build environment is deterministic and isolated
in a container, we can get away with some ugly hacks.</p>
<p>A statically linked <code>libpython</code> from which you can produce a standalone
binary embedding Python is only the first layer in the onion. The next layer
is how to handle the Python standard library.</p>
<p><code>libpython</code> only contains the code needed to run the core bits of the Python
interpreter. If we attempt to run a statically linked <code>python</code> executable
without the standard library in the filesystem, things fail pretty fast:</p>
<pre><code>$ rm -rf lib
$ bin/python
Could not find platform independent libraries &lt;prefix&gt;
Could not find platform dependent libraries &lt;exec_prefix&gt;
Consider setting $PYTHONHOME to &lt;prefix&gt;[:&lt;exec_prefix&gt;]
Fatal Python error: initfsencoding: Unable to get the locale encoding
ModuleNotFoundError: No module named 'encodings'

Current thread 0x00007fe9a3432740 (most recent call first):
Aborted (core dumped)
</code></pre>
<p>I'll spare you the details for the moment, but initializing the CPython
interpreter (via <code>Py_Initialize()</code> <em>requires</em> that parts of the Python
standard library be available). This means that in order to fulfill our dream
of a single file executable, we will need custom code that teaches the
embedded Python interpreter to load the standard library from within the
binary... somehow.</p>
<p>As far as I know, efficient embedded standard library handling without run-time
requirements does not exist in the current Python packaging/distribution
ecosystem. So, I had to devise something new.</p>
<p>Enter <a href="https://github.com/indygreg/pyoxidizer">PyOxidizer</a>. PyOxidizer is
a collection of Rust crates that facilitate building an embeddable Python
library, which can easily be added to an executable. We need <em>native</em> code
to interface with the Python C APIs in order to influence Python interpreter
startup. It is 2018 and Rust is a better C/C++, so I chose Rust for this
<em>driver</em> functionality instead of C. Plus, Rust's integrated build system
makes it easier to automate the integration of the custom Python interpreter
files into binaries.</p>
<p>The role of PyOxidizer is to take the pre-built Python interpreter files from
<a href="https://github.com/indygreg/python-build-standalone">python-build-standalone</a>,
combine those files with any other Python files needed to run an application,
and marry them to a Rust crate. This Rust crate can trivially be turned into
a self-contained executable containing a Python application. Or, it can be
combined with another Rust project. Or it can be emitted as a library and
integrated with a non-Rust application. There's a lot of flexibility by design.</p>
<p>The mechanism I used for embedding the Python standard library into a single
file executable without incurring explicit filesystem access at run-time is
(I believe) new, novel, and somewhat crazy. Let me explain how it works.</p>
<p>First, there are no <code>.so</code>/<code>.pyd</code> shared library compiled Python extensions
to worry about. This is because all compiled extensions are statically linked
into the Python interpreter. To the interpreter, they exist as
<a href="https://docs.python.org/3.7/library/importlib.html#importlib.machinery.BuiltinImporter">built-in modules</a>.
Typically, a CPython build will have some modules like <code>_abc</code>, <code>_io</code>, and
<code>sys</code> provided by <em>built-in modules</em>. Modules like <code>_json</code> exist as standalone
shared libraries that are loaded on demand. <code>python-build-standalone</code>'s
modifications to CPython's build system converts all these would-be standalone
shared libraries into <em>built-in modules</em>. (Because we distribute the object
files that compose the eventual <code>libpython</code>, it is possible to filter out
unwanted modules to cut down on binary size if you don't want to ship a
fully-featured Python interpreter.) Because there are no standalone shared
libraries providing Python modules, we don't have the problem of needing to
load a shared library to load a module, which would undermine our goal of
<em>no filesystem access to import modules</em>. And that's a good thing, too,
because <code>dlopen()</code> requires a path: you can't load a shared library from
a memory address. (Fun fact: there are hacks like
<a href="https://sourceware.org/bugzilla/show_bug.cgi?id=11767">dlopen_with_offset()</a>
that provide an API to load a library from memory, but they require a custom
libc. Google uses this approach for their internal single-file Python
application solution.)</p>
<p>From the <code>python-build-standalone</code> artifacts, PyOxidizer collects all files
belonging to the Python standard library (notably <code>.py</code> and <code>.pyc</code> files).
It also collects other source, bytecode, and resource files needed to run
a custom application.</p>
<p>The relevant files are assembled and serialized into data structures which
contain the names of the resources and their raw content. These data structures
are made available to Rust as <code>&amp;'static [u8]</code> variables (essentially a
<code>static void*</code> if you don't speak Rust).</p>
<p>Using the <a href="https://github.com/dgrunwald/rust-cpython">rust-cpython</a> crate,
PyOxidizer defines a custom Python extension module implemented purely in Rust.
When loaded, the module parses the data structures containing available
Python resource names and data into <code>HashMap&lt;&amp;str, &amp;[u8]&gt;</code> instances. In other
words, it builds a native mapping from resource name to a pointer to its raw
data. The Rust-implemented module exports to Python an API for accessing that
data. From the Python side, you do the equivalent of <code>MODULES.get_code('foo')</code>
to request the bytecode for a named Python module. When called, the Rust code
will perform the lookup and return a <code>memoryview</code> instance pointing to the
raw data. (The use of <code>&amp;[u8]</code> and <code>memoryview</code> means that embedded resource
data is loaded from its static, read-only memory location instead of copied
into a data structure managed by Python. This zero copy approach translates to
less overhead for importing modules. Although, the memory needs to be paged
in by the operating system. So on slow filesystems, reducing I/O and e.g.
compressing module data might be a worthwhile optimization. This can be a
future feature.) </p>
<p>Making data embedded within a binary available to a Python module is relatively
easy. I'm definitely not the first person to come up with this idea. What is
hard - and what I <em>might</em> be the first person to actually do - is how you make
the Python module importing mechanism load <em>all</em> standard library modules via
such a mechanism.</p>
<p>With a custom extension module built-in to the binary exposing module data,
it should <em>just</em> be a matter of registering a custom
<a href="https://docs.python.org/3.7/library/sys.html#sys.meta_path">sys.meta_path</a>
importer that knows how to load modules from that custom location. This
problem turns out to be quite hard!</p>
<p>The initialization of a CPython interpreter is - as I've learned - a bit
complex. A CPython interpreter must be initialized via <code>Py_Initialize()</code>
before any Python code can run. That means in order to modify <code>sys.meta_path</code>,
<code>Py_Initialize()</code> must finish.</p>
<p>A lot of activity occurs under the hood during initialization. Applications
embedding Python have very little control over what happens during
<code>Py_Initialize()</code>. You can change some superficial things like what
filesystem paths to use to bootstrap <code>sys.path</code> and what encodings to use
for stdio descriptors. But you can't really influence the core actions that are
being performed. And there's no mechanism to directly influence
<code>sys.meta_path</code> before an <code>import</code> is performed. (Perhaps there should be?)</p>
<p>During <code>Py_Initialize()</code>, the interpreter needs to configure the encodings
for the filesystem and the stdio descriptors. Encodings are loaded from
Python modules provided by the standard library. So, during the course of
<code>Py_Initialize()</code>, the interpreter needs to import some modules originally
backed by <code>.py</code> files. This creates a dilemma: if <code>Py_Initialize()</code>
needs to <code>import</code> modules in the standard library, the standard library
is backed by memory and isn't available to known importing mechanisms, and
there's no opportunity to configure a custom <code>sys.meta_path</code> importer
before <code>Py_Initialize()</code> runs, how do you teach the interpreter about
your custom module importer and the location of the standard library modules
needed by <code>Py_Initialize()</code>?</p>
<p>This is an extremely gnarly problem and it took me some hours and many false
leads to come up with a solution.</p>
<p>My first attempt involved the esoteric
<a href="https://docs.python.org/3/c-api/import.html#c.PyImport_FrozenModules">frozen modules</a>
feature. (This work predated the use of a custom data structure and module
containing modules data.) The Python interpreter has a
<code>const struct _frozen* PyImport_FrozenModules</code> data structure defining an
array of <em>frozen</em> modules. A <em>frozen</em> module is defined by its module
name and precompiled bytecode data (roughly equivalent to <code>.pyc</code> file
content). Partway through <code>Py_Initialize()</code>, the Python interpreter is able
to import modules. And one of the built-in importers that is automatically
registered knows how to load modules if they are in <code>PyImport_FrozenModules</code>!</p>
<p>I attempted to audit Python interpreter startup and find all modules
that were imported during <code>Py_Initialize()</code>. I then defined a custom
<code>PyImport_FrozenModules</code> containing these modules. In theory, the import
of these modules during <code>Py_Initialize()</code> would be handled by the
<a href="https://docs.python.org/3.7/library/importlib.html#importlib.machinery.FrozenImporter">FrozenImporter</a>
and everything would <em>just work</em>: if I were able to get <code>Py_Initialize()</code> to
complete, I'd be able to register a custom <code>sys.meta_path</code> importer
immediately afterwards and we'd be set.</p>
<p>Things did not go as planned.</p>
<p><code>FrozenImporter</code> doesn't fully conform to the
<a href="https://www.python.org/dev/peps/pep-0451/">PEP 451</a> requirements for
setting specific attributes on modules. Without these attributes, the
<code>from . import aliases</code> statement in <code>encodings/__init__.py</code> fails
because the importer is unable to resolve the relative module name. Derp.
One would think CPython's built-in importers would comply with PEP 451
and that all of Python's standard library could be imported as frozen modules.
But this is not the case! I was able to hack around this particular failure
by using an absolute import. But I hit another failure and did not want to
excavate that rabbit hole. Once I realized that <code>FrozenImporter</code> was lacking
mandated module attributes, I concluded that attempting to use <em>frozen modules</em>
as a general import-from-memory mechanism was not viable. Furthermore, the
C code backing <code>FrozenImporter</code> walks the <code>PyImport_FrozenModules</code> array and
does a string compare on the module name to find matches. While I didn't
benchmark, I was concerned that un-indexed scanning at import time would
add considerable overhead when hundreds of modules were in play. (The C code
backing <code>BuiltinImporter</code> uses the same approach and I do worry CPython's
imports of built-in extension modules is causing measurable overhead.)</p>
<p>With <em>frozen modules</em> off the table, I needed to find another way to inject
a custom module importer that was usable during <code>Py_Initialize()</code>. Because
we control the source Python interpreter, modifications to the source code
or even link-time modifications or run-time hacks like trampolines weren't
off the table. But I <strong>really</strong> wanted things to work out of the box because
I don't want to be in the business of maintaining patches to Python
interpreters.</p>
<p>My foray into <em>frozen modules</em> enlightened me to the craziness that is
the bootstrapping of Python's importing mechanism.</p>
<p>I remember hearing that the Python module importing mechanism used to be
written in C and was rewritten in Python. And I knew that the
<a href="https://docs.python.org/3.7/library/importlib.html">importlib</a> package
defined interfaces allowing you to implement your own importers, which
could be registered on
<a href="https://docs.python.org/3.7/library/sys.html#sys.meta_path">sys.meta_path</a>.
But I didn't know how all of this worked at the interpreter level.</p>
<p>The internal <a href="https://github.com/python/cpython/blob/08c2ba0717089662132af69bf5948d82277a8a69/Python/pylifecycle.c#L178">initimport()</a>
C function is responsible for initializing the module importing mechanism. It
does the equivalent of <code>import _frozen_importlib</code>, but using the
<a href="https://docs.python.org/3/c-api/import.html#c.PyImport_ImportFrozenModuleObject">PyImport_ImportFrozenModule()</a>
API. It then manipulates some symbols and calls <code>_frozen_importlib.install()</code>
with references to the <code>sys</code> and <code>imp</code> built-in modules. Later (in
<code>initexternalimport()</code>), a <code>_frozen_importlib_external</code> module is imported
and has code within it executed.</p>
<p>I was initially very confused by this because - while there are references
to <code>_frozen_importlib</code> and <code>_frozen_importlib_external</code> all over the
CPython code base, I couldn't figure out where the code for those modules
actually lived! Some sleuthing of the build directory eventually revealed
that the files <a href="https://github.com/python/cpython/blob/08c2ba0717089662132af69bf5948d82277a8a69/Lib/importlib/_bootstrap.py">Lib/importlib/_bootstrap.py</a>
and <a href="https://github.com/python/cpython/blob/08c2ba0717089662132af69bf5948d82277a8a69/Lib/importlib/_bootstrap_external.py">Lib/importlib/_bootstrap_external.py</a>
were <em>frozen</em> to the module names <code>_frozen_importlib</code> and
<code>_frozen_importlib_external</code>, respectively.</p>
<p>Essentially what is happening is the bulk of Python's import <em>machinery</em> is
implemented in Python (rather than C). But there's a chicken-and-egg
problem where you can't run just any Python code (including any <code>import</code>
statement) until the interpreter is partially or fully initialized.</p>
<p>When building CPython, the Python source code for <code>importlib._bootstrap</code>
and <code>importlib._bootstrap_external</code> are compiled to bytecode. This
bytecode is emitted to <code>.h</code> files, where it is exposed as a
<code>static char *</code>. This bytecode is eventually referenced by the
default <code>PyImport_FrozenModules</code> array, allowing the modules to be
imported via the frozen importer's C API, which bypasses the higher-level
importing mechanism, allowing it to work before the full importing
mechanism is initialized.</p>
<p><code>initimport()</code> and <code>initexternalimport()</code> both call Python functions in
the frozen modules. And we can clearly look at the source of the
corresponding modules and see the Python code do things like
<a href="https://github.com/python/cpython/blob/08c2ba0717089662132af69bf5948d82277a8a69/Lib/importlib/_bootstrap.py#L1158">register the default importers on <code>sys.meta_path</code></a>.</p>
<p>Whew, that was a long journey into the bowels of CPython's internals. How
does all this help with single file Python executables?</p>
<p>Well, the predicament that led us down this rabbit hole was there was no
way to register a custom module importer before <code>Py_Initialize()</code>
completes and before an <code>import</code> is attempted during said <code>Py_Initialize()</code>.</p>
<p>It took me a while, but I finally realized the frozen
<code>importlib._bootstrap_external</code> module provided the window I needed!
<code>importlib._bootstrap_external</code>/<code>_frozen_importlib_external</code> is <em>always</em>
executed during <code>Py_Initialize()</code>. So if you can modify this module's code,
you can run arbitrary code during <code>Py_Initialize()</code> and influence Python
interpreter configuration. And since <code>_frozen_importlib_external</code> is a frozen
module and the <code>PyImport_FrozenModules</code> array is writable and can be modified
before <code>Py_Initialize()</code> is called, all one needs to do is replace the
<code>_frozen_importlib</code> / <code>_frozen_importlib_external</code> bytecode in
<code>PyImport_FrozenModules</code> and you can run arbitrary code during Python
interpreter startup, before <code>Py_Initialize()</code> completes and before any
standard library imports are performed!</p>
<p>My solution to this problem is to concatenate some custom Python code to
<code>importlib/_bootstrap_external.py</code>. This custom code defines a
<code>sys.meta_path</code> importer that knows how to use our Rust-backed built-in
extension module to find and load module data. It redefines the <code>_install()</code>
function so that this custom importer is registered on <code>sys.meta_path</code>
when the function is called during <code>Py_Initialize()</code>. The <em>new</em> Python
source is compiled to bytecode and the <code>PyImport_FrozenModules</code> array is
modified at run-time to point to the modified <code>_frozen_importlib_external</code>
implementation. When <code>Py_Initialize()</code> executes its first standard library
import, module data is provided by the custom <code>sys.meta_path</code> importer,
which grabs it from a Rust extension module, which reads it from a
read-only data structure in the executable binary, which is converted
to a Python <code>memoryview</code> instance and sent back to Python for processing.</p>
<p>There's a bit of <em>magic</em> happening behind the scenes to make all of this
work. PyOxidizer attempts to hide as much of the gory details as possible.
From the perspective of an application maintainer, you just need to define
a minimal config file and it handles most of the low-level details. And there's
even a higher-level Rust API for configuring the embedded Python interpreter,
should you need it.</p>
<p><code>python-build-standalone</code> and <code>PyOxidizer</code> are still in their infancy.
They are very much alpha quality. I consider them technology previews more
than usable software at this point. But I think enough is there to demonstrate
the viability of using Rust as the build system and run-time glue to build
and distribute standalone applications embedding Python.</p>
<p>Time will tell if my utopian vision of zero-copy, no explicit filesystem
I/O for Python module imports will pan out. Others who have ventured into
this space have warned me that lots of Python modules rely on <code>__file__</code>
to derive paths to other resources, which are later <code>stat()</code>d and
<code>open()</code>d. <code>__file__</code> for in-memory modules doesn't exactly make sense
and can't be operated on like normal paths/files. I'm not sure what the
inevitable struggles to support these modules will lead to. Maybe we'll have
to extract things to temporary directories like other standalone Python
applications. Maybe <code>PyOxidizer</code> will take off and people will start using
the <a href="https://docs.python.org/3.7/library/importlib.html#importlib.abc.ResourceReader">ResourceReader</a>
API, which is apparently the proper way to do these things these days.
(Caveat: <code>PyOxidizer</code> doesn't yet implement this API but support is planned.)
Time will tell. I'm not opposed to gross hacks or writing more code as
needed.</p>
<p>Producing highly distributable and performant Python applications has been far
too difficult for far too long. My primary goal for PyOxidizer is to lower these
barriers. By leveraging Rust, I also hope to bring Python and Rust closer
together. I want to enable applications and libraries to effortlessly harness
the powers of both of these fantastic programming languages.</p>
<p>Again, <code>PyOxidizer</code> is still in its infancy. I anticipate a significant amount
of hacking over the holidays and hope to share updates in the weeks ahead. Until
then, please leave comments, watch the <a href="https://github.com/indygreg/PyOxidizer">project on GitHub</a>,
file issues for bugs and feature requests, etc and we'll see where things lead.</p>

  </div>
</div>



  <hr class="interblog" />
  
<div class="blog_post">
  <a name="global-kernel-locks-in-apfs"></a>
  <h2 class="blog_post_title"><a href="/blog/2018/10/29/global-kernel-locks-in-apfs" rel="bookmark" title="Permanent Link to Global Kernel Locks in APFS">Global Kernel Locks in APFS</a></h2>
  <small>October 29, 2018 at 02:20 PM | categories: 

<a href='/blog/category/python'>Python</a>, <a href='/blog/category/mercurial'>Mercurial</a>, <a href='/blog/category/apple'>Apple</a>
</small><p/>
  <div class="post_prose">
    
  <p>Over the past several months, a handful of people had been complaining
that Mercurial's test harness was executing much slower on Macs. But
this slowdown seemingly wasn't occurring on Linux or Windows. And not
every Mac user experienced the slowness!</p>
<p>Before jetting off to the Mercurial 4.8 developer meetup in Stockholm
a few weeks ago, I sat down with a relatively fresh 6+6 core MacBook Pro
and experienced the problem firsthand: on my 4+4 core i7-6700K running
Linux, the Mercurial test harness completes in ~12 minutes, but on this
MacBook Pro, it was executing in ~38 minutes! On paper, this result
doesn't make any sense because there's no way that the MacBook Pro should
be ~3x slower than that desktop machine.</p>
<p>Looking at Activity Monitor when running the test harness with 12 tests
in parallel revealed something odd: the system was spending ~75% of overall
CPU time inside the kernel! When reducing the number of tests that ran in
parallel, the percentage of CPU time spent in the kernel decreased and
the overall test harness execution time also decreased. This kind of
behavior is usually a sign of something very inefficient in kernel land.</p>
<p>I sample profiled all processes on the system when running the Mercurial
test harness. Aggregate thread stacks revealed a common pattern:
<code>readdir()</code> being in the stack.</p>
<p>Upon closer examination of the stacks, <code>readdir()</code> calls into
<code>apfs_vnop_readdir()</code>, which calls into some functions with <code>bt</code> or
<code>btree</code> in their name, which call into <code>lck_mtx_lock()</code>,
<code>lck_mtx_lock_grab_mutex()</code> and various other functions with
<code>lck_mtx</code> in their name. And the caller of most <code>readdir()</code> appeared
to be Python 2.7's module importing mechanism (notably
<code>import.c:case_ok()</code>).</p>
<p>APFS refers to the
<a href="https://en.wikipedia.org/wiki/Apple_File_System">Apple File System</a>,
which is a filesystem that Apple introduced in 2017 and is the
default filesystem for new versions of macOS and iOS. If upgrading an
old Mac to a new macOS, its HFS+ filesystems would be automatically
converted to APFS.</p>
<p>While the source code for APFS is not available for me to confirm, the
profiling results showing excessive time spent in
<code>lck_mtx_lock_grab_mutex()</code> combined with the fact that execution time
decreases when the parallel process count decreases leads me to the
conclusion that <strong>APFS obtains a global kernel lock during read-only
operations such as <code>readdir()</code></strong>. In other words, APFS slows down when
attempting to perform parallel read-only I/O.</p>
<p>This isn't the first time I've encountered such behavior in a
filesystem: last year I
<a href="/blog/2017/12/08/good-riddance-to-aufs/">blogged about very similar behavior in AUFS</a>,
which was making Firefox CI significantly slower.</p>
<p>Because Python 2.7's module importing mechanism was triggering the
slowness by calling <code>readdir()</code>, I
<a href="https://mail.python.org/pipermail/python-dev/2018-October/155466.html">posted to python-dev</a>
about the problem, as I thought it was important to notify the larger
Python community. After all, this is a generic problem that affects
the performance of starting <em>any</em> Python process when running on APFS.
i.e. if your build system invokes many Python processes in parallel,
you could be impacted by this. As part of obtaining data for that post, I
discovered that Python 3.7 does not call <code>readdir()</code> as part of
module importing and therefore doesn't exhibit a severe slowdown. (Python's
module importing code was rewritten significantly in Python 3 and the <em>fix</em>
was likely introduced well before Python 3.7.)</p>
<p>I've <a href="https://gist.github.com/indygreg/a50e187f5372807cdcab5ac12bc2feea">produced a gist that can reproduce the problem</a>.
The script essentially performs a recursive directory walk. It exercises
the <code>opendir()</code>, <code>readdir()</code>, <code>closedir()</code>, and <code>lstat()</code> functions
heavily and is essentially a benchmark of the filesystem and filesystem
cache's ability to return file metadata.</p>
<p>When you tell it to walk a very large directory tree - say a Firefox
version control checkout (which has over 250,000 files) - the excessive
time spent in the kernel is very apparent on macOS 10.13 High Sierra:</p>
<pre><code>$ time ./slow-readdir.py -l 12 ~/src/firefox
ran 12 walks across 12 processes in 172.209s

real    2m52.470s
user    1m54.053s
sys    23m42.808s

$ time ./slow-readdir.py -l 12 -j 1 ~/src/firefox
ran 12 walks across 1 processes in 523.440s

real    8m43.740s
user    1m13.397s
sys     3m50.687s

$ time ./slow-readdir.py -l 18 -j 18 ~/src/firefox
ran 18 walks across 18 processes in 210.487s

real    3m30.731s
user    2m40.216s
sys    33m34.406s
</code></pre>
<p>On the same machine upgraded to macOS 10.14 Mojave, we see a bit of a
speedup!:</p>
<pre><code>$ time ./slow-readdir.py -l 12 ~/src/firefox
ran 12 walks across 12 processes in 97.833s

real    1m37.981s
user    1m40.272s
sys    10m49.091s

$ time ./slow-readdir.py -l 12 -j 1 ~/src/firefox
ran 12 walks across 1 processes in 461.415s

real    7m41.657s
user    1m05.830s
sys     3m47.041s

$ time ./slow-readdir.py -l 18 -j 18 ~/src/firefox
ran 18 walks across 18 processes in 140.474s

real    2m20.727s
user    3m01.048s
sys    17m56.228s
</code></pre>
<p>Contrast with my i7-6700K Linux machine backed by EXT4:</p>
<pre><code>$ time ./slow-readdir.py -l 8 ~/src/firefox
ran 8 walks across 8 processes in 6.018s

real    0m6.191s
user    0m29.670s
sys     0m17.838s

$ time ./slow-readdir.py -l 8 -j 1 ~/src/firefox
ran 8 walks across 1 processes in 33.958s

real    0m34.164s
user    0m17.136s
sys     0m13.369s

$ time ./slow-readdir.py -l 12 -j 12 ~/src/firefox
ran 12 walks across 12 processes in 25.465s

real    0m25.640s
user    1m4.801s
sys     1m20.488s
</code></pre>
<p>It is apparent that macOS 10.14 Mojave has received performance work
relative to macOS 10.13! Overall kernel CPU time when performing parallel
directory walks has decreased substantially - to ~50% of original on some
invocations! Stacks seem to reveal new code for lock acquisition, so this
might indicate generic improvements to the kernel's locking mechanism
rather than APFS specific changes. Changes to file metadata caching could
also be responsible for performance changes. Although it is difficult to tell
without access to the APFS source code. Despite those improvements, APFS
is still spending a lot of CPU time in the kernel. And the kernel CPU time
is still comparatively very high compared to Linux/EXT4, even for single
process operation.</p>
<p>At this time, I haven't conducted a comprehensive analysis of APFS to
determine what other filesystem operations seem to acquire global kernel
locks: all I know is <code>readdir()</code> does. A casual analysis of profiled
stacks when running Mercurial's test harness against Python 3.7 seems
to show <code>apfs_*</code> functions still on the stack a lot and that seemingly
indicates more APFS slowness under parallel I/O load. But HFS+ exhibited
similar problems (it appeared HFS+ used a single I/O thread inside the
kernel for many operations, making I/O on macOS pretty bad), so I'm
not sure if these could be considered <em>regressions</em> the way <code>readdir()</code>'s
new behavior is.</p>
<p>I've reported this issue to Apple at
<a href="https://bugreport.apple.com/web/?problemID=45648013">https://bugreport.apple.com/web/?problemID=45648013</a>
and on OpenRadar at <a href="https://openradar.appspot.com/radar?id=5025294012383232">https://openradar.appspot.com/radar?id=5025294012383232</a>.
I'm told that issues get more attention from Apple when there are many
duplicates of the same issue. So please reference this issue if you file your
own report.</p>
<p>Now that I've elaborated on the technical details, I'd like to add some
personal commentary. While this post is about APFS, this issue of global
kernel locks during common I/O operations is not unique to APFS. I
<a href="/blog/2017/12/08/good-riddance-to-aufs/">already referenced</a> similar
issues in AUFS. And I've encountered similar behaviors with Btrfs (although
I can't recall exactly which operations). And NTFS has its own
<a href="https://github.com/Microsoft/WSL/issues/873#issuecomment-425272829">bag of problems</a>.</p>
<p>This seeming pattern of global kernel locks for common filesystem operations
and slow filesystems is really rubbing me the wrong way. Modern NVMe SSDs
are capable of reading and writing well over 2 gigabytes per second and
performing hundreds of thousands of I/O operations per second. We even have
Intel soon producing
<a href="https://newsroom.intel.com/editorials/re-architecting-data-center-memory-storage-hierarchy/">persistent solid state storage that plugs into DIMM slots</a>
because it is that friggin fast.</p>
<p>Today's storage hardware is capable of ludicrous performance. It is fast enough
that you will likely saturate multiple CPU cores processing the read or written
data coming from and going to storage - especially if you are using higher-level,
non-JITed (read: slower) programming languages (like Python). There has also been
a trend that systems are growing more CPU cores faster than they are instructions
per second per core. And SSDs only achieve these ridiculous IOPS numbers if many
I/O operations are <em>queued</em> and can be more efficiently dispatched within the
storage device. What this all means is that it probably makes sense to use
parallel I/O across multiple threads in order to extract all potential
performance from your persistent storage layer.</p>
<p>It's also worth noting that we now have solid state storage that outperforms (in
some dimensions) what DRAM from ~20 years ago was capable of. Put another way I/O
APIs and even some filesystems were designed in an era when its RAM was slower than
what today's persistent storage is capable of! While I'm no filesystems or kernel
expert, it does seem a bit silly to be using APIs and filesystems designed for an
era when storage was multiple orders of magnitude slower and systems only had a
single CPU core.</p>
<p>My takeaway is I can't help but feel that systems-level software (including the
kernel) is severely limiting the performance potential of modern storage
devices. If we have e.g. global kernel locks when performing common I/O operations,
there's no chance we'll come close to harnessing the full potential of today's
storage hardware. Furthermore, the behavior of filesystems is woefully under
documented and software developers have little solid advice for how to achieve
optimal I/O performance. As someone who cares about performance, I want to
squeeze every iota of potential out of hardware. But the lack of documentation
telling me which operations acquire locks, which strategies are best for say
reading or writing 10,000 files using N threads, etc makes this extremely
difficult. And even if this documentation existed, because of differences in
behavior across filesystems and operating systems and the difficulty in
programmatically determining the characteristics of filesystems at run time,
it is practically impossible to design a <em>one size fits all</em> approach to
high performance I/O.</p>
<p>The filesystem is a powerful concept. I want to agree and use the <em>everything is a
file</em> philosophy. Unfortunately, filesystems don't appear to be scaling very well
to support the potential of modern day storage technology. We're probably at the
point where commodity priced solid state storage is far more capable than today's
software for the majority of applications. Storage hardware manufacturers will
keep producing faster and faster storage and their marketing teams will keep
convincing us that we need to buy it. But until software catches up, chances are
most of us won't come close to realizing the true potential of modern storage
hardware. And that's even true for specialized applications that do employ tricks
taking hundreds or thousands of person hours to implement in order to eek out every
iota of performance potential. The average software developer and application
using filesystems as they were designed to be used has little to no chance of
coming close to utilizing the performance potential of modern storage devices.
That's really a shame. </p>

  </div>
</div>



  <hr class="interblog" />
  
<div class="blog_post">
  <a name="release-of-python-zstandard-0.9"></a>
  <h2 class="blog_post_title"><a href="/blog/2018/04/09/release-of-python-zstandard-0.9" rel="bookmark" title="Permanent Link to Release of python-zstandard 0.9">Release of python-zstandard 0.9</a></h2>
  <small>April 09, 2018 at 09:30 AM | categories: 

<a href='/blog/category/python'>Python</a>, <a href='/blog/category/mozilla'>Mozilla</a>
</small><p/>
  <div class="post_prose">
    
  <p>I have just released
<a href="https://pypi.python.org/pypi/zstandard/0.9.0">python-zstandard 0.9.0</a>. You can
install the latest release by running <code>pip install zstandard==0.9.0</code>.</p>
<p><a href="http://facebook.github.io/zstd/">Zstandard</a> is a highly tunable and therefore
flexible compression algorithm with support for modern features such as
multi-threaded compression and <em>dictionaries</em>. Its performance is remarkable
and if you use it as a drop-in replacement for zlib, bzip2, or other common
algorithms, you'll frequently see more than a doubling in performance.</p>
<p>python-zstandard provides rich bindings to the zstandard C library without
sacrificing performance, safety, features, or a Pythonic feel. The bindings
run on Python 2.7, 3.4, 3.5, 3.6, 3.7 using either a C extension or CFFI
bindings, so it works with CPython and PyPy.</p>
<p>I can make a compelling argument that python-zstandard is one of the
richest compression packages available to Python programmers. Using it, you
will be able to leverage compression in ways you couldn't with other packages
(especially those in the standard library) all while achieving ridiculous
performance. Due to my focus on performance, python-zstandard is able to
outperform Python bindings to other compression libraries that <em>should</em> be
faster. This is because python-zstandard is very diligent about minimizing
memory allocations and copying, minimizing Python object creation, reusing
state, etc.</p>
<p>While python-zstandard is formally marked as a beta-level project and hasn't
yet reached a 1.0 release, it is suitable for production usage.
python-zstandard 0.8 shipped with Mercurial and is in active production
use there. I'm also aware of other consumers using it in production, including
at Facebook and Mozilla.</p>
<p>The sections below document some of the new features of python-zstandard 0.9.</p>
<h2>File Object Interface for Reading</h2>
<p>The 0.9 release contains a <code>stream_reader()</code> API on the compressor and
decompressor objects that allows you to treat those objects as readable file
objects. This means that you can pass a <code>ZstdCompressor</code> or <code>ZstdDecompressor</code>
around to things that accept file objects and things generally <em>just work</em>.
e.g.:</p>
<div class="pygments_murphy"><pre><span></span>   <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">compressed_file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ifh</span><span class="p">:</span>
       <span class="n">cctx</span> <span class="o">=</span> <span class="n">zstd</span><span class="o">.</span><span class="n">ZstdDecompressor</span><span class="p">()</span>
       <span class="k">with</span> <span class="n">cctx</span><span class="o">.</span><span class="n">stream_reader</span><span class="p">(</span><span class="n">ifh</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
           <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
               <span class="n">chunk</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">32768</span><span class="p">)</span>
               <span class="k">if</span> <span class="ow">not</span> <span class="n">chunk</span><span class="p">:</span>
                   <span class="k">break</span>
</pre></div>

<p>This is probably the most requested python-zstandard feature.</p>
<p>While the feature is usable, it isn't complete. Support for <code>readline()</code>,
<code>readinto()</code>, and a few other APIs is not yet implemented. In addition,
you can't use these <em>reader</em> objects for opening zstandard compressed
tarball files because Python's <code>tarfile</code> package insists on doing
backward seeks when reading. The current implementation doesn't support
backwards seeking because that requires buffering decompressed output and that
is not trivial to implement. I recognize that all these features are useful
and I will try to work them into a subsequent release of 0.9.</p>
<h2>Negative Compression Levels</h2>
<p>The 1.3.4 release of zstandard (which python-zstandard 0.9 bundles) supports
negative compression levels. I won't go into details, but negative compression
levels disable extra compression features and allow you to trade compression
ratio for more speed.</p>
<p>When compressing a 6,472,921,921 byte uncompressed bundle of the Firefox
Mercurial repository, the previous fastest we could go with level 1 was
~510 MB/s (measured on the input side) yielding a 1,675,227,803 file (25.88%
of original).</p>
<p>With level <code>-1</code>, we compress to 1,934,253,955 (29.88% of original) at
~590 MB/s. With level <code>-5</code>, we compress to 2,339,110,873 bytes (36.14% of
original) at ~720 MB/s.</p>
<p>On the decompress side, level 1 decompresses at ~1,150 MB/s (measured at
the output side), -1 at ~1,320 MB/s, and -5 at ~1,350 MB/s (generally speaking,
zstandard's decompression speeds are relatively similar - and fast - across
compression levels).</p>
<p>And that's just with a single thread. zstandard supports using multiple
threads to compress a single input and python-zstandard makes this feature
easy to use. Using 8 threads on my 4+4 core i7-6700K, level 1 compresses
at ~2,000 MB/s (3.9x speedup), -1 at ~2,300 MB/s (3.9x speedup), and -5
at ~2,700 MB/s (3.75x speedup).</p>
<p>That's with a large input. What about small inputs?</p>
<p>If we take 456,599 Mercurial commit objects spanning 298,609,254 bytes from
the Firefox repository and compress them individually, at level 1 we yield
a total of 133,457,198 bytes (44.7% of original) at ~112 MB/s. At level -1,
we compress to 161,241,797 bytes (54.0% of original) at ~215 MB/s. And at
level -5, we compress to 185,885,545 bytes (62.3% of original) at ~395 MB/s.</p>
<p>On the decompression side, level 1 decompresses at ~260 MB/s, -1 at
~1,000 MB/s, and -5 at ~1,150 MB/s.</p>
<p>Again, that's 456,599 operations on a single thread with Python.</p>
<p>python-zstandard has an <em>experimental</em> API where you can pass in a collection
of inputs and it batch compresses or decompresses them in a single operation.
It releases and GIL and uses multiple threads. It puts the results in shared
buffers in order to minimize the overhead of memory allocations and Python
object creation and garbage collection. Using this mode with 8 threads on
my 4+4 core i7-6700K, level 1 compresses at ~525 MB/s, -1 at ~1,070 MB/s,
and -5 at ~1,930 MB/s. On the decompression side, level 1 is ~1,320 MB/s,
-1 at ~3,800 MB/s, and -5 at ~4,430 MB/s.</p>
<p>So, my consumer grade desktop i7-6700K is capable of emitting decompressed
data at over 4 GB/s with Python. That's pretty good if you ask me. (Full
disclosure: the timings were taken just around the compression operation
itself: overhead of loading data into memory was not taken into account. See
the <code>bench.py</code> script in the
<a href="https://github.com/indygreg/python-zstandard">source repository</a> for more.</p>
<h2>Long Distance Matching Mode</h2>
<p>Negative compression levels take zstandard into performance territory that
has historically been reserved for compression formats like lz4 that are
optimized for that domain. <em>Long distance matching</em> takes zstandard in the
other direction, towards compression formats that aim to achieve optimal
compression ratios at the expense of time and memory usage.</p>
<p>python-zstandard 0.9 supports long distance matching and all the configurable
parameters exposed by the zstandard API.</p>
<p>I'm not going to capture many performance numbers here because python-zstandard
performs about the same as the C implementation because <em>LDM</em> mode spends
most of its time in zstandard C code. If you are interested in numbers, I
recommend reading the zstandard
<a href="https://github.com/facebook/zstd/releases/tag/v1.3.2">1.3.2</a>
and <a href="https://github.com/facebook/zstd/releases/tag/v1.3.4">1.3.4</a> release notes.</p>
<p>I will, however, underscore that zstandard can achieve close to lzma's
compression ratios (what the <code>xz</code> utility uses) while completely smoking
lzma on decompression speed. For a bundle of the Firefox Mercurial repository,
zstandard level 19 with a long distance window size of 512 MB using 8 threads
compresses to 1,033,633,309 bytes (16.0%) in ~260s wall, 1,730s CPU.
<code>xz -T8 -8</code> compresses to 1,009,233,160 (15.6%) in ~367s wall, ~2,790s CPU.</p>
<p>On the decompression side, zstandard takes ~4.8s and runs at ~1,350 MB/s as
measured on the output side while <code>xz</code> takes ~54s and runs at ~114 MB/s.
Zstandard, however, does use a lot more memory than <code>xz</code> for decompression,
so that performance comes with a cost (512 MB versus 32 MB for this
configuration).</p>
<h2>Other Notable Changes</h2>
<p>python-zstandard now uses the <em>advanced</em> compression and decompression APIs
everywhere. All tunable compression and decompression parameters are available
to python-zstandard. This includes support for disabling magic headers in frames
(saves 4 bytes per frame - this can matter for very small inputs, especially when
using dictionary compression).</p>
<p>The full dictionary training API is exposed. Dictionary training can now use
multiple threads.</p>
<p>There are a handful of utility functions for inspecting zstandard frames,
querying the state of compressors, etc.</p>
<p>Lots of work has gone into shoring up the code base. We now build with warnings
as errors in CI. I performed a number of focused auditing passes to fix
various classes of deficiencies in the C code. This includes use of the
<em>buffer protocol</em>: python-zstandard is now able to accept <em>any</em> Python
object that provides a view into its underlying raw data.</p>
<p>Decompression contexts can now be constructed with a max memory threshold
so attempts to decompress something that would require more memory will
result in error.</p>
<p>See the
<a href="https://github.com/indygreg/python-zstandard/releases/tag/0.9.0">full release notes</a>
for more.</p>
<h2>Conclusion</h2>
<p>Since I last released a major version of python-zstandard, a lot has changed in
the zstandard world. As I
<a href="/blog/2017/03/07/better-compression-with-zstandard/">blogged last year</a>,
zstandard circa early 2017 was a very compelling compression format: it already
outperformed popular compression formats like zlib and bzip2 across the board.
As a <em>general purpose</em> compression format, it made a compelling case for itself.
In my mind, <em>brotli</em> was its only real challenger.</p>
<p>As I wrote then, zstandard isn't perfect. (Nothing is.) But a year later, it
is refreshing to see advancements.</p>
<p>A criticism one year ago was zstandard was pretty good as a general purpose
compression format but it wasn't great if you live at the fringes. If you were
a speed freak, you'd probably use lz4. If you cared about compression ratios,
you'd probably use lzma. But recent releases of zstandard have made huge strides
into the territory of these niche formats. Negative compression levels allow
zstandard to flirt with lz4's performance. Long distance matching allows
zstandard to achieve close to lzma's compression ratios. <strong>This is a big friggin
deal because it makes it much, much harder to justify a domain-specific compression
format over zstandard.</strong> I think lzma still has a significant edge for ultra
compression ratios when memory utilization is a concern. But for many consumers,
memory is readily available and it is easy to justify trading potentially hundreds
of megabytes of memory to achieve a 10x speedup for decompression. Even if you
aren't willing to sacrifice more memory, the ability to tweak compression
parameters is huge. You can do things like store multiple versions of a
compressed document and conditionally serve the one most appropriate for the
client, all while running the same zstandard-only code on the client. That's
huge.</p>
<p>A year later, zstandard continues to impress me for its set of features and its
versatility. The library is continuing to evolve - all while maintaining
backwards compatibility on the decoding side. (That's a sign of a good
format design if you ask me.) I was honestly shocked to see that zstandard
was able to change its compression settings in a way that allowed it to compete
with lz4 and lzma without requiring a format change.</p>
<p>The more I use zstandard, the more I think that <em>everyone should use this</em> and
that popular compression formats just aren't cut out for modern computing any
more. Every time I download a zlib/gz or bzip2 compressed archive, I'm thinking
<em>if only they used zstandard this archive would be smaller, it would have
decompressed already, and I wouldn't be thinking about how annoying it is
to wait for compression operations to complete</em>. In my mind, zstandard is such
an obvious advancement over the status quo and is such a versatile format -
now covering the gamut of super fast compression to ultra ratios - that it is
bordering on negligent to not use zstandard. With the removal of the controversial
patent rights grant license clause in zstandard 1.3.1, that justifiable
resistance to widespread adoption of zstandard has been eliminated. Zstandard
is objectively superior for many workloads and I heavily encourage its use. I
believe python-zstandard provides a high-quality interface to zstandard and
I encourage you to give it and zstandard a try the next time you compress data.</p>
<p>If you run into any problems or want to get involved with development,
python-zstandard lives at
<a href="https://github.com/indygreg/python-zstandard">indygreg/python-zstandard</a> on
GitHub.</p>
<p>*(I updated the post on 2018-05-16 to remove a paragraph about zstandard
competition. In the original post, I unfairly compared zstandard to Snappy
instead of Brotli and made some inaccurate statements around that comparison.)</p>

  </div>
</div>



  <hr class="interblog" />
  
<div class="blog_post">
  <a name="from-__past__-import-bytes_literals"></a>
  <h2 class="blog_post_title"><a href="/blog/2017/03/13/from-__past__-import-bytes_literals" rel="bookmark" title="Permanent Link to from __past__ import bytes_literals">from __past__ import bytes_literals</a></h2>
  <small>March 13, 2017 at 09:55 AM | categories: 

<a href='/blog/category/python'>Python</a>, <a href='/blog/category/mercurial'>Mercurial</a>, <a href='/blog/category/mozilla'>Mozilla</a>
</small><p/>
  <div class="post_prose">
    
  <p>Last year, I simultaneously committed one of the ugliest and
impressive hacks of my programming <em>career</em>. I haven't had time
to write about it. Until now.</p>
<p>In summary, the hack is a
<a href="https://www.mercurial-scm.org/repo/hg/rev/1c22400db72d">source-transforming module loader</a>
for Python. It can be used by Python 3 to import a Python 2 source
file while translating certain primitives to their Python 3 equivalents.
It is kind of like <a href="https://docs.python.org/3.6/library/2to3.html">2to3</a>
except it executes at run-time during <code>import</code>. The main goal of the
hack was to facilitate porting Mercurial to Python 3 while deferring
having to make the most invasive - and therefore most annoying -
elements of the port in the canonical source code representation.</p>
<p>For the technically curious, it works as follows.</p>
<p>The <code>hg</code> Python executable registers a custom
<a href="https://docs.python.org/3.6/library/sys.html#sys.meta_path">meta path finder</a>
instance. This entity is invoked during <code>import</code> statements to try
to find the module being imported. It tells a later phase of the
import mechanism how to <em>load</em> that module from wherever it is
(usually a <code>.py</code> or <code>.pyc</code> file on disk) to a Python module object.
The custom finder only responds to requests for modules known
to be managed by the Mercurial project. For these modules, it tells
the next stage of the import mechanism to invoke a custom
<a href="https://docs.python.org/3.6/library/importlib.html#importlib.abc.SourceLoader">SourceLoader</a>
instance. Here's where the real magic is: when the custom <em>loader</em>
is invoked, it tokenizes the Python source code using the
<a href="https://docs.python.org/3.6/library/tokenize.html">tokenize</a> module,
iterates over the token stream, finds specific patterns, and
rewrites them to something <em>more appropriate</em>. It then <em>untokenizes</em>
back to Python source code then falls back to the built-in loader
which does the heavy lifting of compiling the source to Python code
objects. So, we have Python 2 source files on disk that magically get
transformed to be Python compatible when they are loaded by Python 3.
Oh, and there is no performance penalty for the token transformation
on subsequence loads because the transformed bytecode is cached in
the <code>.pyc</code> file (using a custom header so we know it was transformed
and can be invalidated when the transformation logic changes).</p>
<p>At the time I wrote it, the token stream manipulation converted most
string literals (<code>''</code>) to bytes literals (<code>b''</code>). In other words, it
restored the Python 2 behavior of string literals being <code>bytes</code> and
not <code>unicode</code>. We jokingly call it
<code>from __past__ import bytes_literals</code> (a play on Python 2's
<code>from __future__ import unicode_literals</code> special syntax which
changes string literals from Python 2's <code>str</code>/<code>bytes</code> type to
<code>unicode</code> to match Python 3's behavior).</p>
<p>Since I implemented the first version, others have implemented:</p>
<ul>
<li><a href="https://www.mercurial-scm.org/repo/hg/rev/178c89e8519a">Automatically inserting</a>
  a <code>from mercurial.pycompat import ...</code> statement to the top of the
  source. This statement is the Mercurial equivalent of importing
  common wrapper types similar to what
  <a href="https://pythonhosted.org/six/">six</a> provides.</li>
<li>More robust
  <a href="https://www.mercurial-scm.org/repo/hg/rev/423377290a3a">function argument parsing support</a>.
  (Because going from a token stream to a higher-level primitive like a
  function call is difficult.)</li>
<li><a href="https://www.mercurial-scm.org/repo/hg/rev/eaaedad68011">Automatically rewriting</a>
  <code>.iteritems()</code> to <code>.items()</code>.</li>
</ul>
<p>As one can expect, when I tweeted a link to this commit, many Python
developers (including a few CPython core developers) expressed a mix
of intrigue and horror. But mostly horror.</p>
<p>I fully concede that what I did here is a gross hack. And, it is the
intention of the Mercurial project to undo this hack and perform a
proper port once Python 3 support in Mercurial is more mature. But, I
want to lay out my defense on why I did this and why the Mercurial
project is tolerant of this ugly hack.</p>
<p>Individuals within the Mercurial project have wanted to port to Python
3 for years. Until recently, it hasn't been a project priority
because a port was too much work for too little end-user gain. And, on
the technical front, a port was just not practical until Python 3.5.
(Two main blockers were no <code>u''</code> literals - restored in Python 3.3 -
and no <code>%</code> formatting for <code>b''</code> literals - restored in 3.5. And as I
understand it, senior members of the Mercurial project had to lobby
Python maintainers pretty hard to get features like <code>%</code> formatting of
<code>b''</code> literals restored to Python 3.)</p>
<p>Anyway, after a number of failed attempts to initiate the Python 3
port over the years, the Mercurial project started making some
positive steps towards Python 3 compatibility, such as switching
to <a href="https://www.python.org/dev/peps/pep-0328/">absolute imports</a> and
addressing syntax issues that allowed modules to be parsed into
an AST and even compiled and loadable. These may seem like small
steps, but for a larger project, it was a lot of work.</p>
<p>The porting effort hit a large wall when it came time to actually
make the AST-valid Python code run on Python 3. Specifically, we had
a strings problem.</p>
<p>When you write software that exchanges data between machines -
sometimes machines running different operating systems or having
different encodings - and there is an expectation that things work
the same and data roundtrips accordingly, trying to force text
encodings is essentially impossible and inevitably breaks something or
someone. It is much easier for Mercurial to operate <em>bytes first</em> and
only take text encoding into consideration when absolutely necessary
(such as when emitting bytes to the terminal in the wanted encoding
or when emitting JSON). That's not to say Mercurial ignores the
existence of encodings. Far from it: Mercurial does attempt to
normalize some data to Unicode. But it often does so with a special
Python type that internally stores the raw byte sequence of the
source so that a consumer can choose to operate at the bytes or
Unicode level. </p>
<p>Anyway, this means that practically every string variable in Mercurial
is a <code>bytes</code> type (or something that acts like a <code>bytes</code> type). And
since string literals in Python 3 are the <code>str</code> type (which represents
Unicode), that would mean having to prefix almost every <code>''</code> string
literal in Mercurial with <code>b''</code> in order to placate Python 3. Having
to update every occurrence of simple primitives that could be statically
transformed automatically felt like busy work. <strong>We wanted to spend time
on the meaningful parts of the Python 3 port so we could find
interesting problems and challenges, not toil with mechanical
conversions that add little to no short-term value while simultaneously
increasing cognitive dissonance and quite possibly increasing the odds
of introducing a bug in Python 2.</strong> In other words, why should humans
do the work that machines can do for us? Thus, the source-transforming
module importer was born.</p>
<p>While I concede what Mercurial did is a giant hack, I maintain it was
the correct thing to do. It has allowed the Python 3 port to move
forward without being blocked on the more tedious and invasive
transformations that could introduce subtle bugs (including performance
regressions) in Python 2. Perfect is the enemy of good. People time is
valuable. The source-transforming module importer allowed us to unblock
an important project without sinking a lot of people time into it. I'd
make that trade-off again.</p>
<p>While I won't encourage others to take this approach to porting to
Python 3, if you want to, Mercurial's source is available under a GPL
license and the custom module importer could be adapted to any project
with minimal modifications. If someone does extract it as reusable code,
please leave a comment and I'll update the post to link to it.</p>

  </div>
</div>



  <hr class="interblog" />
 <a href="/blog/category/python/2"> Previous Page</a>
  --  
 <a href="/blog/category/python/4">Next Page </a>

              </div>
              
          <div id="sidebar">
          <ul>
            <li>
              <h2>Categories</h2>
              <ul>
                <li><a href="/blog/category/apple">Apple</a></li>
                <li><a href="/blog/category/bugzilla">Bugzilla</a></li>
                <li><a href="/blog/category/ci">CI</a></li>
                <li><a href="/blog/category/clang">Clang</a></li>
                <li><a href="/blog/category/docker">Docker</a></li>
                <li><a href="/blog/category/firefox">Firefox</a></li>
                <li><a href="/blog/category/git">Git</a></li>
                <li><a href="/blog/category/javascript">JavaScript</a></li>
                <li><a href="/blog/category/mercurial">Mercurial</a></li>
                <li><a href="/blog/category/mozreview">MozReview</a></li>
                <li><a href="/blog/category/mozilla">Mozilla</a></li>
                <li><a href="/blog/category/personal">Personal</a></li>
                <li><a href="/blog/category/programming">Programming</a></li>
                <li><a href="/blog/category/puppet">Puppet</a></li>
                <li><a href="/blog/category/pyoxidizer">PyOxidizer</a></li>
                <li><a href="/blog/category/python">Python</a></li>
                <li><a href="/blog/category/review-board">Review Board</a></li>
                <li><a href="/blog/category/rust">Rust</a></li>
                <li><a href="/blog/category/sync">Sync</a></li>
                <li><a href="/blog/category/browsers">browsers</a></li>
                <li><a href="/blog/category/build-system">build system</a></li>
                <li><a href="/blog/category/code-review">code review</a></li>
                <li><a href="/blog/category/compilers">compilers</a></li>
                <li><a href="/blog/category/internet">internet</a></li>
                <li><a href="/blog/category/logging">logging</a></li>
                <li><a href="/blog/category/mach">mach</a></li>
                <li><a href="/blog/category/make">make</a></li>
                <li><a href="/blog/category/misc">misc</a></li>
                <li><a href="/blog/category/movies">movies</a></li>
                <li><a href="/blog/category/packaging">packaging</a></li>
                <li><a href="/blog/category/pymake">pymake</a></li>
                <li><a href="/blog/category/security">security</a></li>
                <li><a href="/blog/category/sysadmin">sysadmin</a></li>
                <li><a href="/blog/category/testing">testing</a></li>
              </ul>
            </li>
          </ul>
        </div>



              <div style="clear: both;">&nbsp;</div>
          </div>
        </div>
      </div>
      <div id="footer">
        
  <hr/>
  <p>Copyright (c) 2012- Gregory Szorc. All rights reserved. Design by <a href="http://www.freecsstemplates.org/"> CSS Templates</a>.</p>


      </div>
    </div>
  </body>
</html>





