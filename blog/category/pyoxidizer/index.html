


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
Design by Free CSS Templates
http://www.freecsstemplates.org
Released for free under a Creative Commons Attribution 2.5 License

Name       : Pollinating  
Description: A two-column, fixed-width design with dark color scheme.
Version    : 1.0
Released   : 20101114

-->
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    
  <title>Gregory Szorc's Digital Home
</title>
<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
<link rel="alternate" type="application/atom+xml" title="Atom 1.0"
href="/blog/feed/atom" />
<link rel="stylesheet" href="/style/style.css" type="text/css" />
<link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />


  </head>
  <body>
    <div id="wrapper">
      
  <div id="menu">
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="/blog/">Blog</a></li>
    <li><a href="/notes">Notes</a></li>
    <li><a href="/work.html">Work</a></li>
    <li><a href="/skills.html">Skills</a></li>
    <li><a href="/thoughts.html">Thoughts</a></li>
    <li><a href="/resume.pdf">Resume</a></li>
  </ul>
</div>


      <div id="page">
        <div id="page-bgtop">
          <div id="page-bgbtm">
              <div id="content">
                
  
<div class="blog_post">
  <a name="my-shifting-open-source-priorities"></a>
  <h2 class="blog_post_title"><a href="/blog/2024/03/17/my-shifting-open-source-priorities" rel="bookmark" title="Permanent Link to My Shifting Open Source Priorities">My Shifting Open Source Priorities</a></h2>
  <small>March 17, 2024 at 09:00 PM | categories: 

<a href='/blog/category/personal'>Personal</a>, <a href='/blog/category/pyoxidizer'>PyOxidizer</a>
</small><p/>
  <div class="post_prose">
    
  <p>I'm a maintainer of a handful of open source projects, some of which have
millions of downloads and/or are used in important workloads, including in
production.</p>
<p>I have a full time job as a software engineer and my open source work is
effectively a side job. (Albeit one I try very hard to not let intersect
with my day job.)</p>
<p>Historically, my biggest contributions to my open source projects have come
when I'm not working full time:</p>
<ul>
<li><a href="https://github.com/indygreg/python-zstandard">python-zstandard</a> was started
  when I was on medical leave, recovering from a surgery.</li>
<li><a href="https://github.com/indygreg/python-build-standalone">python-build-standalone</a>
  and <a href="https://github.com/indygreg/PyOxidizer">PyOxidizer</a> were mainly built
  when I was between jobs, after leaving Mozilla.</li>
<li><a href="https://github.com/indygreg/apple-platform-rs/tree/main/apple-codesign">apple-codesign</a>
  was built in the height of COVID when I took a voluntary leave of absence
  from work to reconstitute my mental and physical health.</li>
</ul>
<p>When working full time, my time to contribute to open source has been carved out
of weekday nights and weekends, especially in the winter months. I believe
that code is an art form and programming a form of creative expression. My open
source contributions provide a relaxing avenue for me to express my artistic
creativity, when able.</p>
<p>My open source contributions reflect my personal priorities of where and what
to spend my free time on.</p>
<p>The only constant in life is change.</p>
<p>In the middle of 2022, I switched job roles and found myself reinvigorated by my
new role - Infrastructure Performance - which is at the intersection of some of
my strongest technical and professional skills. I found myself willingly
pouring more energy and time into my day job. That had the side effect of
reducing my open source contributions.</p>
<p>In 2023Q1 I got married. In the months leading up to and after, I chose to
prioritize spending time with my now wife and all the time commitments that
entails. This also reduced the amount of time available for open source
contributions.</p>
<p>In 2023Q4 I became a father to a beautiful baby girl. While on my employer's
generous-for-the-United-States fourteen week paternity leave, I somehow found
some time to contribute to open source. As refreshing as that was, it didn't
last. My <em>man cave</em> where my desktop computer resides has been converted into
a nursery. And for the past few months it has been occupied by my mother-in-law,
who has been generously effectively serving as a live-in nanny. Even when I'm
able to sit down at my desktop, it's hard to get into a state of flow due to
the added entropy from the additional three people now living with me.</p>
<p>After realizing the new normal in 2024Q1, I purchased a <a href="https://www.wahoofitness.com/devices/indoor-cycling/bike-trainers/kickr-move-buy">Wahoo KICKR MOVE</a>
bicycle trainer and now spend considerable time doing virtual bicycle rides on
<a href="https://www.zwift.com/">Zwift</a> because its one of the few <em>leisure</em> activities
I can do at home without drawing scrutiny from my wife and mother-in-law (but
98% my mother-in-law because I've observed that my wife is effectively
infallible). I now get excited about virtually summiting famous climbs instead of
contributing to open source. (Today's was
<a href="https://pjammcycling.com/climb/40.Mont-Ventoux-Bedoin">Mont Ventoux</a> - an
absolute beast of a climb that reminded me a lot of my real world ride up
<a href="https://pjammcycling.com/climb/11.Pikes-Peak">Pike's Peak</a> in 2020.)</p>
<p>Various changes in the past eighteen or so months have created additional
time constraints and prioritization changes that have resulted in my open
source contributions withering.</p>
<p>In addition, my technical interests have been shifting.</p>
<p>I've always gravitated to more systems-level areas of computers. My degree
is in Computer Engineering and I have a stereotypical engineer mindset: I
have an insatiable curiosity about how things work and interact and I want
to always be tinkering. I prefer to be closer to hardware instead of abstracted
far away from it. I enjoy interacting with the building blocks of software
ecosystems: operating systems, filesystems, runtimes, file formats, compilers,
etc.</p>
<p>Historically, my open source contributions to my preferred areas of
computing were limited. Again, to me open source is an enjoyable form of
creative expression. That means I do it for <em>fun</em>. Historically, the
<em>systems-level</em> programming space was limited to languages like C and
C++, which I consider frustrating and painful to use. If I'm going to subject
myself to misery when programming, you are going to have to pay me well to
do it.</p>
<p>As part of creating PyOxidizer, I learned Rust.</p>
<p>When I became proficient in Rust, I realized that Rust unlocks all kinds of
systems-level problems that were effectively off-limits for my open source
contributions. Would I <a href="/blog/2022/01/03/rust-implementation-of-debian-packaging-primitives/">implement</a>
Debian packaging primitives in Python? Or a <a href="/blog/2022/01/09/bulk-analyze-linux-packages-with-linux-package-analyzer/">tool</a>
to bulk analyze Linux packages and peek inside ELF binaries for insights
about what compiler/linker features are used in the wild in Python/C/C++?
Not unless you pay me to do it!</p>
<p>As I learned Rust, I also found myself being drawn away from Python, my
prior go-to language. As I wrote in <a href="/blog/2021/04/13/rust-is-for-professionals/">Rust is for Professionals</a>,
Rust feels surprisingly high level. It isn't as terse as Python but it is
a lot closer than I thought it would be. And Rust gives you vastly stronger
compile-time guarantees and run-time performance than Python. I felt like
Rust's tooling ecosystem was supporting me instead of standing in my way. I
felt that when you consider the overall software development lifecycle - not
just the edit-build-run loop that people tend to fixate on, likely because
it is the easiest to measure - Rust was vastly more productive and a joy to
work with than Python. All those countless hours debugging, fixing, and
authoring tests for <code>TypeError</code> and <code>ValueError</code> Python exceptions you see
in production just don't happen with Rust and that time can be better spent
iterating on core functionality, which is what actually matters. </p>
<p>On top of the Rust undercurrents, I've also become somewhat disenchanted with
the Python ecosystem. As I wrote in 2020's <a href="/blog/2020/01/13/mercurial's-journey-to-and-reflections-on-python-3/">Mercurial's Journey to and Reflections on
Python 3</a>,
the Python 3 transition was bungled and resulted in years - if not a full
decade - of lost opportunity. As I wrote in 2020's <a href="/blog/2023/10/30/my-user-experience-porting-off-setup.py/">My User Experience Porting Off
setup.py</a>, the Python
packaging story feels as discombobulated and frustrating as ever. PyOxidizer
additionally brushed up against <a href="/docs/pyoxidizer/0.24.0/pyoxidizer_technotes.html#desired-changes-from-python-to-aid-pyoxidizer">several limitations</a>
in how Python is designed and implemented, many of which are not trivially
fixable. As a <em>systems-level guy</em>, I am frequently questioning various aspects
of the Python ecosystem which I have contrasting opinions on, including the
importance of correctness and performance.</p>
<p>Starting in 2021, I started gravitating towards writing more Rust code and solving
problems in the systems domain that were previously off-limits to me, like Apple
code signing. Initially the work was in support of PyOxidizer: I was going to
implement all these packaging primitives in pure Rust and enable people to
distribute Python applications without requiring access to a Windows or macOS
machine! Over time, this work consumed me. Apple code signing turned into a major
time sink because of its complexity and the fact I was having to reverse
engineer a lot of its internals. But I was having a ton of fun doing it: more
fun than swimming upstream against decades of encrusted technical debts in the
Python ecosystem.</p>
<p>By late 2021, I realized I made a series of <em>mistakes</em> with PyOxidizer.</p>
<p>I started PyOxidizer as a science experiment to see if it was possible to achieve
a single file executable Python application without requiring a <em>temporary</em>
filesystem at run-time. I succeeded. But the cost was compatibility with the
larger pre-built Python package ecosystem. I built all this complexity into
PyOxidizer to allow people to tweak how Python resources are packaged so they
could choose to build a single file application if they wanted. This ballooned
into a hot mess and was obviously not user-friendly. It violated various
personal principles about optimizing for end-user experience.</p>
<p>Armed with knowledge of all the pitfalls, I realized that there was a 90%
use case for Python application packaging that was simple for end users and
technically achievable using all the code primitives - like the
<a href="https://crates.io/crates/pyembed">pyembed Rust crate</a> - that I built out for
PyOxidizer.</p>
<p>Thus the <a href="/blog/2022/05/10/announcing-the-pyoxy-python-runner/">PyOxy project</a> was born
and released in May 2022.</p>
<p>While I believe PyOxy is already a generally useful primitive to have in the
Python ecosystem, I had bigger goals in mind.</p>
<p>My intent with PyOxy was to build in a simplified and opinionated <em>PyOxidizer
lite</em> mode. The <code>pyoxy</code> executable is already a chameleon: if you rename it to
<code>python</code> it behaves like a <code>python</code> executable. I wanted to extend this so you
could do something like <code>pyoxy build-app</code> and it would collect all dependencies,
assemble a
<a href="https://gregoryszorc.com/docs/pyoxidizer/0.24.0/oxidized_importer_packed_resources.html">Python packed resources</a>
blob, and embed that in a copy of the <code>pyoxy</code> binary as an ELF, Mach-O, or PE
segment. Then at run-time, the variant executable binary would load the application
configuration and Python resources metadata from its own binary and execute the
application. Essentially, PyOxy would evolve into a self-packaging Python
application. I <em>just</em> needed to evolve the Python packed resources format,
implement a very crude ELF, Mach-O, and PE <em>linker</em> to append resources data to an
executable, and teach <code>pyembed</code> to read resources data from an ELF, Mach-O, or
PE segment. All within my sphere of technical competency. And I was excited to
build it and forever alter people's perceptions of how easy it could be to produce
a distributable Python application.</p>
<p>Then the roller coaster of my personal life took over. I felt newly invigorated
with a new job role. I got engaged and married. I became a father.</p>
<p>By early 2023, it was clear my ability to contribute to open source would be
vastly diminished for the foreseeable future. PyOxidizer and PyOxy fell into a
state of neglect. Weeks went by without me even tinkering on my local computer,
much less push commits or publish a release. Weeks turned into months. Months
into quarters. At this point, I haven't pushed a commit to
<a href="https://github.com/indygreg/PyOxidizer">indygreg/PyOxidizer</a> since January 2023.
And I'm not sure when I next will, if ever.</p>
<p>In my limited open source contribution time, I've prioritized other projects
over PyOxidizer.</p>
<p><a href="https://github.com/indygreg/python-build-standalone">python-build-standalone</a>
has gained a life outside PyOxidizer. It is now used by
<a href="https://github.com/astral-sh/rye">rye</a>, Bazel's
<a href="https://github.com/bazelbuild/rules_python">rules_python</a>,
<a href="https://beeware.org/project/projects/tools/briefcase/">briefcase</a>, and a myriad
of other consumers. The release assets have been downloaded over 23 million
times and the download rate appears to be accelerating. I still actively
support python-build-standalone and intend for the project to be actively
supported for the indefinite future: it has become too important to abandon. I'm
actively recruiting assistance to help maintain the project and I'm not concerned
about its future.</p>
<p>Apple code signing still actively draws my engagement. What I love about the
project is it either works or it doesn't: there's limited extra features we can
add to it since Apple mostly dictates the feature set. And I perceive the current
project to be mostly <em>done</em>.</p>
<p><a href="https://github.com/indygreg/python-zstandard">python-zstandard</a> is downloaded
~8 million times per month. The project is long overdue for some modernization.
I'm sitting on a pile of commits to improve it, but progress has been slow. I
just learned this weekend that the maintainer of the other popular zstandard
Python package deleted their GitHub account recently and now users are looking to
onboard to my package. Nothing quite like unanticipated distractions!</p>
<p><strong>That's a very long-winded way of saying that PyOxidizer and all the projects under
its umbrella are effectively in a zombie state.</strong> I'm hesitant to say <em>dead</em> because
if I suddenly found myself with lots of free time I'd love to brush off the cobwebs
and bring the projects back to life. But who am I kidding: they are effectively dead
at the moment because with everything happening in my personal life, I don't see where
I find the time to resuscitate the project. And that assumes I even want to: again,
I've become somewhat disenchanted by the state of Python. The main thing that draws
me to it is the size of the community and the potential for impact. But to realize
that impact I feel like I'd be pushing Python in directions it isn't well-equipped
to go in. Quite franky - and, yes, selfishly - I don't want to subject myself to
the misery unless I'm being well paid to do it. Again, I view my open source
contributions as a <em>fun</em> outlet for my creative expression and nudging Python
packaging in directions it is obviously ill-equipped to go in just isn't <em>fun</em>.</p>
<p><strong>If anyone reading has an interest in taking ownership or maintenance responsibilities
of PyOxidizer, any projects under its umbrella, or any of my other open source projects,
I'm receptive to proposals.</strong> Send me an <a href="mailto:gregory.szorc@gmail.com">email</a>
or create an issue or discussion on GitHub if you want to do it publicly.</p>
<p>But I'm going to assume that PyOxidizer is going to wither and die - or at least
incur some massive backwards incompatible breaks if it continues to live. I've already
filed issues against python-build-standalone - such as
<a href="https://github.com/indygreg/python-build-standalone/issues/221">removing Windows static builds</a> -
to make the project easier to support and less work for future maintainers.</p>
<p>If I have one regret about how this has played out, it is my failure to
communicate developments in my open source commitments / expectations in a timely manner.
I knew the future was bleak in early 2023 but didn't publicly say anything.
I still thought there was a chance that things were going to change and I didn't
want to make a hard decision prematurely. Writing this post has been on my mind
since the middle of 2023 but I just couldn't bring myself to write it. And -
surprise - having a newborn at home is a giant time and mental commitment! I'm
writing this now because people are (finally!) noticing my lack of contributions to
PyOxidizer and asking questions. And I'm home alone for a few days and actually
have time to sit down and compose this post. (Yes, I'm that stretched for time in
my personal life.)</p>
<p>In 2023, I struggled with the idea of letting people down by declaring PyOxidizer
<em>dead</em>. But when I wake up every morning, walk into the nursery, and cause my daughter
to smile and flail her arms and legs with unbridled excitement when she sees me, I'd
have it no other way. When it comes to choosing between open source and family, I
choose family.</p>
<p>It feels appropriate to end this post with a link to <a href="https://xkcd.com/2347/">XKCD 2347: Dependency</a>.
But I'm not the <em>random person in Nebraska</em>: I'm a husband and father.</p>

  </div>
</div>



  <hr class="interblog" />
  
<div class="blog_post">
  <a name="announcing-the-pyoxy-python-runner"></a>
  <h2 class="blog_post_title"><a href="/blog/2022/05/10/announcing-the-pyoxy-python-runner" rel="bookmark" title="Permanent Link to Announcing the PyOxy Python Runner">Announcing the PyOxy Python Runner</a></h2>
  <small>May 10, 2022 at 08:00 AM | categories: 

<a href='/blog/category/python'>Python</a>, <a href='/blog/category/pyoxidizer'>PyOxidizer</a>
</small><p/>
  <div class="post_prose">
    
  <p>I'm pleased to announce the initial release of
<a href="https://pyoxidizer.readthedocs.io/en/latest/pyoxy.html">PyOxy</a>.
Binaries are <a href="https://github.com/indygreg/PyOxidizer/releases/tag/pyoxy%2F0.1.0">available on GitHub</a>.</p>
<p>(Yes, I used my <a href="/blog/2022/04/25/expanding-apple-ecosystem-access-with-open-source,-multi-platform-code-signing/">pure Rust Apple code signing implementation</a>
to remotely sign the macOS binaries from GitHub Actions using a YubiKey
plugged into my Windows desktop: that experience still feels magical
to me.)</p>
<p>PyOxy is all of the following:</p>
<ul>
<li>An executable program used for running Python interpreters.</li>
<li>A single file and highly portable (C)Python distribution.</li>
<li>An alternative <code>python</code> driver providing more control over the
  interpreter than what <code>python</code> itself provides.</li>
<li>A way to make some of PyOxidizer's technology more broadly available without
  using PyOxidizer.</li>
</ul>
<p>Read the following sections for more details.</p>
<h2><code>pyoxy</code> Acts Like <code>python</code></h2>
<p>The <code>pyoxy</code> executable has a <code>run-python</code> sub-command that will essentially
do what <code>python</code> would do:</p>
<pre><code>$ pyoxy run-python
Python 3.9.12 (main, May  3 2022, 03:29:54)
[Clang 14.0.3 ] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
</code></pre>
<p>A Python REPL. That's familiar!</p>
<p>You can even pass <code>python</code> arguments to it:</p>
<pre><code>$ pyoxy run-python -- -c 'print("hello, world")'
hello, world
</code></pre>
<p>When a <code>pyoxy</code> executable is renamed to any filename beginning with <code>python</code>,
it implicitly behaves like <code>pyoxy run-python --</code>.</p>
<pre><code>$ mv pyoxy python3.9
$ ls -al python3.9
-rwxrwxr-x  1 gps gps 120868856 May 10  2022 python3.9

$ ./python3.9
Python 3.9.12 (main, May  3 2022, 03:29:54)
[Clang 14.0.3 ] on darwin
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt;
</code></pre>
<h2>Single File Python Distributions</h2>
<p>The official <code>pyoxy</code> executables are built with PyOxidizer and leverage the
Python distributions provided by my
<a href="https://github.com/indygreg/python-build-standalone/">python-build-standalone</a>
project. On Linux and macOS, a fully featured Python interpreter and its library
dependencies are statically linked into <code>pyoxy</code>. The <code>pyoxy</code> executable also embeds
a copy of the Python standard library and imports it from memory using the
<a href="https://pyoxidizer.readthedocs.io/en/latest/oxidized_importer.html">oxidized_importer</a>
Python extension module.</p>
<p>What this all means is that the official <code>pyoxy</code> executables can function as
single file CPython distributions! Just download a <code>pyoxy</code> executable, rename it
to <code>python</code>, <code>python3</code>, <code>python3.9</code>, etc and it should behave just like a normal
<code>python</code> would!</p>
<p>Your Python installation has never been so simple. And fast: <code>pyoxy</code> should be
a few milliseconds faster to initialize a Python interpreter mostly because of
<code>oxidized_importer</code> and it avoiding filesystem overhead to look for and load
<code>.py[c]</code> files.</p>
<h2>Low-Level Control Over the Python Interpreter with YAML</h2>
<p>The <code>pyoxy run-yaml</code> command is takes the path to a YAML file defining the
embedded Python interpreter configuration and then launches that Python
interpreter in-process:</p>
<pre><code>$ cat &gt; hello_world.yaml &lt;&lt;EOF
---
allocator_debug: true
interpreter_config:
  run_command: 'print("hello, world")'
...
EOF

$ pyoxy run-yaml hello_world.yaml
hello, world
</code></pre>
<p>Under the hood, PyOxy uses the
<a href="https://docs.rs/pyembed/0.20.0/pyembed/">pyembed</a> Rust crate to manage embedded
Python interpreters. The YAML document that PyOxy uses is simply deserialized
into a
<a href="https://docs.rs/pyembed/0.20.0/pyembed/struct.OxidizedPythonInterpreterConfig.html">pyembed::OxidizedPythonInterpreterConfig</a>
Rust struct, which <code>pyembed</code> uses to spawn a Python interpreter. This Rust struct
offers near complete control over how the embedded Python interpreter behaves: it
even allows you to tweak settings that are impossible to change from environment
variables or <code>python</code> command arguments! (Beware: this power means you can
easily cause the interpreter to crash if you feed it a bad configuration!)</p>
<h2>YAML Based Python Applications</h2>
<p><code>pyoxy run-yaml</code> ignores all file content before the YAML <code>---</code> start document
delimiter. This means that on UNIX-like platforms
you can create <em>executable YAML</em> files defining your Python application. e.g.</p>
<pre><code>$ mkdir -p myapp
$ cat &gt; myapp/__main__.py &lt;&lt; EOF
print("hello from myapp")
EOF

$ cat &gt; say_hello &lt;&lt;"EOF"
#!/bin/sh
"exec" "`dirname $0`/pyoxy" run-yaml "$0" -- "$@"
---
interpreter_config:
  run_module: 'myapp'
  module_search_paths: ["$ORIGIN"]
...
EOF

$ chmod +x say_hello

$ ./say_hello
hello from myapp
</code></pre>
<p>This means that to <em>distribute</em> a Python application, you can drop a copy
of <code>pyoxy</code> in a directory then define an executable YAML file masquerading
as a shell script and you can run Python code with as little as two files!</p>
<h2>The Future of PyOxy</h2>
<p>PyOxy is very young. I hacked it together on a weekend in September 2021.
I wanted to shore up some functionality before releasing it then. But I
got perpetually sidetracked and never did the work. I figured it would be
better to make a smaller splash with a lesser-baked product now than wait
even longer. Anyway...</p>
<p>As part of building
<a href="https://pyoxidizer.readthedocs.io/en/stable/pyoxidizer.html">PyOxidizer</a> I've
built some peripheral technology:</p>
<ul>
<li>Standalone and highly distributable Python builds via the
  <a href="https://github.com/indygreg/python-build-standalone">python-build-standalone</a>
  project.</li>
<li>The <a href="https://docs.rs/pyembed/0.20.0/pyembed/">pyembed</a> Rust crate for managing
  an embedded Python interpreter.</li>
<li>The <a href="https://pyoxidizer.readthedocs.io/en/stable/oxidized_importer.html">oxidized_importer</a>
  Python package/extension for importing modules from memory, among other
  things.</li>
<li>The <a href="https://pyoxidizer.readthedocs.io/en/latest/oxidized_importer_packed_resources.html">Python packed resources</a>
  data format for representing a collection of Python modules and resource
  files for efficient loading (by <code>oxidized_importer</code>).</li>
</ul>
<p>I conceived PyOxy as a vehicle to enable people to leverage PyOxidizer's
technology without imposing PyOxidizer onto them. I feel that PyOxidizer's
broader technology is generally useful and too valuable to be gated behind
using PyOxidizer.</p>
<p>PyOxy is only officially released for Linux and macOS for the moment.
It definitely builds on Windows. However, I want to improve the single file
executable experience before officially releasing PyOxy on Windows. This
requires an extensive overhaul to <code>oxidized_importer</code> and the way it
serializes Python resources to be loaded from memory.</p>
<p>I'd like to add a sub-command to produce a
<a href="https://pyoxidizer.readthedocs.io/en/latest/oxidized_importer_packed_resources.html">Python packed resources</a>
payload. With this, you could bundle/distribute a Python application as
<code>pyoxy</code> plus a file containing your application's packed resources alongside
YAML configuring the Python interpreter. Think of this as a more modern and
faster version of the venerable <code>zipapp</code> approach. This would enable PyOxy to
satisfy packaging scenarios provided by tools like Shiv, PEX, and XAR.
However, unlike Shiv and PEX, <code>pyoxy</code> also provides an embedded Python
interpreter, so applications are much more portable since there isn't
reliance on the host machine having a Python interpreter installed.</p>
<p>I'm really keen to see how others want to use <code>pyoxy</code>.</p>
<p>The YAML based control over the Python interpreter could be super useful for
testing, benchmarking, and general Python interpreter configuration
experimentation. It essentially opens the door to things previously only
possible if you wrote code interfacing with Python's C APIs.</p>
<p>I can also envision tools that hide the existence of Python wanting to
leverage the single file Python distribution property of <code>pyoxy</code>. For
example, tools like Ansible could copy <code>pyoxy</code> to a remote machine to provide
a well-defined Python execution environment without having to rely on what
packages are installed. Or <code>pyoxy</code> could be copied into a container or
other sandboxed/minimal environment to provide a Python interpreter.</p>
<p>And that's PyOxy. I hope you find it useful. Please file any bug reports
or feature requests in <a href="https://github.com/indygreg/PyOxidizer/issues">PyOxidizer's issue tracker</a>.</p>

  </div>
</div>



  <hr class="interblog" />
  
<div class="blog_post">
  <a name="pure-rust-implementation-of-apple-code-signing"></a>
  <h2 class="blog_post_title"><a href="/blog/2021/04/14/pure-rust-implementation-of-apple-code-signing" rel="bookmark" title="Permanent Link to Pure Rust Implementation of Apple Code Signing">Pure Rust Implementation of Apple Code Signing</a></h2>
  <small>April 14, 2021 at 01:45 PM | categories: 

<a href='/blog/category/pyoxidizer'>PyOxidizer</a>, <a href='/blog/category/apple'>Apple</a>, <a href='/blog/category/rust'>Rust</a>
</small><p/>
  <div class="post_prose">
    
  <p>A few weeks ago I (foolishly?) set out to implement Apple code signing
(what Apple's <code>codesign</code> tool does) in pure Rust.</p>
<p>I wanted to quickly announce on this blog the existence of the project and
the news that as of a few minutes ago, the <code>tugger-apple-codesign</code> crate
implementing the code signing functionality is now
<a href="https://crates.io/crates/tugger-apple-codesign">published on crates.io</a>!</p>
<p>So, you can now sign Apple binaries and bundles on non-Apple hardware by
doing something like this:</p>
<pre><code>$ cargo install tugger-apple-codesign
$ rcodesign sign /path/to/input /path/to/output
</code></pre>
<p>Current features include:</p>
<ul>
<li>Robust support for parsing embedded signatures and most related data
  structures. <code>rcodesign extract</code> can be used to extract various signature
  data in raw or human readable form.</li>
<li>Parse and verify RFC 5652 Cryptographic Message Syntax (CMS) signature
  data.</li>
<li>Sign binaries. If a code signing certificate key pair is provided,
  a CMS signature will be created. This includes support for Time-Stamp Protocol
  (TSP) / RFC 3161 tokens. If no key pair is provided, you get an ad-hoc
  signature.</li>
<li>Signing bundles. Nested bundles and binaries will automatically be signed.
  Non-code resources will be digested and a <code>CodeResources</code> XML file will be
  produced.</li>
</ul>
<p>The most notable missing features are:</p>
<ul>
<li>No support for obtaining signing keys from keychains. If you want to sign
  with a cryptographic key pair, you'll need to point the tool at a PEM encoded
  key pair and CA chain.</li>
<li>No support for parsing the Code Signing Requirements language. We can parse the
  binary encoding produced by <code>csreq -b</code> and convert it back to this DSL. But we
  don't parse the human friendly language.</li>
<li>No support for notarization.</li>
</ul>
<p>All of these could likely be implemented. However, I am not actively working on
any of these features. If you would like to contribute support, make noise in
the <a href="https://github.com/indygreg/apple-platform-rs/issues">GitHub issue tracker</a>.</p>
<p>The Rust API, CLI, and documentation are still a bit rough around the edges. I
haven't performed thorough QA on aspects of the functionality. However, the
tool is able to produce signed binaries that Apple's canonical <code>codesign</code> tool
says are well-formed. So I'm reasonably confident some of the functionality
works as intended. If you find bugs or missing features, please
<a href="https://github.com/indygreg/apple-platform-rs/issues">report them on GitHub</a>. Or even
better: submit pull requests!</p>
<p>As part of this project, I also created and published the
<a href="https://crates.io/crates/cryptographic-message-syntax">cryptographic-message-syntax</a>
crate, which is a pure Rust partial implementation of RFC 5652, which defines
the cryptographic message signing mechanism. This RFC is a bit dated and seems
to have been superseded by RPKI. So you may want to look elsewhere before
inventing new signing mechanisms that use this format.</p>
<p>Finally, it appears the Windows code signing mechanism (Authenticode) also uses
RFC 5652 (or a variant thereof) for cryptographic signatures. So by implementing
Apple code signatures, I believe I've done most of the legwork to implement
Windows/PE signing! I'll probably implement Windows signing in a new crate whenever
I hook up automatic code signing to PyOxidizer, which was the impetus for this work
(I want to make it possible to build distributable Apple programs without Apple
hardware, using as many open source Rust components as possible).</p>

  </div>
</div>



  <hr class="interblog" />
  
<div class="blog_post">
  <a name="announcing-the-0.9-release-of-pyoxidizer"></a>
  <h2 class="blog_post_title"><a href="/blog/2020/10/18/announcing-the-0.9-release-of-pyoxidizer" rel="bookmark" title="Permanent Link to Announcing the 0.9 Release of PyOxidizer">Announcing the 0.9 Release of PyOxidizer</a></h2>
  <small>October 18, 2020 at 10:00 PM | categories: 

<a href='/blog/category/python'>Python</a>, <a href='/blog/category/pyoxidizer'>PyOxidizer</a>
</small><p/>
  <div class="post_prose">
    
  <p>I have decided to make up for the 6 month lull between PyOxidizer's
0.7 and 0.8 releases by releasing
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/">PyOxidizer</a> 0.9 just 1 week
after 0.8!</p>
<p>The full 0.9 changelog is found
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/history.html#version-0-9-0">in the docs</a>.
First time user? See the
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/getting_started.html">Getting Started</a>
documentation.</p>
<p>While the 0.9 release is far smaller in terms of features compared to 0.8,
it is an important release because of progress closing compatibility gaps.</p>
<h2>Build a <code>python</code> Executable</h2>
<p>PyOxidizer 0.8 quietly shipped the ability to build executables that
behave like <code>python</code> executables via enhancements to the configurability of
embedded Python interpreters.</p>
<p>PyOxidizer 0.9 made some minor changes to make this scenario work better
and there is even
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/packaging_python_executable.html">official documentation</a>
on how to achieve this. So now you can emit a <code>python</code> executable next to your
application's executable. Or you could use PyOxidizer to build a highly portable,
self-contained <code>python</code> executable and ship your Python scripts next to it,
using PyOxidizer's <code>python</code> in your <code>#!</code>.</p>
<h2>Support Packaging Files as Files for Maximum Compatibility</h2>
<p>There is a long-tail of Python packages that don't <em>just work</em> with
PyOxidizer. A subset of these packages don't work because of bugs with how
PyOxidizer attempts to classify files as specific types of Python resources.</p>
<p>The way that normal Python works is you materialize a bunch of files on
the filesystem and at run-time the filesystem-based importer <code>stat()</code>s a
bunch of paths until it finds a candidate file satisfying the <code>import</code>
request. This works of course. But it is inefficient. Since PyOxidizer has
awareness of every resource being packaged at build time, it attempts to
index all known resources and serialize them to an efficient data structure
so finding and loading a resource can be extremely quick (effectively just a
hashmap lookup in Rust code to resolve the memory address of data).</p>
<p>PyOxidizer's approach does work in the majority of cases. But there are
edge cases. For example, NumPy's binary wheels have installed file paths
like <code>numpy.libs/libopenblasp-r0-ae94cfde.3.9.dev.so</code>. The <code>numpy.libs</code>
directory is not a valid Python package directory since it has a <code>.</code> and
since it doesn't have an <code>__init__.py[c]</code> file. This is a case where
PyOxidizer's code for turning files into <em>resources</em> is currently confused.</p>
<p>It is tempting to argue that file layouts like NumPy's are <em>wrong</em>. But
there doesn't seem to be any formal specification preventing the use of
such layouts. The arbiter of truth here is what Python packaging tools
accept and the current code for installing <em>wheels</em> gladly accepts file
layouts like these. So I've accepted that PyOxidizer is just going to have
to support edge cases like this. (I've captured more details about this
particular issue
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/technotes.html#ambiguous-file-classification">in the docs</a>).</p>
<p>Anyway, PyOxidizer 0.9 ships a new, simpler mode for handling files:
<em>files mode</em>. In <a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/packaging_resources.html#classified-resources-versus-files">files mode</a>,
PyOxidizer disables its code for <em>classifying</em> files as typed Python
resources (like module sources and extension modules) and instead treats
a file as... a file.</p>
<p>When in files mode, actions that invoke Python packaging tools return
files objects instead of classified resources. If you then add these files
for packaging, those files are materialized on the filesystem next to your
built executable. You can then use Python's standard filesystem importer
to load these files at run-time.</p>
<p>This allows you to use PyOxidizer with packages like NumPy that were
previously incompatible due to bugs with file/resource classification.
In fact, getting NumPy working with PyOxidizer is
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/packaging_additional_files.html#installing-unclassified-files-on-the-filesystem">now in the official documentation</a>!</p>
<p><em>Files mode</em> is still in its infancy. There exists code for embedding
files data in the produced executable. I plan to eventually teach PyOxidizer's
run-time code to extract these embedded files to a temporary directory,
SquashFS FUSE filesystem, etc. This is the approach that other Python
packaging tools like PyInstaller and XAR use. While it is less efficient, this
approach is highly compatible with Python code in the wild since you sidestep
issues with <code>__file__</code> and other assumptions about installed file layouts. So
it makes sense for PyOxidizer to provide support for this so you can still
achieve the friendliness of a self-contained executable without worrying
about compatibility. Look for improvements to <em>files mode</em> in future releases.</p>
<p>And to help debug issues with PyOxidizer's file handling and resource
classification, the new
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/managing_projects.html#debugging-resource-scanning-and-identification-with-find-resources">pyoxidizer find-resources</a>
command can be used to invoke PyOxidizer's code for scanning and classifying
files. Hopefully this makes it easier to diagnose bugs in this critical
component of PyOxidizer!</p>
<h2>Some Important Bug Fixes</h2>
<p>PyOxidizer 0.8 shipped with some pretty annoying bugs and behavior quirks.</p>
<p>The ability to set custom <code>sys.path</code> values via Starlark was broken. How I
managed to ship that, I'm not sure. But it is fixed in 0.9.</p>
<p>Another bug I can't believe I shipped was
the <code>PythonExecutable.read_virtualenv()</code> Starlark method being broken due to
a typo. You can read from virtualenvs again in PyOxidizer 0.9.</p>
<p>Another important improvement is in the default Python interpreter
configuration. We now automatically initialize Python's locales configuration
by default. Without this, the encoding of filesystem paths and <code>sys.argv</code> may
not have been correct. If someone passed a non-ASCII argument, the Python <code>str</code>
value was likely mangled. PyOxidizer built binaries should behave reasonably
by default now. The <a href="https://github.com/indygreg/PyOxidizer/issues/294">issue</a>
is a good read if the subtle behaviors of how encodings work in Python and on
different operating systems is interesting to you.</p>
<h2>Better Binary Portability Documentation</h2>
<p>The documentation on
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/packaging_binary_compatibility.html">binary portability</a>
has been overhauled. Hopefully it is much more clear about the capabilities
of PyOxidizer to produce a binary that <em>just works</em> on other machines.</p>
<p>I eventually want to get PyOxidizer to a point where users don't have to
think about binary portability. But until PyOxidizer starts generating
installers and providing the ability to run builds in deterministic and
reproducible environments, it is sadly a problem that is being externalized
to end users.</p>
<h2>In Conclusion</h2>
<p>PyOxidizer 0.9 is a small release representing just 1 week of work. But
it contains some notable features that I wanted to get out the door.</p>
<p>As always, please report any issues or feedback in the
<a href="https://github.com/indygreg/PyOxidizer/issues/new">GitHub issue tracker</a>
or the <a href="https://groups.google.com/forum/#!forum/pyoxidizer-users">users mailing list</a>.</p>

  </div>
</div>



  <hr class="interblog" />
  
<div class="blog_post">
  <a name="announcing-the-0.8-release-of-pyoxidizer"></a>
  <h2 class="blog_post_title"><a href="/blog/2020/10/12/announcing-the-0.8-release-of-pyoxidizer" rel="bookmark" title="Permanent Link to Announcing the 0.8 Release of PyOxidizer">Announcing the 0.8 Release of PyOxidizer</a></h2>
  <small>October 12, 2020 at 12:45 AM | categories: 

<a href='/blog/category/python'>Python</a>, <a href='/blog/category/pyoxidizer'>PyOxidizer</a>
</small><p/>
  <div class="post_prose">
    
  <p>I am very excited to announce the 0.8 release of
<a href="https://pyoxidizer.readthedocs.io/en/stable/">PyOxidizer</a>, a modern
Python application packaging tool. You can find the full changelog
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/history.html">in the docs</a>.
First time user? See the
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/getting_started.html">Getting Started</a>
documentation.</p>
<p>Foremost, I apologize that this release took so long to publish (0.7 was
released on 2020-04-09). I fervently believe that frequent releases are
a healthy software development practice. And 6 months between PyOxidizer
releases was way too long. Part of the delay was due to world events
(it has proven difficult to focus on... anything given a global pandemic,
social unrest, and wildfires further undermining any resemblance of
lifestyle normalcy in California). Another contributing factor was I was
waiting on a few 3rd party Rust crates to have new versions published to
crates.io (you can't release a crate to crates.io unless all your
dependencies are also published there).</p>
<p>Release delay and general life hardships aside, the 0.8 release is here
and it is full of notable improvements!</p>
<h2>Python 3.8 and 3.9 Support</h2>
<p><strong>PyOxidizer 0.8 now targets Python 3.8 by default and support for Python
3.9 is available</strong> by tweaking configuration files. Previously, we only
supported Python 3.7 and this release drops support for Python 3.7. I feel
a bit bad for dropping compatibility. But Python 3.8 introduced a
<a href="https://docs.python.org/3/c-api/init_config.html">new C API</a> for initializing
Python interpreters (thank you Victor Stinner!) and this makes PyOxidizer's
run-time code for interfacing with Python interpreters vastly simpler.
I decided that given the beta nature of PyOxidizer, it wasn't worth
maintaining complexity to continue to support Python 3.7. I'm optimistic
that I'll be able to support Python 3.8 as a baseline for a while.</p>
<h1>Better Default Packaging Settings</h1>
<p>PyOxidizer started as a science experiment of sorts to see if I could
achieve the elusive goal of producing a single file executable providing
a Python application. I was successful in proving this hypothesis. But the
cost to achieving this outcome was rather high in terms of end-user
experience: in order to produce single file executables, you had to break
a lot of assumptions about how Python typically works and this in turn broke
a lot of Python code and packages in the wild.</p>
<p>In other words, <strong>PyOxidizer's opinionated defaults of producing a single file
executable were externalizing hardship on end-users and preventing them from
using PyOxidizer.</strong></p>
<p>PyOxidizer 0.8 contains a handful of changes to defaults that should hopefully
lessen the friction.</p>
<p>On Windows, the default Python distribution now has a more traditional
build configuration (using <code>.pyd</code> extension modules and a <code>pythonXY.dll</code>
file). <strong>This means that PyOxidizer can consume pre-built extension modules
without having to recompile them from source.</strong> If you publish a Windows
binary wheel on PyPI, in many cases it will <em>just work</em> with PyOxidizer
0.8! (There are some notable exceptions to this, such as <em>numpy</em>, which is
doing wonky things with the location of shared libraries in wheels - but
I aim to fix this soon.)</p>
<p>Also on Windows, we no longer attempt to embed Python extension modules
(<code>.pyd</code> files) and their shared library dependencies in the produced
binary and load them from memory by default. This is because PyOxidizer's
from-memory library loader didn't work in all cases. For example, some
OpenSSL functionality used by the <code>_ssl</code> module in the standard library
didn't work, preventing Python from establishing TLS connections. The old
mode enabling you to produce a single file executable on Windows is still
available. But you have to opt in to it (at the likely cost of more
packaging and compatibility pain).</p>
<h2>Starlark Configuration Overhaul</h2>
<p>PyOxidizer 0.8 contains a <strong>ton</strong> of changes to its Starlark configuration
files. There are so many changes that you may find it easier to port to
PyOxidizer 0.8 by creating a new configuration file rather than attempting
to port an existing one.</p>
<p>I apologize for this churn and recognize it will be disruptive. However,
this churn needed to happen for various reasons.</p>
<p>Much of the old Starlark configuration semantics was rooted in the days
when configuration files were static TOML files. Now that configuration
files provide the power of a (Python-inspired) programming language, we
are free to expose much more flexibility. But that flexibility requires
refactoring things so the experience feels more <em>native</em>.</p>
<p>Many changes to Starlark were rooted in necessity. For example,
the methods for invoking <code>setup.py</code> or <code>pip install</code> used to live on a
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/config_type_python_distribution.html">Python distribution type</a>
and have been moved to a
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/config_type_python_executable.html">type representing executables</a>.
This is because the binary we are targeting influences how
packaging actions behave. For example, if the binary only supports
loading resources from memory (as opposed to standalone files), we need
to know that when invoking the packaging tool so we can produce files
(notably Python extension modules) compatible with the destination.</p>
<p>A major change to Starlark in 0.8 is around resource location handling.
Before, you could define a static string denoting the <em>resources policy</em>
for where things should be placed. And there were 10+ methods for
adding different resource types (source, bytecode, extensions, package
data) to different load locations (memory, filesystem). This mechanism
is vastly simplified and more powerful in PyOxidizer 0.8!</p>
<p>In PyOxidizer 0.8, there is a single
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/config_type_python_executable.html#pythonexecutable-add-python-resource">add_python_resource()</a>
method for adding a resource to a binary and the Starlark objects you add
can denote where they should be added by
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/config_resource_add_attributes.html">defining attributes on those objects</a>.</p>
<p>Furthermore, you can
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/packaging_resources.html#using-callbacks-to-influence-resource-attributes">define a Starlark function</a>
that is called when resource objects are created to apply custom packaging
<em>rules</em> using custom Starlark code defined in your PyOxidizer config file.
So rather than having everyone try to abide by a few pre-canned <em>policies</em> for
packaging resources, you can define a proper function in your config file
that can be as complex as you want/need it to be! I feel this is vastly simpler
and more powerful than implementing a custom DSL in static configuration files
(like TOML, JSON, YAML, etc).</p>
<p>While the ability to implement your own arbitrarily complex packaging
policies is useful, there is a new
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/config_type_python_packaging_policy.html">PythonPackagingPolicy</a>
Starlark type with enough flexibility to suit most needs.</p>
<h2>Shipping <code>oxidized_importer</code></h2>
<p>During the development of PyOxidizer 0.8, I broke out the custom
Rust-based Python <em>meta-path importer</em> used by PyOxidizer's run-time code
into a standalone Python package. This sub-project is called
<code>oxidized_importer</code> and I previously
<a href="/blog/2020/05/10/using-rust-to-power-python-importing-with-oxidized_importer/">blogged about it</a>.</p>
<p>PyOxidizer 0.8 ships <code>oxidized_importer</code> and all of its useful APIs
available to Python. Read more in the
<a href="https://pyoxidizer.readthedocs.io/v0.8.0/latest/oxidized_importer.html">official docs</a>.
The new Python APIs should make debugging issues with PyOxidizer-packaged
applications vastly simpler: I found them invaluable when tracking down
user-reported bugs!</p>
<h2>Tons of New Tests and Refactored Code</h2>
<p>PyOxidizer was my first non-toy Rust project. And the quality of the Rust
code I produced in early versions of PyOxidizer clearly showed it. And when I
was in the rapid-prototyping phase of PyOxidizer, I eschewed writing tests
in favor of short-term progress.</p>
<p>PyOxidizer 0.8 pays down a ton of technical debt in the code base. Lots of
Rust code has been refactored and is using somewhat reasonable practices.
I'm not yet a Rust guru. But I'm at the point where I cringe when I look at
some of the early code I wrote, which is a good sign. I do have to say that
Rust has been a dream to work with during this transition. Despite being a
low-level language, my early <em>misuse</em> of Rust did not result in crashes like
you would see in languages like C/C++. And Rust's seemingly omniscient compiler
and IDE tools facilitating refactoring have ensured that code changes aren't
accompanied by subtle random bugs that would occur in dynamic programming
languages. I really need to write a dedicated post espousing the virtues of
Rust...</p>
<p>There are a <strong>ton</strong> of new tests in PyOxidizer 0.8 and I now feel somewhat
confident that the <code>main</code> branch of PyOxidizer should be considered
<em>production-ready</em> at any time assuming the tests pass. This will hopefully
lead to more rapid releases in the future.</p>
<p>There are now tests for the <code>pyembed</code> Rust crate, which provides the
run-time code for PyOxidizer-built binaries. We even have
<a href="https://github.com/indygreg/PyOxidizer/tree/main/pyembed/src/test">Python-based unit tests</a>
for validating the Python-exposed APIs behave as expected. These tests have
been invaluable for ensuring that the run-time code works as expected. So now
when someone files a bug I can easily write a test to capture it and keep
the code working as intended through various refactors.</p>
<p>The packaging-time Rust code has also gained its fair share of tests.
We now have fairly comprehensive test coverage around how resources
are added/packaged. Python extension modules have proved to be highly
nuanced in how they are handled. Tremendously helping testing of extension
modules is that we're able to run tests for platform non-native extensions!
While not yet exposed/supported by Starlark configuration files, <strong>I've taught
PyOxidizer's core Rust code to be cross-compiling aware</strong> so that we can
e.g. test Windows or macOS behavior from Linux. Before, I'd have to test
Windows wheel handling on Windows. But after writing a wheel parser in Rust
and teaching PyOxidizer to use a different Python distribution for the
host architecture from the target architecture, I'm now able to write
tests for platform-specific functionality that run on any platform that
PyOxidizer can run on. This <em>may</em> eventually lead to proper cross-compiling
support (at least in some configuration). Time will tell. But the foundation
is definitely there!</p>
<h2>New Rust Crates</h2>
<p>As part of the aforementioned refactoring of PyOxidizer's Rust code, I've
been extracting some useful/generic functionality built as part of
developing PyOxidizer to their own Rust crates.</p>
<p>As part of this release, I'm publishing the initial 0.1 release of the
<a href="https://crates.io/crates/python-packaging">python-packaging</a> crate
(<a href="https://docs.rs/python-packaging/0.1.0/python_packaging/">docs</a>). This crate
provides pure Rust code for various Python <em>packaging</em> related functionality.
This includes:</p>
<ul>
<li>Rust types representing Python resource types (source modules, bytecode
  modules, extension modules, package resources, etc).</li>
<li>Scanning the filesystem for Python resource files .</li>
<li>Configuring an embedded Python interpreter.</li>
<li>Parsing <code>PKG-INFO</code> and related files.</li>
<li>Parsing wheel files.</li>
<li>Collecting Python resources and serializing them to a data structure.</li>
</ul>
<p>The crate is somewhat PyOxidizer centric. But if others are interested
in improving its utility, I'll happily accept pull requests!</p>
<p>PyOxidizer's crates footprint now includes:</p>
<ul>
<li><a href="https://crates.io/crates/python-packed-resources">python-packed-resources</a></li>
<li><a href="https://crates.io/crates/python-packaging">python-packaging</a></li>
<li><a href="https://crates.io/crates/pyembed">pyembed</a></li>
<li><a href="https://crates.io/crates/pyoxidizer">pyoxidizer</a></li>
</ul>
<h2>Major Documentation Updates</h2>
<p>I strongly believe that software should be documented thoroughly and I strive
for PyOxidizer's documentation to be useful and comprehensive.</p>
<p>There have been a lot of changes to PyOxidizer's documentation since the
0.7 release.</p>
<p>All <a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/config.html">configuration file documentation</a>
has been consolidated.</p>
<p>Likewise, I've attempted to consolidate a lot of the <em>paved road</em> documentation
for how to use PyOxidizer in the
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/packaging.html">Packaging User Guide</a>
section of the docs.</p>
<p>I'll be honest, since I have so much of PyOxidizer's workings internalized,
it can be difficult for me to empathize with PyOxidizer's users. So if you
have difficult with the <em>readability</em> of the documentation, please
<a href="https://github.com/indygreg/PyOxidizer/issues/new">file an issue</a> and report
what is confusing so the documentation can be improved!</p>
<h2>Mercurial Shipping With PyOxidizer 0.8</h2>
<p>PyOxidizer is arguably an epic yak shave of mine to help the
<a href="https://www.mercurial-scm.org/">Mercurial version control tool</a> transition
to Python 3 and Rust.</p>
<p>I'm pleased to report that Mercurial is
<a href="https://www.mercurial-scm.org/pipermail/mercurial/2020-October/052395.html">now shipping</a>
PyOxidizer-built distributions on Windows as of the 5.2.2 release a few days
ago! If a complex Python application like Mercurial can be
<a href="https://www.mercurial-scm.org/repo/hg/file/0627cd03b1e9/rust/hgcli/pyoxidizer.bzl">configured</a>
to work with PyOxidizer, chances are your Python application will work as
well.</p>
<h2>Whats Next</h2>
<p>I view PyOxidizer 0.8 as a pivotal release where PyOxidizer is turning the
corner from a prototyping science experiment to something more generally
usable. The investments in test coverage and refactoring of the Rust
internals are paving the way towards future features and bug fixes.</p>
<p>In upcoming releases, I'd like to close remaining known compatibility
gaps with popular Python packages (such as <em>numpy</em> and other packages in
the <em>scientific/data</em> space). I have a general idea of what work needs to
be done and I've been laying the ground work via various refactorings to
execute here.</p>
<p><strong>I want a general theme of future releases to be eliminating reasons why
people can't use PyOxidizer.</strong> PyOxidizer's historical origin was as a
science experiment to see if single file Python applications were possible.
It is clear that achieving this is fundamentally incompatible with
compatibility with tons of Python packages in the wild. I'd like to find a
way where PyOxidizer can achieve 99% package compatibility by default
so new users don't get discouraged when using PyOxidizer. And for the
subset of users who want single file executables, they can spend the
magnitude of additional effort to achieve that.</p>
<p>At some point, I also want to make a pivot towards focusing on producing
distributable artifacts (Debian/RPM packages, MSI installers, macOS DMG
files, etc). I'm slightly bummed that I haven't made much progress here.
But I have a vision in my mind of where I want to go (I'll be making
a standalone Rust crate + Starlark dialect to facilitate producing
distributable artifacts for <em>any</em> application) and I'm anticipating
starting this work in the next few months. In the mean time, PyOxidizer
0.8 should be able to give people a directory tree that they can coerce
into distributable artifacts using existing packaging tooling. That's not as
turnkey as I would like it to be. But the technical problems around
building a distributable Python application binary still needs some work
and I view that as the most pressing need for the Python ecosystem. So
I'll continue to focus there so there is a solid foundation to build upon.</p>
<p>In conclusion, I hope you enjoy the new release! Please report any issues
or feedback in the
<a href="https://github.com/indygreg/PyOxidizer/issues/new">GitHub issue tracker</a>.</p>

  </div>
</div>



  <hr class="interblog" />
 <a href="/blog/category/pyoxidizer/2">Next Page »</a>

              </div>
              
          <div id="sidebar">
          <ul>
            <li>
              <h2>Categories</h2>
              <ul>
                <li><a href="/blog/category/apple">Apple</a></li>
                <li><a href="/blog/category/bugzilla">Bugzilla</a></li>
                <li><a href="/blog/category/ci">CI</a></li>
                <li><a href="/blog/category/clang">Clang</a></li>
                <li><a href="/blog/category/docker">Docker</a></li>
                <li><a href="/blog/category/firefox">Firefox</a></li>
                <li><a href="/blog/category/git">Git</a></li>
                <li><a href="/blog/category/javascript">JavaScript</a></li>
                <li><a href="/blog/category/mercurial">Mercurial</a></li>
                <li><a href="/blog/category/mozreview">MozReview</a></li>
                <li><a href="/blog/category/mozilla">Mozilla</a></li>
                <li><a href="/blog/category/personal">Personal</a></li>
                <li><a href="/blog/category/programming">Programming</a></li>
                <li><a href="/blog/category/puppet">Puppet</a></li>
                <li><a href="/blog/category/pyoxidizer">PyOxidizer</a></li>
                <li><a href="/blog/category/python">Python</a></li>
                <li><a href="/blog/category/review-board">Review Board</a></li>
                <li><a href="/blog/category/rust">Rust</a></li>
                <li><a href="/blog/category/sync">Sync</a></li>
                <li><a href="/blog/category/browsers">browsers</a></li>
                <li><a href="/blog/category/build-system">build system</a></li>
                <li><a href="/blog/category/code-review">code review</a></li>
                <li><a href="/blog/category/compilers">compilers</a></li>
                <li><a href="/blog/category/internet">internet</a></li>
                <li><a href="/blog/category/logging">logging</a></li>
                <li><a href="/blog/category/mach">mach</a></li>
                <li><a href="/blog/category/make">make</a></li>
                <li><a href="/blog/category/misc">misc</a></li>
                <li><a href="/blog/category/movies">movies</a></li>
                <li><a href="/blog/category/packaging">packaging</a></li>
                <li><a href="/blog/category/pymake">pymake</a></li>
                <li><a href="/blog/category/security">security</a></li>
                <li><a href="/blog/category/sysadmin">sysadmin</a></li>
                <li><a href="/blog/category/testing">testing</a></li>
              </ul>
            </li>
          </ul>
        </div>



              <div style="clear: both;">&nbsp;</div>
          </div>
        </div>
      </div>
      <div id="footer">
        
  <hr/>
  <p>Copyright (c) 2012- Gregory Szorc. All rights reserved. Design by <a href="http://www.freecsstemplates.org/"> CSS Templates</a>.</p>


      </div>
    </div>
  </body>
</html>





