


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
Design by Free CSS Templates
http://www.freecsstemplates.org
Released for free under a Creative Commons Attribution 2.5 License

Name       : Pollinating  
Description: A two-column, fixed-width design with dark color scheme.
Version    : 1.0
Released   : 20101114

-->
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    
  <title>Gregory Szorc's Digital Home
</title>
<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
<link rel="alternate" type="application/atom+xml" title="Atom 1.0"
href="/blog/feed/atom" />
<link rel="stylesheet" href="/style/style.css" type="text/css" />
<link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />


  </head>
  <body>
    <div id="wrapper">
      
  <div id="menu">
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="/blog/">Blog</a></li>
    <li><a href="/notes">Notes</a></li>
    <li><a href="/work.html">Work</a></li>
    <li><a href="/skills.html">Skills</a></li>
    <li><a href="/thoughts.html">Thoughts</a></li>
    <li><a href="/resume.pdf">Resume</a></li>
  </ul>
</div>


      <div id="page">
        <div id="page-bgtop">
          <div id="page-bgbtm">
              <div id="content">
                
  
<div class="blog_post">
  <a name="repository-centric-development"></a>
  <h2 class="blog_post_title"><a href="/blog/2014/07/24/repository-centric-development" rel="bookmark" title="Permanent Link to Repository-Centric Development">Repository-Centric Development</a></h2>
  <small>July 24, 2014 at 08:23 PM | categories: 

<a href='/blog/category/git'>Git</a>, <a href='/blog/category/mercurial'>Mercurial</a>, <a href='/blog/category/mozilla'>Mozilla</a>
 | <a href="http://gregoryszorc.com/blog/2014/07/24/repository-centric-development#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>I was editing a wiki page yesterday and I think I coined a new term
which I'd like to enter the common nomenclature: <em>repository-centric
development</em>. The term refers to development/version control
workflows that place repositories - not patches - first.</p>
<p>When collaborating on version controlled code with modern tools like
Git and Mercurial, you essentially have two choices on how to
share version control data: patches or repositories.</p>
<p>Patches have been around since the dawn of version control. Everyone
knows how they work: your version control system has a copy of
the canonical data and it can export a view of a specific change
into what's called a patch. A patch is essentially a diff with
extra metadata.</p>
<p>When distributed version control systems came along, they brought
with them an alternative to patch-centric development:
repository-centric development. You could still exchange patches if you
wanted, but distributed version control allowed you to <em>pull</em> changes
directly from multiple <em>repositories</em>. You weren't limited to a single
master server (that's what the <em>distributed</em> in <em>distributed version
control</em> means). You also didn't have to go through an intermediate
transport such as email to exchange patches: you communicate directly
with a peer repository instance.</p>
<p>Repository-centric development eliminates the <em>middle man</em> required
for patch exchange: instead of exchanging derived data, you exchange
the actual data, speaking the repository's native language.</p>
<p>One advantage of repository-centric development is it eliminates the
problem of patch non-uniformity. Patches come in many different flavors.
You have plain diffs. You have diffs with metadata. You have Git style
metadata. You have Mercurial style metadata. You can produce patches
with various lines of context in the diff. There are different methods
for handling binary content. There are different ways to express
file adds, removals, and renames. It's all a hot mess. Any system
that consumes patches needs to deal with the non-uniformity. Do you
think this isn't a problem in the real world? Think again. If you are
involved with an open source project that collects patches via email
or by uploading patches to a bug tracker, have you ever seen someone
accidentally upload a patch in the wrong format? That's patch
non-uniformity. New contributors to Firefox do this all the time. I
also see it in the Mercurial project. With repository-centric
development, patches never enter the picture, so patch non-uniformity
is a non-issue. (Don't confuse the superficial formatting of patches
with the content, such as an incorrect commit message format.)</p>
<p>Another advantage of repository-centric development is it makes the
act of exchanging data easier. Just have two repositories talk to
each other. This used to be difficult, but hosting services like
GitHub and Bitbucket make this easy. Contrast with patches, which
require hooking your version control tool up to wherever those patches
are located. The Linux Kernel, like so many other projects,
<a href="https://www.kernel.org/doc/Documentation/SubmittingPatches">uses email for contributing changes</a>.
So now Git, Mercurial, etc all fulfill Zawinski's law. This means your
version control tool is talking to your inbox to send and receive code.
Firefox development uses Bugzilla to hold patches as attachments. So now your
version control tool needs to talk to your issue tracker. (Not the worst
idea in the world I will concede.) While, yes, the tools around using
email or uploading patches to issue trackers or whatever else you are
using to exchange patches exist and can work pretty well, the grim
reality is that these tools are all reinventing the wheel of repository
exchange and are solving a problem that has already been solved by
<em>git push</em>, <em>git fetch</em>, <em>hg pull</em>, <em>hg push</em>, etc. Personally, I would
rather <em>hg push</em> to a remote and have tools like issue trackers and
mailing lists pull directly from repositories. At least that way they
have a direct line into the source of truth and are guaranteed a
consistent output format.</p>
<p>Another area where direct exchange is huge is multi-patch commits
(<em>branches</em> in Git parlance) or where commit data is fragmented. When
pushing patches to email, you need to insert metadata saying which patch
comes after which. Then the email import tool needs to reassemble things
in the proper order (remember that the typical convention is one email
per patch and email can be delivered out of order). Not the most
difficult problem in the world to solve. But seriously, it's been
solved already by <em>git fetch</em> and <em>hg pull</em>! Things are worse for
Bugzilla. There is no bullet-proof way to order patches there. The
convention at Mozilla is to add <em>Part N</em> strings to
commit messages and have the Bugzilla import tool do a sort (I assume it
does that). But what if you have a logical commit series spread across
multiple bugs? How do you reassemble everything into a linear series of
commits? You don't, sadly. Just today I wanted to apply a somewhat
complicated series of patches to the Firefox build system I was asked to
review so I could jump into a debugger and see what was going on so I
could conduct a more thorough review. There were 4 or 5 patches spread
over 3 or 4 bugs. Bugzilla and its patch-centric workflow prevented me
from importing the patches. Fortunately, this patch series was pushed to
Mozilla's Try server, so I could pull from there. But I haven't always
been so fortunate. This limitation means developers have to make
sacrifices such as writing fewer, larger patches (this makes code review
harder) or involving unrelated parties in the same bug and/or review.
In other words, deficient tools are imposing limited workflows. No bueno.</p>
<p>It is a fair criticism to say that not everyone can host a server or
that permissions and authorization are hard. Although I think concerns
about impact are overblown. If you are a small project, just create a
GitHub or Bitbucket account. If you are a larger project, realize that
people time is one of your largest expenses and invest in tools like
proper and efficient repository hosting (often this can be GitHub) to
reduce this waste and keep your developers happier and more efficient.</p>
<p>One of the clearest examples of repository-centric development is
GitHub. There are no patches in GitHub. Instead, you <em>git push</em>
and <em>git fetch</em>. Want to apply someone else's work? Just add a remote
and <em>git fetch</em>! Contrast with first locating patches, hooking up
Git to consume them (this part was always confusing to me - do you
need to retroactively have them sent to your email inbox so you can
import them from there), and finally actually importing them. Just
give me a URL to a repository already. But the benefits of
repository-centric development with GitHub don't stop at pushing and
pulling. GitHub has built code review functionality into pushes. They
call these <em>pull requests</em>. While I have significant issues with
GitHub's implemention of pull requests (I need to blog about those some
day), I can't deny the utility of the repository-centric workflow and
all the benefits around it. Once you switch to GitHub and its
repository-centric workflow, you more clearly see how lacking
patch-centric development is and quickly lose your desire to go back
to the 1990's state-of-the-art methods for software development.</p>
<p>I hope you now know what repository-centric development is and will join
me in championing it over patch-based development.</p>
<p>Mozillians reading this will be very happy to learn that work is under
way to shift Firefox's development workflow to a more repository-centric
world. Stay tuned.</p>

  </div>
</div>



  <div class="after_post"><a href="http://gregoryszorc.com/blog/2014/07/24/repository-centric-development#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  
<div class="blog_post">
  <a name="new-repository-for-mozilla-version-control-tools"></a>
  <h2 class="blog_post_title"><a href="/blog/2014/02/05/new-repository-for-mozilla-version-control-tools" rel="bookmark" title="Permanent Link to New Repository for Mozilla Version Control Tools">New Repository for Mozilla Version Control Tools</a></h2>
  <small>February 05, 2014 at 07:15 PM | categories: 

<a href='/blog/category/git'>Git</a>, <a href='/blog/category/mercurial'>Mercurial</a>, <a href='/blog/category/mozilla'>Mozilla</a>
 | <a href="http://gregoryszorc.com/blog/2014/02/05/new-repository-for-mozilla-version-control-tools#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>Version control systems can be highly useful tools.</p>
<p>At Mozilla, we've made numerous improvements and customizations to our
version control tools. We have <a href="https://hg.mozilla.org/hgcustom/hghooks/">custom hooks</a>
that run on the server. We have a <a href="https://hg.mozilla.org/hgcustom/hg_templates/">custom skin</a>
for Mercurial's web interface. Mozillians have written a handful of
Mercurial extensions to aid with common developer tasks, such as
<a href="https://bitbucket.org/sfink/trychooser">pushing to try</a>,
<a href="https://hg.mozilla.org/users/tmielczarek_mozilla.com/bzexport">interacting with Bugzilla</a>,
<a href="https://bitbucket.org/sfink/mqext">making mq more useful</a>, and more.</p>
<p>These have all come into existence in an organic manner, one after the
other. Individuals have seen an itch and scratched it. Good for them.
Good for Mozilla.</p>
<p>Unfortunately, the collection of amassed tools has become quite large.
They have become difficult to discover and keep up to date. The
consistency in quality and style between the tools varies. Each tool has
separate processes for updating and changing.</p>
<p>I contacted the maintainers of the popular version control tools at
Mozilla with a simple proposal: let's maintain all our tools under one
repo. This would allow us to increase cohesion, share code, maintain a
high quality bar, share best practices, etc. There were no major
objections, so we now have a <a href="https://hg.mozilla.org/hgcustom/version-control-tools/">unified repository</a>
containing our version control tools!</p>
<p>Currently, we only have a few Mercurial extensions in there. A goal is
to accumulate as much of the existing Mercurial infrastructure into
that repository as possible. Client code. Server code. All of the code.
I want developers to be able to install the same hooks on their clients
as what's running on the server: why should your local repo let you
commit something that the server will reject? I want developers to be
able to reasonably reproduce Mozilla's canonical version control server
configuration locally. That way, you can test things locally with a high
confidence that your changes will work the same way on production. This
allows deployments to move faster and with less friction.</p>
<p>The immediate emphasis will be on moving extensions into this repo and
deprecating the old homes on user repositories. Over time, we'll move
into consolidating server code and getting hg.mozilla.org and
git.mozilla.org to use this repository. But that's a lower priority: the
most important goal right now is to make it easier and friendlier for
people to run productivity-enhancing tools.</p>
<p>So, if you see your Mercurial extensions alerting you that they've been
moved to a new repository, now you know what's going on.</p>

  </div>
</div>



  <div class="after_post"><a href="http://gregoryszorc.com/blog/2014/02/05/new-repository-for-mozilla-version-control-tools#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  
<div class="blog_post">
  <a name="aggregating-version-control-info-at-mozilla"></a>
  <h2 class="blog_post_title"><a href="/blog/2014/01/21/aggregating-version-control-info-at-mozilla" rel="bookmark" title="Permanent Link to Aggregating Version Control Info at Mozilla">Aggregating Version Control Info at Mozilla</a></h2>
  <small>January 21, 2014 at 10:50 AM | categories: 

<a href='/blog/category/git'>Git</a>, <a href='/blog/category/mercurial'>Mercurial</a>, <a href='/blog/category/mozilla'>Mozilla</a>, <a href='/blog/category/python'>Python</a>
 | <a href="http://gregoryszorc.com/blog/2014/01/21/aggregating-version-control-info-at-mozilla#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>Over the winter break, I set out on an ambitious project to create
a service to help developers and others manage the flury
of patches going into Firefox. While the project is far from complete,
I'm ready to unleash the first part of the project upon the world.</p>
<p>If you point your browsers to
<a href="http://moztree.gregoryszorc.com/">moztree.gregoryszorc.com</a>, you'll
hopefully see some documentation about what I've built.
<a href="https://bitbucket.org/indygreg/moz-tree-utopia">Source code</a> is
available and free, of course. Patches very welcome.</p>
<p>Essentially, I built a centralized indexing service for version
control repositories with Mozilla's extra metadata thrown in.
I tell it what repositories to mirror, and it clones everything,
fetches data such as the pushlog and Git SHA-1 mappings, and
stores everything in a central database. It then exposes this
aggregated data through world-readable web services.</p>
<p>Currently, I have the service indexing the popular project branches
for Firefox (central, aurora, beta, release, esr, b2g, inbound, fx-team,
try, etc). You can view the
<a href="http://moztree.gregoryszorc.com/api/repos">full list</a> via the web
service. As a bonus, I'm also serving these repositories via
<a href="http://hg.gregoryszorc.com/">hg.gregoryszorc.com</a>. My server appears
to be significantly faster than
<a href="https://hg.mozilla.org">hg.mozilla.org</a>. If you want to use it for
your daily needs, go for it. I make no SLA guarantees, however.</p>
<p>I'm also using this service as an opportunity to experiment with
alternate forms of Mercurial hosting. I have mirrors of mozilla-central
and the try repository with generaldelta and lz4 compression enabled.
I may blog about what those are eventually. The teaser is that they can
make Mercurial perform a lot faster under some conditions. I'm also
using ZFS under the hood to manage repositories. Each repository is a
ZFS filesystem. This means I can create repository copies on the server
(user repositories anyone?) at a nearly free cost. Contrast this to the
traditional method of full clones, which take lots of time, memory, CPU,
and storage.</p>
<p>Anyway, some things you can do with the existing web service:</p>
<ul>
<li>Obtain metadata about Mercurial changesets.
  <a href="http://moztree.gregoryszorc.com/api/changeset/940b2974f35b">Example</a>.</li>
<li>Look up metadata about Git commits.
  <a href="http://moztree.gregoryszorc.com/api/git-sha1/40438af67c321">Example</a>.</li>
<li>Obtain a <a href="http://moztree.gregoryszorc.com/api/spore">SPORE descriptor</a>
  describing the web service endpoints. This allows you to auto-generate
  clients from descriptors. Yay!</li>
</ul>
<p>Obviously, that's not a lot. But adding new endpoints is relatively
straightforward. See the <a href="https://bitbucket.org/indygreg/moz-tree-utopia/src/tip/repodata/web/app.py">source</a>.
It's literally as easy as defining a URL mapping and writing a
database query.</p>
<p>The performance is also not the best. I just haven't put in the effort
to tune things yet. All of the querying hits the database, not
Mercurial. So, making things faster should merely be a matter of
database and hosting optimization. Patches welcome!</p>
<p>Some ideas that I haven't had time to implement yet:</p>
<ul>
<li>Return changests in a specific repository</li>
<li>Return recently pushed changesets</li>
<li>Return pushes for a given user</li>
<li>Return commits for a given author</li>
<li>Return commits referencing a given bug</li>
<li>Obtain TBPL URLs for pushes with changeset</li>
<li>Integrate bugzilla metadata</li>
</ul>
<p>Once those are in place, I foresee this service powering a number of
dashboards. Patches welcome.</p>
<p>Again, this service is only the tip of what's possible. There's a lot
that could be built on this service. I have ideas. Others have ideas.</p>
<p>The project includes a Vagrant file and Puppet
manifests for provisioning the server. It's a one-liner to get a
development environment up and running. It should be really easy to
contribute to this project. Patches welcome.</p>

  </div>
</div>



  <div class="after_post"><a href="http://gregoryszorc.com/blog/2014/01/21/aggregating-version-control-info-at-mozilla#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  
<div class="blog_post">
  <a name="importance-of-hosting-your-version-control-server"></a>
  <h2 class="blog_post_title"><a href="/blog/2013/11/13/importance-of-hosting-your-version-control-server" rel="bookmark" title="Permanent Link to Importance of Hosting Your Version Control Server">Importance of Hosting Your Version Control Server</a></h2>
  <small>November 13, 2013 at 09:25 AM | categories: 

<a href='/blog/category/git'>Git</a>, <a href='/blog/category/mercurial'>Mercurial</a>, <a href='/blog/category/mozilla'>Mozilla</a>
 | <a href="http://gregoryszorc.com/blog/2013/11/13/importance-of-hosting-your-version-control-server#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>The subject of where to host version control repositories comes up a lot
at Mozilla. It takes many forms:</p>
<ul>
<li>We should move the Firefox repository to GitHub</li>
<li>I should be allowed to commit to GitHub</li>
<li>I want the canonical repository to be hosted by Bitbucket</li>
</ul>
<p>When Firefox development is concerned, Release Engineerings puts down
their foot and insists the canonical repository be hosted by Mozilla,
under a Mozilla hostname. When that's not possible, they set up a mirror
on Mozilla infrastructure.</p>
<p>I think a
<a href="https://groups.google.com/d/topic/jenkinsci-dev/-myjRIPcVwU/discussion">recent issue with the Jenkins project</a>
demonstrates why hosting your own version control server is important.
The gist is someone force pushed to a bunch of repos hosted on GitHub.
They needed to involve GitHub support to recover from the issue. While
it appears they largely recovered (and GitHub support deserves kudos - I
don't want to take away from their excellence), this problem would have
been avoided or the response time significantly decreased if the Jenkins
people had direct control over the Git server: they either could have
installed a custom hook that would have prevented the pushes or had
access to the reflog so they could have easily seen the last pushed
revision and easily forced pushed back to it. GitHub doesn't have a
mechanism for defining pre-* hooks, doesn't allow defining custom
hooks (a security and performance issue for them), and doesn't
expose the reflog data.</p>
<p>Until repository hosting services expose full repository data (such as
reflogs) and allow you to define custom hooks, accidents like these will
happen and the recovery time will be longer than if you hosted the repo
yourself.</p>
<p>It's possible repository hosting services like GitHub and Bitbucket will
expose these features or provide a means to quickly recover. If so,
kudos to them. But larger, more advanced projects will likely employ
custom hooks and considering custom hooks are a massive security and
performance issue for any hosted service provider, I'm not going to
hold my breath this particular feature is rolled out any time soon.
This is unfortunate, as it makes projects seemingly choose between
low risk/low convenience and GitHub's vibrant developer community.</p>

  </div>
</div>



  <div class="after_post"><a href="http://gregoryszorc.com/blog/2013/11/13/importance-of-hosting-your-version-control-server#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  
<div class="blog_post">
  <a name="thoughts-on-mercurial-(and-git)"></a>
  <h2 class="blog_post_title"><a href="/blog/2013/05/12/thoughts-on-mercurial-(and-git)" rel="bookmark" title="Permanent Link to Thoughts on Mercurial (and Git)">Thoughts on Mercurial (and Git)</a></h2>
  <small>May 12, 2013 at 12:00 PM | categories: 

<a href='/blog/category/mozilla'>Mozilla</a>, <a href='/blog/category/mercurial'>Mercurial</a>, <a href='/blog/category/git'>Git</a>
 | <a href="http://gregoryszorc.com/blog/2013/05/12/thoughts-on-mercurial-(and-git)#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>My first experience with Mercurial (Firefox development)
was very unpleasant. Coming from Git, I thought Mercurial was slow
and perhaps even more awkward to use than Git. I frequently
encountered repository corruption that required me to reclone. I thought
the concept of a patch queue was silly compared to Git branches. It
was all extremely frustrating and I dare say a hinderance to my
productivity. It didn't help that I was surrounded by a bunch of people
who had previous experience with Git and opined about every minute
difference.</p>
<p>Two years later and I'm on much better terms with Mercurial. I initially
thought it might be Stockholm Syndrome, but after reflection I can point
at specific changes and enlightenments that have reshaped my opinions.</p>
<h2>Newer versions of Mercurial are much better</h2>
<p>I first started using Mercurial in the 1.8 days and thought it was
horrible. However, modern releases are much, much better. I've noticed
a steady improvement in the quality and speed of Mercurial in the last
few years.</p>
<p><strong>If you aren't running 2.5 or later (Mercurial 2.6 was released earlier
this month), you should take the time to upgrade today.</strong> When you upgrade,
you should of course read the
<a href="http://mercurial.selenic.com/wiki/WhatsNew">changelog</a> and
<a href="http://mercurial.selenic.com/wiki/UpgradeNotes">upgrade notes</a> so you
can make the most of the new features.</p>
<h2>Proper configuration is key</h2>
<p>For <em>my</em> workflow, the default configuration of Mercurial out of the box
is... far from optimal. There are a number of basic changes that need to
be made to satisfy <em>my</em> expectations for a version control tool.</p>
<p>I used to think this was a shortcoming with Mercurial: why not ship a
powerful and useful environment out of the box? But, after talking to a
Mercurial core contributor, this is mostly by design. Apparently a
principle of the Mercurial project is that the CLI tool (<em>hg</em>) should be
simple by default and should minimize foot guns. They view actions like
rebasing and patch queues as advanced and thus don't have them enabled
by default. Seasoned developers may scoff at this. But, I see where
Mercurial is coming from. I only need to refer everyone to her first
experience with Git as an example of what happens when you don't aim for
simplicity. (I've never met a Git user who didn't think it overly
complicated at first.)</p>
<p>Anyway, to get the most out of Mercurial, it is essential to configure
it to your liking, much like you install plugins or extensions in your
code editor.</p>
<p><strong>Every person running Mercurial should go to
<a href="http://mercurial.selenic.com/wiki/UsingExtensions">http://mercurial.selenic.com/wiki/UsingExtensions</a>
and take the time to find extensions that will make your life better</strong>.
You should also run <em>hg help hgrc</em> to view all the configuration
options. There is a mountain of productivity wins waiting to be realized.</p>
<p>For reference, my <a href="https://gist.github.com/indygreg/5511712">~/.hgrc</a>.
Worth noting are some of the built-in externsions I've enabled:</p>
<ul>
<li>color - Colorize terminal output. Clear UX win.</li>
<li>histedit - Provides  <em>git rebase --interactive</em> behavior.</li>
<li>pager - Feed command output into a pager (like <em>less</em>). Clear UX win.</li>
<li>progress - Draw progress bars on long-running operations. Clear UX
  win.</li>
<li>rebase - Ability to easily rebase patches on top of other heads.
  This is a basic feature of patch management.</li>
<li>transplant - Easily move patches between repositories, branches, etc.</li>
</ul>
<p>If I were on Linux, I'd also use the <em>inotify</em> extension, which installs
filesystem watchers so operations like <em>hg status</em> are instantaneous.</p>
<p>In addition to the built-in extensions, there are a number of 3rd party
extensions that improve my Mozilla workflow:</p>
<ul>
<li><a href="https://bitbucket.org/sfink/mqext">mqext</a> - Automatically commit to
  your patch queue when you qref, etc. This is a lifesaver. If that's
  not enough, it suggests reviewers for your patch, suggests a bug
  component, and let's you find bugs touching the files you are
  touching.</li>
<li><a href="https://github.com/pbiggar/trychooser">trychooser</a> - Easily push
  changes to Mozilla's Try infrastructure.</li>
<li><a href="https://hg.mozilla.org/users/robarnold_cmu.edu/qimportbz">qimportbz</a> -
  Easily import patches from Bugzilla.</li>
<li><a href="https://hg.mozilla.org/users/tmielczarek_mozilla.com/bzexport">bzexport</a> -
  Easily export patches to Bugzilla.</li>
</ul>
<p>I'm amazed more developers don't use these simple productivity wins.
Could it be that people simply don't realize they are available?</p>
<p>Mozilla has a <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=794580">bug</a>
tracking easier configuration of the user's Mercurial environment. My
hope is one day people simply run a single command and get a
Mozilla-optimized Mercurial environment that <em>just works</em>. Along the same
vein, if your extensions are out of date, it prompts you to update them.
This is one of the benefits of a unified developer tool like mach: you
can put these checks in one place and everyone can reap the benefits
easily.</p>
<h2>Mercurial is extensible</h2>
<p>The major differentiator from almost every other version control system
(especially Git) is the ease and degree to which Mercurial can be
extended and contorted. <strong>If you take anything away from this
post it should be that Mercurial is a flexible and agile tool.</strong></p>
<p>If you want to change the behavior of a built-in command, you can write
an extension that monkeypatches that command. If you want to write a new
command, you can of course do that easily. You can have extensions
interact with one another - all natively. You can even override the wire
protocol to provide new <em>capabilities</em> to extend how peers communicate
with one another. You can leverage this to transfer additional metadata
or data types. This has nearly infinite potential. If that's not enough,
it's possible to create a new branching/development primitive through
just an extension alone! If you want to invent Git-style branches with
Mercurial, you could do that! It may require client and server support,
but it's possible.</p>
<p>Mercurial accomplishes this by being written (mostly) in Python (as
opposed to C) and by having a clear API on which extensions can be
built. Writing extensions in Python is huge. You can easily drop into
the debugger to learn the API and your write-test loop is much smaller.</p>
<p>By contrast, most other version control systems (including Git) require
you to parse output of commands (this is the UNIX piping principle).
Mercurial supports this too, but the native Python API is so much more
powerful. Instead of parsing output, you can just read the raw values
from a Python data structure. Yes please.</p>
<p>Since I imagine a lot of people at Mozilla will be reading this, here
are some ways Mozilla could leverage the extensibility of Mercurial:</p>
<ul>
<li>Command to create try pushes (it exists - see above).</li>
<li>Record who pushed what when (we have this - it's called the pushlog).</li>
<li>Command to land patches. If inbound1 is closed,
  automatically rebase on inbound2. etc. This could even be
  monkeypatched into <em>hg push</em> so pushes to inbound are automatically
  intercepted and magic ensues.</li>
<li>Record the automation success/fail status against individual
  revisions and integrate with commands (e.g. only pull up to the most
  recent stable changeset).</li>
<li>Command to create a review request for a patch or patch queue.</li>
<li>Command to assist with reviews. Perhaps a reviewer wants to make minor
  changes. Mercurial could download and apply the patch(es), wait for
  your changes, then reupload to Bugzilla (or the review tool)
  automatically.</li>
<li>Annotating commits or pushes with automation info (which jobs to
  run, etc).</li>
<li>Find Bugzilla component for patch (it exists - see above).</li>
<li>Expose custom protocol for configuring automation settings for a
  repository or a head. e.g. clients (with access) could reconfigure
  PGO scheduling, coalescing, etc without having to involve RelEng -
  useful for twigs and lesser used repositories.</li>
<li>So much more.</li>
</ul>
<p>Essentially, Mercurial itself could become the CLI tool code development
centers around. Whether that is a good idea is up for
debate. But, it can. And that says a lot about the flexibility of
Mercurial.</p>
<h2>Future potential of Mercurial</h2>
<p>When you consider the previous three points, you arrive at a new one:
Mercurial has a ton of future potential. The fact that extensions can
evolve vanilla Mercurial into something that resembles Mercurial in
name only is a testament to this.</p>
<p>When I sat down with a Mercurial core contributor, they reinforced this.
To them, Mercurial is a core library with a limited set of user-facing
commands forming the stable API. Since core features (like storage) are
internal APIs (not public commands - like Git), this means they aren't
bound to backwards compatibility and can refactor internals as needed
and evolve over time without breaking the world. That is a terrific
luxury.</p>
<p>An example of this future potential is
<a href="http://mercurial.selenic.com/wiki/ChangesetEvolution">changeset evolution</a>.
If you don't know what that is, you should because it's awesome. One of
the things they figured out is how to propagate rebasing between
clones!</p>
<h2>Comparing to Git</h2>
<p>Two years ago I would have said I would never opt to use Mercurial over
Git. I cannot say that today.</p>
<p>I do believe Git still has the advantage over Mercurial in a few areas:</p>
<ul>
<li>Branch management. Mercurial branches are a non-starter for
  light-weigh work. Mercurial bookmarks are kinda-sorta like Git
  branches, but not quite. I <em>really</em> like aspects of Git branches.
  Hopefully changeset evolution will cover the remaining gaps and more.</li>
<li>Patch conflict management. Git seems to do a better job of resolving
  patch conflicts. But, I think this is mostly due to Mercurial's patch
  queue extension not using the same merge code as built-in commands
  (this is a fixable problem).</li>
<li>Developer mind share and GitHub. The GitHub ecosystem makes up for
  many of Git's shortcomings. Bitbucket isn't the same.</li>
</ul>
<p>However, I believe Mercurial has the upper hand for:</p>
<ul>
<li>Command line friendliness. Git's command line syntax is notoriously
  awful and the concepts can be difficult to master.</li>
<li>Extensibility. It's so easy to program custom workflows and commands
  with Mercurial. If you want to hack your version control system,
  Mercurial wins hands down. Where Mercurial embraces extensibility, I
  couldn't even find a page listing all the useful Git <em>extensions</em>!</li>
<li>Open source culture. Every time I've popped into the Mercurial IRC
  channel I've had a good experience. I get a response quickly and
  without snark. Git by contrast, well, let's just say I'd rather be
  affiliated with the Mercurial crowd.</li>
<li>Future potential. Git is a content addressable key-value store with a
  version control system bolted on top. Mercurial is designed to be a
  version control system. Furthermore, Mercurial's code base is much
  easier to hack on than Git's. While Git has largely maintained feature
  parity in the last few years, Mercurial has grown new features. I see
  Mercurial evolving faster than Git and in ways Git cannot.</li>
</ul>
<p>It's worth calling out the major detractors for each.</p>
<p>I think Git's major weakness is its lack of extensibility and inability
to evolve (at least currently). Git will need to grow a better
extensibility model with better abstractions to compete with Mercurial
on new features. Or, the Git community will need to be receptive to
experimental features living in the core. All of this will require
some major API breakage. Unfortunately, I see little evidence this will
occur. I'm unable to find a <em>vision</em> document for the future of Git, a
branch with major new features, or interesting threads on the mailing
list. I tried to ask in their IRC channel and got crickets.</p>
<p>I think Mercurial's greatest weakness is lack of developer mindshare.
Git and GitHub are where it's at. This is huge, especially for projects
wanting collaboration.</p>
<p>Of all those points, I want to stress the extensibility and future
potential of Mercurial. If hacking your tools to maximize potential
and awesomeness is your game, Mercurial wins. End of debate. However,
if you don't want to harness these advantages, then I think Git and
Mercurial are mostly on equal footing. But given the rate of
development in the Mercurial project and relative stagnation of Git
(I can't name a major new Git feature in years), I wouldn't be
surprised if Mercurial's feature set obviously overtakes Git's in
the next year or two. Mind share will of course take longer and will
likely depend on what hosting sites like GitHub and Bitbucket do
(I wouldn't be surprised if GitHub rebranded as <em>CodeHub</em> or
something some day). Time will tell.</p>
<h2>Extending case study</h2>
<p><em>I have removed the case study that appeared in the original article
because as Mike Hommey observed in the comments, it wasn't a totally
accurate comparison. I don't believe the case study significantly added
much to the post, so I likely won't write a new one.</em></p>
<h2>Conclusion</h2>
<p>From where I started with Mercurial, I never thought I'd say this. But
here it goes: I like Mercurial.</p>
<p>I started warming up when it became faster and more robust in recent
versions in the last few years. When I learned about its flexibility and
the fundamentals of the project and thus its future potential, I became
a true fan.</p>
<p>It's easy to not like Mercurial if you are a new user coming
from Git and are forced to use a new tool. But, once you take the time to
properly configure it and appreciate it for what it is and what it
can be, Mercurial is easy to like.</p>
<p>I think Mercurial and Git are both fine version control systems. I would
happily use either one for a new project. If the social aspects of
development (including encouraging new contributors) were important to
me, I would likely select Git and GitHub. But, if I wanted something
just for me or I was a large project looking for a system that scales
and is flexible or was looking to the future, I'd go with Mercurial.</p>
<p>Mercurial is a rising star in the version control world. It's getting
faster and better and enabling others to more easily innovate through
powerful extensions. The future is bright for this tool.</p>

  </div>
</div>



  <div class="after_post"><a href="http://gregoryszorc.com/blog/2013/05/12/thoughts-on-mercurial-(and-git)#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
 <a href="/blog/category/git/2">Next Page Â»</a>

              </div>
              
          <div id="sidebar">
          <ul>
            <li>
              <h2>Categories</h2>
              <ul>
                <li><a href="/blog/category/clang">Clang</a></li>
                <li><a href="/blog/category/firefox">Firefox</a></li>
                <li><a href="/blog/category/git">Git</a></li>
                <li><a href="/blog/category/javascript">JavaScript</a></li>
                <li><a href="/blog/category/mercurial">Mercurial</a></li>
                <li><a href="/blog/category/mozilla">Mozilla</a></li>
                <li><a href="/blog/category/puppet">Puppet</a></li>
                <li><a href="/blog/category/python">Python</a></li>
                <li><a href="/blog/category/sync">Sync</a></li>
                <li><a href="/blog/category/browsers">browsers</a></li>
                <li><a href="/blog/category/build-system">build system</a></li>
                <li><a href="/blog/category/compilers">compilers</a></li>
                <li><a href="/blog/category/internet">internet</a></li>
                <li><a href="/blog/category/logging">logging</a></li>
                <li><a href="/blog/category/mach">mach</a></li>
                <li><a href="/blog/category/make">make</a></li>
                <li><a href="/blog/category/misc">misc</a></li>
                <li><a href="/blog/category/movies">movies</a></li>
                <li><a href="/blog/category/pymake">pymake</a></li>
                <li><a href="/blog/category/security">security</a></li>
                <li><a href="/blog/category/sysadmin">sysadmin</a></li>
                <li><a href="/blog/category/testing">testing</a></li>
              </ul>
            </li>
          </ul>
        </div>



              <div style="clear: both;">&nbsp;</div>
          </div>
        </div>
      </div>
      <div id="footer">
        
  <hr/>
  <p>Copyright (c) 2012 Gregory Szorc. All rights reserved. Design by <a href="http://www.freecsstemplates.org/"> CSS Templates</a>.</p>


      </div>
    </div>
  </body>
</html>





