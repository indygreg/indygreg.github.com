<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">Gregory Szorc's Digital Home</title>
  <subtitle type="text">Rambling on</subtitle>

  <updated>2020-01-07T20:09:12Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog" />
  <id>http://gregoryszorc.com/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://gregoryszorc.com/blog/feed/atom/" />
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Problems with Pull Requests and How to Fix Them]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2020/01/07/problems-with-pull-requests-and-how-to-fix-them" />
    <id>http://gregoryszorc.com/blog/2020/01/07/problems-with-pull-requests-and-how-to-fix-them</id>
    <updated>2020-01-07T12:10:00Z</updated>
    <published>2020-01-07T12:10:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Git" />
    <summary type="html"><![CDATA[Problems with Pull Requests and How to Fix Them]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2020/01/07/problems-with-pull-requests-and-how-to-fix-them"><![CDATA[<p>You've probably used or at least heard of <em>pull requests</em>: the <em>pull
request</em> is the contribution workflow practiced on and made popular by
[code] collaboration sites like GitHub, GitLab, Bitbucket, and others.
Someone (optionally) creates a <em>fork</em>, authors some commits, pushes them
to a branch, then creates a <em>pull request</em> to track integrating those commits
into a target repository and branch. The <em>pull request</em> is then used as a
vehicle for code review, tracking automated checks, and discussion until
it is ready to be integrated. Integration is usually performed by a
project maintainer, often with the click of a <em>merge</em> button on the pull
request's web page.</p>
<p>It's worth noting that the term <em>pull request</em> is not universally used:
GitLab calls them <em>merge requests</em> for example. Furthermore I regard the
terms <em>pull request</em> and <em>merge request</em> to be poorly named, as the terms
can be conflated with terminology used by your version control tool (e.g.
<code>git pull</code> or <code>git merge</code>. And the implementations of a <em>pull</em> or <em>merge</em>
request may not even perform a <em>pull</em> or a <em>merge</em> (you can also <em>rebase</em> a
<em>pull</em>/<em>merge</em> request, but nobody is calling them <em>rebase requests</em>). A
modern day <em>pull request</em> is so much more than a version control tool
operation or even a simple request to <em>pull</em> or <em>merge</em> a branch: it is a
nexus to track the integration of a proposed change before during and after
that change is integrated. But alas. Because GitHub coined the term and is
the most popular collaboration platform implementing this functionality, I'll
refer to this general workflow as implemented on GitHub, GitLab, Bitbucket,
and others as <em>pull requests</em> for the remainder of this post.</p>
<p>Pull requests have existed in essentially their current form for over
a decade. The core workflow has remained mostly unchanged.
What is different are the addition of value-add features, such as integrating
status checks like CI results, the ability to rebase or squash commits
instead of merging, code review tooling improvements, and lots of UI
polish. GitLab deserves a call out here, as their implementation of
<em>merge requests</em> tracks so much more than other tools do. (This is a
side-effect of GitLab having more built-in features than comparable tools.)
I will also give kudos to GitLab for adding new features to pull requests
when GitHub was asleep at the wheel as a company a few years ago. (Not having
a CEO for clear product/company leadership really showed.) Fortunately,
both companies (and others) are now churning out new, useful features at a
terrific clip, greatly benefiting the industry!</p>
<p>While I don't have evidence of this, I suspect pull requests (and the forking
model used by services that implement them) came into existence when someone
thought <em>how do I design a collaboration web site built on top of Git's new and
novel distributed nature and branching features</em>. They then proceeded to invent
<em>forking</em> and <em>pull requests</em>. After all, the pull request as implemented by
GitHub was initially a veneer over a common Git workflow of <em>create a clone,
create a branch, and send it somewhere.</em> Without GitHub, you would run <code>git
clone</code>, <code>git branch</code>, then some other command like
<a href="https://git-scm.com/docs/git-request-pull">git request-pull</a> (where have I seen
those words before) to generate/send your branch somewhere. On GitHub, the
comparable steps are roughly <em>create a fork</em>, <em>create a branch to your fork</em>,
and <em>submit a pull request</em>. Today, you can even do all of this straight from
the web interface without having to run <code>git</code> directly! This means that GitHub
can conceptually be thought of as a purely server-side abstraction/implementation
of the Git feature branch workflow.</p>
<p><strong>At its core, the pull request is fundamentally a nice UI and feature layer
built around the common Git feature branch workflow.</strong> It was likely initially
conceived as polish and value-add features over this historically client-side
workflow. And this core property of pull requests from its very first days has
been copied by vendors like Bitbucket and GitLab (and in Bitbucket's case it
was implemented for Mercurial - not Git - as Bitbucket was initially Mercurial
only).</p>
<p>A decade is an eternity in the computer industry. As they say, if you
aren't moving forward, you are moving backward. <strong>I think it is time
for industry to scrutinize the pull request model and to evolve it into
something better.</strong></p>
<p>I know what you are thinking: you are thinking that pull requests
work great and that they are popular because they are a superior model
compared to what came before. These statements - aside from some nuance -
are true. But if you live in the version control space (like I do) or
are paid to deliver tools and workflows to developers to improve
productivity and code/product quality (which I am), the deficiencies
in the pull request workflow and implementation of that workflow among
vendors like GitHub, GitLab, Bitbucket, etc are obvious and begging to be
overhauled if not replaced wholesale.</p>
<p>So buckle in: you've started a ten thousand word adventure about everything
you didn't think you wanted to know about pull requests!</p>
<h2>Problems with Pull Requests</h2>
<p>To build a better workflow, we first have to understand what is
wrong/sub-optimal with pull requests.</p>
<p><strong>I posit that the foremost goal of an pull request is to foster the
incorporation of a high quality and desired change into a target
repository with minimal overhead and complexity for submitter,
integrator, and everyone in between.</strong> Pull requests achieve this
goal by fostering collaboration to discuss the change (including code
review), tracking automated checks against the change, linking to related
issues, etc. In other words, the way I see the world is that a specific
vendor's pull request implementation is just that: an implementation detail.
And like all implementation details, they should be frequently scrutinized
and changed, if necessary.</p>
<p>Let's start dissecting the problems with pull requests by focusing on
the size of review units. Research by
<a href="https://sback.it/publications/icse2018seip.pdf">Google</a>,
Microsoft <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/bosu2015useful.pdf">here</a>,
and <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2015/05/PID3556473.pdf">here</a>,
and others has shown an inverse correlation with review unit size
and defect rate. In Google's words (emphasis mine):</p>
<p>The size distribution of changes is an important factor in the
   quality of the code review process. <strong>Previous studies have found that
   the number of useful comments decreases and the review latency
   increases as the size of the change increases.</strong> Size also
   influences developers' perception of the code review process; a
   survey of Mozilla contributors found that <strong>developers feel that
   size-related factors have the greatest effect on review latency</strong>.
   A correlation between change size and review quality is
   acknowledged by Google and <strong>developers are strongly encouraged to
   make small, incremental changes</strong> (with the exception of large
   deletions and automated refactoring). These findings and our study
   support the value of reviewing small changes and the need for
   research and tools to help developers create such small,
   self-contained code changes for review.</p>
<p>Succinctly, larger changes result in fewer useful comments during
review (meaning quality is undermined) and make reviews take longer
(meaning productivity is undermined). <strong>Takeaway: if you care about
defect rate / quality and/or velocity, you should be authoring and
reviewing more, smaller changes as opposed to fewer, larger changes.</strong></p>
<p>I stronger agree with Google's opinion on this matter and wholeheartedly
endorse writing more, smaller changes. Having practiced both forms of
change authorship, I can say without a doubt that more, smaller changes
is superior: superior for authors, superior for code reviewers, and
superior for people looking at repository history later. The main downside
with this model is that it requires a bit more knowledge of your version
control tool to execute. And, it requires corresponding tooling to play
well with this change authorship model and to introduce as little
friction as possible along the way since the number of interactions
with tooling will increase as change size decreases, velocity
increases, and there are more distinct units of change being considered
for integration.</p>
<p>That last point is important and is germane to this post because the
common implementation of pull requests today is not very compatible
with the <em>many small changes</em> workflow. As I'll argue, <strong>the current
implementation of pull requests actively discourages the many smaller
changes workflow. And since smaller changes result in higher quality
and faster reviews, today's implementations of pull requests are
undermining quality and velocity.</strong></p>
<p>I don't mean to pick on them, but since they are the most popular and
the people who made pull requests popular, let's use GitHub's implementation
of pull requests to demonstrate my point.</p>
<p><strong>I posit that in order for us to author more, smaller changes, we must
either a) create more, smaller pull requests or b) have pull request
reviews put emphasis on the individual commits (as opposed to the
overall <em>merge diff</em>).</strong> Let's examine these individually.</p>
<p>If we were to author more, smaller pull requests, this would seemingly
necessitate the need for dependencies between pull requests in order
to maintain velocity. And dependencies between pull requests adds
a potentially prohibitive amount of overhead. Let me explain. We don't
want to sacrifice the overall rate at which authors and maintainers are
able to integrate proposed changes. If we were to split existing proposed
changes into more, smaller pull requests, we would have a lot more pull
requests. Without dependencies between them, authors could wait for each
pull request to be integrated before sending the next one. But this would
incur more round trips between author and integrator and would almost
certainly slow down the overall process. That's not desirable. The
obvious mitigation to that is to allow multiple, related pull requests
in flight simultaneously. But this would necessitate the invention of
dependencies between pull requests in order to track relationships so
one pull request doesn't integrate before another it logically depends on.
This is certainly technically doable. But it imposes considerable
overhead of its own. How do you define dependencies? Are dependencies
automatically detected or updated based on commits in a DAG? If yes,
what happens when you force push and it is ambiguous whether a <em>new</em>
commit is a logically new commit or a successor of a previous one? If
no, do you really want to impose additional hurdles on submitters to
define dependencies between every pull request? In the extreme case of
one pull request per commit, do you make someone submitting a series of
say twenty commits and pull requests really annotate nineteen dependencies?
That's crazy!</p>
<p>There's another, more practical issue at play: the interplay between
Git branches and pull requests. As implemented on GitHub, a pull request
is tracked by a Git branch. If we have N inter-dependent pull requests,
that means N Git branches. In the worst case, we have one Git branch for
every Git commit. Managing N in-flight Git branches would be absurd.
It would impose considerable overhead on pull request submitters. It
would perfectly highlight the inefficiency in Git's
<a href="/blog/2017/12/11/high-level-problems-with-git-and-how-to-fix-them/">game of refs</a>
branch management that I blogged about two years ago. (Succinctly,
once you are accustomed to workflows - like Mercurial's - which don't
require you to name commits or branches, Git's forced naming of branches
and all the commands requiring those branch names feels grossly inefficient
and a mountain of overhead.) Some tooling could certainly be implemented
to enable efficient submission of pull requests. (See
<a href="https://github.com/ezyang/ghstack">ghstack</a> for an example.) But I
think the interplay between Git branches and GitHub pull requests is
sufficiently complex that the tooling and workflow would be intractable
for anything but the most trivial and best-case scenarios. Keep in mind
that any sufficiently user-friendly solution to this problem would
also entail improving <code>git rebase</code> so it moves branches on rewritten
ancestor commits instead of leaving them on the old versions of
commits. (Seriously, someone should implement this feature: it arguably
makes sense as the default behavior for local branches.) In other
words, <strong>I don't think you can implement the multiple pull request model
reliably and without causing excessive burden on people without
fundamentally changing the requirement that a pull request be a Git
branch</strong>. (I'd love to be proven wrong.)</p>
<p>Therefore, <strong>I don't think the more, smaller changes workflow can be easily
practiced with multiple pull requests using the common GitHub model without
effectively moving the definition of a pull request away from
equivalence with a Git branch</strong> (more on this later). And I also
don't mean to imply that dependencies between pull requests can't be
implemented: they can and
<a href="https://docs.gitlab.com/ee/user/project/merge_requests/merge_request_dependencies.html">GitLab is evidence</a>.
But GitLab's implementation is somewhat simple and crude (possibly
because doing anything more complicated is really hard as I speculate).</p>
<p>So without fundamentally changing the relationship between a pull
request and a branch, that leaves us with our alternative of pull
requests putting more emphasis on the individual changes rather than
the <em>merge diff</em>. Let's talk about that now.</p>
<p>Pull requests have historically placed emphasis on the <em>merge diff</em>.
That is, GitHub (or another provider) takes the Git branch you have
submitted, runs a <code>git merge</code> against the target branch behind the
scenes, and displays that diff front and center for review as the main
proposed unit of change: if you click the <em>Files changed</em> tab to
commence review, you are seeing this overall <em>merge diff</em>. You can
click on the <em>Commits</em> tab then select an individual commit to review
just that commit. Or you can use the dropdown on the <em>Files changed</em>
tab to select an individual commit to review it. These (relatively
new) features are a very welcome improvement and do facilitate
performing a commit-by-commit review, which is a requirement to realize
the benefits of a more, smaller changes workflow. Unfortunately, they
are far from sufficient to fully realize the benefits of that workflow.</p>
<p>Defaults matter and GitHub's default is to show the <em>merge diff</em> when
conducting review. (I bet a large percentage of users don't even know
it is possible to review individual commits.) <strong>Since larger changes
result in a higher defect rate and slower review, GitHub's default
of showing the <em>merge diff</em> effectively means GitHub is defaulting to
lower quality, longer-lasting reviews.</strong> (I suppose this is good for
engagement numbers, as it inflates service usage both immediately and
in the long-term due to subsequent bugs driving further usage. But I
sincerely hope no product manager is thinking <em>let's design a product
that undermines quality to drive engagement</em>.)</p>
<p>Unfortunately, a trivial change of the default to show individual commits
instead of the <em>merge diff</em> is not so simple, as many authors and
projects don't practice clean commit authorship practices, where
individual commits are authored such that they can be reviewed in isolation.</p>
<p>(One way of classifying commit authorship styles is by whether a series
of commits is authored such that each commit is good in isolation or
whether the effect of applying the overall series is what matters. A
handful of mature projects - like the Linux kernel, Firefox, Chrome,
Git, and Mercurial - practice the <em>series of individually-good commits</em>
model, which I'll call a <em>commit-centric workflow</em>. I would wager the
majority of projects on GitHub and similar services practice the <em>we only
care about the final result of the series of commits</em> model. A litmus
test for practicing the latter model is whether pull requests contain commits
like <em>fixup foo</em> or if subsequent revisions to pull requests create new
commits instead of amending existing ones. I'm a strong proponent of
a clean commit history where each commit in the final repository history
stands as <em>good</em> in isolation. But I tend to favor more <em>grown-up</em>
software development practices and am a version control guru. That
being said, the subject/debate is fodder for another post.)</p>
<p>If GitHub (or someone else) switched the pull request default to a
per-commit review without otherwise changing the relationship between a
pull request and a Git branch, that would force a lot of less experienced
users to familiarize themselves with history rewriting in Git. This would
impose considerable pain and suffering on pull request authors, which
would in turn upset users, hurt engagement, etc. Therefore, I don't think
this is a feasible <em>global</em> default that can be changed. Maybe if Git's
user experience for history rewriting were better or we didn't have a
decade of behavior to undo we'd be in a better position... But pull
request implementations don't need to make a <em>global</em> change: <strong>they could
<em>right the ship</em> by offering projects that practice <em>clean commit
practices</em> an option to change the review default so it emphasizes
individual commits instead of the <em>merge diff</em>.</strong> This would go a long way
towards encouraging authoring and reviewing individual commits, which
should have positive benefits on review velocity and code quality
outcomes.</p>
<p>But even if these services did emphasize individual commits by default in
pull request reviews, there's still a handful of significant
deficiencies that would undermine the more, smaller changes workflow
that we desire.</p>
<p>While it is possible to review individual commits, all the review comments
are still funneled into a single per pull request <em>timeline</em> view of
activity. <strong>If submitter and reviewer make the effort to craft and
subsequently review individual commits, your reward is that all the feedback
for the discrete units of change gets lumped together into one massive pile
of feedback for the pull request as a whole.</strong> This unified pile of feedback
(currently) does a poor job of identifying which commit it applies to and
gives the author little assistance in knowing which commits need amending to
address the feedback. This undermines the value of commit-centric workflows
and effectively pushes commit authors towards the <em>fixup</em> style of commit
authorship. <strong>In order to execute per-commit review effectively, review
comments and discussion need to be bucketed by commit and not combined into a
unified pull request timeline.</strong> This would be a massive change to the pull
request user interface and would be a daunting undertaking, so it is
understandable why it hasn't happened yet. And such an undertaking would also
require addressing subtly complex issues like how to preserve reviews in the
face of force pushes. Today, GitHub's review comments can <em>lose context</em> when
force pushes occur. Things are better than they used to be, when review comments
left on individual commits would flat out be deleted (yes: GitHub really did
effectively lose code review comments for several years.) But even with tooling
improvements, problems still remain and should adoption of commit-level review
tracking occur, these technical problems would likely need resolution to
appease users of this workflow.</p>
<p>Even if GitHub (or someone else) implements robust per-commit review
for pull requests, there's still a problem with velocity. And that problem
is that <strong>if the pull request is your unit of integration (read: <em>merging</em>),
then you have to wait until every commit is reviewed before integration
can occur</strong>. This may sound tolerable (it's what we practice today after
all). But I argue this is less optimal than a world where a change
integrates as soon as it is ready to, without having to wait for the
changes after it. <strong>As an author and maintainer, if I see a change that
is ready to integrate, I prefer to integrate it as soon as possible, without
delay.</strong> The longer a ready-to-integrate change lingers, the longer it is
susceptible to bit rot (when the change is no longer valid/good due to
other changes in the system). Integrating a judged-good change sooner also
reduces the time to meaningful feedback: if there is a fundamental
problem early in a series of changes that isn't caught before integration,
integrating earlier changes sooner without waiting for the ones following
will expose problems sooner. This minimizes deltas in changed systems
(often making regression hunting easier), often minimizes the blast radius if
something goes wrong, and gives the author more time and less pressure to
amend subsequent commits that haven't been integrated yet. And in addition
to all of this, <strong>integrating more often just feels better</strong>.
<a href="https://hbr.org/2011/05/the-power-of-small-wins">The Progress Principle</a>
states that people feel better and perform better work when they are
making continuous progress. But setbacks more than offset the power of
small wins. While I'm not aware of any explicit research in this area,
my interpretation of the Progress Principle to change authorship and project
maintenance(which is supported by anecdotal observation) is
that a steady stream of integrated changes feels a hell of a lot better
than a single monolithic change lingering in review purgatory for what can
often seem like an eternity. <strong>While you need to be cognizant to not
confuse movement with meaningful progress, I think there is real power
to the Progress Principle and that we should aim to incorporate changes
as soon as they are ready and not any later.</strong> Applied to version control
and code review, this means integrating a commit as soon as author,
reviewer, and our machine overlords reporting status checks all agree it
is ready, without having to wait for a larger unit of work, like the
pull request. Succinctly, move forward as soon as you are able to!</p>
<p>This desire to <em>integrate faster</em> has significant implications for
pull requests. Again, looking at GitHub's implementation of pull
requests, I don't see how today's pull requests could adapt to this
desired end state without significant structural changes. For starters,
review <strong>must</strong> grow the ability to track per-commit state otherwise
integrating individual commits without the entirety of the parts makes
little sense. But this entails all the complexity I described above.
Then there's the problem of Git branches effectively defining a pull
request. What happens when some commits in a pull request are integrated
and the author rebases or merges their local branch against their new
changes? This may or may not <em>just work</em>. And when it doesn't <em>just work</em>,
the author can easily find themselves in <em>merge conflict hell</em>, where
one commit after the other fails to apply cleanly and their carefully
curated stack of commits quickly becomes a liability and impediment to
forward progress. (As an aside, the Mercurial version control tool has
a concept called <em>changeset evolution</em> where it tracks which commits -
changesets in Mercurial parlance - have been rewritten as other commits
and gracefully reacts in situations like a rebase. For example, if you
have commits <code>X</code> and <code>Y</code> and <code>X</code> is integrated via a rebase as <code>X'</code>, an
<code>hg rebase</code> of <code>Y</code> onto <code>X'</code> will see that <code>X</code> was rewritten as <code>X'</code> and
skip attempting to rebase <code>X</code> because it is already applied! This cleanly
sidesteps a lot of the problems with history rewriting - like merge
conflicts - and can make the end-user experience much more pleasant as
a result.) While it is certainly possible to integrate changes as soon
as they are <em>ready</em> with a pull request workflow, I think that it is
awkward and that by the time you've made enough changes to accommodate
the workflow, very little is left of the pull request workflow as we
know it and it is effectively a different workflow altogether.</p>
<p><strong>The above arguments overly hinge on the assumption that more smaller
changes is superior for quality and/or velocity and that we should
design workflows around this assertion.</strong> While I strongly believe
in the merits of smaller units of change, others may disagree. (If
you do disagree, you should ask yourself whether you believe the
converse: that larger units of change are better for quality and
velocity. I suspect most people can't justify this. But I do believe
there is merit to the argument that smaller units of change impose
additional per-unit costs or have second order effects that undermine
their touted quality or velocity benefits.)</p>
<p><strong>But even if you don't buy into the change size arguments, there's
still a very valid reason why we should think beyond pull requests as
they are implemented today: tool scalability.</strong></p>
<p>The implementation of pull requests today is strongly coupled with
how Git works out of the box. A pull request is initiated from a Git
branch pushed to a remote Git repository. When the pull request is
created, the server creates a Git branch/ref referring to that pull
request's <em>head</em> commits. On GitHub, these refs are
<a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/checking-out-pull-requests-locally">named</a>
<code>pull/ID/head</code> (you can fetch these from the remote Git repository but
they are not fetched by default). Also when a pull request is created
or updated, a <code>git merge</code> is performed to produce a diff for review.
On GitHub, the resulting merge commit is <em>saved</em> and pointed to on
the open pull request via a <code>pull/ID/merge</code> ref, which can also be
fetched locally. (The <em>merge</em> ref is deleted when the pull request is
closed.)</p>
<p>Herein resides our scalability problem: unbound growth of Git refs
and ever-increasing rate of a change for a growing project.
Each Git ref adds overhead to graph walking operations and data exchange.
While involved operations are continuously getting optimized (often through
the use of more advanced data structures or algorithms), there are
intrinsic scaling challenges with this unbound growth that - speaking as
a version control tool maintainer - I want no part of. Are technical
solutions enabling things to scale to millions of Git refs viable?
Yes'ish. But it requires high-effort solutions like
<a href="https://git.eclipse.org/r/#/c/146568/">JGit's Reftable</a>, which
required ~90 review rounds spanned across ~4 months to land. And that's
after design of the feature was first proposed at least as far back
as <a href="https://public-inbox.org/git/CAJo=hJtyof=HRy=2sLP0ng0uZ4=S-DpZ5dR1aF+VHVETKG20OQ@mail.gmail.com/">July 2017</a>.
Don't get me wrong: am I glad Reftable exists: yes. It is a fantastic
solution to a real problem and reading how it works will probably
make you a better engineer. But simultaneously, it is a solution to a
problem that does not need to exist. There is a space for scaling graph
data structures and algorithms to millions or even billions of nodes, edges,
and paths: your version control tool should not be it. Millions or billions
of commits and files: that's fine. But scaling the number of distinct paths
through that graph by introducing millions of DAG heads is insane given how much
complexity it introduces in random areas of the tool. In my opinion it
requires unjustifiably large amounts of investment to make work
at scale. As an engineer, my inclination when posed with problems like
these is to avoid them in the first place. The easiest problems to solve
are those you don't have.</p>
<p><strong>Unfortunately, the tight coupling of pull requests to Git branches/refs
introduces unbound growth and a myriad of problems associated with it.</strong>
Most projects may not grow to a size that experiences these problems. But
as someone who has experience with this problem space at multiple companies,
I can tell you the problem is very real and the performance and scalability
issues it creates undermines the viability of using today's implementation of
pull requests once you've reached a certain scale. Since we can likely fix the
underlying scaling issues with Git, I don't think the explosion of Git refs
is a long-term deal breaker for scaling pull requests. But it is today and
will remain so until Git and the tools built on top of it improve.</p>
<p>In summary, some high-level problems with pull requests are as follows:</p>
<ul>
<li>Review of <em>merge diff</em> by default encourages larger units of review,
  which undermines quality and velocity outcomes.</li>
<li>Inability to incrementally integrate commits within a pull request,
  which slows down velocity, time to meaningful feedback, and can
  lower morale.</li>
<li>Tight coupling of pull requests with Git branches adds rigidity to
  workflows and shoehorns into less flexible and less desired workflows.</li>
<li>Deficiencies in the Git user experience - particular around what happens
  when rewrites (including rebase) occur - significantly curtail what
  workflows can be safely practiced with pull requests.</li>
<li>Tight coupling of pull requests with Git branches can lead to performance
  issues at scale.</li>
</ul>
<p>We can invert language to arrive at a set of more ideal outcomes:</p>
<ul>
<li>Review experience is optimized for individual commits - not the <em>merge
  diff</em> - so review units are smaller and quality and velocity outcomes
  are improved.</li>
<li>Ability to incrementally integrate individual commits from a larger
  set so ready-to-go changes are incorporated sooner, improving velocity,
  time to meaningful feedback, and morale.</li>
<li>How you use Git branches does not impose significant restrictions on
  handling of pull requests.</li>
<li>You can use your version control tool how you want, without having to
  worry about your workflow being shoehorned by how pull requests
  work.</li>
<li>Pull request server can scale to the most demanding use cases with
  relative ease.</li>
</ul>
<p>Let's talk about how we could achieve these more desirable outcomes.</p>
<h2>Exploring Alternative Models</h2>
<p>A <em>pull request</em> is merely an implementation pattern for the general problem
space of <em>integrating a proposed change</em>. There are other patterns used by other
tools. Before I describe them, I want to coin the term <em>integration request</em> to
refer to the generic concept of requesting some change being <em>integrated</em>
elsewhere. GitHub pull requests and GitLab merge requests are implementations
of <em>integration requests</em>, for example.</p>
<p>Rather than describe alternative tools in detail, I will outline the key
areas where different tools differ from pull requests and assess the benefits
and drawbacks to the different approaches.</p>
<h3>Use of the VCS for Data Exchange</h3>
<p>One can classify implementations of <em>integration requests</em> by how they utilize
the underlying version control tools.</p>
<p>Before Git and GitHub came along, you were probably running a centralized version
control tool which didn't support offline commits or feature branches (e.g. CVS
or Subversion). In this world, the common mechanism for <em>integration requests</em>
was exchanging diffs or patches through various media - email, post to a web
service of a code review tool, etc. Your version control tool didn't speak
directly to a VCS server to initiate an <em>integration request</em>. Instead, you
would run a command which would export a text-based representation of the
change and then send it somewhere.</p>
<p>Today, we can classify <em>integration requests</em> by whether or not they speak
the version control tool's native protocol for exchanging data or whether
they exchange patches through some other mechanism. Pull requests speak the
VCS native protocol. Tools like Review Board and Phabricator exchange patches
via custom HTTP web services. Typically, tools using non-native exchange
will require additional client-side configuration, including potentially the
installation of a custom tool (e.g. <code>RBTools</code> for Review Board or <code>Arcanist</code>
for Phabricator). Although modern version control tools sometimes have
this functionality built-in. (e.g. Git and Mercurial fulfill
<a href="https://en.wikipedia.org/wiki/Jamie_Zawinski#Principles">Zawinski's law</a> and
Mercurial has a Phabricator extension in its official distribution).</p>
<p>An interesting outlier is Gerrit, which ingests its <em>integration requests</em> via
<code>git push</code>. (See
<a href="https://gerrit-review.googlesource.com/Documentation/user-upload.html">the docs</a>.)
But the way Gerrit's ingestion via <code>git push</code> works is fundamentally different
from how pull requests work! With pull requests, you are pushing your local
branch to a remote branch and a pull request is built around that remote branch.
With Gerrit, your push command is like <code>git push gerrit HEAD:refs/for/master</code>.
For the non-gurus, that <code>HEAD:refs/for/master</code> syntax means, <em>push the <code>HEAD</code>
commit (effectively the commit corresponding to the working directory) to the
<code>refs/for/master</code> ref on the <code>gerrit</code> remote</em> (the <code>SOURCE:DEST</code>
syntax specifies a mapping of local revision identifier to remote ref). The
wizard behind the curtain here is that Gerrit runs a special Git server that
implements non-standard behavior for the <code>refs/for/*</code> refs. When you push to
<code>refs/for/master</code>, Gerrit receives your Git push like a normal Git server would.
But instead of writing a ref named <code>refs/for/master</code>, it takes the incoming commits
and ingests them into a code review request! Gerrit will create Git refs for the
pushed commits. But it mainly does that for its internal tracking (Gerrit stores
all its data in Git - from Git data to review comments). And if
that functionality isn't too magical for you, you can also pass parameters to
Gerrit via the ref name! e.g. <code>git push gerrit HEAD refs/for/master%private</code>
will create a private review request that requires special permissions to see.
(It is debatable whether overloading the ref name for additional functionality
is a good user experience for average users. But you can't argue that this isn't
a cool hack!)</p>
<p>On the surface, it may seem like using the version control tool's native data
exchange is a superior workflow because it is <em>more native</em> and more modern.
(<em>Emailing patches is so old school.</em>) Gone are the days of having to configure
client-side tools to export and submit patches. Instead, you run <code>git push</code> and
your changes can be turned into an <em>integration request</em> automatically or with
a few mouse clicks. And from a technical level, this exchange methodology is
likely safer, as round-tripping a text-based representation of a change without
data loss is surprisingly finicky. (e.g. JSON's lack of lossless binary data
exchange without encoding to e.g. base64 first often means that many services
exchanging text-based patches are lossy, especially in the presence of content
which doesn't conform to UTF-8, which can be commonplace in tests. You would be
surprised how many tools experience data loss when converting version control
commits/diffs to text. But I digress). Having Git's wire protocol exchange
binary data is safer than exchanging text patches and probably easier to use
since it doesn't require any additional client-side configuration.</p>
<p>But despite being more native, modern, and arguably robust, exchange via the
version control tool may not be <em>better</em>.</p>
<p>For starters, use of the version control tool's native wire protocol inhibits
use of arbitrary version control tools on the client. When your <em>integration
request</em> requires the use of a version control tool's wire protocol, the client
likely needs to be running that version control tool. With other approaches like
exchange of text based patches, the client could be running any software it
wanted: as long as it could spit out a patch or API request in the format the
server needed, an <em>integration request</em> could be created! This meant there was
less potential for <em>lock-in</em>, as people could use their own tools on their
machines if they wanted and they (hopefully) wouldn't be inflicting their choice
on others. Case in point, a majority of Firefox developers use Mercurial - the
VCS of the canonical repository - but a large number use Git on the client. Because
Firefox is using Phabricator (Review Board and Bugzilla before that) for code
review and because Phabricator ingests text-based patches, the choice of the
VCS on the client doesn't matter that much and the choice of the server VCS
can be made without inciting a holy war among developers who would be forced
to use a tool they don't prefer. Yes, there are good reasons for using a
consistent tool (including organizational overhead) and sometimes mandates for
tool use are justified. But in many cases (such as random open source
contributions), it probably doesn't or shouldn't matter. And in cases like
Git and Mercurial, where tools like the fantastic
<a href="https://github.com/glandium/git-cinnabar">git-cinnabar</a> make it
possible to easily convert between the repositories without data loss and
acceptable overhead, adoption of the version control tool's native wire
protocol can exclude or inhibit the productivity of contributors since it can
mandate use of specific, undesired tooling.</p>
<p>Another issue with using the version control tool's wire protocol is that it
often forces or strongly encourages you to work a certain way. Take GitHub
pull requests for example. The pull request is defined around the remote Git
branch that you <code>git push</code>. If you want to update that branch, you need to know
its name. So that requires some overhead to either create and track that branch
or find its name when you want to update it. Contrast with Gerrit, where you
don't have an explicit remote branch you push to: you simply <code>git push gerrit
HEAD:refs/for/master</code> and it figures things out automatically (more on this
later). With Gerrit, I don't have to create a local Git branch to initiate an
<em>integration request</em>. With pull requests, I'm compelled to. And this can undermine
my productivity by compelling me to practice less-efficient workflows!</p>
<p>Our final point of comparison involves scalability. <strong>When you use the version
control tool wire protocol as part of <em>integration requests</em>, you have
introduced the problem of scaling your version control server.</strong> Take it from
someone who has had multiple jobs involving scaling version control servers
and who is intimately aware of the low-level details of both the
Git and Mercurial wire protocols: you don't want to be in the business of
scaling a version control server. The wire protocols for both Git and
Mercurial were designed in a now-ancient era of computing and weren't designed
by network protocol experts. They are fundamentally difficult to scale at
just the wire protocol level. I've heard stories that at one time, the
most expensive single server at Google was their Perforce or Perforce-derived
server (this was several years ago - Google has since moved on to a better
architecture).</p>
<p>The poor network protocols of version control tools have many side-effects,
including the inability or sheer difficulty of using distributed storage
on the server. So in order to scale compute horizontally, you need to invest
in expensive network storage solutions or devise a replication and
synchronization strategy. And take it from someone who worked on data
synchronization products (outside of the source control space) at three
companies: this is a problem you don't want to solve yourself. Data
synchronization is intrinsically difficult and rife with difficult trade-offs.
It's almost always a problem best avoided if you have a choice in the matter.</p>
<p>If creating Git refs is part of creating an <em>integration request</em>, you've
introduced a scaling challenge with the number of Git refs. Do these Git
refs live forever? What happens when you have thousands of developers -
possibly all working in the same repository - and the number of refs or ref
mutations grows to the hundreds of thousands or millions per year?</p>
<p>Can your version control server handle ingesting a push every second or two
with reasonable performance? Unless you are Google, Facebook, or a handful of
other companies I'm aware of, it can't. And before you cry that I'm talking
about problems that only plague the 0.01% of companies out there, I can name a
handful of companies under 10% the size of these behemoths where this is a
problem for them. And I also guarantee that many people don't have client-side
metrics for their <code>git push</code> P99 times or reliability and don't even realize
there is a problem! Scaling version control is probably not a core part of your
company's business. Unfortunately, it all too often becomes something companies
have to allocate resources for because of poorly designed or utilized tools.</p>
<p>Contrast the challenges of scaling <em>integration requests</em> with a native
version control server versus just exchanging patches. With the more
<em>primitive</em> approach, you are probably sending the patch over HTTP to a web
service. And with tools like Phabricator and Review Board, that patch gets
turned into rows in a relational database. <strong>I guarantee it will be easier
to scale an HTTP web service fronting a relational database than it will
be your version control server.</strong> If nothing else, it should be easier to manage
and debug, as there are tons more experts in these domains than in the
version control server domain!</p>
<p>Yes, it is true that many will not hit the scaling limits of the version
control server. And some nifty solutions for scaling do exist. But large
segments of this problem space - including the version control tool maintainers
having to support <em>crazy</em> scaling vectors in their tools - could be avoided
completely if <em>integration requests</em> didn't lean so heavily on the version
control tools's default mode of operation. Unfortunately, solutions like
GitHub pull requests and Gerrit's use of Git refs for storing <em>everything</em>
exert a lot of pressure on scaling the version control server and make this
a very real problem once you reach a certain scale.</p>
<p>Hopefully the above paragraphs enlightened you to some of the implications
that the choice of a data exchange mechanism has on <em>integration requests</em>!
Let's move on to another point of comparison.</p>
<h3>Commit Tracking</h3>
<p>One can classify implementations of <em>integration requests</em> by how they <em>track</em>
commits through their integration lifecycle. What I mean by this is how the
<em>integration request</em> follows the same logical change as it evolves. For
example, if you submit a commit then amend it, how does the system know that the
commit <em>evolved</em> from commit <code>X</code> to <code>X'</code>.</p>
<p>Pull requests don't track commits directly. Instead, a commit is part of a Git
branch and that branch is tracked as the entity the pull request is built
around. The review interface presents the <em>merge diff</em> front and center.
It is possible to view individual commits. But as far as I know, none of
these tools have smarts to explicitly track or map commits across new
submissions. Instead, they simply assume that the commit order will be the
same. If commits are reordered or added or removed in the middle of an
existing series, the tool can get confused quite easily. (With GitHub, it
was once possible for a review comment left on a commit to disappear entirely.
The behavior has since been corrected and if GitHub doesn't know where to
print a comment from a previous commit, it renders it as part of the pull
request's timeline view.)</p>
<p>If all you are familiar with is pull requests, you may not realize there are
alternatives to commit tracking! In fact, the most common alternative (which
isn't <em>do nothing</em>) predates pull requests entirely and is still practiced by
various tools today.</p>
<p>The way that Gerrit, Phabricator, and Review Board work is the commit message
contains a unique token identifying the <em>integration request</em> for that commit.
e.g. a commit message for a Phabricator review will contain the line
<code>Differential Revision: https://phab.mercurial-scm.org/D7543</code>. Gerrit will
have something like <code>Change-Id: Id9bfca21f7697ebf85d6a6fa7bac7de4358d7a43</code>.</p>
<p>The way this annotation appears in the commit message differs by tool.
Gerrit's web UI advertises a shell one-liner to clone repositories which
not only performs a <code>git clone</code> but also uses <code>curl</code> to download a shell
script from the Gerrit server and install it as Git's <code>commit-msg</code> hook in the
newly-cloned repositories. This Git hook will ensure that any newly-created
commit has a <code>Change-ID: XXX</code> line containing a randomly generated, hopefully
unique identifier. Phabricator and Review Board leverage client-side tooling
to rewrite commit messages after submission to their respective tool so
the commit message contains the URL of the code review. One can debate
which approach is <em>better</em> - they each have advantages and drawbacks.
Fortunately, this debate is not germane to this post, so we won't cover it here.</p>
<p>What is important is how this metadata in commit messages is used.</p>
<p>The commit message metadata comes into play when a commit is being ingested
into an <em>integration request</em>. If a commit message lacks metadata or references
an entity that doesn't exist, the receiving system assumes it is new. If the
metadata matches an entity on file, the incoming commit is often automatically
matched up to an existing commit, even if its Git SHA is different!</p>
<p>This approach of inserting a tracking identifier into commit messages works
surprisingly well for tracking the evolution of commits! Even if you amend,
reorder, insert, or remove commits, the tool can often figure out what matches
up to previous submissions and reconcile state accordingly. Although support
for this varies by tool. Mercurial's extension for submitting to Phabricator
is smart enough to take the local commit DAG into account and change dependencies
of review units in Phabricator to reflect the new DAG <em>shape</em>, for example.</p>
<p><strong>The tracking of commits is another one of those areas where the simpler and
more modern features of pull requests often don't work as well as the
solutions that came before.</strong> Yes, inserting an identifier into commit messages
feels hacky and can be brittle at times (some tools don't implement commit
rewriting very well and this can lead to a poor user experience). But you
can't argue with the results: <strong>using explicit, stable identifiers to track
commits is far more robust than the heuristics that pull requests rely on</strong>.
The false negative/positive rate is so much lower. (I know this from first hand
experience because we attempted to implement commit tracking heuristics for
a code review tool at Mozilla before Phabricator was deployed and there were
a surprising number of corner cases we couldn't handle properly. And this was
using Mercurial's <em>obsolescence markers</em>, which gave us commit evolution data
generated directly by the version control tool! If that didn't work well enough,
it's hard to imagine an heuristic that would. We eventually gave up and used
stable identifiers in commit messages, which fixed most of the annoying
corner cases.)</p>
<p>The use of explicit commit tracking identifiers may not seem like it makes a
meaningful difference. But it's impact is profound.</p>
<p>The obvious benefit of tracking identifiers is that they allow rewriting commits
without <em>confusing</em> the <em>integration request</em> tool. <strong>This means that people
can perform advanced history rewriting with near impunity as to how it would
affect the <em>integration request</em>.</strong> I am a heavy history rewriter. I like
curating a series of individually high-quality commits that can each stand
in isolation. When I submit a series like this to a GitHub pull request and
receive feedback on something I need to change, when I enact those changes I have
to think <em>will my rewriting history here make re-review harder</em>? (I try to be
empathetic with the reviewer and make their life easier whenever possible. I
ask what I would appreciate someone doing if I were reviewing their change and
tend to do that.) With GitHub pull requests, if I reorder commits or add or remove
a commit in the middle of a series, I realize that this may make review comments
left on those commits hard to find since GitHub won't be able to sort out the
history rewriting. And this may mean those review comments get <em>lost</em> and are
ultimately not acted upon, leading to bugs or otherwise deficient changes. <strong>This
is a textbook example of tooling deficiencies dictating a sub-optimal workflow
and outcome: because pull requests don't track commits explicitly, I'm
forced to adopt a non-ideal workflow or sacrifice something like commit
quality in order to minimize risks that the review tool won't get confused.</strong>
In general, tools should not externalize these kinds of costs or trade-offs onto
users: they should <em>just work</em> and optimize for generally agreed-upon ideal
outcomes.</p>
<p><strong>Another benefit to tracking identifiers is that they enable per-commit review
to be viable.</strong> Once you can track the logical evolution of a single commit,
you can start to associate things like review comments with individual commits
with a high degree of confidence. With pull requests (as they are implemented
today), you can attempt to associate comments with commits. But because you are
unable to track commits across rewrites with an acceptably high degree of
success, rewritten commits often <em>fall through the cracks</em>, orphaning data
like review comments with them. Data loss is bad, so you need a place to
collect this orphaned data. The main pull request activity timeline facilitates
this function.</p>
<p>But once you can track commits reliably (and tools like Gerrit and Phabricator
prove this is possible), you don't have this severe problem of data loss and
therefore don't need to worry about finding a place to collect orphaned data!
You are then able to create per-commit review units, each as loosely coupled
with other commits and an overall series as you want to make it!</p>
<p>It is interesting to note the different approaches in different tools here.
it is doubly interesting to note behavior that is possible with the review
tool itself and what it does by default!</p>
<p>Let's examine Phabricator. Phabricator's review unit is the
<em>Differential revision</em>. (<em>Differential</em> is the name of the code review tool
in Phabricator, which is actually a suite of functionality - like GitLab,
but not nearly as feature complete.) A <em>Differential revision</em> represents a
single diff. <em>Differential revisions</em> can have parent-child relationships
with others. Multiple revisions associated like this form a conceptual
<em>stack</em> in Phabricator's terminology. Go to
<a href="https://phab.mercurial-scm.org/D4414">https://phab.mercurial-scm.org/D4414</a>
and search for <em>stack</em> to see it in action. (<em>Stack</em> is a bit misleading name
because the parent-child relationships actually form a DAG and Phabricator is
capable of rendering things like multiple children in its graphical view.)
Phabricator's official client side tool for
submitting to Phabricator - Arcanist or <code>arc</code> - has default behavior
of collapsing all Git commits into a single <em>Differential revision</em>.</p>
<p>Phabricator can preserve metadata from the individual commits (it can render
at least the commit messages in the web UI so you can see where the <em>Differential
revision</em> came from). In other words, by default Arcanist does <em>not</em> construct
multiple <em>Differential revisions</em> for each commit and therefore does not construct
parent-child relationships for them. So there is no <em>stack</em> to render here.
To be honest, I'm not sure if modern versions of Arcanist even support doing
this. I do know both Mercurial and Mozilla authored custom client side
tools for submitting to Phabricator to work around deficiencies like this in
Arcanist. Mozilla's may or may not be generally suitable for users outside
of Mozilla - I'm not sure.</p>
<p>Another interesting aspect of Phabricator is that there is no concept of an
over-arching series. Instead, each <em>Differential revision</em> stands in isolation.
They can form parent-child relationships and constitute a <em>stack</em>. But there
is no primary UI or APIs for <em>stacks</em> (the last I looked anyway). This may seem
radical. You may be asking questions like <em>how do I track the overall state
of a series</em> or <em>how do I convey information pertinent to the series as a whole</em>.
These are good questions. But without diving into them, the answer is that
as radical as it sounds to not have an overall tracking entity for a series of
<em>Differential revisions</em>, it does work. And having used this workflow with the
Mercurial Project for a few years, I can say I'm not missing the functionality
that much.</p>
<p>Gerrit is also worth examining. Like Phabricator, Gerrit uses an identifier
in commit messages to track the commit. But whereas Phabricator rewrites
commit messages at initially submission time to contain the URL that was
created as part of that submission, Gerrit peppers the commit message with
a unique identifier at commit creation time. The server then maintains a
mapping of commit identifier to review unit. Implementation details aside,
the end result is similar: individual commits can be tracked more easily.</p>
<p>What distinguishes Gerrit from Phabricator is that Gerrit does have a stronger
grouping around multiple commits. Gerrit will track when commits are submitted
together and will render both a <em>relation chain</em> and <em>submitted together</em> list
automatically. While it lacks the visual beauty of Phabricator's implementation,
it is effective and is shown in the UI by default, unlike Phabricator.</p>
<p>Another difference from Phabricator is that Gerrit uses per-commit review
by default. Whereas you need a non-official client for Phabricator to submit
a series of commits to constitute a linked chain, Gerrit does this by default.
And as far as I can tell, there's no way to tell Gerrit to squash your local
commits down to a single diff for review: if you want a single review to appear,
you must first squash commits locally then push the squashed commit. (More
on this topic later in the post.) </p>
<p><strong>A secondary benefit of per-commit review is that this model enables incremental
integration workflows, where some commits in a series or set can integrate before
others, without having to wait for the entire batch.</strong> Incremental integration
of commits can drastically speed up certain workflows, as commits can integrate
as soon as they are <em>ready</em> and not any longer. The benefits of this model can
be incredible. But actually deploying this workflow can be tricky. One problem
is that your version control tool may get confused when you rebase or merge
partially landed state. Another problem is it can increase the overall change
rate of the repository, which may strain systems from version control to CI
to deployment mechanisms. Another potential problem involves communicating
review sign-off from integration sign-off. Many tools/workflows conflate <em>I
sign off on this change</em> and <em>I sign off on landing this change</em>. While they
are effectively identical in many cases, there are some valid cases where you
want to track these distinctly. And adopting a workflow where commits can
integrate incrementally will expose these corner cases. So before you go down
this path, you want to be thinking about who integrates commits and when
they are integrated. (You should probably be thinking about this anyway because
it is important.)</p>
<h2>Designing a Better Integration Request</h2>
<p>Having described some problems with pull requests and alternate ways of going
about solving the general problem of <em>integration requests</em>, it is time to answer
the million dollar problem: designing a better <em>integration request</em>. (When you
factor in the time people spend in pull requests and the cost of bugs / low
quality changes that slip through due to design of existing tooling, improving
integration requests industry wide would be a <strong>lot</strong> more valuable than $1M.)</p>
<p>As a reminder, the pull request is fundamentally a nice UI and set of features
built around the common Git feature branch workflow. This property is preserved
from the earliest days of pull requests in 2007-2008 and has been copied by
vendors like Bitbucket and GitLab in the years since. In my mind, pull requests
should be ripe for overhaul.</p>
<h3>Replace Forks</h3>
<p><strong>The first change I would make to pull requests is to move away from <em>forks</em>
being a required part of the workflow.</strong> This may seem radical. But it isn't!</p>
<p>A <em>fork</em> on services like GitHub is a fully fledged project - just like the
canonical project it was forked from. It has its own issues, wiki, releases,
pull requests, etc. Now show of hands: how often do you use these features
on a fork? Me neither. <strong>In the overwhelming majority of cases, a <em>fork</em>
exists solely as a vehicle to initiate a pull request against the repository
it was forked from.</strong> It serves little to no additional meaningful
functionality. Now, I'm not saying <em>forks</em> don't serve a purpose - they
certainly do! <strong>But in the case of someone wanting to propose a change to
a repository, a <em>fork</em> is not strictly required and its existence is imposed
on us by the current implementation of pull requests.</strong></p>
<p>I said <em>impose</em> in the previous sentence because <em>forks</em> introduce overhead
and confusion. The existence of a <em>fork</em> may confuse someone as to where a
canonical project lives. <em>Forks</em> also add overhead in the version control
tool. Their existence forces the user to manage an additional Git remote
and branches. It forces people to remember to keep their branches in sync on
their fork. As if remembering to keep your local repository in sync wasn't
hard enough! And if pushing to a <em>fork</em>, you need to re-push data that was
already pushed to the canonical repository, even though that data already
exists on the server (just in a different view of the Git repository). (I
believe Git is working on wire protocol improvements to mitigate this.)</p>
<p><strong>When merely used as a vehicle to initiate <em>integration requests</em>, I do not
believe <em>forks</em> offer enough value to justify their existence.</strong> Should forks
exist: yes. Should people be forced to use them in order to contribute
changes, no. (Valid use cases for a <em>fork</em> would be to perform a community
splinter of a project and to create an independent entity for reasons such as
better guarantees of data availability and integrity.)</p>
<p><em>Forks</em> are essentially a veneer on top of a server-side <code>git clone</code>. And the
reason why a separate Git repository is used at all is probably because the
earliest versions of GitHub were just a pile of abstractions over <code>git</code>
commands. The service took off in popularity, people copied its features
almost verbatim, and nobody ever looked back and thought <em>why are we doing
things like this in the first place.</em></p>
<p>To answer what we would replace <em>forks</em> with, we have to go back to first
principles and ask <em>what are we trying to do.</em> And that is <em>propose a unit
a change against an existing project</em>. And for version control tools, all
you need to propose a change is a patch/commit. So to replace <em>forks</em>, we
<em>just</em> need an alternate mechanism to submit patches/commits to an existing
project.</p>
<p><strong>My preferred alternative to forks is to use <code>git push</code> directly to the
canonical repository.</strong> This could be implemented like Gerrit where you push
to a special ref. e.g. <code>git push origin HEAD:refs/for/master</code>. Or - and this is
my preferred solution - version control servers could grow more smarts about
how <em>pushes</em> work - possibly even changing what commands like <code>git push</code> do if
the server is operating in special modes.</p>
<p>One idea would be for the Git server to expose different refs <em>namespaces</em>
depending on the authenticated user. For example, I'm <code>indygreg</code> on GitHub.
If I wanted to propose a change to a project - let's say <code>python/cpython</code> -
I would <code>git clone git@github.com:python/cpython</code>. I would create a branch -
say <code>indygreg/proposed-change</code>. I would then
<code>git push origin indygreg/proposed-change</code> and because the branch prefix matches
my authenticated username, the server lets it through. I can then open a
pull request without a fork! (Using branch prefixes is less than ideal, but
it should be relatively easy to implement on the server. A better approach
would rely on remapping Git ref names. But this may require a bit more
configuration with current versions of Git than users are willing to stomach.
An even better solution would be for Git to grow some functionality to make
this easier. e.g. <code>git push --workspace origin proposed-change</code> would push
<code>proposed-change</code> to a <em>workspace</em> on the <code>origin</code> remote, which Git would
know how to translate to a proper remote ref update.)</p>
<p>Another idea would be for the version control server to invent a new concept
for exchanging commits - one based on <em>sets of commits</em> instead of DAG
synchronization. Essentially, instead of doing a complicated discovery
dance to synchronize commits with the underlying Git repository, the server
would ingest and expose representations of <em>sets of commits</em> stored next
to - but not within - the repository itself. This way you are not scaling the
repository DAG to infinite heads - which is a hard problem! A concrete
implementation of this might have the client run a <code>git push --workspace
origin proposed-change</code> to tell the remote server to store your
<code>proposed-change</code> branch in your personal <em>workspace</em> (sorry for reusing the term
from the previous paragraph). The Git server would receive your commits,
generate a standalone blob to hold them, save that blob to a key-value
store like S3, then update a mapping of which commits/branches are in
which blobs in a data store such as a relational database somewhere. This
would effectively segment the core project data from the more transient
branch data, keeping the core repository clean and pure. It allows the server
to lean on easier-to-scale data stores such as key-value blob stores and
relational databases instead of the version control tool. I know this idea
is feasible because Facebook implemented it for Mercurial. The <code>infinitepush</code>
extension essentially siphons Mercurial <em>bundles</em> (standalone files holding
commit data) off to a blob store when pushes come in over the wire. At
<code>hg pull</code> time, if a requested revision is not present in the repository, the
server asks the database-backed blob index if the revision exists anywhere.
If it does, the blob/bundle is fetched, dynamically overlayed onto the
repository in memory, and served to the client. While the <code>infinitepush</code>
extension in the official Mercurial project is somewhat lacking (through no
fault of Facebook's), the core idea is solid and I wish someone would spend
the time to flush out the design a bit more because it really could lead
to logically scaling repositories to <em>infinite</em> DAG heads without the
complexities of actually scaling scaling DAG algorithms, repository storage,
and version control tool algorithms to <em>infinite</em> heads. Getting back to the
subject of <em>integration requests</em>, one could imagine having a <em>target</em> for
<em>workspace pushes</em>. For example, <code>git push --workspace=review origin</code> would
push to the <code>review</code> workspace, which would automatically initiate a code
review.</p>
<p>Astute readers of this blog may find these ideas familiar. I proposed
<em>user namespaces</em> in my
<a href="High-level problems with Git and how to fix them">/blog/2017/12/11/high-level-problems-with-git-and-how-to-fix-them/</a>
post a few years ago. So read there for more on implications of doing
away with <em>forks</em>.</p>
<p>Could <em>forks</em> be done away with as a requirement to submit pull requests?
Yes! Gerrit's <code>git push origin HEAD:refs/for/master</code> mechanism proves it.
Is Gerrit's approach too much magic or confusing for normal users? I'm not
sure. Could Git grow features to make the user experience much better so
users don't need to be burdened with complexity or magic and could
simply run commands like <code>git submit --for review</code>? Definitely!</p>
<h3>Shift Focus From Branches to Individual Commits</h3>
<p><strong>My ideal <em>integration request</em> revolves around individual commits, not
branches.</strong> While the client may submit a branch to initiate or update
an <em>integration request</em>, the <em>integration request</em> is composed of a set
of loosely coupled commits, where parent-child relationships can exist to
express a dependency between commits. Each commit is evaluated
individually. Although someone may need to inspect multiple commits to
gain a full understanding of the proposed change. And some UI enabling
operations against a group of related commits (such as mass deleting
abandoned commits) may be warranted.</p>
<p>In this world, the branch would not matter. Instead, commits are king.
Because we would be abandoning the branch name as a tracker for the
<em>integration request</em>, we would need something to replace it, otherwise we
have no way of knowing how to update an existing <em>integration request</em>!
We should do what tools like Phabricator, Gerrit, and Review Board do and
add a persistent identifier to commits which survive history rewriting.
(Branch-based pull requests should do this anyway so history rewrites don't
confuse the review tool and e.g. cause comments to get orphaned - see
above.)</p>
<p><strong>It's worth noting that a commit-centric <em>integration request</em> model does
not imply that everyone is writing or reviewing series of smaller commits!</strong>
While titans of industry and I strongly encourage the authorship of smaller
commits, commit-centric <em>integration requests</em> don't intrinsically force you
to do so. This is because commit-centric <em>integration requests</em> aren't forcing
you to change your local workflow! If you are the type of person who doesn't
want to curate a ton of small, good-in-isolation commits (it does take a bit
more work after all), nobody would be forcing you to do so. Instead, if this
is your commit authorship pattern, the submission of the proposed change
could <em>squash</em> these commits together as part of the submission, <em>optionally</em>
rewriting your local history in the process. If you want to keep dozens of
<em>fixup commits</em> around in your local history, that's fine: just have the
tooling collapse them all together on submission. While I don't think those
<em>fixup commits</em> are that valuable and shouldn't be seen by reviewers, if
we wanted, we could have tools continue to submit them and make them visible
(like they are in e.g. GitHub pull requests today). But they wouldn't be the
focus of review (again like GitHub pull requests today). <strong>Making <em>integration
requests</em> commit-centric doesn't force people to adopt a different commit
authorship workflow. But it does enable projects that wish to adopt more
<em>mature</em> commit hygiene to do so.</strong> That being said, hows tools are
implemented can impose restrictions. But that's nothing about commit-centric
review that fundamentally prohibits the use of <em>fixup commits</em> in local
workflows.</p>
<p>While I should create a dedicated post espousing the virtues of commit-centric
workflows, I'll state my case through proxy by noting that some projects aren't
using modern pull requests precisely because commit-centric workflows are not
viable. When I was at Mozilla, one of the blockers to <em>moving to GitHub</em> was
the pull request review tooling wasn't compatible with our world view that
review units should be small. (This view is generally shared by Google, Facebook,
and some prominent open source projects, among others.) And for reasons
outlined earlier in this post, I think that as long as pull requests revolve
around branches / <em>merge diffs</em> and aren't robust in the face of history rewriting
(due to the lack of robust commit tracking), projects that insist on more
<em>refined</em> practices will continue to eschew pull requests. Again, a link between
review size and quality has been established. And better quality - along
with its long-term effect of lowering development costs due to fewer bugs -
can tip the scales in its favor, even against all the benefits you receive
when using a product like GitHub, GitLab, or Bitbucket.</p>
<h2>The Best of What's Around</h2>
<p>Aspects of a better <em>integration request</em> exist in tools today. Unfortunately,
many of these features are not present on pull requests as implemented by
GitHub, GitLab, Bitbucket, etc. So to improve the pull request, these products
will need to borrow ideas from other tools.</p>
<p><em>Integration requests</em> not built around Git branches (Gerrit, Phabricattor,
Review Board, etc) use identifiers in commit messages to track commits.
This helps tracking commits across changes. There are compelling advantages
to this model. Robust commit tracking is a requirement for commit-centric
workflows. And it would even improve the functionality of branch-based pull
requests. A well-designed <em>integration request</em> would have a robust commit
tracking mechanism.</p>
<p>Gerrit has the best-in-class experience for commit-centric workflows. It is
the only popular implementation of <em>integration requests</em> I'm aware of that
supports and caters to this workflow by default. In fact, I don't think you
can change this! (This behavior is user hostile in some cases since it forces
users to know how to rewrite commits, which is often perilous in Git land. It
would be nice if you could have Gerrit squash commits into the same review unit
automatically on the server. But I understand the unwillingness to implement
this feature because this has its own set of challenges around commit tracking,
which I won't bore you with.) Gerrit also shows groups of related commits
front and center when viewing a proposed change.</p>
<p>Phabricator is the only other tool I know of where one can achieve a reasonable
commit-centric workflow without the pitfalls of orphaned comments, context
overload, etc mentioned earlier in this post. But this requires non-standard
submission tooling and commit series aren't featured prominently in the web UI.
So Phabricator's implementation is not as solid as Gerrit's.</p>
<p>Another Gerrit feature worth lauding is the submission mechanism. You simply
<code>git push</code> to a special ref. That's it. There's no fork to create. No need to
create a Git branch. No need to create a separate pull request after the push.
Gerrit just takes the commits you pushed and turns them into a request for
review. And it doesn't require any additional client-side tooling!</p>
<p>Using a single common <code>git</code> command to submit and update an <em>integration
request</em> is simpler and arguably more intuitive than other tools. Is Gerrit's
submission perfect? No. The <code>git push origin HEAD:refs/for/master</code> syntax is
not intuitive. And overloading submission options by effectively encoding URL
parameters on the ref name is a gross - albeit effective - hack. But users will
likely quickly learn the one-liner's or create more intuitive aliases.</p>
<p>The elegance of using just a <code>git push</code> to initiate an <em>integration request</em>
puts Gerrit in a league of its own. I would be ecstatic if the GitHubs of the
world reduced the complexity of submitting pull requests to simply <em>clone the
canonical repository, create some commits, and run a <code>git</code> command. The future
of submitting </em>integration requests* hopefully looks more like Gerrit than
other alternatives.</p>
<h2>What Needs Built</h2>
<p>Some aspects of the better <em>integration request</em> don't yet exist or need
considerable work before I consider them viable.</p>
<p>For tools which leverage the native version control tool for submission
(e.g. via <code>git push</code>), there needs to be some work to support submission
via a more generic, HTTP endpoint. I'm fine with leveraging <code>git push</code> as a
submission mechanism because it makes the end-user experience so
turnkey. But making it the only submission mechanism is a bit unfortunate.
There is some support for this: I believe you can cobble together a pull
request from scratch via GitHub's APIs, for example. But it isn't as simple
as <em>submit a patch to an endpoint</em>, which it arguably should be. Even
Gerrit's
<a href="https://gerrit-review.googlesource.com/Documentation/rest-api.html">robust HTTP API</a>,
does not seem to allow creating new commits/diffs via that API. Anyway, this
limitation not only excludes non-Git tools from using these tools, but also
limits other tooling from submitting without using Git. For example, you may
want to write a bot that proposes automated changes and it is much easier
to produce a diff than to use <code>git</code> since the former does not require a
filesystem (this matters in <em>serverless</em> environments for example).</p>
<p>A larger issue with many implementations is the over-reliance on Git for server
storage. This is most pronounced in Gerrit, where not only are your <code>git push</code>es
stored in a Git repository on the Gerrit server, but every code review comment
and reply is stored in Git as well! Git <em>is</em> a generic key-value store and you
can store any data you want in it if you shoehorn it properly. And it is cool
that all your Gerrit data can be replicated via <code>git clone</code> - this pretty much
eliminates the <em>we took a decentralized tool and centralized it via GitHub</em>
series of arguments. But if you apply this <em>store everything in Git</em> approach
at scale, it means you will be running a Git server at scale. And not just any
Git server - a write load heavy Git server! And if you have thousands of
developers possibly all working out of the same repository, then you are looking
at potentially millions of new Git refs per year. While the Git, Gerrit, and
JGit people have done some fantastic work making these tools scale, I'd feel
much better if we eschewed the <em>make Git scale to infinite pushes and refs</em>
problem and used a more scalable approach, like an HTTP ingestion endpoint
which writes data to key-value stores or relational databases. In order words,
use of a version control tool for servicing <em>integration requests</em> at scale
is a self-imposed footgun and could be avoided.</p>
<h2>Conclusion</h2>
<p>Congratulations on making it through my brain dump! As massive as the wall
of text is, there are still plenty of topics I could have covered but didn't.
This includes the more specific topic of code review and the various features
that entails. I also largely ignored some general topics like the value that
an <em>integration request</em> can serve on the overall development lifecycle:
<em>integration requests</em> are more than just code review - they serve as a nexus
to track the evolution of a change throughout time.</p>
<p>Hopefully this post gave you some idea at some of the structural issues at
play with the integration of pull requests and <em>integration requests</em>. And
if you are someone in a position to design or implement a better
<em>integration request</em> or tooling around them (including in version control
tools themselves), hopefully it gave you some good ideas or where to go next.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[High-level Problems with Git and How to Fix Them]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2017/12/11/high-level-problems-with-git-and-how-to-fix-them" />
    <id>http://gregoryszorc.com/blog/2017/12/11/high-level-problems-with-git-and-how-to-fix-them</id>
    <updated>2017-12-11T10:30:00Z</updated>
    <published>2017-12-11T10:30:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Git" />
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[High-level Problems with Git and How to Fix Them]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2017/12/11/high-level-problems-with-git-and-how-to-fix-them"><![CDATA[<p>I have a... complicated relationship with Git.</p>
<p>When Git first came onto the scene in the mid 2000's, I was initially
skeptical because of its horrible user interface. But once I learned
it, I appreciated its speed and features - especially the ease at which
you could create feature branches, merge, and even create commits
offline (which was a big deal in the era when Subversion was the
dominant version control tool in open source and you needed to speak with
a server in order to commit code). When I started using Git day-to-day,
it was such an obvious improvement over what I was using before (mainly
Subversion and even CVS).</p>
<p>When I started working for Mozilla in 2011, I was exposed to the
Mercurial version control, which then - and still today - hosts the
canonical repository for Firefox. I didn't like Mercurial initially.
Actually, I despised it. I thought it was slow and its features lacking.
And I frequently encountered repository corruption.</p>
<p>My first experience learning the <em>internals</em> of both Git and Mercurial
came when I found myself hacking on
<a href="http://hg-git.github.io/]">hg-git</a> - a tool that allows you to convert
Git and Mercurial repositories to/from each other. I was hacking on hg-git
so I could improve the performance of converting Mercurial repositories
to Git repositories. And I was doing that because I wanted to use Git -
not Mercurial - to hack on Firefox. I was trying to enable an unofficial
Git mirror of the Firefox repository to synchronize faster so it would
be more usable. The ulterior motive was to demonstrate that Git is a
superior version control tool and that Firefox should switch its canonical
version control tool from Mercurial to Git.</p>
<p>In what is a textbook definition of <em>irony</em>, what happened instead was
I actually learned how Mercurial worked, interacted with the Mercurial
Community, realized that Mozilla's documentation and developer practices
were... lacking, and that Mercurial was actually a much, much more
pleasant tool to use than Git. It's an old post, but I
<a href="/blog/2013/05/12/thoughts-on-mercurial-(and-git)/">summarized my conversion</a>
four and a half years ago. This started a chain of events that somehow
resulted in me contributing a ton of patches to Mercurial, taking
stewardship of <em>hg.mozilla.org</em>, and becoming a member of the Mercurial
Steering Committee - the governance group for the Mercurial Project.</p>
<p>I've been an advocate of Mercurial over the years. Some would probably say
I'm a Mercurial fanboy. I reject that characterization because <em>fanboy</em> has
connotations that imply I'm ignorant of realities. I'm well aware of
Mercurial's faults and weaknesses. I'm well aware of Mercurial's relative
lack of popularity, I'm well aware that this lack of popularity almost
certainly turns away contributors to Firefox and other Mozilla projects
because people don't want to have to learn a new tool. I'm well aware that
there are changes underway to enable Git to scale to <em>very large
repositories</em> and that these changes could threaten Mercurial's scalability
advantages over Git, making choices to use Mercurial even harder to defend.
(As an aside, the party most responsible for pushing Git to adopt
architectural changes to enable it to scale these days is Microsoft.
Could anyone have foreseen that?!)</p>
<p>I've achieved mastery in both Git and Mercurial. I know their internals
and their command line interfaces extremely well. I understand the
architecture and principles upon which both are built. I'm also exposed
to some very experienced and knowledgeable people in the Mercurial
Community. People who have been around version control for much, much
longer than me and have knowledge of random version control tools you've
probably never heard of. This knowledge and exposure allows me to make
connections and see opportunities for version control that quite frankly
most do not. </p>
<p>In this post, I'll be talking about some high-level, high-impact problems
with Git and possible solutions for them. My primary goal of this post is
to foster positive change in Git and the services around it. While I
personally prefer Mercurial, improving Git is good for everyone. Put
another way, I want my knowledge and perspective from being part of
a version control community to be put to good wherever it can.</p>
<p>Speaking of Mercurial, as I said, I'm a heavy contributor and am somewhat
influential in the Mercurial Community. I want to be clear that my opinions
in this post are my own and I'm not speaking on behalf of the Mercurial
Project or the larger Mercurial Community. I also don't intend to claim
that Mercurial is <em>holier-than-thou</em>. Mercurial has tons of user interface
failings and deficiencies. And I'll even admit to being frustrated that some
systemic failings in Mercurial have gone unaddressed for as long as they
have. But that's for another post. This post is about Git. Let's get started.</p>
<h2>The Staging Area</h2>
<p>The staging area is a feature that should not be enabled in the default
Git configuration.</p>
<p>Most people see version control as an obstacle standing in the way of
accomplishing some other task. They just want to save their progress
towards some goal. In other words, they want version control to be a
<em>save file</em> feature in their workflow.</p>
<p>Unfortunately, modern version control tools don't work that way. For
starters, they require people to specify a <em>commit message</em> every time
they save. This in of itself can be annoying. But we generally accept
that as the price you pay for version control: that <em>commit message</em> has
value to others (or even your future self). So you must record it.</p>
<p>Most people want the barrier to saving changes to be effortless. A commit
message is already too annoying for many users! The Git staging area
establishes a <em>higher</em> barrier to saving. Instead of just saving your
changes, you must first <em>stage</em> your changes to be saved.</p>
<p>If you requested <em>save</em> in your favorite GUI application, text editor,
etc and it popped open a <em>select the changes you would like to
save dialog</em>, you would rightly think <em>just save all my changes already,
dammit.</em> But this is exactly what Git does with its staging area! Git
is saying <em>I know all the changes you made: now tell me which changes
you'd like to save.</em> To the average user, this is infuriating because
it works in contrast to how the <em>save</em> feature works in almost every
other application.</p>
<p>There is a counterargument to be made here. You could say that the
editor/application/etc is complex - that it has multiple <em>contexts</em>
(files) - that each context is independent - and that the user should
have full control over which contexts (files) - and even changes within
those contexts - to save. I agree: this is a compelling feature. However,
it isn't an appropriate <em>default</em> feature. The ability to pick which
changes to save is a power-user feature. Most users just want to save all
the changes all the time. So that should be the default behavior. And
the Git staging area should be an opt-in feature.</p>
<p>If intrinsic workflow warts aren't enough, the Git staging area has a
horrible user interface. It is often referred to as the <em>cache</em>
<a href="https://stackoverflow.com/questions/6716355/why-staging-directory-is-also-called-index-git-index/6718135#6718135">for historical reasons</a>.
<em>Cache</em> of course means something to anyone who knows anything about
computers or programming. And Git's use of <em>cache</em> doesn't at all align
with that common definition. Yet the the terminology in Git persists.
You have to run commands like <code>git diff --cached</code> to examine the state
of the <em>staging area</em>. Huh?!</p>
<p>But Git also refers to the <em>staging area</em> as the <em>index</em>. And this
terminology also appears in Git commands! <code>git help commit</code> has numerous
references to the <em>index</em>. Let's see what <code>git help glossary</code> has to say::</p>
<pre><code>index
    A collection of files with stat information, whose contents are
    stored as objects. The index is a stored version of your working tree.
    Truth be told, it can also contain a second, and even a third
    version of a working tree, which are used when merging.

index entry
    The information regarding a particular file, stored in the index.
    An index entry can be unmerged, if a merge was started, but not
    yet finished (i.e. if the index contains multiple versions of that
    file).
</code></pre>
<p>In terms of end-user documentation, this is a train wreck. It tells the
lay user absolutely nothing about what the <em>index</em> actually is. Instead,
it casually throws out references to <em>stat information</em> (requires the user
know what the <code>stat()</code> function call and struct are) and <em>objects</em> (a Git
term for a piece of data stored by Git). It even undermines its own credibility
with that <em>truth be told</em> sentence. This definition is so bad that it
would probably improve user understanding if it were deleted!</p>
<p>Of course, <code>git help index</code> says <em>No manual entry for gitindex</em>. So
there is literally no hope for you to get a concise, understandable
definition of the <em>index</em>. Instead, it is one of those concepts that you
think you learn from interacting with it all the time. <em>Oh, when I
<code>git add</code> something it gets into this state where <code>git commit</code> will
actually save it.</em></p>
<p>And even if you know what the Git staging area/index/cached is, it can
still confound you. Do you know the interaction between uncommitted
changes in the staging area and working directory when you <code>git rebase</code>?
What about <code>git checkout</code>? What about the various <code>git reset</code> invocations?
I have a confession: I can't remember all the edge cases either. To play
it safe, I try to make sure all my outstanding changes are committed
before I run something like <code>git rebase</code> because I <em>know</em> that will be
safe.</p>
<p>The Git staging area doesn't have to be this complicated. A <em>re-branding</em>
away from <em>index</em> to <em>staging area</em> would go a long way. Adding an alias
from <code>git diff --staged</code> to <code>git diff --cached</code> and removing references
to the <em>cache</em> from common user commands would make a lot of sense and
reduce end-user confusion.</p>
<p>Of course, the Git staging area doesn't really need to exist at all!
The staging area is essentially a <em>soft commit</em>. It performs the
<em>save progress</em> role - the basic requirement of a version control tool.
And in some aspects it is actually a better <em>save progress</em> implementation
than a <em>commit</em> because it doesn't require you to type a commit message!
Because the <em>staging area</em> is a soft commit, all workflows using it can
be modeled as if it were a real commit and the <em>staging area</em> didn't
exist at all! For example, instead of <code>git add --interactive</code> +
<code>git commit</code>, you can run <code>git commit --interactive</code>. Or if you wish
to incrementally add new changes to an in-progress commit, you can
run <code>git commit --amend</code> or <code>git commit --amend --interactive</code> or
<code>git commit --amend --all</code>. If you actually understand the various modes
of <code>git reset</code>, you can use those to <em>uncommit</em>. Of course, the user
interface to performing these actions in Git today is a bit convoluted.
But if the <em>staging area</em> didn't exist, new high-level commands like
<code>git amend</code> and <code>git uncommit</code> could certainly be invented. </p>
<p>To the average user, the <em>staging area</em> is a complicated concept. I'm
a power user. I understand its purpose and how to harness its power. Yet
when I use Mercurial (which doesn't have a <em>staging area</em>), I don't miss
the <em>staging area</em> at all. Instead, I learn that all operations involving
the <em>staging area</em> can be modeled as other fundamental primitives (like
<em>commit amend</em>) that you are likely to encounter anyway. The <em>staging
area</em> therefore constitutes an unnecessary burden and cognitive load on
users. While powerful, its complexity and incurred confusion does not
justify its existence in the default Git configuration. The <em>staging
area</em> is a power-user feature and should be opt-in by default. </p>
<h2>Branches and Remotes Management is Complex and Time-Consuming</h2>
<p>When I first used Git (coming from CVS and Subversion), I thought
branches and remotes were incredible because they enabled new workflows
that allowed you to easily track multiple lines of work across many
repositories. And ~10 years later, I still believe the workflows they
enable are important. However, having amassed a broader perspective, I
also believe their implementation is poor and this unnecessarily confuses
many users and wastes the time of <em>all</em> users.</p>
<p>My initial <em>zen moment</em> with Git - the time when Git finally clicked for me -
was when I understood Git's object model: that Git is just a
content indexed key-value store consisting of a different object types
(blobs, trees, and commits) that have a particular relationship with
each other. <em>Refs</em> are symbolic names pointing to Git commit objects. And
Git <em>branches</em> - both local and remote - are just <em>refs</em> having a
well-defined naming convention (<code>refs/heads/&lt;name&gt;</code> for local branches and
<code>refs/remotes/&lt;remote&gt;/&lt;name&gt;</code> for remote branches). Even <em>tags</em> and
<em>notes</em> are defined via <em>refs</em>.</p>
<p><em>Refs</em> are a necessary primitive in Git because the Git storage model is
to throw all <em>objects</em> into a single, key-value namespace. Since the store
is content indexed and the key name is a cryptographic hash of the object's
content (which for all intents and purposes is random gibberish to
end-users), the Git store by itself is unable to locate objects. If all you
had was the key-value store and you wanted to <em>find all commits</em>, you would
need to walk every object in the store and read it to see if it is a commit
object. You'd then need to buffer metadata about those objects in memory so
you could reassemble them into say a DAG to facilitate looking at commit
history. This approach obviously doesn't scale. <em>Refs</em> short-circuit this
process by providing pointers to objects of importance. It may help to
think of the set of <em>refs</em> as an <em>index</em> into the Git store.  </p>
<p><em>Refs</em> also serve another role: as guards against garbage collection.
I won't go into details about loose objects and packfiles, but it's worth
noting that Git's key-value store also behaves in ways similar to
a generational garbage collector like you would find in programming languages
such as Java and Python. The important thing to know is that Git will
garbage collect (read: delete) objects that are unused. And the mechanism
it uses to determine which objects are unused is to iterate through <em>refs</em>
and walk all transitive references from that initial pointer. If there is
an object in the store that can't be traced back to a <em>ref</em>, it is
<em>unreachable</em> and can be deleted.</p>
<p><em>Reflogs</em> maintain the history of a value for a <em>ref</em>: for each <em>ref</em> they
contain a log of what <em>commit</em> it was pointing to, when that pointer
was established, who established it, etc. <em>Reflogs</em> serve two purposes:
facilitating <em>undoing</em> a previous action and holding a reference to <em>old</em>
data to prevent it from being garbage collected. The two use cases are
related: if you don't care about undo, you don't need the old reference
to prevent garbage collection.</p>
<p>This design of Git's store is actually quite sensible. It's not perfect
(nothing is). But it is a solid foundation to build a version control tool
(or even other data storage applications) on top of.</p>
<p>The title of this section has to do with sub-optimal branches and
remotes management. But I've hardly said anything about branches or remotes!
And this leads me to my main complaint about Git's branches and remotes:
that they are very thin veneer over <em>refs</em>. The properties of Git's
underlying key-value store unnecessarily bleed into user-facing concepts
(like branches and remotes) and therefore dictate sub-optimal practices.
This is what's referred to as a <em>leaky abstraction</em>.</p>
<p>I'll give some examples.</p>
<p>As I stated above, many users treat version control as a <em>save file</em>
step in their workflow. I believe that any step that interferes with users
saving their work is user hostile. This even includes writing a commit
message! I already argued that the <em>staging area</em> significantly interferes
with this critical task. Git <em>branches</em> do as well.</p>
<p>If we were designing a version control tool from scratch (or if you were
a new user to version control), you would probably think that a sane
feature/requirement would be to update to <em>any</em> revision and start making
changes. In Git speak, this would be something like
<code>git checkout b201e96f</code>, make some file changes, <code>git commit</code>. I think
that's a pretty basic workflow requirement for a version control tool.
And the workflow I suggested is pretty intuitive: choose the thing to
start working on, make some changes, then save those changes.</p>
<p>Let's see what happens when we actually do this:</p>
<pre><code>$ git checkout b201e96f
Note: checking out 'b201e96f'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b &lt;new-branch-name&gt;

HEAD is now at b201e96f94... Merge branch 'rs/config-write-section-fix' into maint

$ echo 'my change' &gt;&gt; README.md
$ git commit -a -m 'my change'
[detached HEAD aeb0c997ff] my change
 1 file changed, 1 insertion(+)

$ git push indygreg
fatal: You are not currently on a branch.
To push the history leading to the current (detached HEAD)
state now, use

    git push indygreg HEAD:&lt;name-of-remote-branch&gt;

$ git checkout master
Warning: you are leaving 1 commit behind, not connected to
any of your branches:

  aeb0c997ff my change

If you want to keep it by creating a new branch, this may be a good time
to do so with:

 git branch &lt;new-branch-name&gt; aeb0c997ff

Switched to branch 'master'
Your branch is up to date with 'origin/master'.
</code></pre>
<p>I know what all these messages mean because I've mastered Git. But if
you were a newcomer (or even a seasoned user), you might be very confused.
Just so we're on the same page, here is what's happening (along with
some commentary).</p>
<p>When I run <code>git checkout b201e96f</code>, Git is trying to tell me that I'm
potentially doing something that could result in the loss of my data. A
golden rule of version control tools is <em>don't lose the user's data</em>. When
I run <code>git checkout</code>, Git should be stating the risk for data loss very
clearly. But instead, the <em>If you want to create a new branch</em> sentence is
hiding this fact by instead phrasing things around <em>retaining commits you
create</em> rather than the possible loss of data. It's up to the user
to make the connection that <em>retaining commits you create</em> actually means
<em>don't eat my data</em>. Preventing data loss is critical and Git should not
mince words here!</p>
<p>The <code>git commit</code> seems to work like normal. However, since we're in a
<em>detached HEAD</em> state (a phrase that is likely gibberish to most users),
that commit isn't referred to by any <em>ref</em>, so it can be <em>lost</em> easily.
Git <em>should</em> be telling me that I just committed something it may not
be able to find in the future. But it doesn't. Again, Git isn't being
as protective of my data as it needs to be.</p>
<p>The failure in the <code>git push</code> command is essentially telling me I need
to give things a name in order to <em>push</em>. <em>Pushing</em> is effectively <em>remote
save</em>. And I'm going to apply my reasoning about version control tools
not interfering with <em>save</em> to <em>pushing</em> as well: Git is adding an
extra barrier to <em>remote save</em> by refusing to push commits without a
<em>branch</em> attached and by doing so is being user hostile.</p>
<p>Finally, we <code>git checkout master</code> to move to another commit. Here, Git
is actually doing something halfway reasonable. It is telling me I'm
leaving commits behind, which commits those are, and the command to
use to <em>keep</em> those commits. The warning is good but not great. I think
it needs to be stronger to reflect the risk around data loss if that
suggested Git commit isn't executed. (Of course, the <em>reflog</em> for <code>HEAD</code>
will ensure that data isn't immediately deleted. But users shouldn't
need to involve <em>reflogs</em> to not lose data that wasn't rewritten.)</p>
<p>The point I want to make is that Git doesn't allow you to just <em>update
and save</em>. Because its <em>dumb</em> store requires pointers to relevant commits
(<em>refs</em>) and because that requirement isn't abstracted away or paved over
by user-friendly features in the frontend, Git is effectively requiring
end-users to define names (<em>branches</em>) for all commits. If you fail to
define a name, it gets a lot harder to find your commits, exchange them,
and Git may delete your data. While it is technically possible to not
create branches, the version control tool is essentially unusable without
them.</p>
<p>When local branches are exchanged, they appear as <em>remote branches</em> to
others. Essentially, you give each instance of the repository a name
(the <em>remote</em>). And branches/refs fetched from a named <em>remote</em> appear
as a <em>ref</em> in the <em>ref namespace</em> for that <em>remote</em>. e.g.
<em>refs/remotes/origin</em> holds <em>refs</em> for the <em>origin</em> <em>remote</em>. (Git allows
you to not have to specify the <em>refs/remotes</em> part, so you can refer
to e.g. <em>refs/remotes/origin/master</em> as <em>origin/master</em>.)</p>
<p>Again, if you were designing a version control tool from scratch or you
were a new Git user, you'd probably think <em>remote refs</em> would make
good starting points for work. For example, if you know you should be
saving new work on top of the <em>master</em> branch, you might be inclined
to begin that work by running <code>git checkout origin/master</code>. But like
our specific-commit checkout above:</p>
<pre><code>$ git checkout origin/master
Note: checking out 'origin/master'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b &lt;new-branch-name&gt;

HEAD is now at 95ec6b1b33... RelNotes: the eighth batch
</code></pre>
<p>This is the same message we got for a direct checkout. But we did
supply a <em>ref</em>/<em>remote branch</em> name. What gives? Essentially, Git tries
to enforce that the <em>refs/remotes/</em> namespace is read-only and only
updated by operations that exchange data with a remote, namely <code>git fetch</code>,
<code>git pull</code>, and <code>git push</code>.</p>
<p>For this to work correctly, you need to create a new <em>local branch</em>
(which initially points to the commit that <code>refs/remotes/origin/master</code>
points to) and then switch/activate that <em>local branch</em>.</p>
<p>I could go on talking about all the subtle nuances of how Git branches
are managed. But I won't.</p>
<p>If you've used Git, you know you need to use branches. You may or may
not recognize just how frequently you have to type a branch name into
a <code>git</code> command. I guarantee that if you are familiar with version control
tools and workflows that aren't based on having to manage <em>refs</em> to
track data, you will find Git's forced usage of <em>refs</em> and <em>branches</em>
a bit absurd. I half jokingly refer to Git as <em>Game of Refs</em>. I say that
because coming from Mercurial (which doesn't require you to name things),
Git workflows feel to me like all I'm doing is typing the names of branches
and <em>refs</em> into <code>git</code> commands. I feel like I'm wasting my precious
time telling Git the names of things only because this is necessary to
placate the leaky abstraction of Git's storage layer which requires
references to relevant commits.</p>
<p>Git and version control doesn't have to be this way.</p>
<p>As I said, my Mercurial workflow doesn't rely on naming things. Unlike
Git, Mercurial's store has an explicit (not shared) storage location
for commits (<em>changesets</em> in Mercurial parlance). And this data structure
is ordered, meaning a changeset <em>later</em>  always occurs after its
parent/predecessor. This means that Mercurial can open a single
file/index to quickly find all <em>changesets</em>. Because Mercurial doesn't
need pointers to commits of relevance, names aren't required.</p>
<p>My <em>Zen of Mercurial</em> moment came when I realized you didn't have
to name things in Mercurial. Having used Git before Mercurial, I
was conditioned to always be naming things. This is the Git way
after all. And, truth be told, it is common to name things in Mercurial
as well. Mercurial's <em>named branches</em> were the way to do <em>feature
branches</em> in Mercurial for years. Some used the <em>MQ</em> extension (essentially
a port of <a href="https://en.wikipedia.org/wiki/Quilt_(software)">quilt</a>), which
also requires naming individual patches. Git users coming to Mercurial
were missing Git branches and Mercurial's <em>bookmarks</em> were a poor
<em>port</em> of Git branches.</p>
<p>But recently, more and more Mercurial users have been coming to the
realization that names aren't really necessary. If the tool doesn't
actually require naming things, why force users to name things? As long
as users can find the commits they need to find, do you actually need
names?</p>
<p>As a demonstration, my Mercurial workflow leans heavily on the <code>hg show work</code>
and <code>hg show stack</code> commands. You will need to enable the <em>show</em> extension
by putting the following in your hgrc config file to use them:</p>
<pre><code>[extensions]
show =
</code></pre>
<p>Running <code>hg show work</code> (I have also set the config
<code>commands.show.aliasprefix=s</code>to enable me to type <code>hg swork</code>) finds all
in-progress changesets and other likely-relevant changesets (those
with names and DAG heads). It prints a concise DAG of those changesets:</p>
<p><img alt="hg show work output" src="/images/hg-show-work.png" /></p>
<p>And <code>hg show stack</code> shows just the current line of work and its
relationship to other important heads:</p>
<p><img alt="hg show stack output" src="/images/hg-show-stack.png" /></p>
<p>Aside from the <code>@</code> bookmark/name set on that top-most changeset, there are
no names! (That <code>@</code> comes from the remote repository, which has set that name.)</p>
<p>Outside of code archeology workflows, <code>hg show work</code> shows the changesets I
care about 95% of the time. With all I care about (my in-progress work and
possible rebase targets) rendered concisely, I don't have to name things
because I can just find whatever I'm looking for by running <code>hg show work</code>!
Yes, you need to run <code>hg show work</code>, visually scan for what you are looking
for, and copy a (random) hash fragment into a number of commands. This
sounds like a lot of work. But I believe it is far less work than naming
things. Only when you practice this workflow do you realize just how much
time you actually spend finding and then typing names in to <code>hg</code> and -
especailly - <code>git</code> commands! The ability to just <code>hg update</code> to a changeset
and commit without having to name things is just so liberating. It feels
like my version control tool is putting up fewer barriers and letting me
work quickly.</p>
<p>Another benefit of <code>hg show work</code> and <code>hg show stack</code> are that they present
a concise DAG visualization to users. This helps educate users about the
underlying <em>shape</em> of repository data. When you see connected nodes on a
graph and how they change over time, it makes it a lot easier to understand
concepts like <em>merge</em> and <em>rebase</em>. </p>
<p>This <em>nameless</em> workflow may sound radical. But that's because we're all
conditioned to naming things. I initially thought it was crazy as well. But
once you have a mechanism that gives you rapid access to data you care
about (<code>hg show work</code> in Mercurial's case), names become very optional. Now,
a pure <em>nameless</em> workflow isn't without its limitations. You want names
to identify the main <em>targets</em> for work (e.g. the <em>master</em> branch). And when
you exchange work with others, names are easier to work with, especially
since names survive rewriting. But in my experience, most of my commits
are only exchanged with me (synchronizing my in-progress commits across
devices) and with code review tools (which don't really need names and
can operate against raw commits). My most frequent use of names comes
when I'm in <em>repository maintainer mode</em> and I need to ensure commits
have names for others to reference.</p>
<p>Could Git support <em>nameless</em> workflows? In theory it can.</p>
<p>Git needs <em>refs</em> to find relevant commits in its store. And the wire
protocol uses <em>refs</em> to exchange data. So <em>refs</em> have to exist for Git
to function (assuming Git doesn't radically change its storage and
exchange mechanisms to mitigate the need for <em>refs</em>, but that would be
a massive change and I don't see this happening).</p>
<p>While there is a fundamental requirement for <em>refs</em> to exist, this
doesn't necessarily mean that user-facing names must exist. The reason
that we need <em>branches</em> today is because <em>branches</em> are little more than
a <em>ref</em> with special behavior. It is theoretically possible to invent a
mechanism that transparently maps <em>nameless</em> commits onto <em>refs</em>. For
example, you could create a <em>refs/nameless/</em> namespace that was
automatically populated with DAG heads that didn't have names attached.
And Git could exchange these <em>refs</em> just like it can <em>branches</em> today.
It would be a lot of work to think through all the implications and to
design and implement support for <em>nameless</em> development in Git. But I
think it is possible.</p>
<p>I encourage the Git community to investigate supporting <em>nameless</em> workflows.
Having adopted this workflow in Mercurial, Git's workflow around naming
branches feels heavyweight and restrictive to me. Put another way, <em>nameless</em>
commits are actually lighter-weight branches than Git branches! To the
common user who just wants version control to be a <em>save</em> feature,
requiring names establishes a barrier towards that goal. So removing the
naming requirement would make Git simpler and more approachable to new
users.</p>
<h2>Forks aren't the Model You are Looking For</h2>
<p>This section is more about hosted Git services (like GitHub, Bitbucket, and
GitLab) than Git itself. But since hosted Git services are synonymous
with <em>Git</em> and interaction with a hosted Git services is a regular
part of a common Git user's workflow, I feel like I need to cover it.
(For what it's worth, my experience at Mozilla tells me that a large
percentage of people who say <em>I prefer Git</em> or <em>we should use Git</em>
actually mean <em>I like GitHub</em>. Git and GitHub/Bitbucket/GitLab are
effectively the same thing in the minds of many and anyone finding
themselves discussing version control needs to keep this in mind because
<em>Git</em> is more than just the command line tool: it is an ecosystem.)</p>
<p>I'll come right out and say it: I think <em>forks</em> are a relatively poor
model for collaborating. They are light years better than what
existed before. But they are still so far from the turn-key experience
that should be possible. The <em>fork</em> hasn't really changed much since
the current implementation of it was made popular by GitHub many years
ago. And I view this as a general failure of hosted services to
innovate.</p>
<p>So we have a shared understanding, a <em>fork</em> (as implemented on GitHub,
Bitbucket, GitLab, etc) is essentially a complete copy of a repository
(a <code>git clone</code> if using Git) and a fresh workspace for additional
value-added services the hosting provider offers (pull requests, issues,
wikis, project tracking, release tracking, etc). If you open the main
web page for a <em>fork</em> on these services, it looks just like the main
project's. You know it is a fork because there are cosmetics somewhere
(typically next to the project/repository name) saying <em>forked from</em>.</p>
<p>Before service providers adopted the <em>fork</em> terminology, <em>fork</em> was
used in open source to refer to a splintering of a project. If
someone or a group of people didn't like the direction a project was
taking, wanted to take over ownership of a project because of
stagnation, etc, they would <em>fork it</em>. The <em>fork</em> was based on the
original (and there may even be active collaboration between the
fork and original), but the intent of the <em>fork</em> was to create
distance between the original project and its new incantation. A
new entity that was sufficiently independent of the original.</p>
<p><em>Forks</em> on service providers mostly retain this <em>old school</em> <em>fork</em>
model. The <em>fork</em> gets a new copy of issues, wikis, etc. And anyone
who <em>forks</em> establishes what looks like an independent incantation
of a project. It's worth noting that the execution varies by service
provider. For example, GitHub won't enable <em>Issues</em> for a fork by
default, thereby encouraging people to file issues against the
<em>upstream</em> project it was forked from. (This is good default behavior.)</p>
<p>And I know why service providers (initially) implemented things this
way: it was easy. If you are building a product, it's simpler to just
say <em>a user's version of this project is a <code>git clone</code> and they get
a fresh database</em>. On a technical level, this meets the traditional
definition of <em>fork</em>. And rather than introduce a new term into the
vernacular, they just re-purposed <em>fork</em> (albeit with <em>softer</em>
connotations, since the traditional <em>fork</em> commonly implied there
was some form of strife precipitating a <em>fork</em>).</p>
<p>To help differentiate flavors of <em>forks</em>, I'm going to define the
terms <em>soft fork</em> and <em>hard fork</em>. A <em>soft fork</em> is a <em>fork</em> that
exists for purposes of collaboration. The differentiating feature
between a <em>soft fork</em> and <em>hard fork</em> is whether the <em>fork</em> is
intended to be used as its own project. If it is, it is a
<em>hard fork</em>. If not - if all changes are intended to be <em>merged</em>
into the <em>upstream</em> project and be consumed from there - it is a
<em>soft fork</em>.</p>
<p>I don't have concrete numbers, but I'm willing to wager that the vast
majority of <em>forks</em> on Git service providers which have changes are
<em>soft forks</em> rather than <em>hard forks</em>. In other words, these <em>forks</em>
exist purely as a conduit to collaborate with the canonical/upstream
project (or to facilitate a short-lived one-off change).</p>
<p>The current implementation of <em>fork</em> - which borrows a lot from its
predecessor of the same name - is a good - but not great - way to
facilitate collaboration. It isn't great because it technically
resembles what you'd expect to see for <em>hard fork</em> use cases even
though it is used predominantly with <em>soft forks</em>. This mismatch
creates problems.</p>
<p>If you were to take a step back and invent your own version control
hosted service and weren't tainted by exposure to existing services
and were willing to think a bit beyond making it a glorified frontend
for the <code>git</code> command line interface, you might realize that the problem
you are solving - the product you are selling - is collaboration as
a service, not a Git hosting service. And if your product is
collaboration, then implementing your collaboration model around the
<em>hard fork</em> model with strong barriers between the original project and
its <em>forks</em> is counterproductive and undermines your own product.
But this is how GitHub, Bitbucket, GitLab, and others have implemented
their product!</p>
<p>To improve collaboration on version control hosted services, the concept
of a <em>fork</em> needs to significantly curtailed. Replacing it should be
a UI and workflow that revolves around the central, canonical repository.</p>
<p>You shouldn't need to create your own <em>clone</em> or <em>fork</em> of a repository
in order to contribute. Instead, you should be able to clone the
canonical repository. When you create commits, those commits should
be stored and/or more tightly affiliated with the original project - not
inside a <em>fork</em>.</p>
<p>One potential implementation is doable today. I'm going to call it
<em>workspaces</em>. Here's how it would work.</p>
<p>There would exist a namespace for <em>refs</em> that can be controlled by
the user. For example, on GitHub (where my username is <em>indygreg</em>),
if I wanted to contribute to some random project, I would <code>git push</code>
my refs somewhere under <code>refs/users/indygreg/</code> directly to that
project's. No <em>forking</em> necessary. If I wanted to contribute to a
project, I would just clone its repo then push to my <em>workspace</em> under
it. You could do this today by configuring your Git <em>refspec</em> properly.
For pushes, it would look something like
<code>refs/heads/*:refs/users/indygreg/*</code> (that tells Git to map local <em>refs</em>
under <code>refs/heads/</code> to <code>refs/users/indygreg/</code> on that <em>remote</em> repository).
If this became a popular feature, presumably the Git wire protocol could
be taught to advertise this feature such that Git clients automatically
configured themselves to push to user-specific <em>workspaces</em> attached to
the original repository.</p>
<p>There are several advantages to such a <em>workspace</em> model. Many of them
revolve around eliminating <em>forks</em>.</p>
<p>At initial contribution time, no server-side <em>fork</em> is necessary in order
to contribute. You would be able to <em>clone and contribute</em> without waiting
for or configuring a <em>fork</em>. Or if you can create commits from the web
interface, the clone wouldn't even be necessary! Lowering the barrier to
contribution is a good thing, especially if collaboration is the product
you are selling.</p>
<p>In the web UI, <em>workspaces</em> would also revolve around the source project
and not be off in their own world like <em>forks</em> are today. People could
more easily see what others are up to. And fetching their work would
require typing in their username as opposed to configuring a whole new
remote. This would bring communities closer and hopefully lead to better
collaboration.</p>
<p>Not requiring <em>forks</em> also eliminates the need to synchronize your <em>fork</em>
with the upstream repository. I don't know about you, but one of the things
that bothers me about the <em>Game of Refs</em> that Git imposes is that I have
to keep my <em>refs</em> in sync with the upstream <em>refs</em>. When I fetch from
<em>origin</em> and pull down a new <em>master</em> branch, I need to <code>git merge</code>
that branch into my local <em>master</em> branch. Then I need to push that new
<em>master</em> branch to my fork. This is quite tedious. And it is easy to merge
the wrong branches and get your <em>branch</em> state out of whack. There are
better ways to map remote <em>refs</em> into your local names to make this far
less confusing.</p>
<p>Another win here is not having to push and store data multiple times.
When working on a <em>fork</em> (which is a separate repository), after you
<code>git fetch</code> changes from upstream, you need to eventually <code>git push</code> those
into your <em>fork</em>. If you've ever worked on a large repository and didn't
have a super fast Internet connection, you may have been stymied by
having to <code>git push</code> large amounts of data to your <em>fork</em>. This is quite
annoying, especially for people with slow Internet connections. Wouldn't
it be nice if that <code>git push</code> only pushed the data that was truly new and
didn't already exist somewhere else on the server? A <em>workspace</em> model
where development all occurs in the original repository would fix this.
As a bonus, it would make the storage problem on servers easier because
you would eliminate thousands of forks and you probably wouldn't have to
care as much about data duplication across repos/clones because the
version control tool solves a lot of this problem for you, courtesy of
having all data live alongside or in the original repository instead of
in a <em>fork</em>.</p>
<p>Another win from <em>workspace</em>-centric development would be the potential to
do more user-friendly things after <em>pull/merge requests</em> are incorporated
in the official project. For example, the <em>ref</em> in your workspace could
be deleted automatically. This would ease the burden on users to clean up
after their submissions are accepted. Again, instead of mashing keys to
play the <em>Game of Refs</em>, this would all be taken care of for you
automatically. (Yes, I know there are scripts and shell aliases to
make this more turn-key. But user-friendly behavior shouldn't have to
be opt-in: it should be the default.)</p>
<p>But <em>workspaces</em> aren't all rainbows and unicorns. There are access
control concerns. You probably don't want users able to mutate the
<em>workspaces</em> of other users. Or do you? You can make a compelling
case that project <em>administrators</em> should have that ability. And what if
someone pushes bad or illegal content to a workspace and you receive
a cease and desist? Can you take down just the offending workspace while
complying with the order? And what happens if the original project is
deleted? Do all its workspaces die with it? These are not trivial
concerns. But they don't feel impossible to tackle either.</p>
<p><em>Workspaces</em> are only one potential alternative to <em>forks</em>. And I can
come up with multiple implementations of the <em>workspace</em> concept. Although
many of them are constrained by current features in the Git wire protocol.
But Git is (finally) getting a more extensible wire protocol, so hopefully
this will enable <em>nice things</em>.</p>
<p>I challenge Git service providers like GitHub, Bitbucket, and GitLab to
think outside the box and implement something better than how <em>forks</em>
are implemented today. It will be a large shift. But I think users will
appreciate it in the long run.</p>
<h2>Conclusion</h2>
<p>Git is an ubiquitous version control tool. But it is
<a href="http://stevelosh.com/blog/2013/04/git-koans/">frequently lampooned</a> for
its <a href="https://stevebennett.me/2012/02/24/10-things-i-hate-about-git/">poor usability</a>
and <a href="https://git-man-page-generator.lokaltog.net/">documentation</a>.
We even have
<a href="https://spderosso.github.io/onward13.pdf">research</a>
<a href="https://spderosso.github.io/oopsla16.pdf">papers</a> telling us which parts
are bad. Nobody I know has had a pleasant initial experience with Git.
And it is clear that few people actually understand Git: most just know
the command incantations they need to know to accomplish a small set of
common activities. (If you are such a person, there is nothing to be
ashamed about: Git is a <em>hard</em> tool.)</p>
<p>Popular Git-based hosting and collaboration services (such as GitHub,
Bitbucket, and GitLab) exist. While they've made strides to make it
easier to commit data to a Git repository (I purposefully avoid saying
<em>use Git</em> because the most usable tools seem to avoid the <code>git</code> command
line interface as much as possible), they are often a thin veneer over
Git itself (see <em>forks</em>). And Git is a thin veneer over a content
indexed key-value store (see forced usage of bookmarks).</p>
<p>As an industry, we should be concerned about the lousy usability of Git
and the tools and services that surround it. Some may say that Git -
with its near monopoly over version control mindset - is a success. I
have a different view: I think it is a failure that a tool with a user
experience this bad has achieved the success it has.</p>
<p>The cost to Git's poor usability can be measured in tens if not hundreds
of millions of dollars in time people have wasted because they couldn't
figure out how to use Git. Git should be viewed as a source of
embarrassment, not a success story.</p>
<p>What's really concerning is that the usability problems of Git have been
known for years. Yet it is as popular as ever and there have been few
substantial usability improvements. We do have some
<a href="http://gitless.com/">alternative frontends</a> floating around. But these
haven't caught on.</p>
<p>I'm at a loss to understand how an open source tool as popular as Git
has remained so mediocre for so long. The source code is out there.
Anybody can submit a patch to fix it. Why is it that so many people get
tripped up by the same poor usability issues years after Git became
the common version control tool? It certainly appears that as an
industry we have been unable or unwilling to address systemic deficiencies
in a critical tool. Why this is, I'm not sure.</p>
<p>Despite my pessimism about Git's usability and its poor track record of
being attentive to the needs of people who aren't power users, I'm
optimistic that the future will be brighter. While the ~7000 words in this
post pale in comparison to the aggregate word count that has been
written about Git, hopefully this post strikes a nerve and causes
positive change. Just because one generation has toiled with the
usability problems of Git doesn't mean the next generation has to
suffer through the same. Git can be improved and I encourage that change
to happen. The three issues above and their possible solutions would
be a good place to start.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Notes from Git Merge 2015]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2015/05/12/notes-from-git-merge-2015" />
    <id>http://gregoryszorc.com/blog/2015/05/12/notes-from-git-merge-2015</id>
    <updated>2015-05-12T15:40:00Z</updated>
    <published>2015-05-12T15:40:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Git" />
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Notes from Git Merge 2015]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2015/05/12/notes-from-git-merge-2015"><![CDATA[<p><a href="http://git-merge.com/">Git Merge 2015</a> was a Git user conference held
in Paris on April 8 and 9, 2015.</p>
<p>I'm kind of a version control geek. I'm also responsible for a large
part of Mozilla's version control hosting. So, when the videos were
made public, you can bet I took interest.</p>
<p>This post contains my notes from a few of the Git Merge talks. I try
to separate content/facts from my opinions by isolating my opinions
(within parenthesis).</p>
<h2>Git at Google</h2>
<p><a href="http://git-merge.com/videos/git-at-google-dave-borowitz.html">Git at Google: Making Big Projects (and everyone else) Happy</a>
is from a Googler (Dave Borowitz) who works on JGit for the Git
infrastructure team at Google.</p>
<p>"Everybody in this room is going to feel some kind of pain working with
Git at scale at some time in their career."</p>
<p>First Git usage at Google in 2008 for Android. 2011 googlesource.com
launches.</p>
<p>24,000 total Git repos at Google. 77.1M requests/day. 30-40 TB/day. 2-3
Gbps.</p>
<p>Largest repo is 210GB (not public it appears).</p>
<p>800 repos in AOSP. Google maintains internal fork of all Android repos
(so they can throw stuff over the wall). Fresh AOSP tree is 17 GiB. Lots
of contracts dictating access.</p>
<p>Chrome repos include Chromium, Blink, Chromium OS. Performed giant
Subversion migration. Developers of Chrome very set in their ways. Had
many workflows integrated with Subversion web interface. Subversion
blame was fast, Git blame slow. Built caching backend for Git blame to
make developers happy.</p>
<p>Chromium 2.9 GiB, 3.6M objects, 390k commits. Blink 5.3 GiB, 3.1M
objects, 177k commits. They merged them into a monorepo. Mention of
Facebook's monorepo talk and Mercurial scaling efforts for a repo larger
then Chromium/Blink monorepo. Benefits to developers for doing atomic
refactorings, etc.</p>
<p>"Being big is hard."</p>
<p>AOSP: 1 Gbps -&gt; 2 minutes for 17 GiB. 20 Mbps -&gt; 3 hours. Flaky internet
combined with non-resumable clone results in badness. Delta resolution
can take a while. Checkout of hundreds of thousands of files can be
slow, especially on Windows.</p>
<p>"As tool developers... it's hard to tell people don't check in large
binaries, do things this way, ... when all they are trying to do is
get their job done." (I couldn't agree more: tools should ideally not
impose sub-optimal workflows.)</p>
<p>They prefer scaling pain to supporting multiple tools. (I think this
meant don't use multiple VCSs if you can just make one scale.)</p>
<p>Shallow clone beneficial. But some commands don't work. log not very
useful.</p>
<p>Narrow clones mentioned. Apparently talked about elsewhere at Git Merge
not captured on video. Non-trivial problem for Git. "We have no idea
when this is going to happen."</p>
<p>Split repos until narrow clone is available. Google wrote repo to manage
multiple repos. They view repo and multiple repos as stop-gap until
narrow clone is implemented.</p>
<p>git submodule needs some love. Git commands don't handle submodules
or multiple repos very well. They'd like to see repo features
incorporated into git submodule.</p>
<p>Transition to server operation.</p>
<p>Pre-2.0, counting objects was hard. For Linux kernel, 60s 100% CPU time
per clone to count objects. "Linux isn't even that big."</p>
<p>Traditionally Git is single homed. Load from users. Load from
automation.</p>
<p>Told anecdote about how Google's automation once recloned the repo after
a failed Git command. Accidentally made a change one day that caused a
command to persistently fail. DoS against server. (We've had this at
Mozilla.)</p>
<p>Garbage collection on server is CPU intensive and necessary. Takes cores
away from clients.</p>
<p>Reachability bitmaps implemented in JGit, ported to Git 2.0. Counting
objects for Linux clones went from 60s CPU to ~100ms.</p>
<p>Google puts static, pre-generated bundles on a CDN. Client downloads
bundle then does incremental fetch. Massive reduction in server load.
Bundle files better for users. Resumable.</p>
<p>They have ideas for integrating bundles into git fetch, but it's
"a little way's off." (This feature is partially implemented in
Mercurial 3.4 and we have plans for using it at Mozilla.) It's feature
in repo today.</p>
<p>Shared filesystem would be really nice to spread CPU load. NFS "works."
Performance problems with high throughput repositories.</p>
<p>Master-mirror replication can help. Problems with replication lag.
Consistency is hard.</p>
<p>Google uses a distributed Git store using Bigtable and GFS built on
JGit. Git-aware load balancer. Completely separate pool of garbage
collection workers. They do replication to multiple datacenters before
pushes. 6 datacenters across world. Some of their stuff is open source.
A lot isn't.</p>
<p>Humans have difficulty managing hundreds of repositories. "How do you as
a human know what you need to modify?" Monorepos have this problem too.
Inherent with lots of content. (Seemed to imply it is worse with
multiple repos than with a monorepo.)</p>
<p>Porting changes between forks is hard. e.g. cherry picking between
internal and external Android repos.</p>
<p>ACLs are a mess.</p>
<p>Google built Gerrit code review. It does ACLs, auto rebasing, release
branch management. It's a swiss army knife. (This aligns with my
vision for MozReview and code-centric development.)</p>
<h2>Scaling Git at Twitter</h2>
<p>Wilhelm Bierbaum from Twitter talks about
<a href="http://git-merge.com/videos/scaling-git-at-twitter-wilhelm-bierbaum.html">Scaling Git at Twitter</a>.</p>
<p>"We've decided it's really important to make Twitter a good place to work for
developers. Source control is one of those points where we were
lacking. We had some performance problems with Git in the past."</p>
<p>Twitter runs a monorepo. Used to be 3 repos. "Working with a single
repository is the way they prefer to develop software when developing
hundreds of services." They also have a single build system. They have
a geo diverse workforce.</p>
<p>They use normal canonical implementation of Git + some optimizations.</p>
<p>Benefits of a monorepo:</p>
<p>Visibility. Easier for people to find code in one repo. Code search tools
tailored towards single repos.</p>
<p>Single toolchain. single set of tools to build, test, and deploy. When
improvements to tools made, everyone benefits because one toolchain.</p>
<p>Easy to share code (particularly generated code like IDL). When operating
many small services, services developed together. Code duplication is
minimized. Twitter relies on IDL heavily.</p>
<p>Simpler to predict the impact of your changes. Easier to look at single
code base then to understand how multiple code bases interact. Easy to
make a change and see what breaks rather than submit changes to N repos
and do testing in N repos.</p>
<p>Makes refactoring less arduous.</p>
<p>Surfaces architecture issues earlier.</p>
<p>Breaking changes easier to coordinate</p>
<p>Drawbacks of monorepos:</p>
<p>Large disk footprint for full history.</p>
<p>Tuning filesystem only goes so far.</p>
<p>Forces some organizations to adopt sparse checkouts and shallow clones.</p>
<p>Submodules aren't good enough to use. <em>add</em> and <em>commit</em> don't recognize
submodule boundaries very well and aren't very usable.</p>
<p>"To us, using a tool such as repo that is in effect a secondary version
control tool on top of Git does not feel right and doesn't lead to a
fluid experience."</p>
<p>Twitter has centralized use of Git. Don't really benefit from
distributed version control system. Feature branches. Goal is to live as
close to master as possible. Long-running branches discouraged. Fewer
conflicts to resolve.</p>
<p>They have project-level ownership system. But any developer can change
anything.</p>
<p>They have lots of read-only replicas. Highly available writable server.</p>
<p>They use reference repos heavily so object exchange overhead is
manageable.</p>
<p>Scaling issues with many refs. Partially due to how refs are stored on
disk. File locking limits in OS. Commands like status, add, and commit
can be slow, even with repo garbage collected and packed. Locking issues
with garbage collection.</p>
<p>Incorporated file alteration monitor to make status faster. Reference to
Facebook's work on watchman and its Mercurial integration. Significant
impact on OS X. "Pretty much all our developers use OS X." (I assume
they are using Watchman with Git - I've seen patches for this on the Git
mailing list but they haven't been merged into core yet.)</p>
<p>They implemented a custom index format. Adopted faster hashing
algorithm that uses native instructions.</p>
<p>Discovery with many refs didn't scale. 13 MB of raw data for refs
exchange at Twitter. (!!) Experimenting with clients sending a bloom
filter of refs. Hacked it together via HTTP header.</p>
<p>Fetch protocol is expensive. Lots of random I/O. Can take minutes
to do incremental fetches. Bitmap indices help, but aren't good enough
for them. Since they have central and well-defined environment, they
changed fetch protocol to work like a journal: send all changed data since
client's last fetch. Server work is essentially a sendfile system call.
git push appends push packs to a log-structured journal. On fetch,
clients "replay" the transactions from the journal. Similar to MySQL
binary log replication. (This is very similar to some of the Mercurial
replication work I'm doing at Mozilla. Yay technical validation.)
(Append only files are also how Mercurial's storage model works by
default.)</p>
<p>Log-structured data exchange means server side is cheap. They can insert
HTTP caches to handle Range header aware requests.</p>
<p>Without this hack, they can't scale their servers.</p>
<p>Initial clone is seeded by BitTorrent.</p>
<p>It sounds like everyone's unmerged feature branches are on the one
central repo and get transferred everywhere by default. Their journal
fetch can selectively fetch refs so this isn't a huge problem.</p>
<p>They'd like to experiment with sparse repos. But they haven't gotten to
that yet. They'd like a better storage abstraction in Git to enable
necessary future scalability. They want a network-aware storage backend.
Local objects not necessary if the network has them.</p>
<p>They are running a custom Git distribution/fork on clients. But they
don't want to maintain forever. Prefer to send upstream.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Code First and the Rise of the DVCS and GitHub]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2015/01/10/code-first-and-the-rise-of-the-dvcs-and-github" />
    <id>http://gregoryszorc.com/blog/2015/01/10/code-first-and-the-rise-of-the-dvcs-and-github</id>
    <updated>2015-01-10T12:35:00Z</updated>
    <published>2015-01-10T12:35:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Git" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Code First and the Rise of the DVCS and GitHub]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2015/01/10/code-first-and-the-rise-of-the-dvcs-and-github"><![CDATA[<p>The ascendancy of GitHub has very little to do with its namesake tool,
Git.</p>
<p>What GitHub did that was so radical for its time and the strategy that
GitHub continues to execute so well on today is the approach of
putting <em>code first</em> and enabling change to be a frictionless process.</p>
<p>In case you weren't around for the pre-GitHub days or don't remember,
they were not pleasant. Tools around code management were a far cry
from where they are today (I still argue the tools are pretty bad, but
that's for another post). Centralized version control systems were
prevalent (CVS and Subversion in open source, Perforce, ClearCase,
Team Foundation Server, and others in the corporate world). Tools for
looking at and querying code had horrible, ugly interfaces and came out
of a previous era of web design and browser capabilities. It felt like
a chore to do anything, including committing code. Yes, the world
had awesome services like <a href="https://sourceforge.net/">SourceForge</a>,
but they weren't the same as GitHub is today.</p>
<p>Before I get to my central thesis, I want to highlight some supporting
reasons for GitHub's success. There were two developments in the second
half of the 2000s the contributed to the success of GitHub: the rises
of the distributed version control system (DVCS) and the modern web.</p>
<p>While distributed version control systems like Sun WorkShop TeamWare and
BitKeeper existed earlier, it wasn't until the second half of the 2000s
that DVCS systems took off. You can argue part of the reason for this
was open source: my recollection is there wasn't a well-known DVCS
available as free software before 2005. Speaking of 2005, it was a big
year for DVCS projects: Git, Mercurial, and Bazaar all had initial
releases. Suddenly, there were old-but-new ideas on how to do source
control being exposed to new and willing-to-experiment audiences. DVCS
were a critical leap from traditional version control because they
(theoretically) impose less process and workflow limitations on users.
With traditional version control, you needed to be online to commit,
meaning you were managing patches, not commits, in your local
development workflow. There were some forms of branching and merging,
but they were a far cry from what is available today and were often too
complex for mere mortals to use. As more and more people were exposed to
<em>distributed</em> version control, they welcomed its less-restrictive and
more powerful workflows. They realized that source control tools don't
have to be so limiting. <em>Distributed</em> version control also promised all
kinds of revamped workflows that could be harnessed. There were
potential wins all around.</p>
<p>Around the same time that open source DVCS systems were emerging, web
browsers were evolving from an application to render static pages to a
platform for running web <em>applications</em>. Web sites using JavaScript
to dynamically manipulate web page content (DHTML as it was known back
then) were starting to hit their stride. I believe it was GMail that
turned the most heads as to the full power of the <em>modern web</em>
experience, with its novel-for-its-time extreme reliance on
XMLHttpRequest for dynamically changing page content. People were
realizing that powerful, desktop-like applications could be built for
the web and could run everywhere.</p>
<p>GitHub launched in April 2008 standing on the shoulders of both the
emerging interest in the Git content tracking tool and the capabilities
of modern browsers.</p>
<p>I wasn't an early user of GitHub. My recollection is that GitHub was
mostly a Rubyist's playground back then. I wasn't a Ruby programmer, so
I had little reason to use GitHub in the early stages. But people did
start using GitHub. And in the spirit of Ruby (on Rails), GitHub moved
fast, or at least was projecting the notion that they were. While other
services built on top of DVCS tools - like Bitbucket - did exist back then,
GitHub seemed to have momentum associated with it. (Look at the archives
for <a href="https://github.com/blog">GitHub's</a> and
<a href="https://blog.bitbucket.org/">Bitbucket's</a> respective blogs. GitHub has
hundreds of blog entries; Bitbucket numbers in the dozens.) Developers
everywhere up until this point had all been dealing with sub-optimal tools
and workflows. Some of us realized it. Others hadn't. Many of those who
did saw GitHub as a beacon of hope: we have all these new ideas and new
potentials with distributed version control and here is a service under
active development trying to figure out how to exploit that. Oh, and
it's free for open source. Sign me up!</p>
<p>GitHub did capitalize on a market opportunity. They also capitalized on
the value of marketing and the perception that they were moving fast and
providing features that people - especially in open source - wanted.
This captured the early adopters market. But I think what really set
GitHub apart and led to the success they are enjoying today is their
<em>code first</em> approach and their desire to make contribution easy, and
even fun and sociable.</p>
<p>As developers, our job is to solve problems. We often do that by writing
and changing code. And this often involves working as part of a team, or
collaborating. To collaborate, we need tools. You eventually need some
processes. And as I
<a href="/blog/2015/01/09/firefox-contribution-process-debt/">recently blogged</a>,
this can lead to <em>process debt</em> and inefficiencies associated with them.</p>
<p>Before GitHub, the <em>process debt</em> for contributing to other projects was
high. You often had to subscribe to mailing lists in order to submit
patches as emails. Or, you had to create an account on someone's bug
tracker or code review tool before you could send patches. Then you had
to figure out how to use these tools and any organization or
project-specific extensions and workflows attached to them. It was quite
involved and a lot could go wrong. Many projects and organizations (like
Mozilla) still practice this traditional methology. Furthermore (and as
I've
<a href="/blog/2014/10/27/implications-of-using-bugzilla-for-firefox-patch-development/">written before</a>),
these traditional, single patch/commit-based tools often aren't
effective at ensuring the desired output of high quality software.</p>
<p>Before GitHub solved <em>process debt</em> via commoditization of knowledge via
market dominance, they took another approach: emphasizing <em>code first</em>
development.</p>
<p>GitHub is all about the <strong>code</strong>. You load a project page and you see
<strong>code</strong>. You may think a README with basic project information would be
the first thing on a <em>project</em> page. But it isn't. <em>Code</em>, like data,
is king.</p>
<p>Collaboration and contribution on GitHub revolve around the <em>pull
request</em>. It's a way of saying, <em>hey, I made a change, will you take
it?</em> There's nothing too novel in the concept of the <em>pull request</em>:
it's fundamentally no different than sending emails with patches to a
mailing list. But what is so special is GitHub's execution. Gone are
the days of configuring and using one-off tools and processes. Instead,
we have the friendly confines of a clean, friendly, and modern web
experience. While GitHub is built upon the Git tool, you don't even
need to use Git (a tool
<a href="http://git-man-page-generator.lokaltog.net/">lampooned</a>
for its
<a href="http://stevelosh.com/blog/2013/04/git-koans/">horrible usability and approachability</a>)
to contribute on GitHub! Instead, you can
<a href="https://help.github.com/articles/github-flow-in-the-browser/">do everything from your browser</a>.
That warrants repeating: <strong>you don't need to leave your browser to
contribute on GitHub</strong>. GitHub has essentially reduced <em>process debt</em>
to <em>edit a text document</em> territory, and pretty much anybody who has
used a computer can do that. This has enabled GitHub to dabble into
non-code territory, such as its
<a href="https://government.github.com/">GitHub and Government</a> initiative to
foster community involvement in government. (GitHub is really a platform
for easily seeing and changing <em>any</em> content or data. But, please, let
me continue using <em>code</em> as a stand-in, since I want to focus on the
developer audience.)</p>
<p>GitHub took an overly-complicated and fragmented world of varying
contribution processes and made the new world revolve around code and a
unified and simple process for change - the <em>pull request</em>.</p>
<p>Yes, there are other reasons for GitHub's success. You can make strong
arguments that GitHub has capitalized on the social and psychological
aspects of coding and human desire for success and happiness. I agree.</p>
<p>You can also argue GitHub succeeded because of Git. That statement is
more or less technically accurate, but I don't think it is a sound
argument. Git may have been the most feature complete open source
DVCS at the time GitHub came into existence. But that doesn't mean there
is something special about Git that no other DVCS has that makes GitHub
popular. Had another tool been more feature complete or had the backing
of a project as large as Linux at the time of GitHub's launch, we could
very well be looking at a successful service built on something that
isn't Git. Git had early market advantage and I argue its popularity
today - a lot of it via GitHub - is largely a result of its early
advantages over competing tools. And, I would go so far to say that when
you consider the poor usability of Git and the pain that its users go
through when first learning it, more accurate statements would be that
<em>GitHub succeeded in spite of Git</em> and <em>Git owes much of its success to
GitHub</em>.</p>
<p>When I look back at the rise of GitHub, I see a service that has
succeeded by putting people first by allowing them to capitalize
on more productive workflows and processes. They've done this by
emphasizing <em>code</em>, not process, as the means for change. Organizations
and projects should take note.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[On Monolithic Repositories]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2014/09/09/on-monolithic-repositories" />
    <id>http://gregoryszorc.com/blog/2014/09/09/on-monolithic-repositories</id>
    <updated>2014-09-09T10:00:00Z</updated>
    <published>2014-09-09T10:00:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Git" />
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[On Monolithic Repositories]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2014/09/09/on-monolithic-repositories"><![CDATA[<p>When companies or organizations deploy version control, they have to
make many choices. One of them is how many repositories to create.
Your choices are essentially a) a single, monolithic repository that
holds everything b) many separate, smaller repositories that hold
all the individual parts c) something in between.</p>
<p>The prevailing convention today (especially in the open source
realm) is to create many separate and loosely coupled repositories,
each repository mapping to a specific product or service. That does
seem reasonable: if you were organizing files on your filesystem,
you would group them by functionality or role (photos, music,
documents, etc). And, version control tools are functionally
filesystems. So it makes sense to draw repository boundaries at
directory/role levels.</p>
<p>Further reinforcing the separate repository convention is the
scaling behavior of our version control tools. Git, the popular
tool in open source these days, doesn't scale well to very large
repositories due to - among other things - not having narrow clones
(fetching a subset of files). It scales well enough to the
overwhelming majority of projects. But if you are a large
organization generating lots of data (read: gigabytes of data over
hundreds of thousands of files and commits) for version control,
Git is unsuitable in its current form. Other tools (like Mercurial)
don't currently fare that much better (although Mercurial has plans
to tackle these scaling vectors).</p>
<p>Despite popular convention and even limitations in tools, companies
like Google and Facebook opt to run large, monolithic repositories.
Google runs Perforce.
<a href="https://code.facebook.com/posts/218678814984400/scaling-mercurial-at-facebook/">Facebook is on Mercurial</a>,
or at least is in the process of migrating to Mercurial.</p>
<p>Why do these companies run monolithic repositories?
In <a href="http://www.perforce.com/sites/default/files/still-all-one-server-perforce-scale-google-wp.pdf">Google's words</a>:</p>
<p><em>We have a single large depot with almost all of Google's projects
on it. This aids agile development and is much loved by our users,
since it allows almost anyone to easily view almost any code, allows
projects to share code, and allows engineers to move freely from
project to project. Documentation and data is stored on the server
as well as code.</em></p>
<p>So, monolithic repositories are all about moving fast and getting things
done more efficiently. In other words, <strong>monolithic repositories
increase developer productivity.</strong></p>
<p>Furthermore, monolithic repositories are also more compatible with
the ebb and flow of large organizations and large software projects.
Components, features, products, and teams come and go, merge and split.
The only constant is change. And if you are maintaining separate
repositories that attempt to map to this ever-changing organizational
topology, you are going to have a bad time. Either you'll be
constantly copying, moving, merging, splitting, etc data and repositories.
Or your repositories will be organized in a very non-logical and
non-intuitive manner. That translates to overhead and lost productivity.
I think that monolithic repositories handle the realities of large
organizations much better. Big change or reorganization you want
to reflect? You can make a single, atomic, history-preserving commit
to move things around. I think that's much more manageable, especially
when you consider the difficulty and annoyance of history-preserving
changes across repositories.</p>
<p>Naysayers will decry monolithic repositories on principled and practical
grounds.</p>
<p>The principled camp will say that separate repositories
constitute a loosely coupled (dare I say service oriented) architecture
that maps better to how software is consumed, assembled, and deployed
and that erecting barriers in the form of separate repositories
deliberately enforces this architecture. I agree. However, you can
still maintain a loosely coupled architecture with monolithic
repositories. The Subversion model of checking out a single tree
<em>from a larger repository</em> proves this. Furthermore, I would say
architecture decisions should be enforced by people (via code review,
etc), not via version control repository topology. I believe this
principled argument against monolithic repositories to be rather weak.</p>
<p>The principled camp living in the open source realm may also decry
monolithic repositories as an affront to the spirit of open source.
They would say that a monolithic repository creates unfairly strong
ties to the organization that operates it and creates barriers to
forking, etc. This may be true. But monolithic repositories don't
intrinsically infringe on the
<a href="https://www.gnu.org/philosophy/free-sw.html">basic software freedoms</a>,
organizations do. Therefore, I find this principled argument rather
weak.</p>
<p>The practical camp will say that monolithic repositories just don't
scale or aren't suitable for general audiences. These concerns are
real.</p>
<p><em>Fully</em> distributed version control systems (every commit on every
machine) definitely don't scale past certain limits. Depending on your
repository and user base, your scaling limits include disk space
(repository data terabytes in size), bandwidth (repository data terabytes
in size), filesystem (repository hundreds of thousands or millions of
files), CPU and memory (operations on large repositories take too
many system resources), and many heads/branches (tools like Git and
Mercurial don't scale well to tens of thousands of heads/branches).
These limitations with fully distributed version
control are why distributed version control tools like Git and
Mercurial support a partially-distributed mode that behaves more like
your classical server-client model, like those employed by Subversion,
Perforce, etc. Git supports shallow clone and sparse checkout.
Mercurial supports shallow clone (via remotefilelog) and has planned
support for narrow clone and sparse checkout by the end of 2015.
Of course, you can avoid the scaling limitations of distributed
version control by employing a non-distributed tool, such as Subversion.
Many companies continue to reach this conclusion today. However,
users adapted to the distributed workflow would likely be
up in arms (they would probably use tools like hg-subversion or git-svn
to maintain their workflows). So, while scaling of version control
can be a real concern, there are solutions and workarounds. However,
they do involve falling back to a partially-distributed model.</p>
<p>Another concern with monolithic repositories is user access control. You
inevitably have code or data that is more sensitive and want to limit
who can change or even access it. Separate repositories seem to
facilitate a simpler model: per-repository access control. With
monolithic repositories, you have to worry about per-directory/subtree
permissions, an increased risk of data leaking, etc. This concern is
more real with distributed version control, as distributed data and
access control aren't naturally compatible. But these issues can be
resolved. And if the tooling supports it, there is only a semantic
difference between managing access control between repositories versus
components of a single repository.</p>
<p>When it comes to repository hosting conversions, I agree with Google
and Facebook: <strong>I prefer monolithic repositories</strong>. When I am interacting
with version control, I just want to get stuff done. I don't want to
waste time dealing with multiple commands to manage multiple
repositories. I don't want to waste time or expend cognitive load
dealing with submodule, subrepository, or big files management. I
don't want to waste time trying to find and reuse code, data, or
documentation. I want everything at my fingertips, where it can be
easily discovered, inspected, and used. Monolithic repositories
facilitate these workflows more than separate repositories and make
me more productive as a result.</p>
<p>Now, if only all the tools and processes we use and love would work
with monolithic repositories...</p>
<p><em>Want to read more about monolithic repositories? I highly recommend
<a href="http://danluu.com/monorepo/">Advantages of Monolithic Version Control</a>
by Dan Luu.</em></p>]]></content>
  </entry>
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Repository-Centric Development]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2014/07/24/repository-centric-development" />
    <id>http://gregoryszorc.com/blog/2014/07/24/repository-centric-development</id>
    <updated>2014-07-24T20:23:00Z</updated>
    <published>2014-07-24T20:23:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Git" />
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Repository-Centric Development]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2014/07/24/repository-centric-development"><![CDATA[<p>I was editing a wiki page yesterday and I think I coined a new term
which I'd like to enter the common nomenclature: <em>repository-centric
development</em>. The term refers to development/version control
workflows that place repositories - not patches - first.</p>
<p>When collaborating on version controlled code with modern tools like
Git and Mercurial, you essentially have two choices on how to
share version control data: patches or repositories.</p>
<p>Patches have been around since the dawn of version control. Everyone
knows how they work: your version control system has a copy of
the canonical data and it can export a view of a specific change
into what's called a patch. A patch is essentially a diff with
extra metadata.</p>
<p>When distributed version control systems came along, they brought
with them an alternative to patch-centric development:
repository-centric development. You could still exchange patches if you
wanted, but distributed version control allowed you to <em>pull</em> changes
directly from multiple <em>repositories</em>. You weren't limited to a single
master server (that's what the <em>distributed</em> in <em>distributed version
control</em> means). You also didn't have to go through an intermediate
transport such as email to exchange patches: you communicate directly
with a peer repository instance.</p>
<p>Repository-centric development eliminates the <em>middle man</em> required
for patch exchange: instead of exchanging derived data, you exchange
the actual data, speaking the repository's native language.</p>
<p>One advantage of repository-centric development is it eliminates the
problem of patch non-uniformity. Patches come in many different flavors.
You have plain diffs. You have diffs with metadata. You have Git style
metadata. You have Mercurial style metadata. You can produce patches
with various lines of context in the diff. There are different methods
for handling binary content. There are different ways to express
file adds, removals, and renames. It's all a hot mess. Any system
that consumes patches needs to deal with the non-uniformity. Do you
think this isn't a problem in the real world? Think again. If you are
involved with an open source project that collects patches via email
or by uploading patches to a bug tracker, have you ever seen someone
accidentally upload a patch in the wrong format? That's patch
non-uniformity. New contributors to Firefox do this all the time. I
also see it in the Mercurial project. With repository-centric
development, patches never enter the picture, so patch non-uniformity
is a non-issue. (Don't confuse the superficial formatting of patches
with the content, such as an incorrect commit message format.)</p>
<p>Another advantage of repository-centric development is it makes the
act of exchanging data easier. Just have two repositories talk to
each other. This used to be difficult, but hosting services like
GitHub and Bitbucket make this easy. Contrast with patches, which
require hooking your version control tool up to wherever those patches
are located. The Linux Kernel, like so many other projects,
<a href="https://www.kernel.org/doc/Documentation/SubmittingPatches">uses email for contributing changes</a>.
So now Git, Mercurial, etc all fulfill Zawinski's law. This means your
version control tool is talking to your inbox to send and receive code.
Firefox development uses Bugzilla to hold patches as attachments. So now your
version control tool needs to talk to your issue tracker. (Not the worst
idea in the world I will concede.) While, yes, the tools around using
email or uploading patches to issue trackers or whatever else you are
using to exchange patches exist and can work pretty well, the grim
reality is that these tools are all reinventing the wheel of repository
exchange and are solving a problem that has already been solved by
<em>git push</em>, <em>git fetch</em>, <em>hg pull</em>, <em>hg push</em>, etc. Personally, I would
rather <em>hg push</em> to a remote and have tools like issue trackers and
mailing lists pull directly from repositories. At least that way they
have a direct line into the source of truth and are guaranteed a
consistent output format.</p>
<p>Another area where direct exchange is huge is multi-patch commits
(<em>branches</em> in Git parlance) or where commit data is fragmented. When
pushing patches to email, you need to insert metadata saying which patch
comes after which. Then the email import tool needs to reassemble things
in the proper order (remember that the typical convention is one email
per patch and email can be delivered out of order). Not the most
difficult problem in the world to solve. But seriously, it's been
solved already by <em>git fetch</em> and <em>hg pull</em>! Things are worse for
Bugzilla. There is no bullet-proof way to order patches there. The
convention at Mozilla is to add <em>Part N</em> strings to
commit messages and have the Bugzilla import tool do a sort (I assume it
does that). But what if you have a logical commit series spread across
multiple bugs? How do you reassemble everything into a linear series of
commits? You don't, sadly. Just today I wanted to apply a somewhat
complicated series of patches to the Firefox build system I was asked to
review so I could jump into a debugger and see what was going on so I
could conduct a more thorough review. There were 4 or 5 patches spread
over 3 or 4 bugs. Bugzilla and its patch-centric workflow prevented me
from importing the patches. Fortunately, this patch series was pushed to
Mozilla's Try server, so I could pull from there. But I haven't always
been so fortunate. This limitation means developers have to make
sacrifices such as writing fewer, larger patches (this makes code review
harder) or involving unrelated parties in the same bug and/or review.
In other words, deficient tools are imposing limited workflows. No bueno.</p>
<p>It is a fair criticism to say that not everyone can host a server or
that permissions and authorization are hard. Although I think concerns
about impact are overblown. If you are a small project, just create a
GitHub or Bitbucket account. If you are a larger project, realize that
people time is one of your largest expenses and invest in tools like
proper and efficient repository hosting (often this can be GitHub) to
reduce this waste and keep your developers happier and more efficient.</p>
<p>One of the clearest examples of repository-centric development is
GitHub. There are no patches in GitHub. Instead, you <em>git push</em>
and <em>git fetch</em>. Want to apply someone else's work? Just add a remote
and <em>git fetch</em>! Contrast with first locating patches, hooking up
Git to consume them (this part was always confusing to me - do you
need to retroactively have them sent to your email inbox so you can
import them from there), and finally actually importing them. Just
give me a URL to a repository already. But the benefits of
repository-centric development with GitHub don't stop at pushing and
pulling. GitHub has built code review functionality into pushes. They
call these <em>pull requests</em>. While I have significant issues with
GitHub's implemention of pull requests (I need to blog about those some
day), I can't deny the utility of the repository-centric workflow and
all the benefits around it. Once you switch to GitHub and its
repository-centric workflow, you more clearly see how lacking
patch-centric development is and quickly lose your desire to go back
to the 1990's state-of-the-art methods for software development.</p>
<p>I hope you now know what repository-centric development is and will join
me in championing it over patch-based development.</p>
<p>Mozillians reading this will be very happy to learn that work is under
way to shift Firefox's development workflow to a more repository-centric
world. Stay tuned.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[New Repository for Mozilla Version Control Tools]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2014/02/05/new-repository-for-mozilla-version-control-tools" />
    <id>http://gregoryszorc.com/blog/2014/02/05/new-repository-for-mozilla-version-control-tools</id>
    <updated>2014-02-05T19:15:00Z</updated>
    <published>2014-02-05T19:15:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Git" />
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[New Repository for Mozilla Version Control Tools]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2014/02/05/new-repository-for-mozilla-version-control-tools"><![CDATA[<p>Version control systems can be highly useful tools.</p>
<p>At Mozilla, we've made numerous improvements and customizations to our
version control tools. We have <a href="https://hg.mozilla.org/hgcustom/hghooks/">custom hooks</a>
that run on the server. We have a <a href="https://hg.mozilla.org/hgcustom/hg_templates/">custom skin</a>
for Mercurial's web interface. Mozillians have written a handful of
Mercurial extensions to aid with common developer tasks, such as
<a href="https://bitbucket.org/sfink/trychooser">pushing to try</a>,
<a href="https://hg.mozilla.org/users/tmielczarek_mozilla.com/bzexport">interacting with Bugzilla</a>,
<a href="https://bitbucket.org/sfink/mqext">making mq more useful</a>, and more.</p>
<p>These have all come into existence in an organic manner, one after the
other. Individuals have seen an itch and scratched it. Good for them.
Good for Mozilla.</p>
<p>Unfortunately, the collection of amassed tools has become quite large.
They have become difficult to discover and keep up to date. The
consistency in quality and style between the tools varies. Each tool has
separate processes for updating and changing.</p>
<p>I contacted the maintainers of the popular version control tools at
Mozilla with a simple proposal: let's maintain all our tools under one
repo. This would allow us to increase cohesion, share code, maintain a
high quality bar, share best practices, etc. There were no major
objections, so we now have a <a href="https://hg.mozilla.org/hgcustom/version-control-tools/">unified repository</a>
containing our version control tools!</p>
<p>Currently, we only have a few Mercurial extensions in there. A goal is
to accumulate as much of the existing Mercurial infrastructure into
that repository as possible. Client code. Server code. All of the code.
I want developers to be able to install the same hooks on their clients
as what's running on the server: why should your local repo let you
commit something that the server will reject? I want developers to be
able to reasonably reproduce Mozilla's canonical version control server
configuration locally. That way, you can test things locally with a high
confidence that your changes will work the same way on production. This
allows deployments to move faster and with less friction.</p>
<p>The immediate emphasis will be on moving extensions into this repo and
deprecating the old homes on user repositories. Over time, we'll move
into consolidating server code and getting hg.mozilla.org and
git.mozilla.org to use this repository. But that's a lower priority: the
most important goal right now is to make it easier and friendlier for
people to run productivity-enhancing tools.</p>
<p>So, if you see your Mercurial extensions alerting you that they've been
moved to a new repository, now you know what's going on.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Aggregating Version Control Info at Mozilla]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2014/01/21/aggregating-version-control-info-at-mozilla" />
    <id>http://gregoryszorc.com/blog/2014/01/21/aggregating-version-control-info-at-mozilla</id>
    <updated>2014-01-21T10:50:00Z</updated>
    <published>2014-01-21T10:50:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Git" />
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Python" />
    <summary type="html"><![CDATA[Aggregating Version Control Info at Mozilla]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2014/01/21/aggregating-version-control-info-at-mozilla"><![CDATA[<p>Over the winter break, I set out on an ambitious project to create
a service to help developers and others manage the flury
of patches going into Firefox. While the project is far from complete,
I'm ready to unleash the first part of the project upon the world.</p>
<p>If you point your browsers to
<a href="http://moztree.gregoryszorc.com/">moztree.gregoryszorc.com</a>, you'll
hopefully see some documentation about what I've built.
<a href="https://bitbucket.org/indygreg/moz-tree-utopia">Source code</a> is
available and free, of course. Patches very welcome.</p>
<p>Essentially, I built a centralized indexing service for version
control repositories with Mozilla's extra metadata thrown in.
I tell it what repositories to mirror, and it clones everything,
fetches data such as the pushlog and Git SHA-1 mappings, and
stores everything in a central database. It then exposes this
aggregated data through world-readable web services.</p>
<p>Currently, I have the service indexing the popular project branches
for Firefox (central, aurora, beta, release, esr, b2g, inbound, fx-team,
try, etc). You can view the
<a href="http://moztree.gregoryszorc.com/api/repos">full list</a> via the web
service. As a bonus, I'm also serving these repositories via
<a href="http://hg.gregoryszorc.com/">hg.gregoryszorc.com</a>. My server appears
to be significantly faster than
<a href="https://hg.mozilla.org">hg.mozilla.org</a>. If you want to use it for
your daily needs, go for it. I make no SLA guarantees, however.</p>
<p>I'm also using this service as an opportunity to experiment with
alternate forms of Mercurial hosting. I have mirrors of mozilla-central
and the try repository with generaldelta and lz4 compression enabled.
I may blog about what those are eventually. The teaser is that they can
make Mercurial perform a lot faster under some conditions. I'm also
using ZFS under the hood to manage repositories. Each repository is a
ZFS filesystem. This means I can create repository copies on the server
(user repositories anyone?) at a nearly free cost. Contrast this to the
traditional method of full clones, which take lots of time, memory, CPU,
and storage.</p>
<p>Anyway, some things you can do with the existing web service:</p>
<ul>
<li>Obtain metadata about Mercurial changesets.
  <a href="http://moztree.gregoryszorc.com/api/changeset/940b2974f35b">Example</a>.</li>
<li>Look up metadata about Git commits.
  <a href="http://moztree.gregoryszorc.com/api/git-sha1/40438af67c321">Example</a>.</li>
<li>Obtain a <a href="http://moztree.gregoryszorc.com/api/spore">SPORE descriptor</a>
  describing the web service endpoints. This allows you to auto-generate
  clients from descriptors. Yay!</li>
</ul>
<p>Obviously, that's not a lot. But adding new endpoints is relatively
straightforward. See the <a href="https://bitbucket.org/indygreg/moz-tree-utopia/src/tip/repodata/web/app.py">source</a>.
It's literally as easy as defining a URL mapping and writing a
database query.</p>
<p>The performance is also not the best. I just haven't put in the effort
to tune things yet. All of the querying hits the database, not
Mercurial. So, making things faster should merely be a matter of
database and hosting optimization. Patches welcome!</p>
<p>Some ideas that I haven't had time to implement yet:</p>
<ul>
<li>Return changests in a specific repository</li>
<li>Return recently pushed changesets</li>
<li>Return pushes for a given user</li>
<li>Return commits for a given author</li>
<li>Return commits referencing a given bug</li>
<li>Obtain TBPL URLs for pushes with changeset</li>
<li>Integrate bugzilla metadata</li>
</ul>
<p>Once those are in place, I foresee this service powering a number of
dashboards. Patches welcome.</p>
<p>Again, this service is only the tip of what's possible. There's a lot
that could be built on this service. I have ideas. Others have ideas.</p>
<p>The project includes a Vagrant file and Puppet
manifests for provisioning the server. It's a one-liner to get a
development environment up and running. It should be really easy to
contribute to this project. Patches welcome.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Importance of Hosting Your Version Control Server]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/11/13/importance-of-hosting-your-version-control-server" />
    <id>http://gregoryszorc.com/blog/2013/11/13/importance-of-hosting-your-version-control-server</id>
    <updated>2013-11-13T09:25:00Z</updated>
    <published>2013-11-13T09:25:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Git" />
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Importance of Hosting Your Version Control Server]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/11/13/importance-of-hosting-your-version-control-server"><![CDATA[<p>The subject of where to host version control repositories comes up a lot
at Mozilla. It takes many forms:</p>
<ul>
<li>We should move the Firefox repository to GitHub</li>
<li>I should be allowed to commit to GitHub</li>
<li>I want the canonical repository to be hosted by Bitbucket</li>
</ul>
<p>When Firefox development is concerned, Release Engineerings puts down
their foot and insists the canonical repository be hosted by Mozilla,
under a Mozilla hostname. When that's not possible, they set up a mirror
on Mozilla infrastructure.</p>
<p>I think a
<a href="https://groups.google.com/d/topic/jenkinsci-dev/-myjRIPcVwU/discussion">recent issue with the Jenkins project</a>
demonstrates why hosting your own version control server is important.
The gist is someone force pushed to a bunch of repos hosted on GitHub.
They needed to involve GitHub support to recover from the issue. While
it appears they largely recovered (and GitHub support deserves kudos - I
don't want to take away from their excellence), this problem would have
been avoided or the response time significantly decreased if the Jenkins
people had direct control over the Git server: they either could have
installed a custom hook that would have prevented the pushes or had
access to the reflog so they could have easily seen the last pushed
revision and easily forced pushed back to it. GitHub doesn't have a
mechanism for defining pre-* hooks, doesn't allow defining custom
hooks (a security and performance issue for them), and doesn't
expose the reflog data.</p>
<p>Until repository hosting services expose full repository data (such as
reflogs) and allow you to define custom hooks, accidents like these will
happen and the recovery time will be longer than if you hosted the repo
yourself.</p>
<p>It's possible repository hosting services like GitHub and Bitbucket will
expose these features or provide a means to quickly recover. If so,
kudos to them. But larger, more advanced projects will likely employ
custom hooks and considering custom hooks are a massive security and
performance issue for any hosted service provider, I'm not going to
hold my breath this particular feature is rolled out any time soon.
This is unfortunate, as it makes projects seemingly choose between
low risk/low convenience and GitHub's vibrant developer community.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Thoughts on Mercurial (and Git)]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/05/12/thoughts-on-mercurial-(and-git)" />
    <id>http://gregoryszorc.com/blog/2013/05/12/thoughts-on-mercurial-(and-git)</id>
    <updated>2013-05-12T12:00:00Z</updated>
    <published>2013-05-12T12:00:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Mercurial" />
    <category scheme="http://gregoryszorc.com/blog" term="Git" />
    <summary type="html"><![CDATA[Thoughts on Mercurial (and Git)]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/05/12/thoughts-on-mercurial-(and-git)"><![CDATA[<p>My first experience with Mercurial (Firefox development)
was very unpleasant. Coming from Git, I thought Mercurial was slow
and perhaps even more awkward to use than Git. I frequently
encountered repository corruption that required me to reclone. I thought
the concept of a patch queue was silly compared to Git branches. It
was all extremely frustrating and I dare say a hinderance to my
productivity. It didn't help that I was surrounded by a bunch of people
who had previous experience with Git and opined about every minute
difference.</p>
<p>Two years later and I'm on much better terms with Mercurial. I initially
thought it might be Stockholm Syndrome, but after reflection I can point
at specific changes and enlightenments that have reshaped my opinions.</p>
<h2>Newer versions of Mercurial are much better</h2>
<p>I first started using Mercurial in the 1.8 days and thought it was
horrible. However, modern releases are much, much better. I've noticed
a steady improvement in the quality and speed of Mercurial in the last
few years.</p>
<p><strong>If you aren't running 2.5 or later (Mercurial 2.6 was released earlier
this month), you should take the time to upgrade today.</strong> When you upgrade,
you should of course read the
<a href="http://mercurial.selenic.com/wiki/WhatsNew">changelog</a> and
<a href="http://mercurial.selenic.com/wiki/UpgradeNotes">upgrade notes</a> so you
can make the most of the new features.</p>
<h2>Proper configuration is key</h2>
<p>For <em>my</em> workflow, the default configuration of Mercurial out of the box
is... far from optimal. There are a number of basic changes that need to
be made to satisfy <em>my</em> expectations for a version control tool.</p>
<p>I used to think this was a shortcoming with Mercurial: why not ship a
powerful and useful environment out of the box? But, after talking to a
Mercurial core contributor, this is mostly by design. Apparently a
principle of the Mercurial project is that the CLI tool (<em>hg</em>) should be
simple by default and should minimize foot guns. They view actions like
rebasing and patch queues as advanced and thus don't have them enabled
by default. Seasoned developers may scoff at this. But, I see where
Mercurial is coming from. I only need to refer everyone to her first
experience with Git as an example of what happens when you don't aim for
simplicity. (I've never met a Git user who didn't think it overly
complicated at first.)</p>
<p>Anyway, to get the most out of Mercurial, it is essential to configure
it to your liking, much like you install plugins or extensions in your
code editor.</p>
<p><strong>Every person running Mercurial should go to
<a href="http://mercurial.selenic.com/wiki/UsingExtensions">http://mercurial.selenic.com/wiki/UsingExtensions</a>
and take the time to find extensions that will make your life better</strong>.
You should also run <em>hg help hgrc</em> to view all the configuration
options. There is a mountain of productivity wins waiting to be realized.</p>
<p>For reference, my <a href="https://gist.github.com/indygreg/5511712">~/.hgrc</a>.
Worth noting are some of the built-in externsions I've enabled:</p>
<ul>
<li>color - Colorize terminal output. Clear UX win.</li>
<li>histedit - Provides  <em>git rebase --interactive</em> behavior.</li>
<li>pager - Feed command output into a pager (like <em>less</em>). Clear UX win.</li>
<li>progress - Draw progress bars on long-running operations. Clear UX
  win.</li>
<li>rebase - Ability to easily rebase patches on top of other heads.
  This is a basic feature of patch management.</li>
<li>transplant - Easily move patches between repositories, branches, etc.</li>
</ul>
<p>If I were on Linux, I'd also use the <em>inotify</em> extension, which installs
filesystem watchers so operations like <em>hg status</em> are instantaneous.</p>
<p>In addition to the built-in extensions, there are a number of 3rd party
extensions that improve my Mozilla workflow:</p>
<ul>
<li><a href="https://bitbucket.org/sfink/mqext">mqext</a> - Automatically commit to
  your patch queue when you qref, etc. This is a lifesaver. If that's
  not enough, it suggests reviewers for your patch, suggests a bug
  component, and let's you find bugs touching the files you are
  touching.</li>
<li><a href="https://github.com/pbiggar/trychooser">trychooser</a> - Easily push
  changes to Mozilla's Try infrastructure.</li>
<li><a href="https://hg.mozilla.org/users/robarnold_cmu.edu/qimportbz">qimportbz</a> -
  Easily import patches from Bugzilla.</li>
<li><a href="https://hg.mozilla.org/users/tmielczarek_mozilla.com/bzexport">bzexport</a> -
  Easily export patches to Bugzilla.</li>
</ul>
<p>I'm amazed more developers don't use these simple productivity wins.
Could it be that people simply don't realize they are available?</p>
<p>Mozilla has a <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=794580">bug</a>
tracking easier configuration of the user's Mercurial environment. My
hope is one day people simply run a single command and get a
Mozilla-optimized Mercurial environment that <em>just works</em>. Along the same
vein, if your extensions are out of date, it prompts you to update them.
This is one of the benefits of a unified developer tool like mach: you
can put these checks in one place and everyone can reap the benefits
easily.</p>
<h2>Mercurial is extensible</h2>
<p>The major differentiator from almost every other version control system
(especially Git) is the ease and degree to which Mercurial can be
extended and contorted. <strong>If you take anything away from this
post it should be that Mercurial is a flexible and agile tool.</strong></p>
<p>If you want to change the behavior of a built-in command, you can write
an extension that monkeypatches that command. If you want to write a new
command, you can of course do that easily. You can have extensions
interact with one another - all natively. You can even override the wire
protocol to provide new <em>capabilities</em> to extend how peers communicate
with one another. You can leverage this to transfer additional metadata
or data types. This has nearly infinite potential. If that's not enough,
it's possible to create a new branching/development primitive through
just an extension alone! If you want to invent Git-style branches with
Mercurial, you could do that! It may require client and server support,
but it's possible.</p>
<p>Mercurial accomplishes this by being written (mostly) in Python (as
opposed to C) and by having a clear API on which extensions can be
built. Writing extensions in Python is huge. You can easily drop into
the debugger to learn the API and your write-test loop is much smaller.</p>
<p>By contrast, most other version control systems (including Git) require
you to parse output of commands (this is the UNIX piping principle).
Mercurial supports this too, but the native Python API is so much more
powerful. Instead of parsing output, you can just read the raw values
from a Python data structure. Yes please.</p>
<p>Since I imagine a lot of people at Mozilla will be reading this, here
are some ways Mozilla could leverage the extensibility of Mercurial:</p>
<ul>
<li>Command to create try pushes (it exists - see above).</li>
<li>Record who pushed what when (we have this - it's called the pushlog).</li>
<li>Command to land patches. If inbound1 is closed,
  automatically rebase on inbound2. etc. This could even be
  monkeypatched into <em>hg push</em> so pushes to inbound are automatically
  intercepted and magic ensues.</li>
<li>Record the automation success/fail status against individual
  revisions and integrate with commands (e.g. only pull up to the most
  recent stable changeset).</li>
<li>Command to create a review request for a patch or patch queue.</li>
<li>Command to assist with reviews. Perhaps a reviewer wants to make minor
  changes. Mercurial could download and apply the patch(es), wait for
  your changes, then reupload to Bugzilla (or the review tool)
  automatically.</li>
<li>Annotating commits or pushes with automation info (which jobs to
  run, etc).</li>
<li>Find Bugzilla component for patch (it exists - see above).</li>
<li>Expose custom protocol for configuring automation settings for a
  repository or a head. e.g. clients (with access) could reconfigure
  PGO scheduling, coalescing, etc without having to involve RelEng -
  useful for twigs and lesser used repositories.</li>
<li>So much more.</li>
</ul>
<p>Essentially, Mercurial itself could become the CLI tool code development
centers around. Whether that is a good idea is up for
debate. But, it can. And that says a lot about the flexibility of
Mercurial.</p>
<h2>Future potential of Mercurial</h2>
<p>When you consider the previous three points, you arrive at a new one:
Mercurial has a ton of future potential. The fact that extensions can
evolve vanilla Mercurial into something that resembles Mercurial in
name only is a testament to this.</p>
<p>When I sat down with a Mercurial core contributor, they reinforced this.
To them, Mercurial is a core library with a limited set of user-facing
commands forming the stable API. Since core features (like storage) are
internal APIs (not public commands - like Git), this means they aren't
bound to backwards compatibility and can refactor internals as needed
and evolve over time without breaking the world. That is a terrific
luxury.</p>
<p>An example of this future potential is
<a href="http://mercurial.selenic.com/wiki/ChangesetEvolution">changeset evolution</a>.
If you don't know what that is, you should because it's awesome. One of
the things they figured out is how to propagate rebasing between
clones!</p>
<h2>Comparing to Git</h2>
<p>Two years ago I would have said I would never opt to use Mercurial over
Git. I cannot say that today.</p>
<p>I do believe Git still has the advantage over Mercurial in a few areas:</p>
<ul>
<li>Branch management. Mercurial branches are a non-starter for
  light-weigh work. Mercurial bookmarks are kinda-sorta like Git
  branches, but not quite. I <em>really</em> like aspects of Git branches.
  Hopefully changeset evolution will cover the remaining gaps and more.</li>
<li>Patch conflict management. Git seems to do a better job of resolving
  patch conflicts. But, I think this is mostly due to Mercurial's patch
  queue extension not using the same merge code as built-in commands
  (this is a fixable problem).</li>
<li>Developer mind share and GitHub. The GitHub ecosystem makes up for
  many of Git's shortcomings. Bitbucket isn't the same.</li>
</ul>
<p>However, I believe Mercurial has the upper hand for:</p>
<ul>
<li>Command line friendliness. Git's command line syntax is notoriously
  awful and the concepts can be difficult to master.</li>
<li>Extensibility. It's so easy to program custom workflows and commands
  with Mercurial. If you want to hack your version control system,
  Mercurial wins hands down. Where Mercurial embraces extensibility, I
  couldn't even find a page listing all the useful Git <em>extensions</em>!</li>
<li>Open source culture. Every time I've popped into the Mercurial IRC
  channel I've had a good experience. I get a response quickly and
  without snark. Git by contrast, well, let's just say I'd rather be
  affiliated with the Mercurial crowd.</li>
<li>Future potential. Git is a content addressable key-value store with a
  version control system bolted on top. Mercurial is designed to be a
  version control system. Furthermore, Mercurial's code base is much
  easier to hack on than Git's. While Git has largely maintained feature
  parity in the last few years, Mercurial has grown new features. I see
  Mercurial evolving faster than Git and in ways Git cannot.</li>
</ul>
<p>It's worth calling out the major detractors for each.</p>
<p>I think Git's major weakness is its lack of extensibility and inability
to evolve (at least currently). Git will need to grow a better
extensibility model with better abstractions to compete with Mercurial
on new features. Or, the Git community will need to be receptive to
experimental features living in the core. All of this will require
some major API breakage. Unfortunately, I see little evidence this will
occur. I'm unable to find a <em>vision</em> document for the future of Git, a
branch with major new features, or interesting threads on the mailing
list. I tried to ask in their IRC channel and got crickets.</p>
<p>I think Mercurial's greatest weakness is lack of developer mindshare.
Git and GitHub are where it's at. This is huge, especially for projects
wanting collaboration.</p>
<p>Of all those points, I want to stress the extensibility and future
potential of Mercurial. If hacking your tools to maximize potential
and awesomeness is your game, Mercurial wins. End of debate. However,
if you don't want to harness these advantages, then I think Git and
Mercurial are mostly on equal footing. But given the rate of
development in the Mercurial project and relative stagnation of Git
(I can't name a major new Git feature in years), I wouldn't be
surprised if Mercurial's feature set obviously overtakes Git's in
the next year or two. Mind share will of course take longer and will
likely depend on what hosting sites like GitHub and Bitbucket do
(I wouldn't be surprised if GitHub rebranded as <em>CodeHub</em> or
something some day). Time will tell.</p>
<h2>Extending case study</h2>
<p><em>I have removed the case study that appeared in the original article
because as Mike Hommey observed in the comments, it wasn't a totally
accurate comparison. I don't believe the case study significantly added
much to the post, so I likely won't write a new one.</em></p>
<h2>Conclusion</h2>
<p>From where I started with Mercurial, I never thought I'd say this. But
here it goes: I like Mercurial.</p>
<p>I started warming up when it became faster and more robust in recent
versions in the last few years. When I learned about its flexibility and
the fundamentals of the project and thus its future potential, I became
a true fan.</p>
<p>It's easy to not like Mercurial if you are a new user coming
from Git and are forced to use a new tool. But, once you take the time to
properly configure it and appreciate it for what it is and what it
can be, Mercurial is easy to like.</p>
<p>I think Mercurial and Git are both fine version control systems. I would
happily use either one for a new project. If the social aspects of
development (including encouraging new contributors) were important to
me, I would likely select Git and GitHub. But, if I wanted something
just for me or I was a large project looking for a system that scales
and is flexible or was looking to the future, I'd go with Mercurial.</p>
<p>Mercurial is a rising star in the version control world. It's getting
faster and better and enabling others to more easily innovate through
powerful extensions. The future is bright for this tool.</p>]]></content>
  </entry>
</feed>
