<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">Gregory Szorc's Digital Home</title>
  <subtitle type="text">Rambling on</subtitle>

  <updated>2021-04-06T04:26:02Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog" />
  <id>http://gregoryszorc.com/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://gregoryszorc.com/blog/feed/atom/" />
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[MozReview Git Support and Improved Commit Mapping]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2016/02/08/mozreview-git-support-and-improved-commit-mapping" />
    <id>http://gregoryszorc.com/blog/2016/02/08/mozreview-git-support-and-improved-commit-mapping</id>
    <updated>2016-02-08T11:05:00Z</updated>
    <published>2016-02-08T11:05:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="MozReview" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[MozReview Git Support and Improved Commit Mapping]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2016/02/08/mozreview-git-support-and-improved-commit-mapping"><![CDATA[<p>MozReview - Mozilla's Review Board based code review tool - now
supports ingestion from Git. Previously, it only supported Mercurial.</p>
<p><a href="https://mozilla-version-control-tools.readthedocs.org/en/latest/mozreview/install-git.html">Instructions</a>
for configuring Git with MozReview are available. Because blog posts
are not an appropriate medium for documenting systems and processes, I
will not say anything more here on how to use Git with MozReview.</p>
<p>Somewhat related to the introduction of Git support is an improved
mechanism for mapping commits to existing review requests.</p>
<p>When you submit commits to MozReview, MozReview has to decide how
to <a href="https://mozilla-version-control-tools.readthedocs.org/en/latest/mozreview/commits.html#understanding-how-commits-are-mapped-to-review-requests">map</a>
those commits to review requests in Review Board. It has to choose
whether to recycle an existing review request or create a new one.
When recycling, is has to pick an appropriate one. If it chooses
incorrectly, wonky things can happen. For example, a review request
could switch to tracking a new and completely unrelated commit. That's
bad.</p>
<p>Up until today, our commit mapping algorithm was extremely simple. Yet
it seemed to work 90% of the time. However, a number of people
found the cracks and complained. With Git support coming online,
I had a feeling that Git users would find these cracks with higher
frequency than Mercurial users due to what I perceive to be
variations in the commit workflows of Git versus Mercurial. So,
I decided to proactively improve the commit mapping before the Git
users had time to complain.</p>
<p><strong>Both the Git and Mercurial MozReview client-side extensions now insert
a <em>MozReview-Commit-ID</em> metadata line in commit messages.</strong> This line
effectively defines a (likely) unique ID that identifies the commit
across rewrites. When MozReview maps commits to review requests,
it uses this identifier to find matches. What this means is that
history rewriting (such as reordering commits) should be handled
well by MozReview and should not confuse the commit mapping
mechanism.</p>
<p>I'm not claiming the commit mapping mechanism is perfect. In fact,
I know of areas where it can still fall apart. But it is much
better than it was before. If you think you found a bug in the
commit mapping, don't hesitate to
<a href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Developer%20Services&amp;component=MozReview">file a bug</a>.
Please have it block <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1243483">bug 1243483</a>.</p>
<p>A side-effect of introducing this improved commit mapping is that
commit messages will have a <em>MozReview-Commit-ID</em> line in them. This
may startle some. Some may complain about the <em>spam</em>. Unfortunately,
there's no better alternative. Both Mercurial and Git do support a
hidden key-value dictionary for each commit object. In fact, the
MozReview Mercurial extension has been storing the very commit IDs
that now appear in the commit message in this dictionary for months!
Unfortunately, actually using this hidden dictionary for metadata
storage is riddled with problems. For example, some Mercurial
commands don't preserve all the metadata. And accessing or setting
this data from Git is painful. While I wish this metadata (which
provides little value to humans) were not located in the commit
message where humans could be bothered by it, it's really the only
practical place to put it. If people find it super annoying, we
could modify Autoland to strip it before landing. Although, I think
I like having it preserved because it will enable some useful
scenarios down the road, such as better workflows for uplift
requests. It's also worth noting that there is precedent for storing
unique IDs in commit messages for purposes of commit mapping in the
code review tool: <a href="https://gerrit-documentation.storage.googleapis.com/Documentation/2.11.5/user-changeid.html">Gerrit uses Change-ID lines</a>.</p>
<p>I hope you enjoy the Git support and the more robust commit to review
request mapping mechanism!</p>]]></content>
  </entry>
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Making MozReview Faster by Disregarding RESTful Design]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2016/01/13/making-mozreview-faster-by-disregarding-restful-design" />
    <id>http://gregoryszorc.com/blog/2016/01/13/making-mozreview-faster-by-disregarding-restful-design</id>
    <updated>2016-01-13T15:25:00Z</updated>
    <published>2016-01-13T15:25:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="MozReview" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Making MozReview Faster by Disregarding RESTful Design]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2016/01/13/making-mozreview-faster-by-disregarding-restful-design"><![CDATA[<p>When I first started writing web services, I was a huge RESTful fan
boy. The architectural properties - especially the parts related to
caching and scalability - really jived with me. But as I've grown
older and gained experienced, I've realized that RESTful design,
like many aspects of software engineering, is more of a guideline
or ideal than a panacea. This post is about one of those experiences.</p>
<p><a href="https://www.reviewboard.org/docs/manual/2.5/webapi/">Review Board's Web API</a>
is RESTful. It's actually one of the better examples of a RESTful API
I've seen. There is a very clear separation between <em>resources</em>. And
everything - and I mean everything - is a resource. <em>Hyperlinks</em> are
used for the purposes described in Roy T. Fielding's dissertation.
I can tell the people who authored this web API understood RESTful
design and they succeeded in transferring that knowledge to a web API.</p>
<p>Mozilla's <a href="https://reviewboard.mozilla.org">MozReview code review tool</a>
is built on top of Review Board. We've made a number of customizations.
The most significant is the ability to submit a series of commits
as one logical review series. This occurs as a side-effect of a
<em>hg push</em> to the code review repository. Once your changesets
are pushed to the remote repository, that server issues a number of
Review Board Web API HTTP requests to reviewboard.mozilla.org to
create the review requests, assign reviewers, etc. This is mostly all
built on the built-in web API endpoints offered by Review Board.</p>
<p>Because Review Board's Web API adheres to RESTful design principles
so well, turning a series of commits into a series of review requests
takes a lot of HTTP requests. For each commit, we have to perform
something like 5 HTTP requests to define the server state. For
series of say 10 commits (which aren't uncommon since we try to
encourage the use of microcommits), this can add up to dozens of
HTTP requests! And that's just counting the HTTP requests to
Review Board: because we've integrated Review Board with Bugzilla,
events like publishing result in additional RESTful HTTP requests from
Review Board to bugzilla.mozilla.org.</p>
<p>At the end of the day, submitting and publishing a series of 10
commits consumes somewhere between 75 and 100 HTTP requests! While
the servers are all in close physical proximity (read: low network
latencies), we are reusing TCP connections, and each HTTP request
completes fairly quickly, the overhead adds up. <strong>It's not uncommon
for publishing commit series to take over 30s.</strong> This is unacceptable
to developers. We want them to publish commits for review as quickly
as possible so they can get on with their next task. Humans should not
have to wait on machines.</p>
<p>Over in <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1229468">bug 1220468</a>,
I implemented a new batch submit web API for Review Board and converted
the Mercurial server to call it instead of the classic, RESTful Review
Board web APIs. <strong>In other words, I threw away the RESTful properties
of the web API and implemented a monolith API doing exactly what we
need.</strong> The result is a drastic reduction in net HTTP requests. In our
tests, submitting a series of 20 commits for review reduced the HTTP
request count by 104! Furthermore, the new API endpoint performs
all modifications in a single database transaction. Before, each HTTP
request was independent and we had bugs where failures in the middle of
a HTTP request series left the server in inconsistent and unexpected
state. The new API is significantly faster and more atomic as a bonus.
The main reason the new implementation isn't yet nearly instantaneous
is because we're still performing several RESTful HTTP requests to
Bugzilla from Review Board. But there are plans for Bugzilla to
implement the batch APIs we need as well, so stay tuned.</p>
<p>(I don't want to blame the Review Board or Bugzilla maintainers for
their RESTful web APIs that are giving MozReview a bit of scaling pain.
MozReview is definitely abusing them almost certainly in ways that
weren't imagined when they were conceived. To their credit, the
maintainers of both products have recognized the limitations in their
APIs and are working to address them.)</p>
<p>As much as I still love the properties of RESTful design, there are
practical limitations and consequences such as what I described
above. The older and more experienced I get, the less patience I have
for tolerating architecturally pure implementations that sacrifice
important properties, such as ease of use and performance.</p>
<p>It's worth noting that many of the properties of RESTful design are
applicable to <em>microservices</em> as well. When you create a new service
in a microservices architecture, you are creating more overhead for
clients that need to speak to multiple services, making changes less
transactional and atomic, and making it difficult to consolidate
multiple related requests into a higher-level, simpler, and performant
API. I recommend
<a href="http://martinfowler.com/articles/microservice-trade-offs.html">Microservice Trade-Offs</a>
for more on this subject.</p>
<p>There is a place in the world for RESTful and microservice
architectures. And as someone who does a lot of server-side engineering,
I sympathize with wanting scalable, fault-tolerant architectures. But
like most complex problems, you need to be cognizant of trade-offs. It is
also important to not get too caught up with architectural purity if
it is getting in the way of delivering a simple, intuitive, and fast
product for your users. So, please, follow me down from the ivory tower.
The air was cleaner up there - but that was only because it was so
distant from the swamp at the base of the tower that surrounds every
software project.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Lowering the Barrier to Pushing to MozReview]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2015/10/14/lowering-the-barrier-to-pushing-to-mozreview" />
    <id>http://gregoryszorc.com/blog/2015/10/14/lowering-the-barrier-to-pushing-to-mozreview</id>
    <updated>2015-10-14T12:30:00Z</updated>
    <published>2015-10-14T12:30:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="MozReview" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Lowering the Barrier to Pushing to MozReview]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2015/10/14/lowering-the-barrier-to-pushing-to-mozreview"><![CDATA[<p>Starting today, a Mozilla LDAP account with Mercurial SSH access is no
longer required to <em>hg push</em> into
<a href="https://reviewboard.mozilla.org">MozReview</a> to initiate code review
with Mozilla projects.</p>
<p>The <a href="https://mozilla-version-control-tools.readthedocs.org/en/latest/mozreview/install.html">instructions for configuring your client to use MozReview</a>
have been updated to reflect how you can now push to MozReview over HTTP
using a Bugzilla API Key for authentication.</p>
<p>This change effectively enables first-time contributors to use MozReview
for code review. Before, you had to obtain an LDAP account and configure
your SSH client, both of which could be time consuming processes and
therefore discourage people from contributing. (Or you could just use
Bugzilla/Splinter and not get the benefits of MozReview, which many
did.)</p>
<p><strong>I encourage others to update contribution docs to start nudging people
towards MozReview over Bugzilla/patch-based workflows</strong> (such as
bzexport).</p>
<p><a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1195856">Bug 1195856</a>
tracked this feature.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[MozReview Statistics July 2015]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2015/07/16/mozreview-statistics-july-2015" />
    <id>http://gregoryszorc.com/blog/2015/07/16/mozreview-statistics-july-2015</id>
    <updated>2015-07-16T14:00:00Z</updated>
    <published>2015-07-16T14:00:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="MozReview" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[MozReview Statistics July 2015]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2015/07/16/mozreview-statistics-july-2015"><![CDATA[<p>As of today, ~15.6% of commits landing in Firefox in July have gone
through <a href="https://reviewboard.mozilla.org/">MozReview</a> or have been produced
on machines that have used MozReview. This is still a small percentage
of overall commits. But, signs are that the percentage is going up. Last
month, about half as many commits exhibited the same signature. It's
only July 16 and we've already passed the total from June.</p>
<p>What I find interesting is the differences between commits that have
gone through MozReview versus the rest. When you look at the diff
statistics (a quick proxy of change size), we find that MozReview
commits tend to be smaller. The median <em>adds</em> as reported by diff stat
(basically lines that were changed) is 12 for MozReview versus 17
elsewhere. The average is 58 for MozReview versus 100 elsewhere. For
number of files modified, MozReview averages 2.59 versus elsewhere's
2.71. (These numbers exclude some specific large commits that appeared to
be bulk imports of external projects and drove up the non-MozReview
figures.)</p>
<p>It's entirely possible the root cause behind the discrepancy is a
side-effect of the population of MozReview users: perhaps MozReview
users just write smaller commits. However, I'd like to think it's because
MozReview makes it easier to manage multiple commits and people are taking
advantage of that (this is an explicit design goal of MozReview). Whatever
the root cause, I'm glad diffs are smaller.
As I've <a href="/blog/2014/10/27/implications-of-using-bugzilla-for-firefox-patch-development/">written about before</a>,
smaller commits are easier to review and land, thus enabling projects to
move faster.</p>
<p>I have a quarterly goal to remove the requirement for a Mozilla LDAP
account to push to MozReview. That will allow first time contributors to
use MozReview. This will be a huge win, as we can do much more magic in
the MozReview world than we can from vanilla Bugzilla (automatic bug
filing, automatic reviewer assignment, etc). Unofficially, I'd like to
have more than 50% of Firefox commits go through MozReview by the end of
the year.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Publish When Pushing to MozReview]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2015/07/07/publish-when-pushing-to-mozreview" />
    <id>http://gregoryszorc.com/blog/2015/07/07/publish-when-pushing-to-mozreview</id>
    <updated>2015-07-07T14:55:00Z</updated>
    <published>2015-07-07T14:55:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="MozReview" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Publish When Pushing to MozReview]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2015/07/07/publish-when-pushing-to-mozreview"><![CDATA[<p>A lot of people contributed some really great feedback about MozReview
at Whistler. One of the most frequent requests was for the ability to
publish submitted review requests without having to open a browser.
I'm pleased to report that as of yesterday, this feature is implemented!
If reviewers have been assigned to all your review requests, Mercurial
will now prompt you to publish the review requests during <em>hg push</em>.
It should <em>just work</em>.</p>
<p>As part of this change, we also introduced more advanced feature
negotiation into the handshake between client and server. This means
we now have a mechanism for detecting out-of-date client installations.
This will enable us to more aggressively drop backwards compatibility
(making server-side development easier) while simultaneously ensuring
that more people are running modern and hopefully better versions of the
client code. This should translate to moving faster and a better
experience for everyone.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Important Changes to MozReview]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2015/05/29/important-changes-to-mozreview" />
    <id>http://gregoryszorc.com/blog/2015/05/29/important-changes-to-mozreview</id>
    <updated>2015-05-29T16:20:00Z</updated>
    <published>2015-05-29T16:20:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="MozReview" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="code review" />
    <summary type="html"><![CDATA[Important Changes to MozReview]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2015/05/29/important-changes-to-mozreview"><![CDATA[<p>This was a busy week for MozReview! There are a number of changes people
need to be aware of.</p>
<h2>Support for Specifying Reviewers via Commit Messages</h2>
<p>MozReview will now parse <strong>r?gps</strong> syntax out of commit messages to
set reviewers for pushed commits.</p>
<p><a href="https://mozilla-version-control-tools.readthedocs.org/en/latest/mozreview/review-requests.html#specifying-reviewers-in-commit-messages">Read the docs</a>
for more information, including why we are preferring <strong>r?</strong> to <strong>r=</strong>.</p>
<p>Since it landed, a number of workflow concerns have been reported.
See the bug tree for
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1142251">bug 1142251</a>
before filing a bug to help avoid duplicates.</p>
<p>Thank Dan Minor for the feature!</p>
<h2>Review Attachment/Flag Per Commit</h2>
<p>Since the beginning of MozReview, there was one Bugzilla attachment /
review flag per commit series. This has changed to one attachment /
review flag per commit.</p>
<p>Before, you needed to grant <em>Ship It</em> on the parent/root review request
in order to r+ the MozReview review request. Now, you grant <em>Ship It</em>
on individual commits and these turn into individual r+ on Bugzilla.
To reinforce that reviewing the parent/root review request doesn't do
anything meaningful any more, the <em>Ship It</em> button and checkbox have been
removed from the parent/root review request.</p>
<p>The new model more closely maps to how code review in Bugzilla has
worked at Mozilla for ages. And, it is a superior workflow for
future workflows we're trying to enable.</p>
<p>We tried to run a one-time migration script to convert existing
parent/root attachments/review flags to per-commit attachments/flags.
However, there were issues. We will attempt again sometime next week.
In the interim, <strong>in-flight review requests may enter an inconsistent
state if they are updated</strong>. If a new push is performed, the old
parent/root attachment/review flag may linger and per-commit
attachments/flags will be created. This could be confusing. The
workaround is to manually clear the r? flag from the parent/root
attachment or wait for the migration script to run in a few days.</p>
<p>Mark Côté put in a lot of hard work to make this change happen.</p>
<h2>r? Flags Cleared After Review</h2>
<p>Before, submitting a review without granting <em>Ship It</em> wouldn't do
anything to the r? flag: the r? flag would linger.</p>
<p>Now, submitting review without granting <em>Ship It</em> will clear the r?
flag. We think the new default is better for the majority of users.
However, we recognize it isn't always wanted. There is a bug open to
provide a checkbox to keep the r? flag present.</p>
<h2>Metadata Added to Changesets</h2>
<p>If you update to the tip of the version-control-tools repository
(you should do this every week or so to stay fresh - use <em>mach
mercurial-setup</em> to do this automatically), metadata will automatically
be added to commits when working with MozReview-enabled repositories.</p>
<p>Specifically, we insert a hidden, unique, random ID into every changeset.
This ID can be used to map commits to each other. We don't use this ID
yet. But we have plans.</p>
<p>A side-effect of this change is that you can no longer push to MozReview
if you have uncommitted local changes. If this is annoying, use <em>hg
shelve</em> and <em>hg unshelve</em> to create and undo temporary commits. If this
is too annoying, complain by filing a bug and we can look into doing
this automatically as part of pushing.</p>
<h2>What's Next?</h2>
<p>We're actively working on more workflow enhancements to make MozReview
an even more compelling experience.</p>
<p>I'm building a web service to query file metadata from moz.build files.
This will allow MozReview to automatically file bugs in proper
components based on what files changed. Once code reviewer metadata
is added to moz.build files, it will enable us to assign reviewers
automatically as well. The end goal here is to lower the number of steps
needed to turn changed code into a landing. This will be useful when we
turn GitHub pull requests into MozReview review requests (random GitHub
contributors shouldn't need to know who to flag for review, nor should
they be required to file a bug if they write some code). Oh year, we're
working on integrating GitHub pull requests.</p>
<p>Another area of focus is better commit tracking and partially landed
series. I have preliminary patches for automatically adding review URL
annotations to commit messages. This will enable people to easily go
from commit (message) to MozReview, without having to jump through
Bugzilla. This also enables better commit tracking. If you e.g.
perform complicated history rewriting, the review URL annotation will
enable the MozReview server to better map previously-submitted commits
to existing review requests. Partially landed series will enable
commits to land as soon as they are reviewed, without having to wait
on the entire series. It's my strong belief that if a commit is granted
review, it should land as soon as possible. This helps prevent bit rot
of ready-to-land commits. Landings also make people feel better because
you feel like you've accomplished something. Positive feedback loops are
good.</p>
<p>Major work is also being done to overhaul the web UI. The commit series
view (which is currently populated via XHR) will soon be generated on
the server and served as part of the page. This should make pages load a
bit faster. And, things should be prettier as well.</p>
<p>And, of course, work is being invested into Autoland. Support for
submitting pushes to Try landed a few weeks ago. Having Autoland
actually land reviewed commits is on the radar.</p>
<p>Exciting times are ahead. Please continue to provide feedback. If you
see something, <a href="https://mozilla-version-control-tools.readthedocs.org/en/latest/hacking-mozreview.html#filing-bugs">say something</a>.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Commit Part Numbers and MozReview]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2015/01/27/commit-part-numbers-and-mozreview" />
    <id>http://gregoryszorc.com/blog/2015/01/27/commit-part-numbers-and-mozreview</id>
    <updated>2015-01-27T20:17:00Z</updated>
    <published>2015-01-27T20:17:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="MozReview" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="code review" />
    <summary type="html"><![CDATA[Commit Part Numbers and MozReview]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2015/01/27/commit-part-numbers-and-mozreview"><![CDATA[<p>It is common for commit messages in Firefox to contains strings like
<em>Part 1</em>, <em>Part 2</em>, etc. See
<a href="https://hg.mozilla.org/projects/build-system/pushloghtml?changeset=5cb8bcab09cc">this push</a>
for <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=784841">bug 784841</a>
for an extreme multi-part example.</p>
<p>When code review is conducted in Bugzilla, these identifiers are
necessary because Bugzilla orders attachments/patches in the order they
were updated or their patch title (I'm not actually sure!). If part
numbers were omitted, it could be very confusing trying to figure out
which order patches should be applied in.</p>
<p>However, when code review is conducted in
<a href="https://mozilla-version-control-tools.readthedocs.org/en/latest/mozreview.html">MozReview</a>,
<strong>there is no need for explicit part numbers to convey ordering</strong> because
the ordering of commits is implicitly defined by the repository history
that you pushed to MozReview!</p>
<p>I argue that if you are using MozReview, you should stop writing <em>Part
N</em> in your commit messages, as it provides little to no benefit.</p>
<p>I, for one, welcome this new world order: I've previously wasted a lot
of time rewriting commit messages to reflect new part ordering after
doing history rewriting. With MozReview, that overhead is gone and I
barely pay a penalty for rewriting history, something that often
produces a more reviewable series of commits and makes reviewing
and landing a complex patch series significantly easier.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Automatic Python Static Analysis on MozReview]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2015/01/24/automatic-python-static-analysis-on-mozreview" />
    <id>http://gregoryszorc.com/blog/2015/01/24/automatic-python-static-analysis-on-mozreview</id>
    <updated>2015-01-24T23:30:00Z</updated>
    <published>2015-01-24T23:30:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Python" />
    <category scheme="http://gregoryszorc.com/blog" term="MozReview" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="code review" />
    <summary type="html"><![CDATA[Automatic Python Static Analysis on MozReview]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2015/01/24/automatic-python-static-analysis-on-mozreview"><![CDATA[<p>A bunch of us were in Toronto last week hacking on MozReview.</p>
<p>One of the cool things we did was deploy a bot for performing Python
static analysis. If you submit some .py files to MozReview, the bot
should leave a review. If it finds violations (it uses
<a href="https://flake8.readthedocs.org/">flake8</a> internally), it will open
an issue for each violation. It also leaves a comment that should
hopefully give enough detail on how to fix the problem.</p>
<p>While we haven't done much in the way of performance optimizations,
the bot typically submits results less than 10 seconds after the review
is posted! So, a human should never be reviewing Python that the bot
hasn't seen. This means you can stop thinking about style nits and start
thinking about what the code does.</p>
<p>This bot should be considered an alpha feature. The code for the bot
isn't even checked in yet. We're running the bot against production
to get a feel for how it behaves. If things don't go well, we'll turn
it off until the problems are fixed.</p>
<p>We'd like to eventually deploy C++, JavaScript, etc bots. Python won out
because it was the easiest to integrate (it has sane and efficient
tooling that is compatible with Mozilla's code bases - most existing
JavaScript tools won't work with Gecko-flavored JavaScript, sadly).</p>
<p>I'd also like to eventually make it easier to locally run the same
static analysis we run in MozReview. Addressing problems locally before
pushing is a no-brainer since it avoids needless context switching from
other people and is thus better for productivity. This will come in
time.</p>
<p>Report issues in #mozreview or in the Developer Services :: MozReview
Bugzilla component.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Bugzilla and the Future of Firefox Development]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2015/01/16/bugzilla-and-the-future-of-firefox-development" />
    <id>http://gregoryszorc.com/blog/2015/01/16/bugzilla-and-the-future-of-firefox-development</id>
    <updated>2015-01-16T10:50:00Z</updated>
    <published>2015-01-16T10:50:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="MozReview" />
    <category scheme="http://gregoryszorc.com/blog" term="Bugzilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="code review" />
    <summary type="html"><![CDATA[Bugzilla and the Future of Firefox Development]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2015/01/16/bugzilla-and-the-future-of-firefox-development"><![CDATA[<p><a href="https://bugzilla.mozilla.org">Bugzilla</a> has played a major role in the
Firefox development process for over 15 years. <strong>With upcoming changes
to how code changes to Firefox are submitted and reviewed, I think it is
time to revisit the central role of Bugzilla and bugs in the Firefox
development process.</strong> I know this is a contentious thing to say. Please,
gather your breath, and calmly read on as I explain why I believe this.</p>
<p>The current Firefox change process defaults to requiring a Bugzilla bug
for everything. It is rare (and from my experience frowned upon) when a
commit to Firefox doesn't reference a bug number. We've essentially made
Bugzilla and a bug prerequisites for changing anything in the Firefox
version control repository. For the remainder of this post, I'm going to
say that we <em>require</em> a bug for any change, even though that statement
isn't technically accurate. Also, when I say <em>Bugzilla</em>, I mean
<em>bugzilla.mozilla.org</em>, not the generic project.</p>
<p>Before I go on, let's boil the Firefox change process down to basics.</p>
<p>At the heart of any change to the Firefox source repository is a diff.
The diff (a representation of the differences between a set of files)
is the smallest piece of data necessary to represent a change to the
Firefox code. I argue that anything more than the vanilla diff is
overhead and could contribute to
<a href="/blog/2015/01/09/firefox-contribution-process-debt/">process debt</a>.
Now, there is some essential overhead. Version control tools supplement
diffs with metadata, such as the author, commit message, and date. Mozilla
has also instituted a near-mandatory code review policy, where changes
need to be signed off by a set of trusted individuals. I view both of
these additions to the vanilla diff as essential for Firefox development
and non-negotiable. Therefore, the bare minimum requirements for changing
Firefox code are a diff plus metadata (a commit/patch) and (almost
always) a review/sign-off. That's it. Notably absent from this list is a
Bugzilla bug. <strong>I argue that a bug is not strictly required to
change Firefox.</strong> Instead, we've instituted a near-universal policy
that we should have bugs. We've <strong>chosen</strong> to add overhead and process
debt - interaction with Bugzilla - to our Firefox change process.</p>
<p>Now, this choice to require all changes be associated with bugs has its
merits. Bugs provide excellent anchor points for historical context and
for additional information after the change has been committed and is
forever set in stone in the repository (commits are immutable in
Mercurial and Git and you can't easily attach metadata to the commit
after the fact). Bugs are great to track relationships between different
problems or units of work. Bugs can even be used to track progress
towards a large feature. Bugzilla components also provide a decent
mechanism to follow related activity. There's also a lot of tooling and
familiar process standing on top of the Bugzilla <em>platform</em>. There's a
lot to love here and I don't want diminish the importance of all these
things.</p>
<p><strong>When I look to the future, I see a world where the current, central
role of Bugzilla and bugs as part of the Firefox change process begin to
wane.</strong> I see a world where the benefits to maintaining our current
Bugzilla-centric workflow start to erode and the cost of maintaining
it becomes higher and harder to justify. You actually don't have to look
too far into the future: that world is already here and I've already
started to feel the pains of it.</p>
<p>A few days ago, I blogged about
<a href="/blog/2015/01/10/code-first-and-the-rise-of-the-dvcs-and-github/">GitHub and its code first approach to change</a>.
That post was spun off from an early draft of this post (as were the
posts about <a href="/blog/2015/01/09/firefox-contribution-process-debt/">Firefox contribution debt</a>
and <a href="/blog/2015/01/12/utilizing-github-for-firefox-development/">utilizing GitHub for Firefox development</a>).
I wanted to introduce the concept of <em>code first</em> because it is
central to my justification for changing how we do things. In summary,
<strong>code first capitalizes on the fact that any change to software
involves code and therefore puts code front and center in the change
process.</strong> (In hindsight, I probably should have used the term <em>code
centric</em>, because that's how I want people to think about things.) So
how does <em>code first</em> relate to Bugzilla and Firefox development?</p>
<p>Historically, code review has occurred in Bugzilla: upload a patch to
Bugzilla, ask for review, and someone will look at it. And, since
practically every change to Firefox requires review, you need a bug in
Bugzilla to contain that review. Thus, <strong>one way to view a bug is as a
vehicle for code review</strong>. Not every bug is <em>just</em> a code review, of
course. But a good number of them are.</p>
<p>The only constant is change. And <strong>the way Mozilla conducts code review
for changes to Firefox (and other projects) is changing</strong>. We now have
<a href="https://mozilla-version-control-tools.readthedocs.org/en/latest/mozreview.html">MozReview</a>,
a code review tool that is <em>not Bugzilla</em>. If we start accepting GitHub
pull requests, we <em>may</em> perform reviews exclusively on GitHub, another
tool that is <em>not Bugzilla</em>.</p>
<p>(Before I go on, I want to quickly point out that MozReview is nowhere
close to its final form. Parts of MozReview are pretty bad right now.
The maintainers all know this and we have plans to fix it. We'll be in
Toronto all of next week working on it. If you don't think you'll ever
use it because parts are bad today, I ask you to withhold judgement for
a few more months.)</p>
<p>In case you were wondering, the question on whether Bugzilla should
always be used for code review for Firefox has been answered and that
answer is <em>no</em>. People, including maintainers of Bugzilla, realized
that better-than-Splinter/Bugzilla code review tools exist and that
continuing to invest time to develop Bugzilla/Splinter into a
best-in-class code review tool would be better spent <em>integrating</em>
Bugzilla with an existing tool. This is why we now have a
<a href="https://www.reviewboard.org/">Review Board</a> based code review tool -
MozReview - integrated with Bugzilla. If you care about code quality and
more powerful workflows, you should be rejoicing at this because
<a href="/blog/2014/10/27/implications-of-using-bugzilla-for-firefox-patch-development/">the implementation of code review in Bugzilla does not maximize optimal outcomes</a>.</p>
<p>The world we're moving to is one where code review occurs outside of
Bugzilla. This raises an important question: <strong>if Bugzilla was being used
primarily as a vehicle for code review, what benefit and/or role should
Bugzilla play when code review is conducted outside of Bugzilla?</strong></p>
<p><strong>I posit that there are a class of bugs that won't need to exist
going forward because bugs will provide little to no value.</strong> Put
another way, I believe that a growing number of commits to the Firefox
repository won't reference bugs.</p>
<p>Come with me on a journey to the future.</p>
<p>MozReview is purposefully being designed in a code and repository
centric way. To initiate the formal process for considering a change to
code, you push to a Mercurial (or Git!) repository. This could be
directly to Mozilla's review repository. If I have my way, this could
even be kicked off by submitting a pull request on GitHub or Bitbucket.
No Bugzilla attachment uploading here: our systems talk in terms of
repositories and commits. Again, this is by design: we don't want
submitting code to Mozilla to be any harder than <em>hg push</em> or <em>git
push</em> so as to not introduce <em>process debt</em>. If you have code, you'll be
able to send it to us.</p>
<p>In the near future, MozReview will stop cross-posting detailed review
updates to Bugzilla. Instead, we'll use Review Board's e-mail feature
to send its flavor of emails. These will have rich HTML content (or
plain text if you insist) and will provide a better experience
than Bugzilla ever will. We'll adopt the model of tools like
Phabricator and GitHub and only post summaries or links of activity,
not full content, to bugs. You may be familiar with the concept as
applied to the web: it's called hyperlinking.</p>
<p>Work is being invested into Autoland. Autoland is an automated landing
queue that pushes/lands commits semi-automatically once they are ready
(have review, pass automation, etc). Think of Autoland as a bot that
does all the labor intensive and menial actions around pushing that
you do now. I believe Autoland will eventually handle near 100% of
pushes to the Firefox repository. And, if I have my way, Autoland will
result in the abolishment of <em>integration branches</em> and merge commits in
the Firefox repository. Good riddance.</p>
<p>MozReview and Autoland will be highly integrated. MozReview will be the
primary user interface for interacting with Autoland. (Some of this
should be in place by the end of the quarter.)</p>
<p>In this world, MozReview and its underlying version control repositories
essentially become a <em>database</em> of all submitted, pending, and discarded
commits to Firefox. The metaphorical <em>primary keys</em> of this <em>database</em>
are not bug numbers: they are code/commits. (Code first!) Some of the
flags stored in this <em>database</em> tell Autoland what it should do. And the
MozReview user interface (and API) provide a mechanism into controlling
those flags.</p>
<p>Landing a change in Firefox will be initiated by a simple action such as
clicking a checkbox in MozReview. (That could even be the <em>Grant Review</em>
checkbox.) Commits cleared for landing will be picked up by
Autoland and eventually automatically pushed to the Firefox repository
(assuming the build and test automation is happy, of course). Once
Autoland takes control, humans are just passengers. We won't be bothered
with menial tasks like updating the commit message to reflect a review
was performed: this will happen automatically inside MozReview or
Autoland. (Although, there's a chance we may adopt some PGP-based
signing to more strongly convey review for some code changes in order to
facilitate stronger auditing and trust guarantees. Stay tuned.)
Likewise, if a commit becomes associated with a bug, we can add that
metadata to the commit before it is landed, no human involvement
necessary beyond specifying the link in the MozReview web UI (or API).
Autoland/MozReview will close review requests and/or bugs automatically.
(Are you excited about performing less work yet?)</p>
<p>When commits are added to MozReview, <strong>MozReview will read metadata from
the repository they came from to automatically determine an appropriate
reviewer</strong>. (We <a href="https://groups.google.com/d/msg/mozilla.dev.platform/iXr70VgapWk/GkTCcKRjNi8J">plan</a>
to leverage moz.build files for this in the case of Firefox.) This
should eliminate a lot of <em>process debt</em> around choosing a reviewer.
<strong>Similar metadata will also be used to determine what Bugzilla component
a change is related to, static analysis rules to use to critique the
phsyical structure of the change, and even automation jobs that should
be executed given the set of files that changed.</strong> The use of this
metadata will erode significant <em>process debt</em> around the change
contribution workflow.</p>
<p>As commits are pushed into MozReview/Autoland, the systems will be
intelligent about automatically tracking dependencies and facilitating
complex development workflows that people run into on a daily basis.</p>
<p>If I create a commit on top of someone else's commit that hasn't been
checked in yet, MozReview will detect the dependency between
my changes and the parent ones. This is an advantage of being code
first: by interfacing with repositories rather than patch files, you
have an explicit dependency graph embedded in the repository commit DAG
that can be used to aid machines in their activities.</p>
<p>It will also be possible to partially land a series of commits. If I get
review on the first 5 of 10 commits but things stall on commit 6, I can ask
Autoland to land the already-reviewed commits so they don't get bit
rotted and so you have partial progress (psychological studies show that
a partial reward for work results in greater happiness through a sense
of accomplishment).</p>
<p>Since initiating actions in MozReview is light weight (just <em>hg push</em>),
itch scratching is encouraged. I don't know about you, but in the course
of working on the Firefox code base, I frequently find myself wanting to
make small, 15-30s changes to fix something really minor. In today's world,
the overhead for these small changes is often high. I need to upload a
separate patch to Bugzilla. Sometimes I even need to create a new bug to
hold that patch. If that patch depends on other work I did, I need to
set up bug dependencies then worry about landing everything in the right
order. All of a sudden, the overhead isn't worth it and my positive
intentions go unacted on. Multiplied by hundreds of developers over
many years, and you can imagine the effect on software quality. With
MozReview, the overhead for itch scratching like this is minor. Just
make a small commit, push, and the system will sort everything out.
(These small commits are where I think a <em>bugless</em> process really
shines.)</p>
<p>This future world revolves around code and commits and operations on
them. While <em>MozReview</em> has <em>review</em> in its name, it's more than a
review tool: it's a <em>database</em> and interface to code and its state.</p>
<p><strong>In this code first world, Bugzilla performs an ancillary role.</strong>
Bugzilla is still there. Bugs are still there. MozReview review requests
and commits <em>link</em> to bugs. But it is the code, not bugs, that are king.
If you want to do anything with code, you interact with the code
tools. And Bugzilla is not one of them.</p>
<p>Another way of looking at this is that nearly everything involving code
or commits becomes excised from Bugzilla. This would relegate Bugzilla
to, well, an issue/bug tracker. And - ta da - that's something it excels
at since that's what it was originally designed to do! MozReview will
provide an adequate platform to discuss code (a platform that Bugzilla
provides today since it hosts code review). So if <em>not Bugzilla</em>
tools are handling everything related to code, do you really need a bug
any more?</p>
<p>This is the future we're trying to build with MozReview and Autoland.
And this is why I think bugs and Bugzilla will play a less central role
in the development process of Firefox in the future.</p>
<p>Yes, there are many consequences and concerns about making this shift.
You would be rational to be skeptical and doubt that this is the right
thing to do. I have another post in the works that attempts to outline
some common conerns and propose solutions to many of them. Before writing
a long comment pointing out every way in which this will fail to work,
I encourage you to wait for that post to be published. Stay tuned.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[The Mozlandia Tree Outage and Code Review]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2014/12/04/the-mozlandia-tree-outage-and-code-review" />
    <id>http://gregoryszorc.com/blog/2014/12/04/the-mozlandia-tree-outage-and-code-review</id>
    <updated>2014-12-04T08:40:00Z</updated>
    <published>2014-12-04T08:40:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="MozReview" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="code review" />
    <summary type="html"><![CDATA[The Mozlandia Tree Outage and Code Review]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2014/12/04/the-mozlandia-tree-outage-and-code-review"><![CDATA[<p>You may have noticed the Firefox trees
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1107156">were closed</a>
for the better part of yesterday.</p>
<p>Long story short, a file containing URLs for Firefox installers was
updated to reference https://ftp.mozilla.org/ from
http://download-installer.cdn.mozilla.net/. The original, latter
host is a CDN. The former is not. When thousands of clients started
hitting ftp.mozilla.org, it overwhelmed the servers and network,
causing timeouts and other badness.</p>
<p>The change in question was accidental. It went through code review.
From a code change standpoint, procedures were followed.</p>
<p>It is tempting to point fingers at the people involved. However, I
want us to consider placing blame elsewhere: on the code review
tool.</p>
<p>The diff being reviewed was to change the Firefox version number
from 32.0 to 32.0.3. If you were asked to review this
patch, I'm guessing your eyes would have glanced over everything in the
URL except the version number part. I'm pretty sure mine would have.</p>
<p>Let's take a look at what the reviewer saw in Bugzilla/Splinter (click
to see full size):</p>
<p><a href="/images/intraline-splinter.png">
<img src="/images/intraline-splinter.png" width="600" />
</a></p>
<p>And here is what the reviewer would have seen had the review been
conducted in MozReview:</p>
<p><a href="/images/intraline-reviewboard.png">
<img src="/images/intraline-reviewboard.png" width="600">
</a></p>
<p>Which tool makes the change of hostname more obvious? Bugzilla/Splinter
or MozReview?</p>
<p><strong>MozReview's support for intraline diffs more clearly draws attention to
the hostname change. I posit that had this patch been reviewed with
MozReview, the chances are greater we wouldn't have had a network
outage yesterday.</strong></p>
<p>And it isn't just intraline diffs that make Splinter/Bugzilla a
sub-optimal code review tool. I recently blogged about the
<a href="/blog/2014/10/27/implications-of-using-bugzilla-for-firefox-patch-development/">numerous ways that using Bugzilla for code revie results in harder
reviews and buggier
code</a>.
Every day we continue using Bugzilla/Splinter instead of investing in
better code review tools is a day severe bugs like this can and will
slip through the cracks.</p>
<p>If there is any silver lining to this outage, I hope it is that we need
to double down on our investment in developer tools, particularly code
review.</p>]]></content>
  </entry>
</feed>
