


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
Design by Free CSS Templates
http://www.freecsstemplates.org
Released for free under a Creative Commons Attribution 2.5 License

Name       : Pollinating  
Description: A two-column, fixed-width design with dark color scheme.
Version    : 1.0
Released   : 20101114

-->
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    
  <title>Gregory Szorc's Digital Home
</title>
<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
<link rel="alternate" type="application/atom+xml" title="Atom 1.0"
href="/blog/feed/atom" />
<link rel="stylesheet" href="/style/style.css" type="text/css" />
<link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />


  </head>
  <body>
    <div id="wrapper">
      
  <div id="menu">
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="/blog/">Blog</a></li>
    <li><a href="/notes">Notes</a></li>
    <li><a href="/work.html">Work</a></li>
    <li><a href="/skills.html">Skills</a></li>
    <li><a href="/thoughts.html">Thoughts</a></li>
    <li><a href="/resume.pdf">Resume</a></li>
  </ul>
</div>


      <div id="page">
        <div id="page-bgtop">
          <div id="page-bgbtm">
              <div id="content">
                
  
<div class="blog_post">
  <a name="update-bugzilla-automatically-on-push"></a>
  <h2 class="blog_post_title"><a href="/blog/2014/06/30/update-bugzilla-automatically-on-push" rel="bookmark" title="Permanent Link to Update Bugzilla Automatically on Push">Update Bugzilla Automatically on Push</a></h2>
  <small>June 30, 2014 at 11:15 PM | categories: 

<a href='/blog/category/mercurial'>Mercurial</a>, <a href='/blog/category/mozilla'>Mozilla</a>
 | <a href="http://gregoryszorc.com/blog/2014/06/30/update-bugzilla-automatically-on-push#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>Do you manually create Bugzilla comments when you push changes to a
Firefox source repository? Yeah, I do too.</p>
<p>That's always annoyed me.</p>
<p>It is screaming to be automated.</p>
<p>So I automated it.</p>
<p>You can too. From a Firefox source checkout:</p>
<p>$ ./mach mercurial-setup</p>
<p>That should clone the
<a href="https://hg.mozilla.org/hgcustom/version-control-tools/">version-control-tools</a>
repository into <em>~/.mozbuild/version-control-tools</em>.</p>
<p>Then, add the following to your <em>~/.hgrc</em> file:</p>
<div class="pygments_murphy"><pre><span class="k">[extensions]</span>
<span class="na">bzpost</span> <span class="o">=</span> <span class="s">~/.mozbuild/version-control-tools/hgext/bzpost</span>

<span class="k">[bugzilla]</span>
<span class="na">username</span> <span class="o">=</span> <span class="s">me@example.com</span>
<span class="na">password</span> <span class="o">=</span> <span class="s">password</span>
</pre></div>

<p>Now, when you <em>hg push</em> to a Firefox repository, the commit URLs will
get posted to referenced bugs automatically.</p>
<p>Please note that pushing to <em>release</em> trees such as mozilla-central is
not yet supported. In due time.</p>
<p>Please let me know if you run into any issues.</p>
<h2>Estimated Cost Savings</h2>
<p>Assuming the following:</p>
<ul>
<li>It costs Mozilla $200,000 per year per full-time engineer working on
  Firefox (a general rule of thumb for non-senior positions is that your
  true employee cost is 2x your base salary).</li>
<li>Each full-time engineer works 40 hours per week for 46 weeks out of
  the year.</li>
<li>It takes 15 seconds to manually update Bugzilla for each push.</li>
<li>There are 20,000 pushes requiring Bugzilla attention per year.</li>
</ul>
<p>We arrive at the following:</p>
<ul>
<li>Cost per employee per hour worked: $108.70</li>
<li>Total person-time to manually update Bugzilla: ~83 hours</li>
<li>Total cost to manually update Bugzilla after push: $9,058.</li>
</ul>
<p>I was intentionally conservative with all the inputs except time
worked (I think many of us work more than 40 hour weeks).
My estimates also don't take into account the lost productivity
associated with getting mentally derailed by interacting with Bugzilla.
With this in mind, I could very easily justify a total cost at
least 2x-3x higher.</p>
<p>It took me maybe 3 hours to crank this out. I could spend another few
weeks on it full time and Mozilla would still save money (assuming
100% adoption).</p>
<p>I encourage people to run their own cost calculations on other tasks
that can be automated. Inefficiencies multiplied by millions of dollars
(your collective employee cost) result in large piles of money. Not
having tools (even simple ones like this) is equivalent to setting
loads of cash on fire.</p>

  </div>
</div>



  <div class="after_post"><a href="http://gregoryszorc.com/blog/2014/06/30/update-bugzilla-automatically-on-push#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  
<div class="blog_post">
  <a name="track-firefox-repositories-with-local-only-mercurial-tags"></a>
  <h2 class="blog_post_title"><a href="/blog/2014/06/30/track-firefox-repositories-with-local-only-mercurial-tags" rel="bookmark" title="Permanent Link to Track Firefox Repositories with Local-Only Mercurial Tags">Track Firefox Repositories with Local-Only Mercurial Tags</a></h2>
  <small>June 30, 2014 at 10:25 AM | categories: 

<a href='/blog/category/mercurial'>Mercurial</a>, <a href='/blog/category/mozilla'>Mozilla</a>
 | <a href="http://gregoryszorc.com/blog/2014/06/30/track-firefox-repositories-with-local-only-mercurial-tags#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>After reading my recent
<a href="/blog/2014/06/23/please-stop-using-mq/">Please Stop Using MQ</a> post,
a number of people asked me about my development workflow. While I
still owe a full answer to that question, one of the cornerstores
is a unified Mercurial repository. Instead of having separate clones
for mozilla-central, mozilla-inbound, aurora, beta, etc, I have a
single clone with the changesets from all the repositories.</p>
<p>I feel having a unified repository has made me more productive. I no
longer have to waste time shuffling changesets between local clones.
This introduced all kinds of extra cognitive load and manual
processes that slowed me down. I highly encourage others to adopt
unified repositories.</p>
<p>Because the various Firefox repositories don't have unique branches
or bookmarks tracking the various heads, aggregating multiple
repositories introduces a client-side problem of identifying
which head is which. If you merely do a <em>hg pull</em>, you'll get a
bunch of anonymous heads.</p>
<p>To solve this problem, you'll need to employ minor client-side
magic. Previously, I <a href="/2013/07/22/mercurial-extension-for-gecko-development/">recommended</a>
my heavyweight <em>mozext</em> extension.</p>
<p>Today, I'm proud to announce a new, lighter extension:
<a href="https://hg.mozilla.org/hgcustom/version-control-tools/file/default/hgext/firefoxtree/__init__.py">firefoxtree</a>.
When pulling from a known Firefox repository, this extension will add
a local-only Mercurial tag for that repository. For example,
when pulling mozilla-central, the <em>central</em> tag will be created.</p>
<p>Local-only tags are a Mercurial feature only available to
extensions. A local-only tag is effectively an overlay of tags
that don't get transferred as part of push and pull operations.
They behave like normal tags: you can <em>hg up</em> to them and reference
them elsewhere changeset identifiers are used. They are also read
only: if you update to a tag and then commit, the tag will not
move forward (contrast with branches or bookmarks).</p>
<h2>Example Usage</h2>
<p>Clone <em>https://hg.mozilla.org/hgcustom/version-control-tools</em> and add
the following to your <em>.hg/hgrc</em>:</p>
<pre><code>[extensions]
firefoxtree = /path/to/version-control-tools/hgext/firefoxtree
</code></pre>
<p>To use, simply pull from a Firefox repo:</p>
<div class="pygments_murphy"><pre><span class="nv">$ </span>hg pull https://hg.mozilla.org/mozilla-central

<span class="nv">$ </span>hg up central

<span class="c"># Do your development work.</span>

<span class="c"># Time to land.</span>
<span class="nv">$ </span>hg pull https://hg.mozilla.org/integration/mozilla-inbound
<span class="nv">$ </span>hg rebase -d inbound
<span class="nv">$ </span>hg out -r . https://hg.mozilla.org/integration/mozilla-inbound
<span class="nv">$ </span>hg push -r .  https://hg.mozilla.org/integration/mozilla-inbound
</pre></div>

<p>Please note that <em>hg push</em> tries to push all local changes on all
heads to a remote by default. When operating a unified repo, you'll
need to use the <em>-r</em> argument to <em>hg push</em> and <em>hg out</em> to limit
what changesets are considered. I most frequently use <em>-r .</em> to limit
changes to the current checked out changeset.</p>
<p>Also note that this extension conflicts with my <em>mozext</em> extension.
I hope to update <em>mozext</em> to make it behave in the same manner. (It
was easier to write a new extension than to update mozext.)</p>

  </div>
</div>



  <div class="after_post"><a href="http://gregoryszorc.com/blog/2014/06/30/track-firefox-repositories-with-local-only-mercurial-tags#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  
<div class="blog_post">
  <a name="please-stop-using-mq"></a>
  <h2 class="blog_post_title"><a href="/blog/2014/06/23/please-stop-using-mq" rel="bookmark" title="Permanent Link to Please Stop Using MQ">Please Stop Using MQ</a></h2>
  <small>June 23, 2014 at 11:50 AM | categories: 

<a href='/blog/category/mercurial'>Mercurial</a>, <a href='/blog/category/mozilla'>Mozilla</a>
 | <a href="http://gregoryszorc.com/blog/2014/06/23/please-stop-using-mq#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>Are you a <a href="http://mercurial.selenic.com/">Mercurial</a> user?</p>
<p>Do you use the <a href="http://mercurial.selenic.com/wiki/MqExtension">mq</a>
extension? If so, please don't.</p>
<p>Why, you ask? Good question. The short version is that mq is a
solution spawned from version control techniques that were popular
over a decade ago. We have better tools now. mq is technologically
obsolete.</p>
<p>But if you want to know the full answer, keep reading.</p>
<h2>A history of Mercurial and mq</h2>
<p>The mq extension is just that: an extension to Mercurial's core
capabilities. (Mercurial consists of a core/basic feature set
supplemented by
<a href="http://www.selenic.com/hg/help/extensions">built-in</a> and
<a href="http://mercurial.selenic.com/wiki/UsingExtensions">3rd party</a>
extensions that provide more advanced or lesser used, niche
features.) Modern versions of Mercurial (if you aren't
running version 3.0+, please upgrade ASAP) are significantly
different from the Mercurial that necessitated the existence and
usage of the mq extension.</p>
<p>In the early days of Mercurial (Mercurial was
<a href="http://lkml.iu.edu//hypermail/linux/kernel/0504.2/0670.html">announced</a>
in April 2005), your choices for <em>branching</em> were not spectacular.
Your option in the core of Mercurial was to use Mercurial <em>branches</em>.
Mercurial branches are very heavy beasts. Branches are permanent.
If you change the branch a changeset (Mercurial's term for a commit)
is assciated with, the SHA-1 of that changeset changes. The takeaway
is Mercurial branches aren't very user friendly. That's why modern
versions of Mercurial print a warning when you create one:</p>
<pre><code>$ hg branch my-new-feature
marked working directory as branch my-new-feature
(branches are permanent and global, did you want a bookmark?)
</code></pre>
<p>Branches were and still are a relatively poor user experience
inside Mercurial, especially when compared to Git branches
(comparing Git and Mercurial branches is an apples to oranges
comparison: Mercurial branches are more synonymous with CVS or
Subversion branches). In defense of branches, they are good for
some roles, such as tracking release branches.
(Mozilla's <a href="https://hg.mozilla.org/releases/mozilla-aurora/">aurora</a>,
<a href="https://hg.mozilla.org/releases/mozilla-beta/">beta</a>,
<a href="https://hg.mozilla.org/releases/mozilla-release/">release</a>, etc
Firefox repositories should arguably be modeled as branches
instead of separate repositories.)</p>
<p>Further complicating the usability of branches in early versions
of Mercurial was the lack of commands to rewrite history.
Concepts such as rebasing or reordering patches were not
always available in Mercurial (or if they were there were
significant limitations). Today, this seems like an obvious
shortcoming of a version control system. But keep in mind the
state of version control around 2005-2007. CVS and Subversion
were the big players. Perforce, SourceSafe, TFS, etc were popular
in corporate settings. While I'm sure there were version control
systems at the time that supported rewriting history,
my recollection is that rewriting history did not <em>become a
thing</em> until Git rose in popularity (which I think was around
2008 or 2009). At that time, the concept of mutating past commits
was alien, if not absurd. Why would you want to lose data on what
you've already done? Isn't that the antithesis of a version control
system?! Git - and many of its concepts, including history
rewriting - were perceived as radical. It doesn't matter if they
borrowed the ideas from other tools: Git's newfound popularity
made them common and a new necessity. If you went from Git to
Subversion (or even Mercurial), the superiority of Git's
flexibility was obvious (although the UI was not so great, but
people can - and do - still cope).</p>
<p>It was under this renaissance of modern version control tools
in the late 2000's where mq became popular. But its popularity
was not because of the strength of mq: it was because of its
necessity.</p>
<p>mq was added to Mercurial in February 2006 and released as part of
Mercurial 0.8.1 in April 2006. As far as I can tell, at the time of
mq's release, mq was the only tolerable way to perform history
rewriting in Mercurial (<em>hg qref</em> and <em>hg qpush --move</em> are a
very crude method of history rewriting). Now, you could leverage
multiple Mercurial commands to give the illusion of history
rewriting, but it was very cumbersome. No sane person wanted to
deal with that. So mq was used.</p>
<p>The introduction of the <em>transplant</em> extension in the
Mercurial 0.9.2 release in December 2006 added another history
rewriting facility to Mercurial. The <em>transplant</em> command
effectively copies changesets between branches or heads.</p>
<p>The Mercurial 0.9.5 release in September 2007 introduced the
<em>record</em> extension. The <em>record</em> command provides interactive
and incremental commit support, similar to <em>git add -i</em>.
While <em>record</em> isn't strictly history rewriting, it provides
a very useful functionality for helping to produce separate,
smaller commits from a larger ongoing change.</p>
<p>The release of Mercurial 1.1 in December 2008 was - on paper at
least - an milestone for Mercurial. This release added the
<em>rebase</em> extension.  This introduced the <em>rebase</em> command,
which moves changesets (as opposed to <em>transplant</em>, which merely
copies them). Rebasing allowed you to pull remote changes and
then easily move your local changesets on top of the new changes,
among other things.</p>
<p>An even bigger feature added in Mercurial 1.1 was the <em>bookmarks</em>
extension. <a href="http://mercurial.selenic.com/wiki/Bookmarks">Bookmarks</a>
are Mercurial's lightweigh branches. Instead of permanent
association with a changeset, a bookmark is a movable label
attached to a changeset. They are very similar to Git branches.</p>
<p>The initial bookmarks feature was far from robust. You couldn't
push bookmarks and share them with others until Mercurial 1.6
in June 2010. It's worth noting that bookmarks became part of the
Mercurial core (as opposed to existing in an extension that must
be enabled) in Mercurial 1.8, released in March 2011.</p>
<p>Bookmarks, record, and rebase provided a decent framework for
history editing in Mercurial. But there were still some rough
edges, notably around making it easier to edit history: mq
was still easier to use for doing tasks like reordering patches.</p>
<p>It wasn't until Mercurial 2.2 in May 2012 that Mercurial
gained the ability to easily reorder patches using something
other than mq. It came via the <em>histedit</em> extension, which
provides the <em>histedit</em> command. This command provides a mechanism
to interactively edit history. It is very similar to <em>git rebase
--interactive</em>.</p>
<p>With the introduction of the <em>histedit</em> extension, you could
(finally) perform most of the more advanced repository
interaction workflows that mq allowed without using mq. Continue
reading the next section to learn why not using mq is important.</p>
<p>For Mozillians reading, it's worth noting that the conversion of
the Firefox source repository from CVS to Mercurial
<a href="http://soberbuildengineer.com/blog/2007/04/version-control-system-shootout-redux-redux/">occurred in March 2007</a>.
At that time, Mercurial had <em>mq</em> and <em>transplant</em> for
performing history rewriting. mq was thus the most convenient
method for rewriting history and managing individual patches
(a process Firefox development largely maintains to this day).
Thus, mq effectively became a de facto requirement for developing
Firefox patches. Despite mq being arguably unnecessary since
Mercurial 2.2's release in May 2012, mq is still widely used within
Mozilla. My perception is that most developers continue to use
mq. Furthermore, even new developers are still picking it up
instead of utilizing Mercurial's other commands for managing
changesets. FWIW, I believe many are so turned off by mq or
don't want to learn Mercurial or mq that they do their
day-to-day development in Git and only involve Mercurial
when doing the final push to the canonical Firefox Mercurial
repository.</p>
<p>Now that we learned why mq is popular, let's talk about why it
shouldn't be used any more.</p>
<h2>The hack that is mq</h2>
<p>In terms of architecture, mq is a giant hack: a wart on top of
Mercurial. The goal of every version control system is to track
changes over time. mq actively works against that.</p>
<p>At the core of every Mercurial repository is a <em>store</em> that
contains the repository data. The changesets in the repository
are logically represented as a directed acyclic graph (DAG).
When you run <em>hg commit</em>, <em>hg pull</em>, <em>hg import</em>, or any
command that introduces new changesets, new data is added to
the DAG and written to the store.</p>
<p>One of the most important properties of the store is that it is
supposed to be append-only: once data is added, it is never
removed. This property allows Mercurial to fulfill the <em>contract</em>
of version control systems, which is to keep track of data without
losing anything.</p>
<p>This append-only property is important because it means Mercurial
can know about all of the history for all of time. If you need to
perform a merge, Mercurial knows exactly what came before and thus
the most effective way to perform that merge. (It's worth noting
that merging can be quite complicated. All this extra data helps
do the merge correctly the first time, which means you can spend
your time writing code instead of resolving merge conflicts.)</p>
<p>The <em>"mq is a hack"</em> statement derives from how mq interacts with
Mercurial's store. Your mq <em>patch queue</em> is effectively an overlay
over Mercurial's built-in store that is in an ever-changing state
of partial application. When you <em>hg qpush</em> to apply a patch from
the <em>patch queue</em>, you effectively do an <em>hg import</em> to <em>import</em>
a Mercurial changeset file into the core Mercurial store. That's
mostly fine. But when you <em>hg qpop</em> (unapply a patch from mq), you
are effectively asking Mercurial to delete a changeset and all
data associated with it from the core Mercurial store. In other
words, <em>qpop</em> breaks the ideal append-only property of the
Mercurial store: <em>qpop</em> forces Mercurial to delete data and lose
track of history. This makes Mercurial very sad.</p>
<p>Because you are throwing away repository data, merges become much
harder. This means you spend more of your time dealing with
resolving conflicts. To further complicate that, the mq code paths
for performing merges and conflict resolution aren't as robust as
those used by, say, <em>hg rebase</em> and <em>hg histedit</em>. So if you use mq,
you are pretty much guaranteed a poorer conflict resolution process.
This means you spend more of your time wrestling with tools instead
of, you know, actually doing something productive.</p>
<p>Deleting repository data by unapplying patches via mq also has
negative performance implications. Given a large enough repository
(such as Firefox's - it currently has ~200,000 changesets), these
performance issues can result in severely degraded performance.
An extreme example of this is Mozilla's
<a href="https://hg.mozilla.org/try/">Try repository</a>. The
<a href="http://bke.ro/?p=386">runaway process/CPU issues leading to outages</a>
is due to a
<a href="http://bz.selenic.com/show_bug.cgi?id=4255">known Mercurial issue</a>
dealing with inefficient handling of stores that aren't append-only.
When you use mq, you risk running into the same issues. Although the
performance implication should hopefully be a magnitude or two less
pronounced than what Mozilla's Try repository experiences.</p>
<p>In theory, mq could compensate for deletion of data from Mercurial's
core store by retaining that data itself. But it doesn't. This leads
to yet more reasons why you shouldn't use mq.</p>
<p>mq throws away perfectly fine history data. When you <em>hg qrefresh</em>,
your current patch is overwritten with the new one. The old version
is discared. This actively works against the goal of a version
control system to record history. Have you ever started down a path
and realized a few commits later that you need to throw it away and
backtrack to a few commits back? I do that all the time. If you
<em>qrefresh</em>, tough luck: you've lost your history. If only the
history store was append-only.</p>
<p>(In fairness to mq, the patch queue maintained by mq is itself a
Mercurial repository and can be committed to, preventing history
loss. The <a href="https://hg.mozilla.org/hgcustom/version-control-tools/file/36eb33f9058d/hgext/mqext/README.txt">mqext extension</a>
even provides a mechanism for automatically committing the patch
queue repo during <em>qrefresh</em> and other mutation events. But as we
will see, even with this, mq is not perfect.)</p>
<p>mq also fails to adequately update patches when they are moved
around. Little known fact: mq patches have their parent changeset
encoded in them. If you run <em>hg qpush --exact</em>, Mercurial will apply
the patch against the parent changeset it was actually created
against, as opposed to the current work directory changeset. In
theory, you should never encounter conflicts when
applying patches this way. Because Mercurial's changeset SHA-1s
are dependent on content (like Git), if 23d165967da3 is the
child of d5741ada659d, then there should be absolutely no way
that 23d165967da3 should fail to apply directly to d5741ada659d.
The problem is that mq fails to update the parent changeset when
you push patches on top of a new parent! e.g.</p>
<div class="pygments_murphy"><pre><span class="c"># Let&#39;s create a root commit.</span>
<span class="nv">$ </span><span class="nb">echo</span> <span class="s1">&#39;foo&#39;</span> &gt; foo
<span class="nv">$ </span>hg commit -A -m <span class="s1">&#39;initial commit&#39;</span>
adding foo
<span class="nv">$ </span>hg log
changeset:   0:23d165967da3
user:        Gregory Szorc &lt;gps@mozilla.com&gt;
date:        Sun Jun <span class="m">22</span> 13:48:05 <span class="m">2014</span> -0700
summary:     initial commit
</pre></div>

<p>Notice the changeset of that commit. <em>023d165...</em>.</p>
<p>Now let's create a new mq patch.</p>
<div class="pygments_murphy"><pre><span class="nv">$ </span><span class="nb">echo</span> <span class="s1">&#39;patch 1&#39;</span> &gt; foo
<span class="nv">$ </span>hg qnew -m <span class="s1">&#39;make mq patch 1&#39;</span> p1

<span class="c"># Creating an mq patch creates a file in .hg/patches.</span>
<span class="nv">$ </span>cat .hg/patches/p1
<span class="c"># HG changeset patch</span>
<span class="c"># Parent 23d165967da39e5846976eb6ed967f1058827ffa</span>
<span class="c"># User Gregory Szorc &lt;gps@mozilla.com&gt;</span>
make p1

diff --git a/foo b/foo
--- a/foo
+++ b/foo
@@ -1,1 +1,1 @@
-foo
+patch 1
</pre></div>

<p>Notice how the parent is listed as the changeset in Mercurial's core
store.</p>
<p>Now let's pop that patch, create a new commit, and push the old mq
patch.</p>
<div class="pygments_murphy"><pre><span class="nv">$ </span>hg qpop
popping p1
patch queue now empty

<span class="nv">$ </span><span class="nb">echo</span> <span class="s1">&#39;bar&#39;</span> &gt; bar
<span class="nv">$ </span>hg commit -A -m <span class="s1">&#39;second commit&#39;</span>
adding bar

<span class="nv">$ </span>hg log
changeset:   1:d5741ada659d
tag:         tip
user:        Gregory Szorc &lt;gps@mozilla.com&gt;
date:        Sun Jun <span class="m">22</span> 13:48:37 <span class="m">2014</span> -0700
summary:     second commit

changeset:   0:23d165967da3
user:        Gregory Szorc &lt;gps@mozilla.com&gt;
date:        Sun Jun <span class="m">22</span> 13:48:05 <span class="m">2014</span> -0700
summary:     initial commit

<span class="nv">$ </span>hg qpush
applying p1
now at: p1

<span class="nv">$ </span>hg log --graph
@ changeset:   2:64851294d038
<span class="p">|</span> tag:         p1
<span class="p">|</span> tag:         qbase
<span class="p">|</span> tag:         qtip
<span class="p">|</span> tag:         tip
<span class="p">|</span> user:        Gregory Szorc &lt;gps@mozilla.com&gt;
<span class="p">|</span> date:        Sun Jun <span class="m">22</span> 14:27:55 <span class="m">2014</span> -0700
<span class="p">|</span> summary:     make mq patch 1
<span class="p">|</span>
o changeset:   1:d5741ada659d
<span class="p">|</span> tag:         qparent
<span class="p">|</span> user:        Gregory Szorc &lt;gps@mozilla.com&gt;
<span class="p">|</span> date:        Sun Jun <span class="m">22</span> 13:48:37 <span class="m">2014</span> -0700
<span class="p">|</span> summary:     second commit
<span class="p">|</span>
o changeset:   0:23d165967da3
  user:        Gregory Szorc &lt;gps@mozilla.com&gt;
  date:        Sun Jun <span class="m">22</span> 13:48:05 <span class="m">2014</span> -0700
  summary:     initial commit
</pre></div>

<p>We see our mq patch is now applied on top of the second commit,
<em>d5741ada659d</em> because it was pushed while the working directory
was sitting at <em>d5741ada659d</em>.</p>
<p>But let's see what mq says:</p>
<div class="pygments_murphy"><pre><span class="nv">$ </span>hg cat .hg/patches/p1
<span class="c"># HG changeset patch</span>
<span class="c"># Parent 23d165967da39e5846976eb6ed967f1058827ffa</span>
<span class="c"># User Gregory Szorc &lt;gps@mozilla.com&gt;</span>
make p1

diff --git a/foo b/foo
--- a/foo
+++ b/foo
@@ -1,1 +1,1 @@
-foo
+patch 1
</pre></div>

<p>mq still says <em>23d165967da3</em> is the parent, even though we changed the
parent! mq is lying to us! Now, we
can rectify the situation by running <em>hg qrefresh</em>. That will cause mq
to regenerate the patch file, which will pick up the new parent. But
who does that? Unless you need to qrefresh to resolve conflicts or
other changes, nobody. This means that if you distribute the patch -
say you are uploading it for review - the parent changeset may not
be accurate and anyone applying that patch may apply it to the wrong
changeset and get unexpected results. That's no good.</p>
<p>For what it's worth, this behavior of not auto refreshing patches
is by design. We don't necessarily want application to be a mutating
operation, especially since mq repositories aren't automatically
versioned. This is partially because mq was effectively designed to be
<a href="https://savannah.nongnu.org/projects/quilt">quilt</a> built into
Mercurial. And <em>quilt</em> is a tool that was invented before the modern
version control tools era. mq's behavior is influenced more from
emulating <em>quilt</em> than from the desire to facilitate a sane
patch/stack/feature based workflow. If you ever wanted to know why
mq works the way it does and not like something more modern, that's
why.</p>
<p>Another huge reason to not use mq is because its concepts and
workflows are alien to modern and well-understood practices. While
I'm a huge fan of Mercurial and prefer it over Git (read my
<a href="/blog/2013/05/12/thoughts-on-mercurial-%28and-git%29/">thoughts on the topic</a>),
I don't pretend that Git isn't the most widely used version control
software right now (at least in the open source world).
It got that way despite its horrible
<a href="http://stevelosh.com/blog/2013/04/git-koans/">UI shortcomings</a>.
I argue its rise was because people enjoy workflows such
as lightweight branches and fast, often-simple merging.
(GitHub and its fairly good web UI certainly helped the cause.)
People today know Git. They know lightweight branches. I think
they largely understand the concept of repositories with multiple
heads and grok how a distributed version control system means you can
commit locally without affecting a remote (server). They grok
how can you push local commits to a remote (sometimes in the
form of a pull request). mq doesn't work this way - the way that
people have come to expect from Git. There are
<a href="https://en.wikipedia.org/wiki/List_of_cognitive_biases">cognitive biases</a>
that lead us to believe that because mq is different (from Git)
that it is inferior. Why should someone apply and unapply
individual patches on a temporary queue (or stack depending on how
you think about it) instead of working with <em>branches</em>? If someone
groks Git and multiple heads/branches/bookmarks, why should they
go through all the trouble of learning mq? The fact that mq
doesn't work as well as non-mq mechanisms is icing on the
figurative cake.</p>
<p>If the reasons I've listed are not enough, know this: mq users
will not able to fully utilize the game-changing
<a href="http://mercurial.selenic.com/wiki/ChangesetEvolution">Changeset Evolution</a>
feature of Mercurial. Remember in the late 2000's when people
thought Git was crazy for allowing you to mutate history - the
antithesis of version control because it threw away data? Changeset
Evolution and obsolescence markers - the mechanism used to enable
Changeset Evolution - are Mercurial's answer to that. They enable
Mercurial to retain metadata about previous changesets and how they
<em>evolved</em> into newer changesets. That criticism about history
rewriting deleting history: Changeset Evolution makes it largely
go away. A light version of the history of past commits is preserved
and propagated during push and pull operations.</p>
<p>Changeset Evolution changes the game much like Git changed the
landscape of version control in the late 2000's. So much of our
notions of how modern version control work are based on the
<em>current</em> behavior of tools. For example, any Git user will tell
you, <em>never git push --force</em>.
<a href="https://groups.google.com/forum/#!searchin/jenkinsci-dev/force$20push/jenkinsci-dev/-myjRIPcVwU/mrwn8VkyXagJ">Bad things will happen</a>.
Why do they say that? They say that because the user experience of
distributed history rewriting in Git can be horrible and error prone.
And it is like this because Git's implementation of history rewriting
burns the old books of history once they are translated to the
new world order. (OK, to be fair to Git it does have a reflog that
can kinda sorta be used to recover in disaster scenarios. But it's
far from robust and there are numerous caveats, notably that the
reflog is not part of data distributed with push/fetch and therefore
susceptible to single/few points of failure.) Mercurial's
obsolescence markers, by contrast, leave footnotes in our history
books and transfer these annotations as part of the distributed
repository data. Changeset Evolution uses these footnotes to
reconstruct the pages of history, even if they differ
from our own perspective. For example, you can force push rewritten
history and other clients can recover from that automagically. Want
to do complex history rewriting and force push?
Go right ahead: Mercurial and Changeset Evolution will
enable you to work without imposing as many (practical)
restrictions on your workflow as other tools. Good tools are flexible
and impose fewer restrictions. This is why Mercurial and Changeset
Evolution have the potential to change the world of version control
much like Git changed things half a decade ago.</p>
<p>Are you still not convinced mq is a bad idea? Know this: a
Mercurial core developer
<a href="http://www.selenic.com/pipermail/mercurial-devel/2014-June/059535.html">recently proposed marking mq as deprecated</a>.
That's right: there's very little love for mq within the Mercurial
Project. Maintainers generally think what I've stated in this post:
mq is yesterday's solution to yesterday's problem and it should
be cast aside.</p>
<p>If you are a mq user, I hope you are now convinced that mq is a bad
idea and you should transition away from it as soon as possible. In
the next section, I'll talk about moving off mq.</p>
<h2>Moving away from mq</h2>
<p>I completely abandonded mq in December 2013 and am never using it
again. In hindsight, I should have made the transition much sooner.</p>
<p>I could write an entire post about my workflow. Since this post is
already a bit long, I'm going to describe it with mostly command
line examples.</p>
<p>I use bookmarks for managing my <em>feature branches</em>. I use one
bookmark per logical feature. This workflow is very similar to
using Git branches.</p>
<div class="pygments_murphy"><pre><span class="c"># Create a new bookmark for the new feature I&#39;m developing.</span>
<span class="nv">$ </span>hg bookmark gps/my-new-feature

<span class="c"># make changes to files</span>
<span class="o">(</span>gps/my-new-feature<span class="o">)</span> <span class="nv">$ </span>hg commit
<span class="c"># make more changes)</span>
<span class="o">(</span>gps/my-new-feature<span class="o">)</span> <span class="nv">$ </span>hg commit
<span class="c"># keep making small changes</span>
<span class="o">(</span>gps/my-new-features<span class="o">)</span> <span class="nv">$ </span>hg commit

<span class="c"># I decide I want to reorder or merge a few commits. I look at the</span>
<span class="c"># DAG to see which changeset to rewrite.</span>
<span class="o">(</span>gps/my-new-features<span class="o">)</span> <span class="nv">$ </span>hg log --graph

<span class="o">(</span>gps/my-new-feature<span class="o">)</span> <span class="nv">$ </span>hg histedit 5e907ed10e22
<span class="c"># this opens an editor where I can say what changes to make)</span>

<span class="c"># Let&#39;s start a new feature.</span>
<span class="o">(</span>gps/my-new-feature<span class="o">)</span> <span class="nv">$ </span>hg up central
<span class="o">(</span>leaving bookmark gps/my-new-feature<span class="o">)</span>
<span class="nv">$ </span>hg bookmark gps/feature2
<span class="c"># Make some changes</span>
<span class="o">(</span>gps/feature2<span class="o">)</span> <span class="nv">$ </span>hg commit

<span class="c"># I got review on my original feature. Let&#39;s push it.</span>
<span class="o">(</span>gps/feature2<span class="o">)</span> <span class="nv">$ </span>hg up gps/my-new-feature
<span class="o">(</span>activating bookmark gps/marionette-restart<span class="o">)</span>

<span class="o">(</span>gps/my-new-feature<span class="o">)</span> <span class="nv">$ </span>hg pull gecko
pulling from http://hg.stage.mozaws.net/gecko
searching <span class="k">for</span> changes
adding changesets
adding manifests
adding file changes
added <span class="m">118</span> changesets with <span class="m">543</span> changes to <span class="m">328</span> files <span class="o">(</span>+1 heads<span class="o">)</span>
OBSEXC: pull obsolescence markers
OBSEXC: looking <span class="k">for</span> common markers in <span class="m">215590</span> nodes
OBSEXC: no unknown remote markers
OBSEXC: DONE
updating bookmark aurora
updating bookmark b2g28
updating bookmark b2ginbound
updating bookmark beta
updating bookmark central
updating bookmark esr24
updating bookmark fx-team
updating bookmark inbound
updating bookmark release
<span class="o">(</span>run <span class="s1">&#39;hg heads .&#39;</span> to see heads, <span class="s1">&#39;hg merge&#39;</span> to merge<span class="o">)</span>

<span class="o">(</span>gps/my-new-feature<span class="o">)</span> <span class="nv">$ </span>hg rebase -d fx-team

<span class="c"># Verify I&#39;m about to push what I want to push.</span>
<span class="o">(</span>gps/my-new-feature<span class="o">)</span> <span class="nv">$ </span>hg out -r . fx-team

<span class="c"># And push the changes.</span>
<span class="o">(</span>gps/my-new-feature<span class="o">)</span> <span class="nv">$ </span>hg push -r . fx-team

<span class="c"># And delete the bookmark that I don&#39;t need any more.</span>
<span class="o">(</span>gps/my-new-feature<span class="o">)</span> <span class="nv">$ </span>hg bookmark -d gps/my-new-feature
</pre></div>

<p>That's how bookmarks work. If you upgrade to Mercurial 3.0 or newer,
Mercurial will print messages when you enter and leave bookmarks. This
is a great UI improvement!</p>
<p>I also have the
<a href="http://mercurial.selenic.com/wiki/PromptExtension">prompt extension</a>
installed and configured so my shell prompt contains the active
bookmark. This helps me keep track of what head I'm committing to.</p>
<p>I'm also a user of the experimental
<a href="http://mercurial.selenic.com/wiki/EvolveExtension">evolve extension</a>.
This is the extension that is implementing the <em>Changeset Evolution</em>
feature. Eventually the functionality will be merged into core
Mercurial. One such workflow with <em>evolve</em> is as follows.</p>
<div class="pygments_murphy"><pre><span class="c"># Create a bookmark for a new feature</span>
<span class="nv">$ </span>hg bookmark gps/my-new-feature

<span class="c"># Make some changes.</span>
<span class="o">(</span>gps/my-new-feature<span class="o">)</span> <span class="nv">$ </span>hg commit -m <span class="s1">&#39;first commit&#39;</span>

<span class="c"># Make some more changes.</span>
<span class="o">(</span>gps/my-new-feature<span class="o">)</span> <span class="nv">$ </span>hg commit -m <span class="s1">&#39;second commit&#39;</span>

<span class="c"># Submit code for review. (Exact commands excluded.)</span>

<span class="c"># Wait for review comments. There is a nit on the first commit.</span>
<span class="nv">$ </span>hg previous
<span class="o">[</span>204142<span class="o">]</span> first commit

<span class="c"># Make changes</span>
<span class="nv">$ </span>hg amend
<span class="m">1</span> new unstable changesets

<span class="c"># (amend is provided by evolve. It is equivalent to hg commit --amend)</span>

<span class="c"># evolve is the command that looks at the history rewriting markers</span>
<span class="c"># and knows how to rebase, etc other changesets in the face of</span>
<span class="c"># rewriting.</span>
<span class="nv">$ </span>hg evolve
move:<span class="o">[</span>204143<span class="o">]</span> second commit
atop:<span class="o">[</span>204144<span class="o">]</span> first commit
merging foo
warning: conflicts during merge.
merging foo incomplete! <span class="o">(</span>edit conflicts, <span class="k">then</span> use <span class="s1">&#39;hg resolve --mark&#39;</span><span class="o">)</span>
evolve failed!
fix conflict and run <span class="s2">&quot;hg evolve --continue&quot;</span>
abort: unresolved merge conflicts <span class="o">(</span>see hg <span class="nb">help </span>resolve<span class="o">)</span>

<span class="c"># Manually address conflict markers in file &quot;foo&quot;</span>
<span class="nv">$ </span>hg resolve -m foo
no more unresolved files

<span class="nv">$ </span>hg evolve --continue
grafting revision 204143

<span class="c"># And I&#39;m ready to push.</span>
</pre></div>

<p>If you really love the concept of mq and patch queues and absolutely
must do development that way (as opposed to bookmarks/branches), then
you should consider using the
<a href="http://mercurial.selenic.com/wiki/ShelveExtension">shelve extension</a>
instead of mq. While shelve is still a bit hacky in that it violates the
append-only goal of the Mercurial store, it does so in a way that
integrates much better than mq. For example, when you <em>unshelve</em>,
the changesets will only apply to the parent changeset they were
last attached to. You will get no merge conflicts during <em>unshelve</em>. If
you want to rebase, you will need to use the <em>rebase</em> command, which
will go through Mercurial's more robust merging code paths, leaving
conflict markers instead of <em>.rej</em> files
(assuming you are using the <em>internal</em>
<a href="http://mercurial.selenic.com/wiki/MergeToolConfiguration">merge tool</a>).
Shelve also groups multiple changesets together. Contrast with
mq's default behavior of a flat list of patches (my mq queue grew
to over 100 patches with patches belonging to dozens of bugs).
Shelve is all around a better mq and is a good compromise between
the stack/queue based development workflow of mq with the more modern
development workflow of bookmarks. If nothing else, shelve integrates
much better into the Mercurial core. As a quantitative measurement
of this, mq weighs in
at <a href="http://selenic.com/repo/hg/file/cd3c79392056/hgext/mq.py">3461</a>
lines. Shelve, by comparison, is a svelt
<a href="http://selenic.com/repo/hg/file/cd3c79392056/hgext/shelve.py">704 lines</a>.
Considering they do nearly the same thing (shelve offloads functionality
like folding and reordering to core Mercurial commands that didn't
exist at the time of mq's inception), I trust shelve with its reduced
surface area to be more robust and bug free.</p>
<p>But as good as shelve is, it's still not as integrated as bookmarks
or branches. If you can, try to stick to the Mercurial core
features and avoid shelve. But whatever you do, try to avoid mq!</p>
<h2>Conclusion</h2>
<p>I never used Mercurial before becoming an employee of Mozilla
and a contributor to Firefox. I was a mq user for my first two plus
years of Mercurial use. I blindly followed the Mozilla
documentation and advice of my fellow Mozillians to use mq.
It wasn't until I truly invested in learning Mercurial (as
opposed to learning merely the command line interface - the
minimum required for me to contribute to Firefox) that I
realized how wrong the common Mozilla mindset about Mercurial
and mq was. I was incorrectly associating mq with <em>"The Mercurial
Way"</em> and thought Mercurial was inherently lacking. I knew
about branches and bookmarks, but didn't realize I could use
them as an alternative to mq.</p>
<p>Only after learning Mercurial's internals, contributing patches to
the Mercurial core, and reading the changelog of the Mercurial
project itself did I realize the truth: <strong>mq's popularity is a
result of historical necessity that no longer exists; and, continued
usage of mq represents a general failure in user eduction about
mq's drawbacks and Mercurial's modern features.</strong> In other words,
the more informed I became, the more I learned what a bad idea
mq is and why it should be avoided.</p>
<p>At Mozilla, we happened to switch to Mercurial at a time (2007) when
mq was the only reasonable solution available to Mercurial. The
procedures and documentation developed in 2007 have persisted to
2014, largely ignoring advancements in Mercurial over that time.
To be fair to my fellow Mozillians and Mercurial users everywhere,
Mercurial wasn't truly ready to jettison mq until the <em>histedit</em>
extension came into existence a few years ago. But that was
<em>years</em> ago. We all should have had time to switch, but we haven't.
Or if we have, we've switched to Git. (And I can't blame anyone for
switching to Git - both its mind share and the network effect of
GitHub are <em>very</em> compelling reasons.)</p>
<p>I hope you now know why mq is a bad idea. Please join me in realizing
that mq was a solution for yesterday's problems. mq is a legacy tool
that loses data and makes your life harder. It's time to let go of
the past and embrace the future. Please join me in shaving the mq
neck beard that has been growing since CVS was a popular version
control system.</p>
<h2>Addendum on Code Review</h2>
<p>While I've wanted to write this post for a while, the trigger for me
finally writing it is my work on integrating Mercurial with the
<a href="http://www.reviewboard.org/">Review Board</a> code
review software. The Bugzilla Team at Mozilla is working on a project
to integrate Review Board into Bugzilla for code review, supplementing
the antiquated-by-comparison Splinter code review feature.
Instead of uploading patches to Bugzilla - how Mozilla and Firefox
development has done it for over a decade - you will push changesets
to a Mercurial repository and pushed
changesets will automatically turn into code reviews on Review
Board and get cross-posted to referenced Bugzilla bugs.</p>
<p>This is all part of a larger goal to make it easier for patches to be
submitted and landed consistently and centrally. This should lead to
various automation and tooling improvements, such as bots conducting
aspects of code review and automatically landing reviewed patches.</p>
<p>These things are very difficult to do in a Bugzilla-only and patch-based
world because it is difficult to first aggregate patches and second
process them in a unified manner. Patches come in many different
flavors. You have Mercurial style diffs.
You have plain patches, and patches with Git or Mercurial style
annotation.  You have different lines of context in the patch.
You have different handling of binary content. You have mq lying
about the parent changeset. All these contribute
to a massive impedance mismatch of sorts that makes it extremely
difficult to roll out any kind of automation. Any tools built on
top must first solve a very difficult data normalization and
distribution problem. These are problems that should not exist and
drastically raise the barrier to forward progress.</p>
<p>Contrast this with pushing to Mercurial (or Git) repositories. The
repository is the data, not the patch file. Clients are able to
extract variations of that data however they see fit. Commit
data is centralized, distributable, and unified. There are dozens
of existing tools and services that already know how to speak
with repositories. Our data problem not only goes away, but
many solutions have already been invented for us.</p>
<p>Back to Review Board.</p>
<p>I've written an <a href="https://hg.mozilla.org/hgcustom/version-control-tools/file/default/hgext/reviewboard">extension</a>
that pushes review-specific metadata to the Mercurial server. This
effectively allows Mercurial to <em>speak</em> code review and interact
with the code review server. For Mercurial clients that are writing
obsolescence markers, we are able to <em>track</em> the changesets
undergoing review against their logical successors. For example,
if you pull and rebase, this will rewrite changeset X to changeset Y
(because the SHA-1 changes). Mercurial knows that a) changeset X was
under review and b) Y is the new version of X. So, when you push
Y for code review, the review associated with X is updated
automagically. You could accomplish this with heuristic-based
matching or user prompting, but these are error prone (you wouldn't
believe the number of corner cases) or require excessive user
time, especially when complex history rewriting is involved.
Mercurial's obsolescence markers allow the matching to <em>just work</em>
in most scenarios and for people to spend more time writing and
reviewing code as opposed to telling the code review tool what
and how to review.</p>
<p>As I was implementing this extension, I realized that mq users
(most Mercurial users at Mozilla I reckon) would be unable to reap the
benefits of all this magic because, well, they are using mq. I care
passionately about developer productivity. Good tools are the tools
that don't require constant massaging. I want everyone to get the
full benefits of Mozilla's new code review system when it launches.
And the only way that happens is if people stop using mq. And the
only way that happens is if people learn why mq is a bad idea. So
if nothing else has convinced you to stop using mq yet, maybe the
lure of an amazing and automagical code review and collaboration
experience will sway you.</p>

  </div>
</div>



  <div class="after_post"><a href="http://gregoryszorc.com/blog/2014/06/23/please-stop-using-mq#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  
<div class="blog_post">
  <a name="using-mercurial-for-status-reports"></a>
  <h2 class="blog_post_title"><a href="/blog/2014/04/01/using-mercurial-for-status-reports" rel="bookmark" title="Permanent Link to Using Mercurial for Status Reports">Using Mercurial for Status Reports</a></h2>
  <small>April 01, 2014 at 12:30 PM | categories: 

<a href='/blog/category/mercurial'>Mercurial</a>, <a href='/blog/category/mozilla'>Mozilla</a>
 | <a href="http://gregoryszorc.com/blog/2014/04/01/using-mercurial-for-status-reports#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>Mercurial has a pair of amazing features called
<a href="http://www.selenic.com/hg/help/revsets">Revisions Sets</a>
and <a href="http://www.selenic.com/hg/help/templates">Templates</a>. Combined,
they allow you to query Mercurial like a database and to generate custom
reports from obtained data.</p>
<p>As I've <a href="/blog/2013/11/08/using-mercurial-to-query-mozilla-metadata/">demonstrated</a>,
you can write Mercurial extensions to provide custom revision set
queries and template functions and keywords. My
<a href="https://hg.mozilla.org/hgcustom/version-control-tools/file/default/hgext/mozext">mozext</a>
extension aggregates Mozilla's <em>pushlog</em> data into a local SQLite
database and makes this data available to revision sets and templates.</p>
<p>My hack of the day is to use revision sets and templates to create a
weekly status report:</p>
<div class="pygments_murphy"><pre>hg log -r &#39;public() and me() and firstpushdate(&quot;-7&quot;)&#39; \
--template &#39;* {ifeq(reviewer, &quot;gps&quot;, &quot;Review: &quot;, &quot;Landing: &quot;)}{firstline(desc)}\n&#39;
</pre></div>

<p>When I run this, I get the output:</p>
<div class="pygments_murphy"><pre>* Review: Bug 957241 - Don&#39;t package the full sdk when we don&#39;t need it. r=gps
* Review: Bug 987146 - Represent SQL queries more efficiently. r=gps.
* Review: Bug 987984 - VirtualenvManager.call_setup() should use self.python_path instead of sys.executable, r=gps
* Landing: Bug 987398 - Part 1: Run mochitests from manifests with mach; r=ahal
* Landing: Bug 987398 - Part 2: Handle install-to-subdir in TestResolver; r=ahal
* Landing: Bug 987414 - Pass multiple test arguments to mach testing commands; r=ahal
* Review: Bug 988141 - Clean up config/recurse.mk after bug 969164. r=gps
* Landing: Bug 973992 - Support experiments add-ons; r=Unfocused
* Review: Bug 927672 - Force pymake to fall back to mozmake when run on build slaves. r=gps
* Review: Bug 989147 - Use new sccache for Linux and Android builds. r=gps
* Review: Bug 989147 - Add missing part of the patch from rebase conflict. r=gps
* Landing: Bug 975000 - Disable updating and compatibility checking for Experiments; r=Unfocused
* Landing: Bug 985084 - Experiment add-ons should be disabled by default; r=Unfocused
* Landing: Backed out changeset 4834a3833639 and c580afddd1cb (bug 985084 and bug 97500)
* Landing: Bug 975000 - Disable updating and compatibility checking for Experiments; r=Unfocused
* Landing: Bug 985084 - Experiment add-ons should be disabled by default; r=Unfocused
* Landing: Bug 989137 - Part 1: Uninstall unknown experiments; r=Unfocused
* Landing: Bug 989137 - Part 2: Don&#39;t use a global logger; r=gfritzsche
* Landing: Bug 989137 - Part 3: Log.jsm API to get a Logger that prefixes messages; r=bsmedberg
* Landing: Bug 989137 - Part 4: Use a prefixing logger for Experiments logging; r=gfritzsche
* Landing: Bug 989137 - Part 5: Prefix each log message with the instance of the object; r=gfritzsche
* Review: Bug 988849 - Add mach target for jit tests; r=gps
* Landing: Bug 989137 - Part 6: Create experiment XPIs during the build; r=bsmedberg
* Landing: Bug 989137 - Part 7: Remove unncessary content from test experiments; r=Unfocused
* Landing: Bug 985084 - Part 2: Properly report userDisabled in the API; r=Unfocused
</pre></div>

<p>Which I can then copy and paste directly into the
<a href="http://benjamin.smedbergs.us/weekly-updates.fcgi/">status tool</a> to
capture all my weekly code contributions! That takes a few seconds to
run and saves me a few minutes of typing.</p>
<p>For the curious, let's break that Mercurial command down.</p>
<ul>
<li>public() selects all <em>public</em> changesets. These are changesets in the
  repository that have been pushed to a publishing repository. In other
  words, patches that landed in Firefox.</li>
<li>me() is a custom revset from my <em>mozext</em> extension that parses the
  commit message and selects changesets that I authored or reviewed.</li>
<li>firstpushdate("-7") is a custom revset from my <em>mozext</em> extension. It
  selects changesets that were first pushed in the last 7 days (using
  pushlog data stored in a local SQLite database).</li>
</ul>
<p>The template piece should be easy to read. I have a simple branch
testing whether the changeset is a review or not, then output a label
followed by the first line of the commit message.</p>
<p>I have this command saved under the <em>[alias]</em> section of my <em>~/.hgrc</em>
file so I can just type <em>hg statusreport</em>.</p>
<p>While there is room to improve the tool (stripping <em>r=</em> lines from
commit messages for example), I think it's a pretty cool hack and shows
how Mercurial can grow to solve problems you don't think your version
control system knows how to solve.</p>

  </div>
</div>



  <div class="after_post"><a href="http://gregoryszorc.com/blog/2014/04/01/using-mercurial-for-status-reports#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  
<div class="blog_post">
  <a name="how-promises-and-tasks-are-improving-tests"></a>
  <h2 class="blog_post_title"><a href="/blog/2014/03/30/how-promises-and-tasks-are-improving-tests" rel="bookmark" title="Permanent Link to How Promises and Tasks are Improving Tests">How Promises and Tasks are Improving Tests</a></h2>
  <small>March 30, 2014 at 02:15 PM | categories: 

<a href='/blog/category/mozilla'>Mozilla</a>, <a href='/blog/category/javascript'>JavaScript</a>
 | <a href="http://gregoryszorc.com/blog/2014/03/30/how-promises-and-tasks-are-improving-tests#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>I was a very early adoptor of promises and
<a href="https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Task.jsm">Tasks</a>
in Firefox's JavaScript code base. To me, promises on their own are ok.
The ability to chain promises together and tack one error handler on
the end sure beats the
<a href="http://tritarget.org/blog/2012/11/28/the-pyramid-of-doom-a-javascript-style-trap/">Pyramid of Doom</a>
and having to pass errors into callbacks everywhere. But what really
lured me in were tasks: using generators (then a feature only available
in SpiderMonkey) to represent async code flow as nice, easy-to-read
procedural flow that nearly every programming can relate to. It made
code much easier to read and grok. I've been using tasks ever since.</p>
<p>When I started writing new APIs that returned promises instead of using
callbacks, I found myself writing a lot of tests consuming promises and
using tasks. So, I
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=819033">added an add_task</a>
API to our xpcshell test harness to make writing task-based unit tests
involve less boilerplate. That API is now used heavily for new xpcshell
tests.</p>
<p>While I initially added <em>add_task()</em> to cut down on the boilerplate for
writing tests, I only recently realized it has another benefit: it's
helped cut down on hung tests!</p>
<p>Before, with callback-based APIs, we'd code tests like so:</p>
<div class="pygments_murphy"><pre><span class="nx">add_test</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">do_something</span><span class="p">(</span><span class="kd">function</span> <span class="nx">onThatThing</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
     <span class="nx">Assert</span><span class="p">.</span><span class="nx">ok</span><span class="p">(</span><span class="nx">result</span><span class="p">.</span><span class="nx">success</span><span class="p">);</span>
     <span class="nx">run_next_test</span><span class="p">();</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></div>

<p>Or another pattern:</p>
<div class="pygments_murphy"><pre><span class="nx">add_test</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">do_something</span><span class="p">(</span><span class="kd">function</span> <span class="nx">onThatThing</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// The next line throws an Error by accident!</span>
    <span class="nx">result</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
    <span class="nx">run_next_test</span><span class="p">();</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></div>

<p>In the first example, the test will hang if the callback never gets
called. The test harness driver will eventually terminate
the test (after a multi-second delay with no output). Not good.</p>
<p>In the second example, we are still susceptible to the callback not
being called. But we have a different problem: an untrapped Error is
thrown from a callback! This results in the same behavior:
<em>run_next_test()</em> (the function that says to advance to the next test)
won't execute and the test will hang until it times out.</p>
<p>A more proper way to write this test is:</p>
<div class="pygments_murphy"><pre><span class="nx">add_test</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">do_something</span><span class="p">(</span><span class="kd">function</span> <span class="nx">onThatThing</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="nx">result</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">ex</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">do_report_unexpected_exception</span><span class="p">(</span><span class="nx">ex</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">run_next_test</span><span class="p">();</span>
  <span class="p">});</span>
<span class="p">});</span>
</pre></div>

<p>In reality, few people surround all their callbacks with try..catch
blocks because, well, it's a lot of typing and people don't always think
it's necessary (the test passes most of the time, doesn't it?).</p>
<p>What promises and task-based tests are doing is enabling us to write
more robust tests without all of the extra work. Here is how you would
use task-based tests:</p>
<div class="pygments_murphy"><pre><span class="nx">add_task</span><span class="p">(</span><span class="kd">function</span><span class="o">*</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">yield</span> <span class="nx">do_something</span><span class="p">();</span>
  <span class="c1">// The next line throws an Error by accident!</span>
  <span class="nx">result</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span>
<span class="p">});</span>
</pre></div>

<p>Here, the Error thrown by the test function is thrown within the context
of an executing Task. It is caught by the Task and converted into a
rejected promise. <strong>The test harness sees that failure immediately
and no timeout occurs!</strong> This can cut down on overhead when writing
tests, especially if you are trying to debug a hang.</p>
<p>Furthermore, the test is 4 lines versus 10. Less typing means you have
more time to write additional tests or you can focus on writing other
patches.</p>
<p>Finally, the task-based test functions are easier to understand. That 4
line, procedural test is much easier to grok than its callback-based
counterpart.</p>
<p>And before I conclude, I should mention that we can do more with
promises. For example, <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=976205">bug 976205</a> is making uncaught promise errors turn into test failures!
There is also an awesome patch in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=867742">bug 867742</a> to
introduce a unified JavaScript test harness API for defining JavaScript
tests in our tree (currently the APIs for xpcshell tests and mochitests
are different, leading to cognitive dissonance and lower productivity).
<strong>If you want to be a hero to the Firefox developer community, help
finish that patch.</strong></p>
<p>Given that so much Firefox feature development time (at Mozilla) is
spent writing and debugging tests, I encourage everyone to consider
promises and tasks for his or her next feature so that you can cut
down on development time and complete projects faster.</p>

  </div>
</div>



  <div class="after_post"><a href="http://gregoryszorc.com/blog/2014/03/30/how-promises-and-tasks-are-improving-tests#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
 <a href="/blog/category/mozilla/10">« Previous Page</a>
  --  
 <a href="/blog/category/mozilla/12">Next Page »</a>

              </div>
              
          <div id="sidebar">
          <ul>
            <li>
              <h2>Categories</h2>
              <ul>
                <li><a href="/blog/category/bugzilla">Bugzilla</a></li>
                <li><a href="/blog/category/clang">Clang</a></li>
                <li><a href="/blog/category/docker">Docker</a></li>
                <li><a href="/blog/category/firefox">Firefox</a></li>
                <li><a href="/blog/category/git">Git</a></li>
                <li><a href="/blog/category/javascript">JavaScript</a></li>
                <li><a href="/blog/category/mercurial">Mercurial</a></li>
                <li><a href="/blog/category/mozreview">MozReview</a></li>
                <li><a href="/blog/category/mozilla">Mozilla</a></li>
                <li><a href="/blog/category/puppet">Puppet</a></li>
                <li><a href="/blog/category/python">Python</a></li>
                <li><a href="/blog/category/review-board">Review Board</a></li>
                <li><a href="/blog/category/sync">Sync</a></li>
                <li><a href="/blog/category/browsers">browsers</a></li>
                <li><a href="/blog/category/build-system">build system</a></li>
                <li><a href="/blog/category/code-review">code review</a></li>
                <li><a href="/blog/category/compilers">compilers</a></li>
                <li><a href="/blog/category/internet">internet</a></li>
                <li><a href="/blog/category/logging">logging</a></li>
                <li><a href="/blog/category/mach">mach</a></li>
                <li><a href="/blog/category/make">make</a></li>
                <li><a href="/blog/category/misc">misc</a></li>
                <li><a href="/blog/category/movies">movies</a></li>
                <li><a href="/blog/category/pymake">pymake</a></li>
                <li><a href="/blog/category/security">security</a></li>
                <li><a href="/blog/category/sysadmin">sysadmin</a></li>
                <li><a href="/blog/category/testing">testing</a></li>
              </ul>
            </li>
          </ul>
        </div>



              <div style="clear: both;">&nbsp;</div>
          </div>
        </div>
      </div>
      <div id="footer">
        
  <hr/>
  <p>Copyright (c) 2012 Gregory Szorc. All rights reserved. Design by <a href="http://www.freecsstemplates.org/"> CSS Templates</a>.</p>


      </div>
    </div>
  </body>
</html>





