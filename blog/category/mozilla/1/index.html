


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
Design by Free CSS Templates
http://www.freecsstemplates.org
Released for free under a Creative Commons Attribution 2.5 License

Name       : Pollinating  
Description: A two-column, fixed-width design with dark color scheme.
Version    : 1.0
Released   : 20101114

-->
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    
  <title>Gregory Szorc's Digital Home
</title>
<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
<link rel="alternate" type="application/atom+xml" title="Atom 1.0"
href="/blog/feed/atom" />
<link rel="stylesheet" href="/style/style.css" type="text/css" />
<link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />


  </head>
  <body>
    <div id="wrapper">
      
  <div id="menu">
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="/blog/">Blog</a></li>
    <li><a href="/notes">Notes</a></li>
    <li><a href="/work.html">Work</a></li>
    <li><a href="/skills.html">Skills</a></li>
    <li><a href="/thoughts.html">Thoughts</a></li>
    <li><a href="/resume.pdf">Resume</a></li>
  </ul>
</div>


      <div id="page">
        <div id="page-bgtop">
          <div id="page-bgbtm">
              <div id="content">
                
  
<div class="blog_post">
  <a name="high-level-problems-with-git-and-how-to-fix-them"></a>
  <h2 class="blog_post_title"><a href="/blog/2017/12/11/high-level-problems-with-git-and-how-to-fix-them" rel="bookmark" title="Permanent Link to High-level Problems with Git and How to Fix Them">High-level Problems with Git and How to Fix Them</a></h2>
  <small>December 11, 2017 at 10:30 AM | categories: 

<a href='/blog/category/git'>Git</a>, <a href='/blog/category/mercurial'>Mercurial</a>, <a href='/blog/category/mozilla'>Mozilla</a>
 | <a href="http://gregoryszorc.com/blog/2017/12/11/high-level-problems-with-git-and-how-to-fix-them#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>I have a... complicated relationship with Git.</p>
<p>When Git first came onto the scene in the mid 2000's, I was initially
skeptical because of its horrible user interface. But once I learned
it, I appreciated its speed and features - especially the ease at which
you could create feature branches, merge, and even create commits
offline (which was a big deal in the era when Subversion was the
dominant version control tool in open source and you needed to speak with
a server in order to commit code). When I started using Git day-to-day,
it was such an obvious improvement over what I was using before (mainly
Subversion and even CVS).</p>
<p>When I started working for Mozilla in 2011, I was exposed to the
Mercurial version control, which then - and still today - hosts the
canonical repository for Firefox. I didn't like Mercurial initially.
Actually, I despised it. I thought it was slow and its features lacking.
And I frequently encountered repository corruption.</p>
<p>My first experience learning the <em>internals</em> of both Git and Mercurial
came when I found myself hacking on
<a href="http://hg-git.github.io/]">hg-git</a> - a tool that allows you to convert
Git and Mercurial repositories to/from each other. I was hacking on hg-git
so I could improve the performance of converting Mercurial repositories
to Git repositories. And I was doing that because I wanted to use Git -
not Mercurial - to hack on Firefox. I was trying to enable an unofficial
Git mirror of the Firefox repository to synchronize faster so it would
be more usable. The ulterior motive was to demonstrate that Git is a
superior version control tool and that Firefox should switch its canonical
version control tool from Mercurial to Git.</p>
<p>In what is a textbook definition of <em>irony</em>, what happened instead was
I actually learned how Mercurial worked, interacted with the Mercurial
Community, realized that Mozilla's documentation and developer practices
were... lacking, and that Mercurial was actually a much, much more
pleasant tool to use than Git. It's an old post, but I
<a href="/blog/2013/05/12/thoughts-on-mercurial-(and-git)/">summarized my conversion</a>
four and a half years ago. This started a chain of events that somehow
resulted in me contributing a ton of patches to Mercurial, taking
stewardship of <em>hg.mozilla.org</em>, and becoming a member of the Mercurial
Steering Committee - the governance group for the Mercurial Project.</p>
<p>I've been an advocate of Mercurial over the years. Some would probably say
I'm a Mercurial fanboy. I reject that characterization because <em>fanboy</em> has
connotations that imply I'm ignorant of realities. I'm well aware of
Mercurial's faults and weaknesses. I'm well aware of Mercurial's relative
lack of popularity, I'm well aware that this lack of popularity almost
certainly turns away contributors to Firefox and other Mozilla projects
because people don't want to have to learn a new tool. I'm well aware that
there are changes underway to enable Git to scale to <em>very large
repositories</em> and that these changes could threaten Mercurial's scalability
advantages over Git, making choices to use Mercurial even harder to defend.
(As an aside, the party most responsible for pushing Git to adopt
architectural changes to enable it to scale these days is Microsoft.
Could anyone have foreseen that?!)</p>
<p>I've achieved mastery in both Git and Mercurial. I know their internals
and their command line interfaces extremely well. I understand the
architecture and principles upon which both are built. I'm also exposed
to some very experienced and knowledgeable people in the Mercurial
Community. People who have been around version control for much, much
longer than me and have knowledge of random version control tools you've
probably never heard of. This knowledge and exposure allows me to make
connections and see opportunities for version control that quite frankly
most do not. </p>
<p>In this post, I'll be talking about some high-level, high-impact problems
with Git and possible solutions for them. My primary goal of this post is
to foster positive change in Git and the services around it. While I
personally prefer Mercurial, improving Git is good for everyone. Put
another way, I want my knowledge and perspective from being part of
a version control community to be put to good wherever it can.</p>
<p>Speaking of Mercurial, as I said, I'm a heavy contributor and am somewhat
influential in the Mercurial Community. I want to be clear that my opinions
in this post are my own and I'm not speaking on behalf of the Mercurial
Project or the larger Mercurial Community. I also don't intend to claim
that Mercurial is <em>holier-than-thou</em>. Mercurial has tons of user interface
failings and deficiencies. And I'll even admit to being frustrated that some
systemic failings in Mercurial have gone unaddressed for as long as they
have. But that's for another post. This post is about Git. Let's get started.</p>
<h2>The Staging Area</h2>
<p>The staging area is a feature that should not be enabled in the default
Git configuration.</p>
<p>Most people see version control as an obstacle standing in the way of
accomplishing some other task. They just want to save their progress
towards some goal. In other words, they want version control to be a
<em>save file</em> feature in their workflow.</p>
<p>Unfortunately, modern version control tools don't work that way. For
starters, they require people to specify a <em>commit message</em> every time
they save. This in of itself can be annoying. But we generally accept
that as the price you pay for version control: that <em>commit message</em> has
value to others (or even your future self). So you must record it.</p>
<p>Most people want the barrier to saving changes to be effortless. A commit
message is already too annoying for many users! The Git staging area
establishes a <em>higher</em> barrier to saving. Instead of just saving your
changes, you must first <em>stage</em> your changes to be saved.</p>
<p>If you requested <em>save</em> in your favorite GUI application, text editor,
etc and it popped open a <em>select the changes you would like to
save dialog</em>, you would rightly think <em>just save all my changes already,
dammit.</em> But this is exactly what Git does with its staging area! Git
is saying <em>I know all the changes you made: now tell me which changes
you'd like to save.</em> To the average user, this is infuriating because
it works in contrast to how the <em>save</em> feature works in almost every
other application.</p>
<p>There is a counterargument to be made here. You could say that the
editor/application/etc is complex - that it has multiple <em>contexts</em>
(files) - that each context is independent - and that the user should
have full control over which contexts (files) - and even changes within
those contexts - to save. I agree: this is a compelling feature. However,
it isn't an appropriate <em>default</em> feature. The ability to pick which
changes to save is a power-user feature. Most users just want to save all
the changes all the time. So that should be the default behavior. And
the Git staging area should be an opt-in feature.</p>
<p>If intrinsic workflow warts aren't enough, the Git staging area has a
horrible user interface. It is often referred to as the <em>cache</em>
<a href="https://stackoverflow.com/questions/6716355/why-staging-directory-is-also-called-index-git-index/6718135#6718135">for historical reasons</a>.
<em>Cache</em> of course means something to anyone who knows anything about
computers or programming. And Git's use of <em>cache</em> doesn't at all align
with that common definition. Yet the the terminology in Git persists.
You have to run commands like <code>git diff --cached</code> to examine the state
of the <em>staging area</em>. Huh?!</p>
<p>But Git also refers to the <em>staging area</em> as the <em>index</em>. And this
terminology also appears in Git commands! <code>git help commit</code> has numerous
references to the <em>index</em>. Let's see what <code>git help glossary</code> has to say::</p>
<pre><code>index
    A collection of files with stat information, whose contents are
    stored as objects. The index is a stored version of your working tree.
    Truth be told, it can also contain a second, and even a third
    version of a working tree, which are used when merging.

index entry
    The information regarding a particular file, stored in the index.
    An index entry can be unmerged, if a merge was started, but not
    yet finished (i.e. if the index contains multiple versions of that
    file).
</code></pre>
<p>In terms of end-user documentation, this is a train wreck. It tells the
lay user absolutely nothing about what the <em>index</em> actually is. Instead,
it casually throws out references to <em>stat information</em> (requires the user
know what the <code>stat()</code> function call and struct are) and <em>objects</em> (a Git
term for a piece of data stored by Git). It even undermines its own credibility
with that <em>truth be told</em> sentence. This definition is so bad that it
would probably improve user understanding if it were deleted!</p>
<p>Of course, <code>git help index</code> says <em>No manual entry for gitindex</em>. So
there is literally no hope for you to get a concise, understandable
definition of the <em>index</em>. Instead, it is one of those concepts that you
think you learn from interacting with it all the time. <em>Oh, when I
<code>git add</code> something it gets into this state where <code>git commit</code> will
actually save it.</em></p>
<p>And even if you know what the Git staging area/index/cached is, it can
still confound you. Do you know the interaction between uncommitted
changes in the staging area and working directory when you <code>git rebase</code>?
What about <code>git checkout</code>? What about the various <code>git reset</code> invocations?
I have a confession: I can't remember all the edge cases either. To play
it safe, I try to make sure all my outstanding changes are committed
before I run something like <code>git rebase</code> because I <em>know</em> that will be
safe.</p>
<p>The Git staging area doesn't have to be this complicated. A <em>re-branding</em>
away from <em>index</em> to <em>staging area</em> would go a long way. Adding an alias
from <code>git diff --staged</code> to <code>git diff --cached</code> and removing references
to the <em>cache</em> from common user commands would make a lot of sense and
reduce end-user confusion.</p>
<p>Of course, the Git staging area doesn't really need to exist at all!
The staging area is essentially a <em>soft commit</em>. It performs the
<em>save progress</em> role - the basic requirement of a version control tool.
And in some aspects it is actually a better <em>save progress</em> implementation
than a <em>commit</em> because it doesn't require you to type a commit message!
Because the <em>staging area</em> is a soft commit, all workflows using it can
be modeled as if it were a real commit and the <em>staging area</em> didn't
exist at all! For example, instead of <code>git add --interactive</code> +
<code>git commit</code>, you can run <code>git commit --interactive</code>. Or if you wish
to incrementally add new changes to an in-progress commit, you can
run <code>git commit --amend</code> or <code>git commit --amend --interactive</code> or
<code>git commit --amend --all</code>. If you actually understand the various modes
of <code>git reset</code>, you can use those to <em>uncommit</em>. Of course, the user
interface to performing these actions in Git today is a bit convoluted.
But if the <em>staging area</em> didn't exist, new high-level commands like
<code>git amend</code> and <code>git uncommit</code> could certainly be invented. </p>
<p>To the average user, the <em>staging area</em> is a complicated concept. I'm
a power user. I understand its purpose and how to harness its power. Yet
when I use Mercurial (which doesn't have a <em>staging area</em>), I don't miss
the <em>staging area</em> at all. Instead, I learn that all operations involving
the <em>staging area</em> can be modeled as other fundamental primitives (like
<em>commit amend</em>) that you are likely to encounter anyway. The <em>staging
area</em> therefore constitutes an unnecessary burden and cognitive load on
users. While powerful, its complexity and incurred confusion does not
justify its existence in the default Git configuration. The <em>staging
area</em> is a power-user feature and should be opt-in by default. </p>
<h2>Branches and Remotes Management is Complex and Time-Consuming</h2>
<p>When I first used Git (coming from CVS and Subversion), I thought
branches and remotes were incredible because they enabled new workflows
that allowed you to easily track multiple lines of work across many
repositories. And ~10 years later, I still believe the workflows they
enable are important. However, having amassed a broader perspective, I
also believe their implementation is poor and this unnecessarily confuses
many users and wastes the time of <em>all</em> users.</p>
<p>My initial <em>zen moment</em> with Git - the time when Git finally clicked for me -
was when I understood Git's object model: that Git is just a
content indexed key-value store consisting of a different object types
(blobs, trees, and commits) that have a particular relationship with
each other. <em>Refs</em> are symbolic names pointing to Git commit objects. And
Git <em>branches</em> - both local and remote - are just <em>refs</em> having a
well-defined naming convention (<code>refs/heads/&lt;name&gt;</code> for local branches and
<code>refs/remotes/&lt;remote&gt;/&lt;name&gt;</code> for remote branches). Even <em>tags</em> and
<em>notes</em> are defined via <em>refs</em>.</p>
<p><em>Refs</em> are a necessary primitive in Git because the Git storage model is
to throw all <em>objects</em> into a single, key-value namespace. Since the store
is content indexed and the key name is a cryptographic hash of the object's
content (which for all intents and purposes is random gibberish to
end-users), the Git store by itself is unable to locate objects. If all you
had was the key-value store and you wanted to <em>find all commits</em>, you would
need to walk every object in the store and read it to see if it is a commit
object. You'd then need to buffer metadata about those objects in memory so
you could reassemble them into say a DAG to facilitate looking at commit
history. This approach obviously doesn't scale. <em>Refs</em> short-circuit this
process by providing pointers to objects of importance. It may help to
think of the set of <em>refs</em> as an <em>index</em> into the Git store.  </p>
<p><em>Refs</em> also serve another role: as guards against garbage collection.
I won't go into details about loose objects and packfiles, but it's worth
noting that Git's key-value store also behaves in ways similar to
a generational garbage collector like you would find in programming languages
such as Java and Python. The important thing to know is that Git will
garbage collect (read: delete) objects that are unused. And the mechanism
it uses to determine which objects are unused is to iterate through <em>refs</em>
and walk all transitive references from that initial pointer. If there is
an object in the store that can't be traced back to a <em>ref</em>, it is
<em>unreachable</em> and can be deleted.</p>
<p><em>Reflogs</em> maintain the history of a value for a <em>ref</em>: for each <em>ref</em> they
contain a log of what <em>commit</em> it was pointing to, when that pointer
was established, who established it, etc. <em>Reflogs</em> serve two purposes:
facilitating <em>undoing</em> a previous action and holding a reference to <em>old</em>
data to prevent it from being garbage collected. The two use cases are
related: if you don't care about undo, you don't need the old reference
to prevent garbage collection.</p>
<p>This design of Git's store is actually quite sensible. It's not perfect
(nothing is). But it is a solid foundation to build a version control tool
(or even other data storage applications) on top of.</p>
<p>The title of this section has to do with sub-optimal branches and
remotes management. But I've hardly said anything about branches or remotes!
And this leads me to my main complaint about Git's branches and remotes:
that they are very thin veneer over <em>refs</em>. The properties of Git's
underlying key-value store unnecessarily bleed into user-facing concepts
(like branches and remotes) and therefore dictate sub-optimal practices.
This is what's referred to as a <em>leaky abstraction</em>.</p>
<p>I'll give some examples.</p>
<p>As I stated above, many users treat version control as a <em>save file</em>
step in their workflow. I believe that any step that interferes with users
saving their work is user hostile. This even includes writing a commit
message! I already argued that the <em>staging area</em> significantly interferes
with this critical task. Git <em>branches</em> do as well.</p>
<p>If we were designing a version control tool from scratch (or if you were
a new user to version control), you would probably think that a sane
feature/requirement would be to update to <em>any</em> revision and start making
changes. In Git speak, this would be something like
<code>git checkout b201e96f</code>, make some file changes, <code>git commit</code>. I think
that's a pretty basic workflow requirement for a version control tool.
And the workflow I suggested is pretty intuitive: choose the thing to
start working on, make some changes, then save those changes.</p>
<p>Let's see what happens when we actually do this:</p>
<pre><code>$ git checkout b201e96f
Note: checking out 'b201e96f'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b &lt;new-branch-name&gt;

HEAD is now at b201e96f94... Merge branch 'rs/config-write-section-fix' into maint

$ echo 'my change' &gt;&gt; README.md
$ git commit -a -m 'my change'
[detached HEAD aeb0c997ff] my change
 1 file changed, 1 insertion(+)

$ git push indygreg
fatal: You are not currently on a branch.
To push the history leading to the current (detached HEAD)
state now, use

    git push indygreg HEAD:&lt;name-of-remote-branch&gt;

$ git checkout master
Warning: you are leaving 1 commit behind, not connected to
any of your branches:

  aeb0c997ff my change

If you want to keep it by creating a new branch, this may be a good time
to do so with:

 git branch &lt;new-branch-name&gt; aeb0c997ff

Switched to branch 'master'
Your branch is up to date with 'origin/master'.
</code></pre>
<p>I know what all these messages mean because I've mastered Git. But if
you were a newcomer (or even a seasoned user), you might be very confused.
Just so we're on the same page, here is what's happening (along with
some commentary).</p>
<p>When I run <code>git checkout b201e96f</code>, Git is trying to tell me that I'm
potentially doing something that could result in the loss of my data. A
golden rule of version control tools is <em>don't lose the user's data</em>. When
I run <code>git checkout</code>, Git should be stating the risk for data loss very
clearly. But instead, the <em>If you want to create a new branch</em> sentence is
hiding this fact by instead phrasing things around <em>retaining commits you
create</em> rather than the possible loss of data. It's up to the user
to make the connection that <em>retaining commits you create</em> actually means
<em>don't eat my data</em>. Preventing data loss is critical and Git should not
mince words here!</p>
<p>The <code>git commit</code> seems to work like normal. However, since we're in a
<em>detached HEAD</em> state (a phrase that is likely gibberish to most users),
that commit isn't referred to by any <em>ref</em>, so it can be <em>lost</em> easily.
Git <em>should</em> be telling me that I just committed something it may not
be able to find in the future. But it doesn't. Again, Git isn't being
as protective of my data as it needs to be.</p>
<p>The failure in the <code>git push</code> command is essentially telling me I need
to give things a name in order to <em>push</em>. <em>Pushing</em> is effectively <em>remote
save</em>. And I'm going to apply my reasoning about version control tools
not interfering with <em>save</em> to <em>pushing</em> as well: Git is adding an
extra barrier to <em>remote save</em> by refusing to push commits without a
<em>branch</em> attached and by doing so is being user hostile.</p>
<p>Finally, we <code>git checkout master</code> to move to another commit. Here, Git
is actually doing something halfway reasonable. It is telling me I'm
leaving commits behind, which commits those are, and the command to
use to <em>keep</em> those commits. The warning is good but not great. I think
it needs to be stronger to reflect the risk around data loss if that
suggested Git commit isn't executed. (Of course, the <em>reflog</em> for <code>HEAD</code>
will ensure that data isn't immediately deleted. But users shouldn't
need to involve <em>reflogs</em> to not lose data that wasn't rewritten.)</p>
<p>The point I want to make is that Git doesn't allow you to just <em>update
and save</em>. Because its <em>dumb</em> store requires pointers to relevant commits
(<em>refs</em>) and because that requirement isn't abstracted away or paved over
by user-friendly features in the frontend, Git is effectively requiring
end-users to define names (<em>branches</em>) for all commits. If you fail to
define a name, it gets a lot harder to find your commits, exchange them,
and Git may delete your data. While it is technically possible to not
create branches, the version control tool is essentially unusable without
them.</p>
<p>When local branches are exchanged, they appear as <em>remote branches</em> to
others. Essentially, you give each instance of the repository a name
(the <em>remote</em>). And branches/refs fetched from a named <em>remote</em> appear
as a <em>ref</em> in the <em>ref namespace</em> for that <em>remote</em>. e.g.
<em>refs/remotes/origin</em> holds <em>refs</em> for the <em>origin</em> <em>remote</em>. (Git allows
you to not have to specify the <em>refs/remotes</em> part, so you can refer
to e.g. <em>refs/remotes/origin/master</em> as <em>origin/master</em>.)</p>
<p>Again, if you were designing a version control tool from scratch or you
were a new Git user, you'd probably think <em>remote refs</em> would make
good starting points for work. For example, if you know you should be
saving new work on top of the <em>master</em> branch, you might be inclined
to begin that work by running <code>git checkout origin/master</code>. But like
our specific-commit checkout above:</p>
<pre><code>$ git checkout origin/master
Note: checking out 'origin/master'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b &lt;new-branch-name&gt;

HEAD is now at 95ec6b1b33... RelNotes: the eighth batch
</code></pre>
<p>This is the same message we got for a direct checkout. But we did
supply a <em>ref</em>/<em>remote branch</em> name. What gives? Essentially, Git tries
to enforce that the <em>refs/remotes/</em> namespace is read-only and only
updated by operations that exchange data with a remote, namely <code>git fetch</code>,
<code>git pull</code>, and <code>git push</code>.</p>
<p>For this to work correctly, you need to create a new <em>local branch</em>
(which initially points to the commit that <code>refs/remotes/origin/master</code>
points to) and then switch/activate that <em>local branch</em>.</p>
<p>I could go on talking about all the subtle nuances of how Git branches
are managed. But I won't.</p>
<p>If you've used Git, you know you need to use branches. You may or may
not recognize just how frequently you have to type a branch name into
a <code>git</code> command. I guarantee that if you are familiar with version control
tools and workflows that aren't based on having to manage <em>refs</em> to
track data, you will find Git's forced usage of <em>refs</em> and <em>branches</em>
a bit absurd. I half jokingly refer to Git as <em>Game of Refs</em>. I say that
because coming from Mercurial (which doesn't require you to name things),
Git workflows feel to me like all I'm doing is typing the names of branches
and <em>refs</em> into <code>git</code> commands. I feel like I'm wasting my precious
time telling Git the names of things only because this is necessary to
placate the leaky abstraction of Git's storage layer which requires
references to relevant commits.</p>
<p>Git and version control doesn't have to be this way.</p>
<p>As I said, my Mercurial workflow doesn't rely on naming things. Unlike
Git, Mercurial's store has an explicit (not shared) storage location
for commits (<em>changesets</em> in Mercurial parlance). And this data structure
is ordered, meaning a changeset <em>later</em>  always occurs after its
parent/predecessor. This means that Mercurial can open a single
file/index to quickly find all <em>changesets</em>. Because Mercurial doesn't
need pointers to commits of relevance, names aren't required.</p>
<p>My <em>Zen of Mercurial</em> moment came when I realized you didn't have
to name things in Mercurial. Having used Git before Mercurial, I
was conditioned to always be naming things. This is the Git way
after all. And, truth be told, it is common to name things in Mercurial
as well. Mercurial's <em>named branches</em> were the way to do <em>feature
branches</em> in Mercurial for years. Some used the <em>MQ</em> extension (essentially
a port of <a href="https://en.wikipedia.org/wiki/Quilt_(software)">quilt</a>), which
also requires naming individual patches. Git users coming to Mercurial
were missing Git branches and Mercurial's <em>bookmarks</em> were a poor
<em>port</em> of Git branches.</p>
<p>But recently, more and more Mercurial users have been coming to the
realization that names aren't really necessary. If the tool doesn't
actually require naming things, why force users to name things? As long
as users can find the commits they need to find, do you actually need
names?</p>
<p>As a demonstration, my Mercurial workflow leans heavily on the <code>hg show work</code>
and <code>hg show stack</code> commands. You will need to enable the <em>show</em> extension
by putting the following in your hgrc config file to use them:</p>
<pre><code>[extensions]
show =
</code></pre>
<p>Running <code>hg show work</code> (I have also set the config
<code>commands.show.aliasprefix=s</code>to enable me to type <code>hg swork</code>) finds all
in-progress changesets and other likely-relevant changesets (those
with names and DAG heads). It prints a concise DAG of those changesets:</p>
<p><img alt="hg show work output" src="/images/hg-show-work.png" /></p>
<p>And <code>hg show stack</code> shows just the current line of work and its
relationship to other important heads:</p>
<p><img alt="hg show stack output" src="/images/hg-show-stack.png" /></p>
<p>Aside from the <code>@</code> bookmark/name set on that top-most changeset, there are
no names! (That <code>@</code> comes from the remote repository, which has set that name.)</p>
<p>Outside of code archeology workflows, <code>hg show work</code> shows the changesets I
care about 95% of the time. With all I care about (my in-progress work and
possible rebase targets) rendered concisely, I don't have to name things
because I can just find whatever I'm looking for by running <code>hg show work</code>!
Yes, you need to run <code>hg show work</code>, visually scan for what you are looking
for, and copy a (random) hash fragment into a number of commands. This
sounds like a lot of work. But I believe it is far less work than naming
things. Only when you practice this workflow do you realize just how much
time you actually spend finding and then typing names in to <code>hg</code> and -
especailly - <code>git</code> commands! The ability to just <code>hg update</code> to a changeset
and commit without having to name things is just so liberating. It feels
like my version control tool is putting up fewer barriers and letting me
work quickly.</p>
<p>Another benefit of <code>hg show work</code> and <code>hg show stack</code> are that they present
a concise DAG visualization to users. This helps educate users about the
underlying <em>shape</em> of repository data. When you see connected nodes on a
graph and how they change over time, it makes it a lot easier to understand
concepts like <em>merge</em> and <em>rebase</em>. </p>
<p>This <em>nameless</em> workflow may sound radical. But that's because we're all
conditioned to naming things. I initially thought it was crazy as well. But
once you have a mechanism that gives you rapid access to data you care
about (<code>hg show work</code> in Mercurial's case), names become very optional. Now,
a pure <em>nameless</em> workflow isn't without its limitations. You want names
to identify the main <em>targets</em> for work (e.g. the <em>master</em> branch). And when
you exchange work with others, names are easier to work with, especially
since names survive rewriting. But in my experience, most of my commits
are only exchanged with me (synchronizing my in-progress commits across
devices) and with code review tools (which don't really need names and
can operate against raw commits). My most frequent use of names comes
when I'm in <em>repository maintainer mode</em> and I need to ensure commits
have names for others to reference.</p>
<p>Could Git support <em>nameless</em> workflows? In theory it can.</p>
<p>Git needs <em>refs</em> to find relevant commits in its store. And the wire
protocol uses <em>refs</em> to exchange data. So <em>refs</em> have to exist for Git
to function (assuming Git doesn't radically change its storage and
exchange mechanisms to mitigate the need for <em>refs</em>, but that would be
a massive change and I don't see this happening).</p>
<p>While there is a fundamental requirement for <em>refs</em> to exist, this
doesn't necessarily mean that user-facing names must exist. The reason
that we need <em>branches</em> today is because <em>branches</em> are little more than
a <em>ref</em> with special behavior. It is theoretically possible to invent a
mechanism that transparently maps <em>nameless</em> commits onto <em>refs</em>. For
example, you could create a <em>refs/nameless/</em> namespace that was
automatically populated with DAG heads that didn't have names attached.
And Git could exchange these <em>refs</em> just like it can <em>branches</em> today.
It would be a lot of work to think through all the implications and to
design and implement support for <em>nameless</em> development in Git. But I
think it is possible.</p>
<p>I encourage the Git community to investigate supporting <em>nameless</em> workflows.
Having adopted this workflow in Mercurial, Git's workflow around naming
branches feels heavyweight and restrictive to me. Put another way, <em>nameless</em>
commits are actually lighter-weight branches than Git branches! To the
common user who just wants version control to be a <em>save</em> feature,
requiring names establishes a barrier towards that goal. So removing the
naming requirement would make Git simpler and more approachable to new
users.</p>
<h2>Forks aren't the Model You are Looking For</h2>
<p>This section is more about hosted Git services (like GitHub, Bitbucket, and
GitLab) than Git itself. But since hosted Git services are synonymous
with <em>Git</em> and interaction with a hosted Git services is a regular
part of a common Git user's workflow, I feel like I need to cover it.
(For what it's worth, my experience at Mozilla tells me that a large
percentage of people who say <em>I prefer Git</em> or <em>we should use Git</em>
actually mean <em>I like GitHub</em>. Git and GitHub/Bitbucket/GitLab are
effectively the same thing in the minds of many and anyone finding
themselves discussing version control needs to keep this in mind because
<em>Git</em> is more than just the command line tool: it is an ecosystem.)</p>
<p>I'll come right out and say it: I think <em>forks</em> are a relatively poor
model for collaborating. They are light years better than what
existed before. But they are still so far from the turn-key experience
that should be possible. The <em>fork</em> hasn't really changed much since
the current implementation of it was made popular by GitHub many years
ago. And I view this as a general failure of hosted services to
innovate.</p>
<p>So we have a shared understanding, a <em>fork</em> (as implemented on GitHub,
Bitbucket, GitLab, etc) is essentially a complete copy of a repository
(a <code>git clone</code> if using Git) and a fresh workspace for additional
value-added services the hosting provider offers (pull requests, issues,
wikis, project tracking, release tracking, etc). If you open the main
web page for a <em>fork</em> on these services, it looks just like the main
project's. You know it is a fork because there are cosmetics somewhere
(typically next to the project/repository name) saying <em>forked from</em>.</p>
<p>Before service providers adopted the <em>fork</em> terminology, <em>fork</em> was
used in open source to refer to a splintering of a project. If
someone or a group of people didn't like the direction a project was
taking, wanted to take over ownership of a project because of
stagnation, etc, they would <em>fork it</em>. The <em>fork</em> was based on the
original (and there may even be active collaboration between the
fork and original), but the intent of the <em>fork</em> was to create
distance between the original project and its new incantation. A
new entity that was sufficiently independent of the original.</p>
<p><em>Forks</em> on service providers mostly retain this <em>old school</em> <em>fork</em>
model. The <em>fork</em> gets a new copy of issues, wikis, etc. And anyone
who <em>forks</em> establishes what looks like an independent incantation
of a project. It's worth noting that the execution varies by service
provider. For example, GitHub won't enable <em>Issues</em> for a fork by
default, thereby encouraging people to file issues against the
<em>upstream</em> project it was forked from. (This is good default behavior.)</p>
<p>And I know why service providers (initially) implemented things this
way: it was easy. If you are building a product, it's simpler to just
say <em>a user's version of this project is a <code>git clone</code> and they get
a fresh database</em>. On a technical level, this meets the traditional
definition of <em>fork</em>. And rather than introduce a new term into the
vernacular, they just re-purposed <em>fork</em> (albeit with <em>softer</em>
connotations, since the traditional <em>fork</em> commonly implied there
was some form of strife precipitating a <em>fork</em>).</p>
<p>To help differentiate flavors of <em>forks</em>, I'm going to define the
terms <em>soft fork</em> and <em>hard fork</em>. A <em>soft fork</em> is a <em>fork</em> that
exists for purposes of collaboration. The differentiating feature
between a <em>soft fork</em> and <em>hard fork</em> is whether the <em>fork</em> is
intended to be used as its own project. If it is, it is a
<em>hard fork</em>. If not - if all changes are intended to be <em>merged</em>
into the <em>upstream</em> project and be consumed from there - it is a
<em>soft fork</em>.</p>
<p>I don't have concrete numbers, but I'm willing to wager that the vast
majority of <em>forks</em> on Git service providers which have changes are
<em>soft forks</em> rather than <em>hard forks</em>. In other words, these <em>forks</em>
exist purely as a conduit to collaborate with the canonical/upstream
project (or to facilitate a short-lived one-off change).</p>
<p>The current implementation of <em>fork</em> - which borrows a lot from its
predecessor of the same name - is a good - but not great - way to
facilitate collaboration. It isn't great because it technically
resembles what you'd expect to see for <em>hard fork</em> use cases even
though it is used predominantly with <em>soft forks</em>. This mismatch
creates problems.</p>
<p>If you were to take a step back and invent your own version control
hosted service and weren't tainted by exposure to existing services
and were willing to think a bit beyond making it a glorified frontend
for the <code>git</code> command line interface, you might realize that the problem
you are solving - the product you are selling - is collaboration as
a service, not a Git hosting service. And if your product is
collaboration, then implementing your collaboration model around the
<em>hard fork</em> model with strong barriers between the original project and
its <em>forks</em> is counterproductive and undermines your own product.
But this is how GitHub, Bitbucket, GitLab, and others have implemented
their product!</p>
<p>To improve collaboration on version control hosted services, the concept
of a <em>fork</em> needs to significantly curtailed. Replacing it should be
a UI and workflow that revolves around the central, canonical repository.</p>
<p>You shouldn't need to create your own <em>clone</em> or <em>fork</em> of a repository
in order to contribute. Instead, you should be able to clone the
canonical repository. When you create commits, those commits should
be stored and/or more tightly affiliated with the original project - not
inside a <em>fork</em>.</p>
<p>One potential implementation is doable today. I'm going to call it
<em>workspaces</em>. Here's how it would work.</p>
<p>There would exist a namespace for <em>refs</em> that can be controlled by
the user. For example, on GitHub (where my username is <em>indygreg</em>),
if I wanted to contribute to some random project, I would <code>git push</code>
my refs somewhere under <code>refs/users/indygreg/</code> directly to that
project's. No <em>forking</em> necessary. If I wanted to contribute to a
project, I would just clone its repo then push to my <em>workspace</em> under
it. You could do this today by configuring your Git <em>refspec</em> properly.
For pushes, it would look something like
<code>refs/heads/*:refs/users/indygreg/*</code> (that tells Git to map local <em>refs</em>
under <code>refs/heads/</code> to <code>refs/users/indygreg/</code> on that <em>remote</em> repository).
If this became a popular feature, presumably the Git wire protocol could
be taught to advertise this feature such that Git clients automatically
configured themselves to push to user-specific <em>workspaces</em> attached to
the original repository.</p>
<p>There are several advantages to such a <em>workspace</em> model. Many of them
revolve around eliminating <em>forks</em>.</p>
<p>At initial contribution time, no server-side <em>fork</em> is necessary in order
to contribute. You would be able to <em>clone and contribute</em> without waiting
for or configuring a <em>fork</em>. Or if you can create commits from the web
interface, the clone wouldn't even be necessary! Lowering the barrier to
contribution is a good thing, especially if collaboration is the product
you are selling.</p>
<p>In the web UI, <em>workspaces</em> would also revolve around the source project
and not be off in their own world like <em>forks</em> are today. People could
more easily see what others are up to. And fetching their work would
require typing in their username as opposed to configuring a whole new
remote. This would bring communities closer and hopefully lead to better
collaboration.</p>
<p>Not requiring <em>forks</em> also eliminates the need to synchronize your <em>fork</em>
with the upstream repository. I don't know about you, but one of the things
that bothers me about the <em>Game of Refs</em> that Git imposes is that I have
to keep my <em>refs</em> in sync with the upstream <em>refs</em>. When I fetch from
<em>origin</em> and pull down a new <em>master</em> branch, I need to <code>git merge</code>
that branch into my local <em>master</em> branch. Then I need to push that new
<em>master</em> branch to my fork. This is quite tedious. And it is easy to merge
the wrong branches and get your <em>branch</em> state out of whack. There are
better ways to map remote <em>refs</em> into your local names to make this far
less confusing.</p>
<p>Another win here is not having to push and store data multiple times.
When working on a <em>fork</em> (which is a separate repository), after you
<code>git fetch</code> changes from upstream, you need to eventually <code>git push</code> those
into your <em>fork</em>. If you've ever worked on a large repository and didn't
have a super fast Internet connection, you may have been stymied by
having to <code>git push</code> large amounts of data to your <em>fork</em>. This is quite
annoying, especially for people with slow Internet connections. Wouldn't
it be nice if that <code>git push</code> only pushed the data that was truly new and
didn't already exist somewhere else on the server? A <em>workspace</em> model
where development all occurs in the original repository would fix this.
As a bonus, it would make the storage problem on servers easier because
you would eliminate thousands of forks and you probably wouldn't have to
care as much about data duplication across repos/clones because the
version control tool solves a lot of this problem for you, courtesy of
having all data live alongside or in the original repository instead of
in a <em>fork</em>.</p>
<p>Another win from <em>workspace</em>-centric development would be the potential to
do more user-friendly things after <em>pull/merge requests</em> are incorporated
in the official project. For example, the <em>ref</em> in your workspace could
be deleted automatically. This would ease the burden on users to clean up
after their submissions are accepted. Again, instead of mashing keys to
play the <em>Game of Refs</em>, this would all be taken care of for you
automatically. (Yes, I know there are scripts and shell aliases to
make this more turn-key. But user-friendly behavior shouldn't have to
be opt-in: it should be the default.)</p>
<p>But <em>workspaces</em> aren't all rainbows and unicorns. There are access
control concerns. You probably don't want users able to mutate the
<em>workspaces</em> of other users. Or do you? You can make a compelling
case that project <em>administrators</em> should have that ability. And what if
someone pushes bad or illegal content to a workspace and you receive
a cease and desist? Can you take down just the offending workspace while
complying with the order? And what happens if the original project is
deleted? Do all its workspaces die with it? These are not trivial
concerns. But they don't feel impossible to tackle either.</p>
<p><em>Workspaces</em> are only one potential alternative to <em>forks</em>. And I can
come up with multiple implementations of the <em>workspace</em> concept. Although
many of them are constrained by current features in the Git wire protocol.
But Git is (finally) getting a more extensible wire protocol, so hopefully
this will enable <em>nice things</em>.</p>
<p>I challenge Git service providers like GitHub, Bitbucket, and GitLab to
think outside the box and implement something better than how <em>forks</em>
are implemented today. It will be a large shift. But I think users will
appreciate it in the long run.</p>
<h2>Conclusion</h2>
<p>Git is an ubiquitous version control tool. But it is
<a href="http://stevelosh.com/blog/2013/04/git-koans/">frequently lampooned</a> for
its <a href="https://stevebennett.me/2012/02/24/10-things-i-hate-about-git/">poor usability</a>
and <a href="https://git-man-page-generator.lokaltog.net/">documentation</a>.
We even have
<a href="https://spderosso.github.io/onward13.pdf">research</a>
<a href="https://spderosso.github.io/oopsla16.pdf">papers</a> telling us which parts
are bad. Nobody I know has had a pleasant initial experience with Git.
And it is clear that few people actually understand Git: most just know
the command incantations they need to know to accomplish a small set of
common activities. (If you are such a person, there is nothing to be
ashamed about: Git is a <em>hard</em> tool.)</p>
<p>Popular Git-based hosting and collaboration services (such as GitHub,
Bitbucket, and GitLab) exist. While they've made strides to make it
easier to commit data to a Git repository (I purposefully avoid saying
<em>use Git</em> because the most usable tools seem to avoid the <code>git</code> command
line interface as much as possible), they are often a thin veneer over
Git itself (see <em>forks</em>). And Git is a thin veneer over a content
indexed key-value store (see forced usage of bookmarks).</p>
<p>As an industry, we should be concerned about the lousy usability of Git
and the tools and services that surround it. Some may say that Git -
with its near monopoly over version control mindset - is a success. I
have a different view: I think it is a failure that a tool with a user
experience this bad has achieved the success it has.</p>
<p>The cost to Git's poor usability can be measured in tens if not hundreds
of millions of dollars in time people have wasted because they couldn't
figure out how to use Git. Git should be viewed as a source of
embarrassment, not a success story.</p>
<p>What's really concerning is that the usability problems of Git have been
known for years. Yet it is as popular as ever and there have been few
substantial usability improvements. We do have some
<a href="http://gitless.com/">alternative frontends</a> floating around. But these
haven't caught on.</p>
<p>I'm at a loss to understand how an open source tool as popular as Git
has remained so mediocre for so long. The source code is out there.
Anybody can submit a patch to fix it. Why is it that so many people get
tripped up by the same poor usability issues years after Git became
the common version control tool? It certainly appears that as an
industry we have been unable or unwilling to address systemic deficiencies
in a critical tool. Why this is, I'm not sure.</p>
<p>Despite my pessimism about Git's usability and its poor track record of
being attentive to the needs of people who aren't power users, I'm
optimistic that the future will be brighter. While the ~7000 words in this
post pale in comparison to the aggregate word count that has been
written about Git, hopefully this post strikes a nerve and causes
positive change. Just because one generation has toiled with the
usability problems of Git doesn't mean the next generation has to
suffer through the same. Git can be improved and I encourage that change
to happen. The three issues above and their possible solutions would
be a good place to start.</p>

  </div>
</div>



  <div class="after_post"><a href="http://gregoryszorc.com/blog/2017/12/11/high-level-problems-with-git-and-how-to-fix-them#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  
<div class="blog_post">
  <a name="good-riddance-to-aufs"></a>
  <h2 class="blog_post_title"><a href="/blog/2017/12/08/good-riddance-to-aufs" rel="bookmark" title="Permanent Link to Good Riddance to AUFS">Good Riddance to AUFS</a></h2>
  <small>December 08, 2017 at 03:00 PM | categories: 

<a href='/blog/category/docker'>Docker</a>, <a href='/blog/category/mozilla'>Mozilla</a>
 | <a href="http://gregoryszorc.com/blog/2017/12/08/good-riddance-to-aufs#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>For over a year, AUFS - a layering filesystem for Linux - has been
giving me fits.</p>
<p>As
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1291940">I initially measured last year</a>,
AUFS has... suboptimal performance characteristics. The crux of the problem is
that AUFS obtains a <strong>global</strong> lock in the Linux kernel (at least version 3.13)
for various I/O operations, including <em>stat()</em>. If you have more than a couple
of active CPU cores, the overhead from excessive kernel locking inside
<em>_raw_spin_lock()</em> can add more overhead than extra CPU cores add capacity.
That's right: under certain workloads, adding more CPU cores actually slows
down execution due to cores being starved waiting for a global lock in the
kernel!</p>
<p>If that weren't enough, AUFS can also violate POSIX filesystem guarantees
under load. It appears that AUFS sometimes forgets about created files or
has race conditions that prevent created files from being visible to
readers until many seconds later! I <em>think</em> this issue only occurs when
there are concurrent threads creating files.</p>
<p>These two characteristics of AUFS have inflicted a lot of hardship on
Firefox's continuous integration. Large parts of Firefox's CI execute in
Docker. And the host environment for Docker has historically used Ubuntu
14.04 with Linux 3.13 and Docker using AUFS. AUFS was/is the default
storage driver for many versions of Docker. When this storage driver is
used, all files inside Docker containers are backed by AUFS unless a
Docker <em>volume</em> (a directory bind mounted from the host filesystem - EXT4
in our case) is in play.</p>
<p>When we started using EC2 instances with more CPU cores, we weren't
getting a linear speedup for CPU bound operations. Instead, CPU cycles
were being spent inside the kernel. Stack profiling showed AUFS as the
culprit. We were thus unable to leverage more powerful EC2 instances
because adding more cores would only provide marginal to negative gains
against significant cost expenditure.</p>
<p>We worked around this problem by making heavy use of Docker <em>volumes</em>
for tasks incurring significant I/O. This included version control clones
and checkouts.</p>
<p>Somewhere along the line, we discovered that AUFS volumes were also the
cause of several random <em>file not found</em> errors throughout automation.
Initially, we thought many of these errors were due to bugs in the
underlying tools (Mercurial and Firefox's build system were common
victims because they do lots of concurrent I/O). When the bugs
mysteriously went away after ensuring certain operations were performed
on EXT4 volumes, we were able to blame AUFS for the myriad of filesystem
consistency problems.</p>
<p>Earlier today, we pushed out a change to upgrade Firefox's CI to Linux
4.4 and switched Docker from AUFS to overlayfs (using the <em>overlay2</em> storage
driver). The improvements exceeded my expectations.</p>
<p>Linux build times have decreased by ~4 minutes, from ~750s to ~510s.</p>
<p>Linux Rust test times have decreased by ~4 minutes, from ~615s to ~380s.</p>
<p>Linux PGO build times have decreased by ~5 minutes, from ~2130s to ~1820s.</p>
<p>And this is just the build side of the world. I don't have numbers
off hand, but I suspect many tests also got a nice speedup from this
change.</p>
<p>Multiplied by thousands of tasks per day and factoring in the cost
to operate these machines, the elimination of AUFS has substantially
increased the efficiency (and reliability) of Firefox CI and easily
saved Mozilla tens of thousands of dollars per year. And that's just
factoring in the savings in the AWS bill. Time is money and people
are a lot more expensive than AWS instances (you can run over 3,000
c5.large EC2 instances at spot pricing for what it costs to employ me
when I'm <em>on the clock</em>). So the real win here comes from Firefox
developers being able to move faster because their builds and tests
complete several minutes faster.</p>
<p>In conclusion, if you care about performance or filesystem correctness,
avoid AUFS. Use overlayfs instead.</p>

  </div>
</div>



  <div class="after_post"><a href="http://gregoryszorc.com/blog/2017/12/08/good-riddance-to-aufs#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  
<div class="blog_post">
  <a name="from-__past__-import-bytes_literals"></a>
  <h2 class="blog_post_title"><a href="/blog/2017/03/13/from-__past__-import-bytes_literals" rel="bookmark" title="Permanent Link to from __past__ import bytes_literals">from __past__ import bytes_literals</a></h2>
  <small>March 13, 2017 at 09:55 AM | categories: 

<a href='/blog/category/python'>Python</a>, <a href='/blog/category/mercurial'>Mercurial</a>, <a href='/blog/category/mozilla'>Mozilla</a>
 | <a href="http://gregoryszorc.com/blog/2017/03/13/from-__past__-import-bytes_literals#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>Last year, I simultaneously committed one of the ugliest and
impressive hacks of my programming <em>career</em>. I haven't had time
to write about it. Until now.</p>
<p>In summary, the hack is a
<a href="https://www.mercurial-scm.org/repo/hg/rev/1c22400db72d">source-transforming module loader</a>
for Python. It can be used by Python 3 to import a Python 2 source
file while translating certain primitives to their Python 3 equivalents.
It is kind of like <a href="https://docs.python.org/3.6/library/2to3.html">2to3</a>
except it executes at run-time during <code>import</code>. The main goal of the
hack was to facilitate porting Mercurial to Python 3 while deferring
having to make the most invasive - and therefore most annoying -
elements of the port in the canonical source code representation.</p>
<p>For the technically curious, it works as follows.</p>
<p>The <code>hg</code> Python executable registers a custom
<a href="https://docs.python.org/3.6/library/sys.html#sys.meta_path">meta path finder</a>
instance. This entity is invoked during <code>import</code> statements to try
to find the module being imported. It tells a later phase of the
import mechanism how to <em>load</em> that module from wherever it is
(usually a <code>.py</code> or <code>.pyc</code> file on disk) to a Python module object.
The custom finder only responds to requests for modules known
to be managed by the Mercurial project. For these modules, it tells
the next stage of the import mechanism to invoke a custom
<a href="https://docs.python.org/3.6/library/importlib.html#importlib.abc.SourceLoader">SourceLoader</a>
instance. Here's where the real magic is: when the custom <em>loader</em>
is invoked, it tokenizes the Python source code using the
<a href="https://docs.python.org/3.6/library/tokenize.html">tokenize</a> module,
iterates over the token stream, finds specific patterns, and
rewrites them to something <em>more appropriate</em>. It then <em>untokenizes</em>
back to Python source code then falls back to the built-in loader
which does the heavy lifting of compiling the source to Python code
objects. So, we have Python 2 source files on disk that magically get
transformed to be Python compatible when they are loaded by Python 3.
Oh, and there is no performance penalty for the token transformation
on subsequence loads because the transformed bytecode is cached in
the <code>.pyc</code> file (using a custom header so we know it was transformed
and can be invalidated when the transformation logic changes).</p>
<p>At the time I wrote it, the token stream manipulation converted most
string literals (<code>''</code>) to bytes literals (<code>b''</code>). In other words, it
restored the Python 2 behavior of string literals being <code>bytes</code> and
not <code>unicode</code>. We jokingly call it
<code>from __past__ import bytes_literals</code> (a play on Python 2's
<code>from __future__ import unicode_literals</code> special syntax which
changes string literals from Python 2's <code>str</code>/<code>bytes</code> type to
<code>unicode</code> to match Python 3's behavior).</p>
<p>Since I implemented the first version, others have implemented:</p>
<ul>
<li><a href="https://www.mercurial-scm.org/repo/hg/rev/178c89e8519a">Automatically inserting</a>
  a <code>from mercurial.pycompat import ...</code> statement to the top of the
  source. This statement is the Mercurial equivalent of importing
  common wrapper types similar to what
  <a href="https://pythonhosted.org/six/">six</a> provides.</li>
<li>More robust
  <a href="https://www.mercurial-scm.org/repo/hg/rev/423377290a3a">function argument parsing support</a>.
  (Because going from a token stream to a higher-level primitive like a
  function call is difficult.)</li>
<li><a href="https://www.mercurial-scm.org/repo/hg/rev/eaaedad68011">Automatically rewriting</a>
  <code>.iteritems()</code> to <code>.items()</code>.</li>
</ul>
<p>As one can expect, when I tweeted a link to this commit, many Python
developers (including a few CPython core developers) expressed a mix
of intrigue and horror. But mostly horror.</p>
<p>I fully concede that what I did here is a gross hack. And, it is the
intention of the Mercurial project to undo this hack and perform a
proper port once Python 3 support in Mercurial is more mature. But, I
want to lay out my defense on why I did this and why the Mercurial
project is tolerant of this ugly hack.</p>
<p>Individuals within the Mercurial project have wanted to port to Python
3 for years. Until recently, it hasn't been a project priority
because a port was too much work for too little end-user gain. And, on
the technical front, a port was just not practical until Python 3.5.
(Two main blockers were no <code>u''</code> literals - restored in Python 3.3 -
and no <code>%</code> formatting for <code>b''</code> literals - restored in 3.5. And as I
understand it, senior members of the Mercurial project had to lobby
Python maintainers pretty hard to get features like <code>%</code> formatting of
<code>b''</code> literals restored to Python 3.)</p>
<p>Anyway, after a number of failed attempts to initiate the Python 3
port over the years, the Mercurial project started making some
positive steps towards Python 3 compatibility, such as switching
to <a href="https://www.python.org/dev/peps/pep-0328/">absolute imports</a> and
addressing syntax issues that allowed modules to be parsed into
an AST and even compiled and loadable. These may seem like small
steps, but for a larger project, it was a lot of work.</p>
<p>The porting effort hit a large wall when it came time to actually
make the AST-valid Python code run on Python 3. Specifically, we had
a strings problem.</p>
<p>When you write software that exchanges data between machines -
sometimes machines running different operating systems or having
different encodings - and there is an expectation that things work
the same and data roundtrips accordingly, trying to force text
encodings is essentially impossible and inevitably breaks something or
someone. It is much easier for Mercurial to operate <em>bytes first</em> and
only take text encoding into consideration when absolutely necessary
(such as when emitting bytes to the terminal in the wanted encoding
or when emitting JSON). That's not to say Mercurial ignores the
existence of encodings. Far from it: Mercurial does attempt to
normalize some data to Unicode. But it often does so with a special
Python type that internally stores the raw byte sequence of the
source so that a consumer can choose to operate at the bytes or
Unicode level. </p>
<p>Anyway, this means that practically every string variable in Mercurial
is a <code>bytes</code> type (or something that acts like a <code>bytes</code> type). And
since string literals in Python 3 are the <code>str</code> type (which represents
Unicode), that would mean having to prefix almost every <code>''</code> string
literal in Mercurial with <code>b''</code> in order to placate Python 3. Having
to update every occurrence of simple primitives that could be statically
transformed automatically felt like busy work. <strong>We wanted to spend time
on the meaningful parts of the Python 3 port so we could find
interesting problems and challenges, not toil with mechanical
conversions that add little to no short-term value while simultaneously
increasing cognitive dissonance and quite possibly increasing the odds
of introducing a bug in Python 2.</strong> In other words, why should humans
do the work that machines can do for us? Thus, the source-transforming
module importer was born.</p>
<p>While I concede what Mercurial did is a giant hack, I maintain it was
the correct thing to do. It has allowed the Python 3 port to move
forward without being blocked on the more tedious and invasive
transformations that could introduce subtle bugs (including performance
regressions) in Python 2. Perfect is the enemy of good. People time is
valuable. The source-transforming module importer allowed us to unblock
an important project without sinking a lot of people time into it. I'd
make that trade-off again.</p>
<p>While I won't encourage others to take this approach to porting to
Python 3, if you want to, Mercurial's source is available under a GPL
license and the custom module importer could be adapted to any project
with minimal modifications. If someone does extract it as reusable code,
please leave a comment and I'll update the post to link to it.</p>

  </div>
</div>



  <div class="after_post"><a href="http://gregoryszorc.com/blog/2017/03/13/from-__past__-import-bytes_literals#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  
<div class="blog_post">
  <a name="better-compression-with-zstandard"></a>
  <h2 class="blog_post_title"><a href="/blog/2017/03/07/better-compression-with-zstandard" rel="bookmark" title="Permanent Link to Better Compression with Zstandard">Better Compression with Zstandard</a></h2>
  <small>March 07, 2017 at 09:55 AM | categories: 

<a href='/blog/category/python'>Python</a>, <a href='/blog/category/mercurial'>Mercurial</a>, <a href='/blog/category/mozilla'>Mozilla</a>
 | <a href="http://gregoryszorc.com/blog/2017/03/07/better-compression-with-zstandard#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>I think I first heard about the <a href="http://facebook.github.io/zstd/">Zstandard</a>
compression algorithm at a Mercurial developer sprint in 2015.
At one end of a large table a few people were uttering expletives out
of sheer excitement. At developer gatherings, that's the universal signal
for <em>something is awesome</em>. Long story short, a Facebook engineer shared
a link to the
<a href="http://fastcompression.blogspot.com/">RealTime Data Compression blog</a>
operated by Yann Collet (then known as the author of LZ4 - a compression
algorithm known for its insane speeds) and people were completely
nerding out over the excellent articles and the data within showing the
beginnings of a new general purpose lossless compression algorithm named
Zstandard. It promised better-than-deflate/zlib compression ratios <strong>and</strong>
performance on both compression and decompression. This being a Mercurial
meeting, many of us were intrigued because zlib is used by Mercurial
for various functionality (including on-disk storage and compression over
the wire protocol) and zlib operations frequently appear as performance hot
spots.</p>
<p>Before I continue, if you are interested in low-level performance and
software optimization, I highly recommend perusing the
<a href="http://fastcompression.blogspot.com/">RealTime Data Compression blog</a>.
There are some absolute nuggets of info in there.</p>
<p>Anyway, over the months, the news about Zstandard (zstd) kept getting
better and more promising. As the 1.0 release neared, the Facebook
engineers I interact with (Yann Collet - Zstandard's author - is now
employed by Facebook) were absolutely ecstatic about Zstandard and its
potential. I was toying around with pre-release versions and was
absolutely blown away by the performance and features. I believed
the hype.</p>
<p>Zstandard 1.0 was
<a href="https://code.facebook.com/posts/1658392934479273/smaller-and-faster-data-compression-with-zstandard">released on August 31, 2016</a>.
A few days later, I started the
<a href="https://github.com/indygreg/python-zstandard">python-zstandard</a> project to
provide a fully-featured and Pythonic interface to the underlying zstd C
API while not sacrificing safety or performance. The ulterior motive was
to leverage those bindings in Mercurial so Zstandard could be a first class
citizen in Mercurial, possibly replacing zlib as the default compression
algorithm for all operations.</p>
<p>Fast forward six months and I've achieved many of those goals.
python-zstandard has a nearly complete interface to the zstd C API.
It even exposes some primitives not in the C API, such as batch
compression operations that leverage multiple threads and use minimal
memory allocations to facilitate insanely fast execution. (Expect a
dedicated post on python-zstandard from me soon.)</p>
<p>Mercurial 4.1 ships with the python-zstandard bindings. Two Mercurial
4.1 peers talking to each other will exchange Zstandard compressed
data instead of zlib. For a Firefox repository clone, transfer size is
reduced from ~1184 MB (zlib level 6) to ~1052 MB (zstd level 3) in the
default Mercurial configuration while using ~60% of the CPU that zlib
required on the compressor end. When cloning from hg.mozilla.org, the
pre-generated zstd <em>clone bundle</em> hosted on a CDN using maximum
compression is ~707 MB - ~60% the size of zlib! And, work is ongoing
for Mercurial to support Zstandard for on-disk storage, which should
bring considerable performance wins over zlib for local operations.</p>
<p>I've learned a lot working on python-zstandard and integrating Zstandard
into Mercurial. My primary takeaway is <strong>Zstandard is awesome</strong>.</p>
<p>In this post, I'm going to extol the virtues of Zstandard and provide
reasons why I think you should use it.</p>
<h2>Why Zstandard</h2>
<p>The main objective of lossless compression is to spend one resource
(CPU) so that you may reduce another (I/O). This trade-off is usually
made because data - either at rest in storage or in motion over a
network or even through a machine via software and memory - is a
limiting factor for performance. So if compression is needed for your
use case to mitigate I/O being the limiting resource and you can swap
in a different compression algorithm that magically reduces both CPU
and I/O requirements, that's pretty exciting. At scale, better
and more efficient compression can translate to substantial cost
savings in infrastructure. It can also lead to improved application
performance, translating to better end-user engagement, sales,
productivity, etc. This is why companies like Facebook (Zstandard),
Google (brotli, snappy, zopfli), and
<a href="https://www.crunchbase.com/organization/pied-piper">Pied Piper</a>
(middle-out) invest in compression.</p>
<p>Today, the most widely used compression algorithm in the world is
likely <a href="https://en.wikipedia.org/wiki/DEFLATE">DEFLATE</a>. And, software
most often interacts with DEFLATE via what is likely the most widely
used software library in the world, <a href="http://www.zlib.net/">zlib</a>.</p>
<p>Being at least 27 years old, DEFLATE is getting a bit long in the
tooth. Computers are completely different today than they were in 1990.
The Pentium microprocessor debuted in 1993. If memory serves (pun
intended), it used PC66 DRAM, which had a transfer rate of 533 MB/s.
For comparison, a modern NVMe M.2 SSD (like the Samsung 960 PRO)
can read at 3000+ MB/s and write at 2000+ MB/s. In other words,
persistent storage today is faster than the RAM from the era when
DEFLATE was invented. And of course CPU and network speeds have
increased as well. We also have completely different instruction
sets on CPUs for well-designed algorithms and software to take
advantage of. What I'm trying to say is the market is ripe for
DEFLATE and zlib to be dethroned by algorithms and software that
take into account the realities of modern computers.</p>
<p>(For the remainder of this post I'll use <em>zlib</em> as a stand-in for
<em>DEFLATE</em> because it is simpler.)</p>
<p>Zstandard initially piqued my attention by promising better-than-zlib
compression and performance in both the compression and decompression
directions. That's impressive. But it isn't unique. Brotli achieves
the same, for example. But what kept my attention was Zstandard's rich
feature set, tuning abilities, and therefore versatility.</p>
<p>In the sections below, I'll describe some of the benefits of Zstandard
in more detail.</p>
<p>Before I do, I need to throw in an obligatory disclaimer about data
and numbers that I use. Benchmarking is hard. Benchmarks should not
be trusted. There are so many variables that can influence performance
and benchmarks. (A recent example that surprised me is the
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1323106">CPU frequency/power ramping properties of Xeon versus non-Xeon Intel CPUs</a>.
tl;dr a Xeon won't hit max CPU frequency if only a core or two
is busy, meaning that any single or low-threaded benchmark is
likely misleading on Xeons unless you change power settings to
mitigate its conservative power ramping defaults. And if you change
power settings, does that reflect real-life usage?)</p>
<p>Reporting useful and accurate performance numbers for compression is
hard because there are so many variables to care about. For example:</p>
<ul>
<li>Every corpus is different. Text, JSON, C++, photos, numerical data,
  etc all exhibit different properties when fed into compression and
  could cause compression ratios or speeds to vary significantly.</li>
<li>Few large inputs versus many smaller inputs (some algorithms work
  better on large inputs; some libraries have high per-operation
  overhead).</li>
<li>Memory allocation and use strategy. Performance can vary
  significantly depending on how a compression library allocates,
  manages, and uses memory. This can be an implementation specific
  detail as opposed to a core property of the compression algorithm.</li>
</ul>
<p>Since Mercurial is the driver for my work in Zstandard, the data and
numbers I report in this post are mostly Mercurial data. Specifically,
I'll be referring to data in the
<a href="https://hg.mozilla.org/mozilla-unified">mozilla-unified Firefox repository</a>.
This repository contains over 300,000 commits spanning almost 10 years.
The data within is a good mix of text (mostly C++, JavaScript, Python,
HTML, and CSS source code and other free-form text) and binary (like
PNGs). The Mercurial layer adds some binary structures to e.g. represent
metadata for deltas, diffs, and patching. There are two Mercurial-specific
pieces of data I will use. One is a Mercurial <em>bundle</em>. This is essentially
a representation of all data in a repository. It stores a mix of raw,
fulltext data and deltas on that data. For the mozilla-unified repo, an
uncompressed bundle (produced via <code>hg bundle -t none-v2 -a</code>) is ~4457 MB.
The other piece of data is <em>revlog chunks</em>. This is a mix of fulltext
and delta data for a specific item tracked in version control. I
frequently use the <em>changelog</em> corpus, which is the fulltext data
describing changesets or commits to Firefox. The numbers quoted and
used for charts in this post
<a href="https://docs.google.com/spreadsheets/d/1PHhGxsQR3zDE-2Eeu5Hn2t-UKw4oGV-7LQTMGEdBh9U/edit?usp=sharing">are available in a Google Sheet</a>.</p>
<p>All performance data was obtained on an i7-6700K running Ubuntu 16.10
(Linux 4.8.0) with a mostly stock config. Benchmarks were performed in
memory to mitigate storage I/O or filesystem interference. Memory used
is DDR4-2133 with a cycle time of 35 clocks.</p>
<p>While I'm pretty positive about Zstandard, it isn't perfect. There are
corpora for which Zstandard performs worse than other algorithms, even
ones I compare it directly to in this post. So, your mileage may vary.
Please enlighten me with your counterexamples by leaving a comment.</p>
<p>With that (rather large) disclaimer out of the way, let's talk about
what makes Zstandard awesome.</p>
<h2>Flexibility for Speed Versus Size Trade-offs</h2>
<p>Compression algorithms typically contain parameters to control how
much work to do. You can choose to spend more CPU to (hopefully)
achieve better compression or you can spend less CPU to sacrifice
compression. (OK, fine, there are other factors like memory usage at
play too. I'm simplifying.) This is commonly exposed to
end-users as a compression <em>level</em>. (In reality there are often
multiple parameters that can be tuned. But I'll just use <em>level</em>
as a stand-in to represent the concept.)</p>
<p>But even with adjustable compression levels, the performance of many
compression algorithms and libraries tend to fall within a relatively
narrow window. In other words, many compression algorithms focus on
niche markets. For example, LZ4 is super fast but doesn't yield great
compression ratios. LZMA yields terrific compression ratios but is
extremely slow.</p>
<p>This can be visualized in the following chart showing results when
compressing a mozilla-unified Mercurial bundle:</p>
<p><img alt="bundle compression with common algorithms" src="/images/compression-bundle-common.png" /></p>
<p>This chart plots the logarithmic compression speed in megabytes per
second against achieved compression ratio. The further right a data
point is, the better the compression and the smaller the output.
The higher up a point is, the faster compression is.</p>
<p>The ideal compression algorithm lives in the top right, which means
it compresses well and is fast. But the powers of mathematics push
compression algorithms away from the top right.</p>
<p>On to the observations.</p>
<p>LZ4 is highly vertical, which means its compression ratios are
limited in variance but it is extremely flexible in speed. So for
this data, you might as well stick to a lower compression level
because higher values don't buy you much.</p>
<p>Bzip2 is the opposite: a horizontal line. That means it is consistently
the same speed while yielding different compression ratios. In other
words, you might as well crank bzip2 up to maximum compression because
it doesn't have a significant adverse impact on speed.</p>
<p>LZMA and zlib are more interesting because they exhibit more variance
in both the compression ratio and speed dimensions. But let's be frank,
they are still pretty narrow. LZMA looks pretty good from a shape
perspective, but its top speed is just too slow - only ~26 MB/s!</p>
<p>This small window of flexibility means that you often have to choose
a compression algorithm based on the speed versus size trade-off you are
willing to make at that time. That choice often gets baked into
software. And as time passes and your software or data gains popularity,
changing the software to swap in or support a new compression algorithm
becomes harder because of the cost and disruption it will cause. That's
technical debt.</p>
<p>What we really want is a single compression algorithm that occupies
lots of <em>space</em> in both dimensions of our chart - a curve that has
high variance in both compression speed and ratio. Such an algorithm
would allow you to make an easy decision choosing a compression
algorithm without locking you into a narrow behavior profile. It would
allow you make a completely different size versus speed trade-off in
the future by only adjusting a config knob or two in your application -
no swapping of compression algorithms needed!</p>
<p>As you can guess, Zstandard fulfills this role. This can clearly be seen
in the following chart (which also adds brotli for comparison).</p>
<p><img alt="bundle compression with modern algorithms" src="/images/compression-bundle-modern.png" /></p>
<p>The advantages of Zstandard (and brotli) are obvious. Zstandard's
compression speeds go from ~338 MB/s at level 1 to ~2.6 MB/s at
level 22 while covering compression ratios from 3.72 to 6.05. On one
end, <strong>zstd level 1 is ~3.4x faster than zlib level 1 while achieving
better compression than zlib level 9!</strong> That fastest speed is only 2x
slower than LZ4 level 1. On the other end of the spectrum, zstd
level 22 runs ~1 MB/s slower than LZMA at level 9 and produces a
file that is only 2.3% larger.</p>
<p>It's worth noting that zstd's C API exposes several knobs for tweaking
the compression algorithm. Each compression level maps to a pre-defined
set of values for these knobs. It is possible to set these values beyond
the ranges exposed by the default compression levels 1 through 22. I've
done some basic experimentation with this and have made compression even
faster (while sacrificing ratio, of course). This covers the gap between
Zstandard and brotli on this end of the tuning curve.</p>
<p>The wide span of compression speeds and ratios is a game changer
for compression. Unless you have special requirements such as
lightning fast operations (which LZ4 can provide) or special
corpora that Zstandard can't handle well, Zstandard is a very safe and
flexible choice for general purpose compression.</p>
<h2>Multi-threaded Compression</h2>
<p>Zstd 1.1.3 contains a multi-threaded compression API that allows a
compression operation to leverage multiple threads. The output from
this API is compatible with the Zstandard frame format and doesn't require
any special handling on the decompression side. <strong>In other words, a
compressor can switch to the multi-threaded API and decompressors won't
care.</strong></p>
<p>This is a big deal for a few reasons. First, today's advancements in
computer processors tend to yield more capacity from more cores not
from faster clocks and better cycle efficiency (although many cases
do benefit greatly from modern instruction sets like AVX and therefore
better cycle efficiency). Second, so many compression libraries are
only single-threaded and require consumers to invent their own framing
formats or storage models to facilitate multi-threading. (See
<a href="http://blosc.org/">Blosc</a> for such a library.) Lack of a
multi-threaded API in the compression library means trusting another
piece of software or writing your own multi-threaded code.</p>
<p>The following chart adds a plot of Zstandard multi-threaded compression
with 4 threads.</p>
<p><img alt="multi-threaded compression" src="/images/compression-bundle-multithreaded.png" /></p>
<p>The existing curve for Zstandard basically shifted straight up. Nice!</p>
<p>The ~338 MB/s speed for single-threaded compression on zstd level 1
increases to ~1,376 MB/s with 4 threads. That's ~4.06x faster. And,
it is ~2.26x faster than the previous fastest entry, LZ4 at level 1!
The output size only increased by ~4 MB or ~0.3% over single-threaded
compression.</p>
<p>The scaling properties for multi-threaded compression on this input
are terrific: all 4 cores are saturated and the output size barely
changed.</p>
<p>Because Zstandard's multi-threaded compression API produces data compatible
with any Zstandard decompressor, it can logically be considered an extension
of <em>compression levels</em>. This means that the already extremely flexible
speed vs ratio curve becomes even wider in the speed axis. Zstandard
was already a justifiable choice with its extreme versatility. But when
you throw in native multi-threaded compression API support, the
flexibility for tuning compression performance is just absurd. With
enough cores, you are likely to run into I/O limits long before you
exhaust the CPU, at which point you can crank up the compression
level and sacrifice as much CPU as you are willing to burn. That's
a good position to be in.</p>
<h2>Decompression Speed</h2>
<p>Compression speed and ratios only tell half the story about a compression
algorithm. Except for archiving scenarios where you write once and
read rarely, you probably care about decompression performance.</p>
<p>Popular compression algorithms like zlib and bzip2 have less than stellar
decompression speeds. On my i7-6700K, zlib decompression can deliver many
decompressed data sets at the output end at 200+ MB/s. However, on the
input/compressed end, it frequently fails to reach 100 MB/s or even
80 MB/s. This is significant because if your application is reading data
over a 1 Gbps network or from a local disk (modern SSDs can read at several
hundred MB/s or more), then your application has a CPU bottleneck at
decoding the data - and that's before you actually do anything useful
with the data in the application layer! (Remember: the idea behind
compression is to spend CPU to mitigate an I/O bottleneck. So if
compression makes you CPU bound, you've undermined the point of
compression!) And if my Skylake CPU running at 4.0 GHz is CPU -
not I/O - bound, A Xeon in a data center will be even slower and
even more CPU bound (Xeons tend to run at much lower clock speeds -
the laws of thermodynamics require that in order to run more cores in
the package). In short, <strong>if you are using zlib for high throughput
scenarios, there's a good chance it is a bottleneck and slowing down
your application</strong>.</p>
<p>We again measure the speed of algorithms using a Firefox Mercurial
bundle. The following charts plot decompression speed versus ratio
for this file. The first chart measures decompression speed on the
input end of the decompressor. The second measures speed at the
output end.</p>
<p><img alt="decompression input" src="/images/decompression-bundle-input.png" /></p>
<p><img alt="decompression output" src="/images/decompression-bundle-output.png" /></p>
<p>Zstandard matches its great compression speed with great decompression
speed. Zstandard can deliver decompressed output at 1000+ MB/s while
consuming input at 200-275MB/s. Furthermore, decompression speed is
mostly independent of the compression level. (Although higher
compression levels require more memory in the decompressor.) So, <strong>if
you want to throw more CPU at re-compression later so data at rest takes
less space, you can do that without sacrificing read performance.</strong>
I haven't done the math, but there is probably a break-even point
where having dedicated machines re-compress terabytes or petabytes
of data at rest offsets the costs of those machine through reduced
storage costs.</p>
<p>While Zstandard is not as fast decompressing as LZ4 (which can consume
compressed input at 500+ MB/s), its performance is often ~4x faster
than zlib. On many CPUs, this puts it well above 1 Gbps, which is
often desirable to avoid a bottleneck at the network layer.</p>
<p>It's also worth noting that while Zstandard and brotli were comparable
on the compression half of this data, Zstandard has a clear advantage
doing decompression.</p>
<p>Finally, you don't appear to pay a price for multi-threaded Zstandard
compression on the decompression side (<code>zstdmt</code> in the chart).</p>
<h2>Dictionary Support</h2>
<p>The examples so far in this post have used a single 4,457 MB piece of
input data to measure behavior. Large data can behave completely
differently from small data. This is because so much of what
compression algorithms do is find patterns that came before so incoming
data can be <em>referenced</em> to old data instead of uniquely stored. And if
data is small, there isn't much of it that came before to reference!</p>
<p>This is often why many small, independent chunks of input compress
poorly compared to a single large chunk. This can be demonstrated by
comparing the widely-used <em>zip</em> and <em>tar</em> archive formats. On the
surface, both do the same thing: they are a container of files. But
they employ compression at different phases. A <em>zip</em> file will zlib
compress each entry independently. However, a <em>tar</em> file doesn't use
compression internally. Instead, the tar file itself is fed into a
compression algorithm and compressed as a whole.</p>
<p>We can observe the difference on real world data. Firefox
ships with a file named <code>omni.ja</code>. Despite the weird extension, this
is a <em>zip</em> file. The file contains most of the assets for non-compiled
code used by Firefox. This includes the JavaScript, HTML, CSS, and
images that power many parts of the Firefox frontend. The file weighs
in at 9,783,749 bytes for the 64-bit Windows Firefox Nightly from
2017-03-06. (Or 9,965,793 bytes when using <code>zip -9</code> - the code for
generating <code>omni.ja</code> is smarter than <code>zip</code> and creates smaller
files.) But a zlib level 9 compressed <code>tar.gz</code> file of that directory
is 8,627,155 bytes. That 1,156KB / 13% size difference is significant
when you are talking about delivering bits to end users! (In this
case, the content within the archive needs to be individually
addressable to facilitate fast access to any item without having
to decompress the entire archive: this matters for performance.)</p>
<p>A more extreme example of the differences between <em>zip</em> and <em>tar</em>
is the files in the Firefox source checkout. On revision
a08ec245fa24 of the Firefox Mercurial repository, a <em>zip</em> file of
all files in version control is 430,446,549 bytes versus
322,916,403 bytes for a <em>tar.gz</em> file (1,177,430,383 bytes uncompressed
spanning 180,912 files). Using Zstandard, compressing each file
discretely at compression level 3 yields 391,387,299 bytes of
compressed data versus 294,926,418 as a single stream (without the
<em>tar</em> container). Same compression algorithm. Different application
method. Drastically different results. That's the impact of input
size on compression performance.</p>
<p>While the compression ratio and speed of a single large stream is
often better than multiple smaller chunks, there are still
use cases that either don't have enough data or prefer independent
access to each piece of input (like Firefox's <code>omni.ja</code> file). So
a robust compression algorithm should handle small inputs as well
as it does large inputs.</p>
<p>Zstandard helps offset the inherent inefficiencies of small inputs
by supporting <em>dictionary compression</em>. A <em>dictionary</em> is
essentially data used to seed the compressor's state. If the
compressor sees data that exists in the dictionary, it references
the dictionary instead of storing new data in the compressed output
stream. This results in smaller output sizes and better compression
ratios. One drawback to this is the dictionary has to be used to
decompress data, which means you need to figure out how to
distribute the dictionary and ensure it remains in sync with all
data producers and consumers. This isn't always trivial.</p>
<p>Dictionary compression only works if there is enough repeated data
and patterns in the inputs that can be extracted to yield a
useful dictionary. Examples of this include markup languages, source
code, or pieces of similar data (such as JSON payloads from HTTP API
requests or telemetry data), which often have many repeated keywords
and patterns.</p>
<p>Dictionaries are typically produced by <em>training</em> them on existing
data. Essentially, you feed a bunch of samples into an algorithm
that spits out a meaningful and useful dictionary. The more coherency
in the data that will be compressed, the better the dictionary and
the better the compression ratios.</p>
<p>Dictionaries can have a significant effect on compression ratios and
speed.</p>
<p>Let's go back to Firefox's <code>omni.ja</code> file. Compressing each file
discretely at zstd level 12 yields 9,177,410 bytes of data. But if
we produce a 131,072 byte dictionary by training it on all files
within <code>omni.ja</code>, the total size of each file compressed discretely
is 7,942,886 bytes. Including the dictionary, the total size is
8,073,958 bytes, 1,103,452 bytes smaller than non-dictionary
compression! (The zlib-based <code>omni.ja</code> is 9,783,749 bytes.) So
Zstandard plus dictionary compression would likely yield a
meaningful ~1.5 MB size reduction to the <code>omni.ja</code> file. This would
make the Firefox distribution smaller and <em>may</em> improve startup
time (since many files inside <code>omni.ja</code> are accessed at
startup), which would make a number of people very happy. (Of
course, Firefox doesn't yet contain the zstd C library. And adding
it just for this use case may not make sense. But Firefox does ship
with the brotli library and brotli supports dictionary compression
and has similar performance characteristics as Zstandard, so, uh,
someone may want to look into transitioning <code>omni.jar</code> to
<em>not zlib</em>.)</p>
<p>But the benefits of dictionary compression don't end at compression
ratios: operations with dictionaries can be faster as well!</p>
<p>The following chart shows performance when compressing Mercurial
<em>changeset</em> data (describes a Mercurial commit) for the Firefox
repository. There are 382,530 discrete inputs spanning 221,429,458
bytes (mean: 579 bytes, median: 306 bytes). (Note: measurements were
conducted in Python and therefore may introduce some overhead.)</p>
<p><img alt="dictionary compression performance" src="/images/decompression-dictionary-changeset.png" /></p>
<p>Aside from zstd level 3 dictionary compression, Zstandard is faster
than zlib level 6 across the board (I suspect this one-off is an
oddity with the zstd compression parameters at this level and this
corpus because zstd level 4 is faster than level 3, which is weird).</p>
<p>It's also worth noting that non-dictionary zstandard compression
has similar compression ratios to zlib. Again, this demonstrates
the intrinsic difficulties of compressing small inputs.</p>
<p>But the real takeaway from this data are the speed differences with
dictionary compression enabled. Dictionary decompression is
2.2-2.4x <em>faster</em> than non-dictionary decompression. Already
respectable ~240 MB/s decompression speed (measured at the output
end) becomes ~530 MB/s. Zlib level 6 was ~140 MB/s, so swapping
in dictionary compression makes things ~3.8x faster. It takes ~1.5s
of CPU time to zlib decompress this corpus. So if Mercurial can
be taught to use Zstandard dictionary compression for changelog data,
certain operations on this corpus will complete ~1.1s faster. That's
significant.</p>
<p>It's worth stating that Zstandard isn't the only compression algorithm
or library to support dictionary compression. Brotli and zlib do as
well, for example. But, Zstandard's support for dictionary compression
seems to be more polished than other libraries I've seen. It has multiple
APIs for training dictionaries from sample data. (Brotli has none nor
does brotli's documentation say how to generate dictionaries as far as
I can tell.)</p>
<p>Dictionary compression is definitely an advanced feature, applicable
only to certain use cases (lots of small, similar data). But there's
no denying that if you can take advantage of dictionary compression,
you may be rewarded with significant performance wins.</p>
<h2>A Versatile C API</h2>
<p>I spend a lot of my time these days in higher-level programming
languages like Python and JavaScript. By the time you interact with
compression in high-level languages, the low-level compression APIs
provided by the compression library are most likely hidden from you
and bundled in a nice, friendly abstraction, suitable for a
higher-level language. And more often than not, many features of
that low-level API are not exposed for you to call. So, you don't
get an appreciation for how good (or bad) or feature rich (or
lacking) the low-level API is.</p>
<p>As part of writing
<a href="https://github.com/indygreg/python-zstandard">python-zstandard</a>, I've
spent a lot of time interfacing with the zstd C API. And, as part
of evaluating other compression libraries for use in Mercurial, I've
been looking at C APIs for other libraries and the Python bindings to
them. A takeaway from this is an appreciation for the quality of
zstd's C API.</p>
<p>Many compression library APIs are either too simple or too complex.
Zstandard's is in the Goldilocks zone. Aside from a few minor missing
features, its C API was more than adequate in its 1.0 release.</p>
<p>What I really appreciate about the zstd C API is that it provides
high, medium, and low-level APIs. From the highest level, you throw
it pointers to input and output buffers and it does an operation.
From the medium level, you use a reusable <em>context</em> holding state
and other parameters and it does an operation. From the low-level,
you are calling multiple functions and shuffling bytes around,
maintaining your own state and potentially bypassing the Zstandard
<em>framing</em> format in the process. The different levels give you
almost total control over everything. This is critical for performance
optimization and when writing bindings for higher-level languages that
may have different expectations on the behavior of software. The
performance I've achieved in python-zstandard just isn't (easily)
possible with other compression libraries because of their lacking
API design.</p>
<p>Oftentimes when interacting with a C library I think <em>if only there
were a function to let me do X my life would be much easier</em>. I
rarely have this experience with Zstandard. The C API is well thought out,
has almost all the features I want/need, and is pretty easy to use.
While most won't notice this difference, it should be a significant
advantage for Zstandard in the long run, as more bindings are
written and more people have a high-quality experience with it
because the C API allows them to.</p>
<h2>Zstandard Isn't Perfect</h2>
<p>I've been pretty positive about Zstandard so far in this post.
In fear of sounding like a fanboy who is so blinded by admiration
that he can't see faults and because nothing is perfect, I need to
point out some negatives about Zstandard. (Aside: put little faith
in the words uttered by someone who can't find a fault in something
they praise.)</p>
<p>First, the <a href="https://github.com/facebook/zstd/blob/3bee41a70eaf343fbcae3637b3f6edbe52f35ed8/doc/zstd_compression_format.md#zstandard-frames">framing format</a>
is a bit heavyweight in some scenarios. The frame header is at <em>least</em>
6 bytes. For input of 256-65791 bytes, recording the original source
size and its checksum will result in a 12 byte frame. Zlib, by contrast,
is only 6 bytes for this scenario. When storing tens of thousands of
compressed records (this is a use case in Mercurial), the frame overhead
can matter and this can make it difficult for compressed Zstandard
data to be as small as zlib for very small inputs. (It's worth noting
that zlib doesn't store the decompressed size in its header. There are
pros and cons to this, which I'll discuss in my eventual post about
python-zstandard and how it achieves optimal performance.) If the frame
overhead matters to you, the zstd C API does expose a <em>block</em> API that
operates at a level below the framing format, allowing you to roll your
own framing protocol. I also
<a href="https://github.com/facebook/zstd/issues/591">filed a GitHub issue</a> to
make the 4 byte magic number optional, which would go a long way to
cutting down on frame overhead.</p>
<p>Second, the C API is not yet fully stabilized. There are a number of
functions marked as <em>experimental</em> that aren't exported from the shared
library and are only available via static linking. There's a ton of
useful functionality in there, including low-level compression parameter
adjustment, digested dictionaries (for reusing computed dictionaries
across multiple <em>contexts</em>), and the multi-threaded compression API.
python-zstandard makes heavy use of these <em>experimental</em> APIs. This
requires bundling zstd with python-zstandard and statically linking
with this known version because functionality could change at any time.
This is a bit annoying, especially for distro packagers.</p>
<p>Third, the low-level compression parameters are under-documented. I
think I understand what a lot of them do. But it isn't obvious when
I should consider adjusting what. The default compression levels
seem to work pretty well and map to reasonable compression parameters.
But a few times I've noticed that tweaking things slightly can result
in desirable improvements. I wish there were a guide of sorts to
help you tune these parameters.</p>
<p>Fourth, dictionary compression is still a bit too complicated and
hand-wavy for my liking. I can measure obvious benefits when using it
largely out of the box with some corpora. But it isn't always a win
and the cost for training dictionaries is too high to justify using
it outside of scenarios where you are pretty sure it will be beneficial.
When I do use it, I'm not sure which compression levels it works best
with, how many samples need to be fed into the dictionary trainer,
which training algorithm to use, etc. If that isn't enough, there is
also the concept of <em>content-only dictionaries</em> where you use a
fulltext as the dictionary. This can be useful for delta-encoding
schemes (where compression effectively acts like a diff/delta
generator instead of using something like Myers diff). If this topic
interests you, there is a
<a href="https://www.mercurial-scm.org/pipermail/mercurial-devel/2017-January/092186.html">thread on the Mercurial developers list</a>
where Yann Collet and I discuss this.</p>
<p>Fifth, the patent rights grant. There is some
<a href="https://github.com/facebook/zstd/blob/4ded9e591cbed57c54fc8f7a50412af5980e23a7/PATENTS#L14">wording in the PATENTS file</a>
in the Zstandard project that may... concern lawyers. While Zstandard
is covered by the standard BSD 3-Clause license, that supplemental
<code>PATENTS</code> file may scare some lawyers enough that you won't be able
to use Zstandard. You may want to talk to a lawyer before using
Zstandard, especially if you or your company likes initiating patent
lawsuits against companies (or wishes to reserve that right - as many
companies do), as that is the condition upon which the license
terminates. Note that there is a long history between Facebook and
consumers of its open source software regarding this language in the
<code>PATENTS</code> file. Do a search for <code>React patent grant</code> to read more.</p>
<p>Sixth and finally, Zstandard is still relatively new. I can totally
relate to holding off until something new and shiny proves itself.
That being said, the Zstandard framing protocol has some escape
hatches for future needs. And, the project proved during its pre-1.0
days that it knows how to handle backwards and future compatibility
issues. And considering Facebook and others are using Zstandard in
production, I wouldn't be too worried. I think the biggest risk is
to people (like me) who are writing code against the <em>experimental</em>
C APIs. But even then, the changes to the experimental APIs in the
past several months have been minor. I'm not losing sleep over it.</p>
<p>That may seem like a long and concerning list. Most of the issues are
relatively minor. The language in the <code>PATENTS</code> file may be a
showstopper to some. From my perspective, the biggest thing Zstandard has
going against it is its youth. But that will only improve with age.
While I'm usually pretty conservative about adopting new technology
(I've gotten burned enough times that I prefer the neophytes do the
field testing for me), the upside to using Zstandard is potentially
drastic performance and efficiency gains. And that can translate to
success versus failure or millions of dollars in saved infrastructure
costs and productivity gains. I'm willing to take my chances.</p>
<h2>Conclusion</h2>
<p>For the corpora I've thrown at it, Zstandard handily outperforms zlib
in almost every dimension. And, it even manages to best other <em>modern</em>
compression algorithms like brotli in many tests.</p>
<p>The underlying algorithm and techniques used by Zstandard are highly
parameterized, lending themselves to a variety of use cases from embedded
hardware to massive data crunching machines with hundreds of gigabytes
of memory and dozens of CPU cores.</p>
<p>The C API is well-designed and facilitates high performance and
adaptability to numerous use cases. It is <em>batteries included</em>,
providing functions to train dictionaries and perform multi-threaded
compression.</p>
<p>Zstandard is backed by Facebook and seems to have a healthy open source
culture <a href="https://github.com/facebook/zstd">on Github</a>. My interactions
with Yann Collet have been positive and he seems to be a great
project maintainer.</p>
<p>Zstandard is an exciting advancement for data compression and therefore
for the entire computing field. As someone who has lived in the world
of zlib for years, was a casual user of compression, and thought zlib
was <em>good enough</em> for most use cases, I can attest that Zstandard is
game changing. After being enlightened to all the advantages of
Zstandard, I'll never casually use zlib again: it's just too slow and
inflexible for the needs of modern computing. If you use compression,
I highly recommend investigating Zstandard.</p>
<p><em>(I updated the post on 2017-03-08 to include a paragraph about the
supplemental license in the <code>PATENTS</code> file.)</em></p>

  </div>
</div>



  <div class="after_post"><a href="http://gregoryszorc.com/blog/2017/03/07/better-compression-with-zstandard#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
  
<div class="blog_post">
  <a name="mercurial,-sha-1,-and-trusting-version-control"></a>
  <h2 class="blog_post_title"><a href="/blog/2017/02/28/mercurial,-sha-1,-and-trusting-version-control" rel="bookmark" title="Permanent Link to Mercurial, SHA-1, and Trusting Version Control">Mercurial, SHA-1, and Trusting Version Control</a></h2>
  <small>February 28, 2017 at 12:40 PM | categories: 

<a href='/blog/category/mercurial'>Mercurial</a>, <a href='/blog/category/mozilla'>Mozilla</a>
 | <a href="http://gregoryszorc.com/blog/2017/02/28/mercurial,-sha-1,-and-trusting-version-control#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>The Internet went crazy on Thursday when Google
<a href="https://security.googleblog.com/2017/02/announcing-first-sha1-collision.html">announced a SHA-1 collision</a>.
This has spawned a lot of talk about the impact of SHA-1 in version
control. Linus Torvalds (the creator of Git) weighed in on the
<a href="http://marc.info/?l=git&amp;m=148787047422954">Git mailing list</a> and on
<a href="https://plus.google.com/+LinusTorvalds/posts/7tp2gYWQugL">Google+</a>.
There are also posts like
<a href="http://www.metzdowd.com/pipermail/cryptography/2017-February/031623.html">SHA1 collisions make Git vulnerable to attakcs by third-parties, not just repo maintainers</a>
outlining the history of Git and SHA-1. On the Mercurial side,
Matt Mackall (the creator of Mercurial) authored a
<a href="https://www.mercurial-scm.org/wiki/mpm/SHA1">SHA-1 and Mercurial security article</a>.
(If you haven't read Matt's article, please do so now before
continuing.)</p>
<p>I'd like to contribute my own take on the problem with a slant towards
Mercurial and while also comparing Mercurial's exposure to SHA-1
collisions to Git's. Since this is a security topic, I'd like to
explicitly state that I'm not a cryptographer. However, I've worked on
a number of software components that do security/cryptography (like
Firefox Sync) and I'm pretty confident saying that my grasp on
cryptographic primitives and security techniques is better than the
average developer's.</p>
<p>Let's talk about Mercurial's exposure to SHA-1 collisions on a technical
level.</p>
<p>Mercurial, like Git, is <em>vulnerable</em> to SHA-1 collisions. Mercurial is
vulnerable because its logical storage mechanism (like Git's) indexes
tracked content by SHA-1. If two objects with differing content have the
same SHA-1, content under version control could be changed and detecting
that would be difficult or impossible. That's obviously bad.</p>
<p>But, Mercurial's exposure to SHA-1 collisions isn't as severe as Git's.
To understand why, we have to understand how each stores data.</p>
<p>Git's logical storage model is a content-addressable key-value store.
Values (<em>objects</em> in Git parlance) consist of a header identifying the
object type (commit, tree, blob, or tag), the size of the data (as a
string), and the raw content of the thing being stored. Common content
types are file content (blob), a list of files (tree), and a description
of a commit (commit). Keys in this blob store are SHA-1 hashes of objects.
All Git objects go into a single <em>namespace</em> in the Git repository's
<em>store</em>. A beneficial side-effect of this is data de-duplication: if the
same file is added to a Git repository, it's <em>blob</em> object will be
identical and it will only be stored once by Git. A detrimental
side-effect is that hash collisions are possible between any two objects,
irregardless of their type or location in the repository.</p>
<p>Mercurial's logical storage model is also content-addressable. However,
it is significantly different from Git's approach. Mercurial's logical
storage model allocates a separate sub-store for each tracked <em>path</em>.
If you run <code>find .hg/store -name '*.i'</code> inside a Mercurial repository,
you'll see these files. There is a separate file for each path
that has committed data. If you <code>hg add foo.txt</code> and <code>hg commit</code>, there
will be a <code>data/foo.txt.i</code> file holding data for <code>foo.txt</code>.
There are also special files <code>00changelog.i</code> and <code>00manifest.i</code> holding
data for commits/changesets and file lists, respectively. Each of these
<code>.i</code> files - a <a href="https://www.mercurial-scm.org/repo/hg/file/a185b903bda3/mercurial/help/internals/revlogs.txt">revlog</a> -
is roughly equivalent to an ordered collection of Git objects for a
specific tracked path. This means that Mercurial's store consists of
N discrete and independent namespaces for data. Contrast with Git's
single namespace.</p>
<p>The benefits and drawbacks are the opposite of those pointed out for
Git above: Mercurial doesn't have automatic content-based de-duplication
but it does provide some defense against hash collisions. Because each
logical path is independent of all others, a Mercurial repository will
happily commit two files with different content but same hashes. This
is more robust than Git because a hash collision is isolated to a single
logical path / revlog. In other words, a random file added to the
repository in directory <code>X</code> that has a hash collision with a file in
directory <code>Y</code> won't cause problems.</p>
<p>Mercurial also differs significantly from Git in terms of how the hash
is obtained. Git's hash is computed from raw content preceded by a header
derived directly from the object's role and size. (Takeaway: the header is
static and can be derived trivially.) Mercurial's hash is computed from
raw content preceded by a header. But that header consists of the 20 byte
SHA-1 hash(es) of the parent revisions in the revlog to which the content
is being added. This <em>chaining</em> of hashes means that the header is not
always static nor always trivially derived. This means that the same
content can be stored in the revlog under multiple hashes. It also means
that it is possible to store differing content having a hash collision
within the same revlog! But only under some conditions - Mercurial will
still barf in some scenarios if there is a hash collision within content
tracked by the revlog. This is different from Git's behavior, where the
same content <em>always</em> results in the same Git object hash. (It's worth
noting that a SHA-1 collision on data with a Git object header has not
yet been encountered in the wild.)</p>
<p>The takeaway from the above paragraphs is Mercurial's storage model
is slightly more robust against hash collisions than Git's because there
are multiple, isolated namespaces for storing content and because all
hashes are chained to previous content. So, when SHA-1 collisions
are more achievable and someone manages to create a collision for a
hash used by version control, Mercurial's storage layer will be able
to cope with that better than Git's.</p>
<p>But the concern about SHA-1 weakness is more about security than storage
robustness. The disaster scenario for version control is that an
attacker could replace content under version control, possibly
undetected. If one can generate a hash collision, then this is
possible. Mercurial's chaining of content provides some defense, but
it isn't sufficient.</p>
<p>I agree with <a href="https://www.mercurial-scm.org/wiki/mpm/SHA1">Matt Mackall</a>
that at the present time there are bigger concerns with content
safety than SHA-1 collisions. Namely, if you are an attacker, it is
much easier to introduce a subtle bug that contains a security
vulnerability than to introduce a SHA-1 collision. It is also
much easier to hack the canonical version control server (or any
user or automated agent that has permissions to push to the server)
and add a <em>bad</em> commit. Many projects don't have adequate defenses
to detect such <em>bad</em> commits. Ask yourself: if a bad actor pushed
a <em>bad</em> commit to my repository, would it be detected? Keep in mind
that spoofing author and committer metadata in commits is trivial.
<strong>The current state of Mercurial and Git rely primarily on trust -
not SHA-1 hashes - as their primary defense against malicious
actors.</strong></p>
<p>The desire to move away from SHA-1 has been on the radar of the
Mercurial project for years. For 10+ years, the <em>revlog</em> data
structure has allocated 32 bytes for hashes while only using 20 bytes
for SHA-1. And, the topic of SHA-1 weakness and desire to move to
something stronger has come up at the developer <em>sprints</em> for the
past several years. However, it has never been pressing enough to act
on because <em>there are bigger problems</em>. If it were easy to change, then
Mercurial likely would have done it already. But changing is not easy.
As soon as you introduce a new hash format in a repository, you've
potentially locked out all legacy versions of the Mercurial software
from accessing the repository (unless the repository stores multiple
hashes and allows legacy clients to access the legacy SHA-1 hashes).
There are a number of concerns from legacy compatibility (something
Mercurial cares deeply about) to user experience to even performance
(SHA-1 hashing even at 1000+MB/s floats to the top of performance
profiling for some Mercurial operations). I'm sure the topic will be
discussed heavily at the upcoming developers sprint in a few weeks.</p>
<p>While Mercurial should (and will eventually) replace SHA-1, I think
the biggest improvement Mercurial (or Git for that matter) can make
to repository <em>security</em> is providing a better mechanism for tracking
and auditing trust. Existing mechanisms for GPG signing every commit
aren't practical or are a non-starer for many workflows. And, they
rely on GPG, which has notorious end-user usability problems. (I would
prefer my version control tool not subject me to toiling with GPG.)
I've thought about this topic considerably, authoring a
<a href="https://www.mercurial-scm.org/wiki/CommitSigningPlan">proposal for easier and more flexible commit signing</a>.
There is also a related proposal to establish a
<a href="https://www.mercurial-scm.org/wiki/CommitCustodyConcept">cryptographically meaningful chain-of-custody for a patch</a>.
There are some good ideas there. But, like all user-facing
cryptography, the devil is in the details. There are some hard
problems to solve, like how to manage/store public keys that were
used for signatures. While there is some prior art in version control
tools (see Monotone), it is far from a solved problem. And at the
end of the day, you are still left having to trust a set of keys
used to produce signatures.</p>
<p>While version control can keep using cryptographically strong hashes
to mitigate collisions within its storage layer to prevent content
swapping and can employ cryptographic signatures of tracked data,
there is still the issue of trust. Version control can give you the
tools for establishing and auditing trust. Version control can also
provide tools for managing trust relationships. But at the end of the
day, the actual act of trusting trust boils down to people making
decisions (possibly through corporate or project policies). This
will always be a weak link. Therefore, it's what malicious actors
will attack. The best your version control tool can do is give its
users the capability and tools to run a secure and verifiable
repository so that when bad content is inevitably added you can't
blame the version control tool for having poor security.</p>

  </div>
</div>



  <div class="after_post"><a href="http://gregoryszorc.com/blog/2017/02/28/mercurial,-sha-1,-and-trusting-version-control#disqus_thread">Read and Post Comments</a></div>
  <hr class="interblog" />
 <a href="/blog/category/mozilla/2">Next Page »</a>

              </div>
              
          <div id="sidebar">
          <ul>
            <li>
              <h2>Categories</h2>
              <ul>
                <li><a href="/blog/category/bugzilla">Bugzilla</a></li>
                <li><a href="/blog/category/clang">Clang</a></li>
                <li><a href="/blog/category/docker">Docker</a></li>
                <li><a href="/blog/category/firefox">Firefox</a></li>
                <li><a href="/blog/category/git">Git</a></li>
                <li><a href="/blog/category/javascript">JavaScript</a></li>
                <li><a href="/blog/category/mercurial">Mercurial</a></li>
                <li><a href="/blog/category/mozreview">MozReview</a></li>
                <li><a href="/blog/category/mozilla">Mozilla</a></li>
                <li><a href="/blog/category/puppet">Puppet</a></li>
                <li><a href="/blog/category/python">Python</a></li>
                <li><a href="/blog/category/review-board">Review Board</a></li>
                <li><a href="/blog/category/sync">Sync</a></li>
                <li><a href="/blog/category/browsers">browsers</a></li>
                <li><a href="/blog/category/build-system">build system</a></li>
                <li><a href="/blog/category/code-review">code review</a></li>
                <li><a href="/blog/category/compilers">compilers</a></li>
                <li><a href="/blog/category/internet">internet</a></li>
                <li><a href="/blog/category/logging">logging</a></li>
                <li><a href="/blog/category/mach">mach</a></li>
                <li><a href="/blog/category/make">make</a></li>
                <li><a href="/blog/category/misc">misc</a></li>
                <li><a href="/blog/category/movies">movies</a></li>
                <li><a href="/blog/category/pymake">pymake</a></li>
                <li><a href="/blog/category/security">security</a></li>
                <li><a href="/blog/category/sysadmin">sysadmin</a></li>
                <li><a href="/blog/category/testing">testing</a></li>
              </ul>
            </li>
          </ul>
        </div>



              <div style="clear: both;">&nbsp;</div>
          </div>
        </div>
      </div>
      <div id="footer">
        
  <hr/>
  <p>Copyright (c) 2017 Gregory Szorc. All rights reserved. Design by <a href="http://www.freecsstemplates.org/"> CSS Templates</a>.</p>


      </div>
    </div>
  </body>
</html>





