<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">Gregory Szorc's Digital Home</title>
  <subtitle type="text">Rambling on</subtitle>

  <updated>2013-05-14T00:28:07Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog" />
  <id>http://gregoryszorc.com/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://gregoryszorc.com/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Mozilla Build System Brain Dump]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/05/13/mozilla-build-system-brain-dump" />
    <id>http://gregoryszorc.com/blog/2013/05/13/mozilla-build-system-brain-dump</id>
    <updated>2013-05-13T17:25:00Z</updated>
    <published>2013-05-13T17:25:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Firefox" />
    <category scheme="http://gregoryszorc.com/blog" term="mach" />
    <summary type="html"><![CDATA[Mozilla Build System Brain Dump]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/05/13/mozilla-build-system-brain-dump"><![CDATA[<p>I hold a lot of context in my head when it comes to the future of
Mozilla's build system and the interaction with it. I wanted to
perform a brain dump of sorts so people have an idea of where I'm
coming from when I inevitably propose radical changes.</p>
<h2>The sad state of build system interaction and the history of mach</h2>
<p>I believe that Mozilla's build system has had a poor developer
experience for as long as there has been a Mozilla build system.
Getting started with Firefox development was a right of passage. It
required following (often out-of-date) directions on MDN. It
required finding pages through MDN search or asking other people
for info over IRC. It was the kind of process that turned away
potential contributors because it was just too damn hard.</p>
<p>mach - while born out of my initial efforts to radically change
the build system proper - morphed into a generic command
dispatching framework by the time it landed in mozilla-central.
It has one overarching purpose: provide a single gateway point for
performing common developer tasks (such as building the tree and
running tests). The concept was nothing new - individual developers
had long coded up scripts and tools to streamline workflows. Some
even published these for others to use. What set mach apart was a
unified interface for these <em>commands</em> (the mach script in the
top directory of a checkout) and that these productivity gains
were <strong>in the tree</strong> and thus easily discoverable and usable by
<em>everybody</em> without significant effort (just run <em>mach help</em>).</p>
<p>While mach doesn't yet satisfy everyone's needs, it's slowly
growing new features and making developers' lives easier with
every one. All of this is happening despite that there
is not a single person tasked with working on mach full time.
Until a few months ago, mach was largely my work. Recently, Matt
Brubeck has been contributing a flury of enhancements - thanks
Matt! Ehsan Akhgari and Nicholas Alexander have contributed a
few commands as well! There are also a few people with a single
command to their name. This is fulfilling my original vision of
facilitating developers to scratch their own itches by
contributing mach commands.</p>
<p>I've noticed more people referencing mach in IRC channels. And,
more people get angry when a mach command breaks or changes
behavior. So, I consider the mach experiment a success. Is it
perfect, no. If it's not good enough for you, please file a bug
and/or code up a patch. If nothing else, please tell me: I love to
know about everyone's subtle requirements so I can keep them in
mind when refactoring the build system and hacking on mach.</p>
<h2>The object directory is a black box</h2>
<p>One of the ideas I'm trying to advance is that the object directory
should be considered a black box for the majority of developers. In
my ideal world, developers don't need to look inside the object
directory. Instead, they interact with it through condoned and
supported tools (like mach).</p>
<p>I say this for a few reasons. First, as the build config module owner
I would like the ability to massively refactor the <em>internals</em> of
the object directory without disrupting workflows. If people are
interacting directly with the object directory, I get significant
push back if things change. This inevitably holds back much-needed
improvements and triggers resentment towards me, build peers, and
the build system. Not a good situation. Whereas if people are
indirectly interacting with the object directory, we simply need to
maintain a consistent interface (like mach) and nobody should care
if things change.</p>
<p>Second, I believe that the methods used when directly interacting
with the object directory are often sub-par compared with going
through a more intelligent tool and that productivity suffers as a
result. For example, when you type <em>make</em> in inside the object
directory you need to know to pass <em>-j8</em>, use make vs pymake,
and that you also need to build <em>toolkit/library</em>, etc.
Also, by invoking make directory, you bypass other handy features,
such as automatic compiler warning aggregation (which only happens
if you invoke the build system through mach). If you go through a
tool like <em>mach</em>, you <em>should</em> automatically get the most ideal
experience possible.</p>
<p>In order for this vision to be realized, we need massive
improvements to tools like mach to cover the missing workflows that
still require direct object directory interaction. We also need people
to start using mach. I think increased mach usage comes after mach
has established itself as obviously superior to the alternatives
(I already believe it offers this for tasks like running tests).</p>
<h2>I don't want to force mach upon people but...</h2>
<p>Nobody likes when they are forced to change a process that has been
familiar for years. Developers especially. I get it. That's why
I've always attempted to position mach as an alternative to
existing workflows. If you don't like mach, you can always fall
back to the previous workflow. Or, you can improve mach (patches
more than welcome!). Having gone down the
please-use-this-tool-it's-better road before at other
organizations, I strongly believe that the best method to incur
adoption of a new tool is to gradually sway people through
obvious superiority and praise (as opposed to a mandate to switch).
I've been trying this approach with mach.</p>
<p>Lately, more and more people have been saying things like
<em>we should have the build infrastructure build through mach
instead of client.mk</em> and <em>why do we need testsuite-targets.mk when
we have mach commands.</em> While I personally feel that client.mk
and testsuite-targets.mk are antiquated as a developer-facing
interface compared to mach, I'm reluctant to eliminate them because
I don't like forcing change on others. That being said, there are
compelling reasons to eliminate or at least refactor how they work.</p>
<p>Let's take <em>testsuite-targets.mk</em> as an example. This is the make
file that provides the targets to run tests (like <em>make xpcshell-test</em>
and <em>make mochitest-browser-chrome</em>). What's interesting about this
file is that it's only used in local builds: our automation
infrastructure does not use <em>testsuite-targets.mk</em>! Instead,
<em>mozharness</em> and the old buildbot configs manually build up the
command used to invoke the test harnesses. Initially, the mach
commands for running tests simply invoked make targets defined
in <em>testsuite-targets.mk</em>. Lately, we've been converting the mach
commands to invoke the Python test runners directly. I'd argue that
the logic for <em>invoke the test runner</em> only needs to live in one
place in the tree. Furthermore as a build module peer, I have little
desire to support multiple implementations. Especially considering
how fragile they can be.</p>
<p>I think we're trending towards an outcome where mach (or the code
behind mach commands) transitions into the authoratitive invocation
method and <em>legacy</em> interfaces like <em>client.mk</em> and
<em>testsuite-targets.mk</em> are reimplemented to either call mach
commands or the same routine that powers them. Hopefully this
will be completely transparent to developers.</p>
<h2>The future of mozconfigs and environment configuration</h2>
<p><em>mozconfig</em> files are shell scripts used to define variables consumed
by the build system. They are the only officially supported mechanism
for configuring how the build system works.</p>
<p>I'd argue mozconfig files are a mediocre solution at best. First,
there's the issue of mozconfig statements that don't actually do
anything. I've seen no-op mozconfig content cargo culted into the
in-tree mozconfigs (used for the builder configurations)! Oops.
Second, doing things in mozconfig files is just awkward. Defining
the object directory requires <em>mk_add_options MOZ_OBJDIR=some-path</em>.
What's <em>mk_add_options</em>? If <em>some-path</em> is relative, what is it
relative <em>to</em>? While certainly addressable, the documentation on
how mozconfig files work is not terrific and fails to explain many
pitfalls. Even with proper documentation, there's still the issue
of the file format allowing no-op variable assignments to persist.</p>
<p>I'm very tempted to reinvent build configuration as something not
mozconfigs. What exactly, I don't know. mach has support for ini-like
configuration files. We could certainly have mach and the build
system pull configs from the same file.</p>
<p>I'm not sure what's going to happen here. But deprecating mozconfig
files as they are today is part of many of the options.</p>
<h2>Handling multiple mozconfig files</h2>
<p>A lot of developers only have a single mozconfig file (per source tree
at least). For these developers, life is easy. You simply install
your mozconfig in one of the default locations and it's automagically
used when you use mach or client.mk. Easy peasy.</p>
<p>I'm not sure what the relative numbers are, but many developers
maintain multiple mozconfig files per source tree. e.g. they'll
have one mozconfig to build desktop Firefox and another one for
Android. They may have debug variations of each.</p>
<p>Some developers even have a single mozconfig file but leverage the
fact that mozconfig files are shell scripts and have their
mozconfig dynamically do things depending on the current working
directory, value of an environment variable, etc.</p>
<p>I've also seen wrapper scripts that glorify setting environment
variables, changing directory, etc and invoke a command.</p>
<p>I've been thinking a lot about providing a common and well-supported
solution for switching between active build configurations.
<a href="https://developer.mozilla.org/en-US/docs/Developer_Guide/mach#Adding_mach_to_your_shell%27s_search_path">Installing mach on $PATH</a>
goes a long way to facilitate this. If you are in an object
directory, the mozconfig used when that object directory was
created is automatically applied. Simple enough. However, I want
people to start treating object directories as black boxes. So, I'd
rather not see people have their shell inside the object directory.</p>
<p>Whenever I think about solutions, I keep arriving at a
virtualenv-like solution. Developers would potentially need to
<em>activate</em> a Mozilla build environment (similar to how Windows
developers need to launch MozillaBuild). Inside this environment,
the shell prompt would contain the name of the current build
configuration. Users could switch between configurations using
<em>mach switch</em> or some other magic command on the $PATH.</p>
<p>Truth be told, I'm skeptical if people would find this useful. I'm
not sure it's that much better than exporting the MOZCONFIG
environment variable to define the active config. This one requires
more thought.</p>
<h2>The integration between the build environment and Python</h2>
<p>We use Python extensively in the build system and for common
developer tasks. mach is written in Python. moz.build processing
is implemented in Python. Most of the test harnesses are written in
Python.</p>
<p>Doing practically anything in the tree requires a Python
interpreter that knows about all the Python code in the tree and
how to load it.</p>
<p>Currently, we have two very similar Python environments. One is
a virtualenv created while running configure at the beginning of
a build. The other is essentially a cheap knock-off that mach
creates when it is launched.</p>
<p>At some point I'd like to consolidate these Python environments.
From any Python process we should have a way to automatically
bootstrap/activate into a well-defined Python environment. This
certainly sounds like establishing a unified Python virtualenv
used by both the build system and mach.</p>
<p>Unfortunately, things aren't straightforward. The virtualenv today
is constructed in the object directory. How do we determine the
current object directory? By loading the mozconfig file. How do we
do that? Well, if you are mach, we use Python. And, how does mach
know where to find the code to load the mozconfig file? You can
see the dilemma here.</p>
<p>A related issue is that of portable build environments. Currently, a
lot of our automation recreates the build system's virtualenv from
its own configuration (not that from the source tree). This has
and will continue to bite us. We'd <em>really</em> like to package up the
virtualenv (or at least its config) with tests so there is no
potential for discrepancy.</p>
<p>The inner workings of how we integrate with Python should be
invisible to most developers. But, I figured I'd capture it
here because it's an annoying problem. And, it's also related
to an <em>activated</em> build environment. What if we required all
developers to <em>activate</em> their shell with a Mozilla build
environment (like we do on Windows)? Not only would this solve
Python issues, but it would also facilitate simpler config
switching (outlined above). Hmmm...</p>
<h2>Direct interaction with the build system considered harmful</h2>
<p>Ever since there was a build system developers have been typing
<em>make</em> (or <em>make.py</em>) to build the tree. One of the goals of the
transition to <em>moz.build</em> files is to facilitate building the tree
with Tup. <em>make</em> will do nothing when you're not using Makefiles!
Another goal of the <em>moz.build</em> transition is to start
derecursifying the make build system such that we build things in
parallel. It's likely we'll produce monolithic make files and then
process <em>all</em> targets for a related class <em>IDLs</em>, <em>C++ compilation</em>,
etc in one invocation of <em>make</em>. So, uh, what happens during a partial
tree build? If a .cpp file from <em>/dom/src/storage</em> is being handled by
a monolithic make file invoked by the Makefile at the top of the
tree, how does a partial tree build pick that up? Does it build just
that target or every target in the monolithic/non-recursive make file?</p>
<p>Unless the build peers go out of our way to install redundant targets
in leaf Makefiles, directly invoking <em>make</em> from a subdirectory of
the tree won't do what it's done for years.</p>
<p>As I said above, I'm sympathetic to forced changes in procedure, so
it's likely we'll provide backwards-compatibile behavior. But, I'd
prefer to not do it. I'd first prefer partial-tree builds are not
necessary and a full tree build finishes quickly. But, we're not going
to get there for a bit. As an alternative, I'll take people building
through <em>mach build</em>. That way, we have an easily extensible interface
on which to build partial tree logic. We saw this recently when
dumbmake/smartmake landed. And, going through <em>mach</em> also reinforces my
ideal that the object directory is a black box.</p>
<h2>Semi-persistent state</h2>
<p>Currently, most state as it pertains to a checkout or build is in the
object directory. This is fine for artifacts from the build system.
However, there is a whole class of state that arguably shouldn't be in
the object directory. Specifically, it shouldn't be clobbered when you
rebuild. This includes logs from previous builds, the warnings database,
previously failing tests, etc. The list is only going to grow over time.</p>
<p>I'd like to establish a location for semi-persistant state related to
the tree and builds. Perhaps we change the clobber logic to ignore a
specific directory. Perhaps we start storing things in the user's home
directory. Perhaps we could establish a second <em>object directory</em> named
the <em>state directory</em>? How would this interact with <em>build environments</em>?</p>
<p>This will probably sit on the backburner until there is a compelling use
case for it.</p>
<h2>The battle against C++</h2>
<p>Compiling C++ consumes the bulk of our build time. Anything we can do to
speed up C++ compilation will work wonders for our build times.</p>
<p>I'm optimistic things like precompiled headers and compiling multiple
.cpp files with a single process invocation will drastically decrease
build times. However, no matter how much work we put in to make C++
compilation faster, we still have a giant issue: dependency hell.</p>
<p>As <a href="/presentations/2012-11-29-firefox-build-system/#34">shown</a> in my
build system presentation a few months back, we have dozens of header
files included by hundreds if not thousands of C++ files. If you change
one file: you invalidate build dependencies and trigger a rebuild. This
is why whenever files like mozilla-config.h change you are essentially
confronted with a full rebuild. ccache may help if you are lucky. But, I
fear that as long as headers proliferate the way they do, there is
little the build system by itself can do.</p>
<p>My attitude towards this is to wait and see what we can get out of
precompiled headers and the like. Maybe that makes it good enough. If
not, I'll likely be making a lot of noise at Platform meetings
requesting that C++ gurus brainstorm on a solution for reducing
header proliferation.</p>
<h2>Conclusion</h2>
<p>Belive it or not, these are only some of the topics floating around in
my head! But I've probably managed to bore everyone enough so I'll
call it a day.</p>
<p>I'm always interested in opinions and ideas, especially if they are
different from mine. I encourage you to leave a comment if you have
something to say.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Bulk Analysis of Mozilla's Build and Test Data]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/04/01/bulk-analysis-of-mozilla's-build-and-test-data" />
    <id>http://gregoryszorc.com/blog/2013/04/01/bulk-analysis-of-mozilla's-build-and-test-data</id>
    <updated>2013-04-01T13:12:00Z</updated>
    <published>2013-04-01T13:12:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Firefox" />
    <summary type="html"><![CDATA[Bulk Analysis of Mozilla's Build and Test Data]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/04/01/bulk-analysis-of-mozilla's-build-and-test-data"><![CDATA[<p>When you push code changes to Firefox and other similar Mozilla
projects, a flood of automated jobs is triggered on Mozilla's
infrastructure. It works like any other continuous integration
system. First you build, then you run tests, etc. What sets it
apart from other continuous integration systems is the size:
Mozilla runs thousands of jobs per week and the combined output
sums into the tens of gigabytes.</p>
<p>Most of the data from Mozilla's continuous integration is
available on public servers, notably ftp.mozilla.org. This includes
compiled binaries, logs, etc.</p>
<p>While there are tools that can sift through this mountain of data
(like <a href="https://tbpl.mozilla.org">TBPL</a>), they don't allow ad-hoc
queries over the raw data. Furthermore, these tools are very
function-specific and there are many data views they don't expose.
This <em>missing</em> data has always bothered me because, well, there
are cool and useful things I'd like to do with this data.</p>
<p>This itch has been bothering me for well over a year. The
persistent burning sensation coupled with rain over the weekend
caused me to scratch it.</p>
<p>The <a href="https://github.com/indygreg/mozilla-build-analyzer">product of my weekend labor</a>
is a system facilitating bulk storage and analysis of Mozilla's
build data. While it's currently very alpha, it's already showing
promise for more throrough data analysis.</p>
<p>Essentially, the tool works by collecting the dumps of all the jobs
executed on Mozilla's infrastructure. It can optionally supplement
this with the raw logs from those jobs. Then, it combs through this
data, extracts useful bits, and stores them. Once the initial
fetching has completed, you simply need to re-"parse" the data set
into useful data. And, since all data is stored locally, the
performance of this is not bound by Internet bandwidth. In practice,
this means that you can obtain a new metric faster than would have
been required before. The downside is you will likely be storing
gigabytes of raw data locally. But, disks are cheap. And, you have
control over what gets pulled in, so you can limit it to what you
need.</p>
<p>Please note the project is very alpha and is only currently serving
my personal interests. However, I know there is talk about <em>TBPL2</em>
and what I have built could evolve into the data store for the next
generation TBPL tool. Also, most of the work so far has centered on
data import. There is tons of analysis code waiting to be written.</p>
<p>If you are interested in improving the tool, please file a GitHub
pull request.</p>
<p>I hope to soon blog about useful information I've obtained through this
tool.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Omnipresent mach]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/03/03/omnipresent-mach" />
    <id>http://gregoryszorc.com/blog/2013/03/03/omnipresent-mach</id>
    <updated>2013-03-03T12:30:00Z</updated>
    <published>2013-03-03T12:30:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Firefox" />
    <category scheme="http://gregoryszorc.com/blog" term="mach" />
    <summary type="html"><![CDATA[Omnipresent mach]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/03/03/omnipresent-mach"><![CDATA[<p>Matt Brubeck recently landed an awesome patch for mach in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=840588">bug 840588</a>:
it allows mach to be used by any directory. I'm calling it
<em>omnipresent mach</em>.</p>
<p>Essentially, Matt changed the <em>mach</em> driver (the script in the root
directory of mozilla-central) so instead of having it look in hard-coded
relative paths for all its code, it walks up the directory tree and
looks for signs of the source tree or the object directory.</p>
<p>What this all means is that if you have the <em>mach</em> script installed in
your $PATH and you just type <em>mach</em> in your shell from within any source
directory or object directory, <em>mach</em> should just work. So, no more
typing <em>./mach</em>: just copy <em>mach</em> to <em>~/bin</em>, <em>/usr/local/bin</em> or some
other directory on your $PATH and you should just be able to type
<em>mach</em>.</p>
<p>Unfortunately, there are bound to be bugs here. Since <em>mach</em>
traditionally was only executed with the current working directory as
the top source directory, some commands are not prepared to handle a
variable current working directory. Some commands will likely get
confused when it comes resolving relative paths, etc. If you find
an issue, please report it! A temporary workaround is to just invoke
mach from the top source directory like you've always been doing.</p>
<p>If you enjoy the feature, thank Matt: this was completely his idea and
he saw it through from conception to implementation.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[moz.build Files and the Firefox Build System]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2013/02/28/moz.build-files-and-the-firefox-build-system" />
    <id>http://gregoryszorc.com/blog/2013/02/28/moz.build-files-and-the-firefox-build-system</id>
    <updated>2013-02-28T19:45:00Z</updated>
    <published>2013-02-28T19:45:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Firefox" />
    <category scheme="http://gregoryszorc.com/blog" term="build system" />
    <summary type="html"><![CDATA[moz.build Files and the Firefox Build System]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2013/02/28/moz.build-files-and-the-firefox-build-system"><![CDATA[<p>The next time you update mozilla-central you may notice some significant
changes with the build system. That's because this morning we finally
landed the start of a massive overhaul of the build system! There are
many end goals to this effort. The important ones for most will be
faster build times and a build system that is friendlier to make changes
to.</p>
<h2>Introducing moz.build Files</h2>
<p>If you look in the tree, you'll notice that nearly every directory
now has a <em>moz.build</em> file.</p>
<p><em>moz.build</em> files are what we are using to define the build system. Think of
them each as a descriptor that describes how to build its own part of the
tree. An individual <em>moz.build</em> file will contain the C++ sources to
compile, the headers to export, the tests to run, etc. Eventually.
Currently, they are limited to directory traversal information.</p>
<p><em>moz.build</em> files essentially add a level of indirection between the
build system definition and how the tree is actually built. Before
<em>moz.build</em> files, the same metadata we are now capturing in <em>moz.build</em>
files (or plan to capture) was captured in <em>Makefile.in</em> files. We
performed simple variable substitution on these <em>Makefile.in</em> files to
produce <em>Makefile</em> files in the object directory. These <em>Makefile</em> files
were used by GNU Make (or Pymake on Windows) to build the tree.</p>
<p>As I outlined in <a href="/blog/2012/06/25/improving-mozilla's-build-system/">Improving Mozilla's Build System</a>,
<em>Makefile.in</em> are suboptimal for a number of reasons. The important
bit is they essentially tie us to the use of make (recursive or otherwise).
We are very interested in supporting modern build systems such as Tup
(the theory being they will build the tree faster).</p>
<p>Enter <em>moz.build</em> files. Storing our build configuration in
<em>moz.build</em> files allows us to decouple the definition of the build
system from the tool used to build it.</p>
<h2>How moz.build Files Work</h2>
<p>At the tail end of <em>configure</em>, the build system invokes the
<em>config.status</em> script in the object directory. The role of
<em>config.status</em> is to combine the information collected during
<em>configure</em> with the build configuration obtained from <em>moz.build</em> files
and take the necessary actions to ensure the build backend (make) can
build the tree.</p>
<p>Before today, <em>config.status</em> essentially iterated over the source tree
and converted <em>Makefile.in</em> files to <em>Makefile</em> in the object directory.
Things are now slightly more complicated with <em>moz.build</em> files.</p>
<p>When <em>config.status</em> runs, it starts with the
<a href="https://hg.mozilla.org/mozilla-central/file/87de54667483/moz.build">root moz.build</a>
from the source tree. It feeds this file into a Python interpreter. It
then looks for special variables like <em>DIRS</em> and <em>PARALLEL_DIRS</em> to determine
which directories contain additional <em>moz.build</em> files. It then descends
into all the referenced directories, reading their <em>moz.build</em> files.
While this is happening, we are converting the results of each
<em>moz.build</em> file execution into <em>backend.mk</em> files that make knows how
to build. It also performs the <em>Makefile.in</em> to <em>Makefile</em> conversion
like it always has. When the whole process has finished, the object
directory contains a bunch of <em>Makefile</em> and <em>backend.mk</em> files. make
runs like it always has. The only real difference is some variables are
coming from the <em>moz.build</em>-derived <em>backend.mk</em> files instead of
<em>Makefile</em>.</p>
<p>This is just a brief overview, of course. If you want to know more,
see the code in <em>/python/mozbuild/mozbuild/frontend</em> and
<em>/python/mozbuild/mozbuild/backend</em>.</p>
<h2>Build System Future</h2>
<p>With the introduction of <em>moz.build</em> files, the intent is to <strong>eventually
completely eliminate Makefile.in and have all the build definition live
in moz.build files.</strong></p>
<p>Doing this all at once would have been next to impossible. So, we
decided to eliminate <em>Makefile.in</em> gradually. The first step is what
landed today: essentially moving <em>DIRS</em> variables out of <em>Makefile.in</em>
and into <em>moz.build</em> files. Next, we will be eliminating empty
<em>Makefile.in</em> (<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=844635">bug 844635</a>)
and will be moving more parts of the build definition from <em>Makefile.in</em>
to <em>moz.build</em> files. The next part to move over will likely be IDLs
(<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=818246">bug 818246</a>).
After that, it may be exported files (<em>EXPORTS</em> in <em>Makefile.in</em>
parlance). And repeat until we have no more <em>Makefile.in</em> in the tree.</p>
<p>Each migration of build definition data to <em>moz.build</em> files will likely
occur in two phases:</p>
<ol>
<li>A largely mechanical move of the variables from <em>Makefile.in</em> to
   <em>moz.build</em>.</li>
<li>Better build backend integration resulting from the move.</li>
</ol>
<p>In phase #1, we will essentially cut and paste variable assignments to
<em>moz.build</em> files. make will read the same variables it does today and
perform the same actions. The only difference is the values in these
variables will be defined in <em>moz.build</em> files.</p>
<p>In phase #2, we will leverage the fact that our build definition now has
an API. We will change our existing make backend to be more efficient.
For example, we should soon be able to compile IDLs and copy exported
headers without make traversing through the directory tree at build time.
We will be able to do this because the <em>moz.build</em> traversal at
pre-build time sees data from all <em>moz.build</em> files and with this
<em>complete world view</em> is able to produce more optimal make files than
what you would get if you recursed into multiple directories. In short:
it will make the build faster.</p>
<p>Once we have a sufficient portion of the build definition moved to
<em>moz.build</em> files we will be able to experiment with new build backends
(like Tup), look into automatic Visual Studio project generation, and
more easily experiment with different ways of building (such as
precompiled headers, fewer compiler process invocations, etc). These
should all contribute to faster build times.</p>
<h2>Frequently Asked Questions</h2>
<h4>What impact will I see from this change?</h4>
<p>If you never touched <em>Makefile.in</em> files in the tree, you should not
notice anything different about how the tree builds or how the build
system works. You should have nothing to fear.</p>
<p>The most obvious changes to the source tree are:</p>
<ol>
<li>There is a <em>moz.build</em> file in almost every directory now.</li>
<li>The variables related to directory traversal (those containing <em>DIRS</em>
   in their name) are now defined in <em>moz.build</em> files instead of
   <em>Makefile.in</em>.</li>
<li>If your <em>Makefile.in</em> contains a variable that has been moved to
   <em>moz.build</em> files, make will spew an error when processing that file
   and the build will fail.</li>
</ol>
<h4>Will this change how I build?</h4>
<p>It shouldn't. You should build the tree just like you always have. Most
of you won't notice any differences.</p>
<p>If you see something weird, speak up in #build or file a bug if you are
really confident it is wrong.</p>
<h4>What are the risks to this change?</h4>
<p>The migration of variables from <em>Makefile.in</em> to <em>moz.build</em> files is
largely mechanical and significant portions are done manually. This can
be a mind-numbing and tedious process. Not helping things is the fact
that Splinter's review interface for these kinds of patches is hard to
read.</p>
<p>This all means that there is a non-trivial risk for <em>transcription</em>
errors. All it takes is an inverted conditional block and all of a
sudden large parts of the tree are no longer built, for example.</p>
<p>We have established <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=846425">bug 846825</a>
to investigate any oddities from the initial transfer. Developers are
encouraged to help with the effort. Please spot check that your
directories are still being built, tests run, etc. Pay special attention
to changes made in the last 4 months as these parts of <em>Makefile.in</em>
would have been bit rotted and more prone to data loss.</p>
<p>Parts of the tree not enabled in standard configurations are more prone
to breakage due to less testing. i.e. build configurations not captured
by TBPL have a higher chance of breaking.</p>
<h4>Will this make the tree build faster?</h4>
<p>Not yet. But eventually it will. This initial landing paves the
groundwork to making the tree build faster (see the <em>Future</em> section
above).</p>
<h4>I see a lot of empty moz.build files!</h4>
<p>Yes. Sorry about that. The good news is they shouldn't be empty for
long. As things move from <em>Makefile.in</em> to <em>moz.build</em> we'll see fewer
and fewer empty <em>moz.build</em> files. We'll also see fewer and fewer
<em>Makefile.in</em> files once we start deleting empty <em>Makefile.in</em>.</p>
<p>If you want to know why we must have empty files, it's mainly for
validation. If we allowed <em>moz.build</em> files to be optional, how would
you detect a typo in a directory name? Directory exists? What if that
directory exists but isn't supposed to have a <em>moz.build</em> file?</p>
<h4>You bitrotted my patches!</h4>
<p>Yes. I'm sorry. The transition period to <em>moz.build</em> files could be a
little messy. There will be lots of changes to <em>Makefile.in</em> and
<em>moz.build</em> files and lots of chances for bit rot. Uplifts could be
especially nasty. (Although I don't believe many uplifts involve
significant changes to the build configuration.)</p>
<p>This all means there is a strong incentive for us to complete the
transition as quickly as possible.</p>
<h4>Can I help with the transition to moz.build files?</h4>
<p>Yes!</p>
<p>The transition is largely mechanical (at least phase #1). If you are
interested in moving a variable or set of variables, hop in #build on
IRC and speak up!</p>
<h4>You said moz.build files are actually Python files?!</h4>
<p>Yes they are! However, they are executed in a very tightly controlled
sandbox. You can't import modules, open files, etc. UPPERCASE variable
names are reserved and only a few functions are exposed. If you attempt
to assign to an unknown UPPERCASE variable or assign an invalid value,
an error will occur. This is already much better than Makefile because
we can now detect errors earlier in the build process (rather than 15
minutes into a build).</p>
<h4>What variables and functions are available in moz.build files?</h4>
<p>If you run |./mach mozbuild-reference| you will see a print-out of
all the variables, functions, and symbols that are exposed to the Python
sandbox that moz.build files execute in. There are even tests that will
fail the build if the sandbox contains symbols not in this output!</p>
<p>The output should be valid reSTructuredText (in case you want to convert
to HTML for reading in your browser).</p>
<h4>What if a moz.build file contains an error?</h4>
<p>The build will break.</p>
<p>A lot of work has gone into making the output of moz.build errors human
friendly and actionable. If you do something wrong, it won't just
complain: it will tell you how to fix it!</p>
<h4>Besides build times, how else will this improve the build system?</h4>
<p>There are several ways!</p>
<p>As mentioned above, moz.build are more strict about what data is allowed
to be defined. If you assign to an UPPERCASE variable, that variable
must be known to the sandbox or else the assignment will error. This
means that if you assign to an UPPERCASE variable, you know it has a
side-effect. No more cargo culting of old, meaningless variables!</p>
<p>To change the behavior of moz.build files (add new variables or
functions, change how makefile generation works, etc) will require
changes to the code in /python/mozbuild. This code belongs squarely to
the build module and requires appropriate review. A problem with
Makefiles is that they have lots of foot guns by default and its easy
for self-inflicted wounds to land in the tree without explicit build
peer review. This problem largely goes away with moz.build files because
the sandbox takes away all of make's foot guns.</p>
<p>The output of a moz.build execution is essentially a static data
structure. It's easy to validate them for conformance. If we discover
bad practices in our build definition, we can centrally add tests for
them and enforce best practices.</p>
<p>We will also see user experience wins by moving data to moz.build files.
Take mochitests for an example. We currently have several flavors
(plain, browser, chrome, etc). Sometimes you cannot distinguish the
flavor by the filename alone. With moz.build files, it will be easier to
answer questions like "what mochitest flavor is this file?" mach could
hook into this so you can type |mach mochitest path/to/file.html|
instead of |mach mochitest-plain path/to/file.html|. Even better, you
should just be able to type |mach path/to/test.html| and mach knows from
the build definition that path/to/test.html is a plain mochitest file
and assumes you want to run it. There are dozens of small development
workflow wins to be gained here!</p>
<h4>If I change a moz.build file, what happens?</h4>
<p>If you change a moz.build file, then make should detect that it
has changed and it will update the dynamically generated <em>backend.mk</em>
file and reinvoke the requested build action. This should all happen
automatically (just like <em>Makefile.in</em> to <em>Makefile</em> conversion works
automatically).</p>
<h4>My build seems to pause for a few seconds before starting!</h4>
<p>A change to <em>any</em> moz.build file will cause a full traversal of the
entire moz.build tree. On modern machines, this should only take 1-3
seconds. If your source tree is not in the page cache (and you need
to load moz.build files from disk) or if you are on older hardware, this
could be a little slower.</p>
<p>This is an unfortunate side-effect of having a whole world view of the
build definition. The build delay incurred by these full scans should
eventually be cancelled out by build backend optimizations resulting
from having this whole world view, however.</p>
<p>The good news is this full scan should only occur if a mozbuild file
changes. And, if you are performing make recursion, it should only
happen once (not in every directory). If you notice multiple moz.build
scanning-related pauses during builds, please file a bug in Core ::
Build Config!</p>
<p>Finally, we are performing the reads on a single thread currently. We
can throw more cores at the task if someone codes up a patch.</p>
<h4>What happened to allmakefiles.sh?</h4>
<p>It has been sacked. allmakefiles.sh was an optimization to perform all
the Makefile.in to Makefile conversion in one go. The directory
traversal performed by moz.build reading effectively replaces the role
of allmakefiles.sh. Not only that, but the moz.build build definition is
always up to date! allmakefiles.sh was typically out of sync with
reality and was a burden to maintain.</p>
<h4>Did we just invent our own build system?</h4>
<p>Kinda. We invented a generic Python sandboxing infrastructure. Then we
hooked up code to populate it with variables from our build system and
told it how to perform file traversal by reading specific variables set
during file execution. Then we hooked up code for taking the evaluated
results of all those sandboxes and convert them into make files.</p>
<p>Conceptually, what we invented is like GYP but with a different config
file format. We have dabbled with the idea of converting the parsed
build definition into GYP classes and then leveraging GYP to produce
Makefiles, Ninja files, Visual Studio Projects, etc. This would an
interesting experiment!</p>
<p>If you want to call it a build system, call it a build system. However,
it is currently tightly coupled to Mozilla's needs, so you can't just
use it anywhere. The concept might be worth exploring, however.</p>
<h4>Is there anything else you'd like to share?</h4>
<p>I think we set the record for most parts in a bug: 61. Although, they
are numbered 1-17, 19-20. Part 18 has 30+ sub-parts using letters from
the English and Greek alphabet for identifiers. Part 61 uses the
infinity symbol as its number. See the
<a href="https://hg.mozilla.org/mozilla-central/pushloghtml?changeset=c65d59d33aa8">pushlog</a>.</p>
<p>Finally, I'd like to thank everyone who helped with this effort. The bug
itself was <em>only</em> 6 months old and had active development off and on for
a lot of it. Ted Mielczarek and Mike Hommey provided invaluable feedback
on the core build system patches. A number of module owners stepped in
to lend eyes to the mechanical conversion of their files. Last but not
least, Ms2ger provided invaluable review aid on many of the patches. The
work was so good that we all agreed that an Ms2ger f+ was good enough
for a build peer rs! If reviewing the patches wasn't enough, Ms2ger
also oversaw the tree closure and merging of the landing. I don't know
how I will repay this debt.</p>
<h4>Any more questions?</h4>
<p>If you have more questions, drop in #build on irc.mozilla.org and ask
away.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Changes to How mach Loads mozconfigs]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2012/12/05/changes-to-how-mach-loads-mozconfigs" />
    <id>http://gregoryszorc.com/blog/2012/12/05/changes-to-how-mach-loads-mozconfigs</id>
    <updated>2012-12-05T10:30:00Z</updated>
    <published>2012-12-05T10:30:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Firefox" />
    <summary type="html"><![CDATA[Changes to How mach Loads mozconfigs]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2012/12/05/changes-to-how-mach-loads-mozconfigs"><![CDATA[<p>If you use mach to build Firefox, there is a chance you may run into
some errors from a change that landed on mozilla-central Wednesday.</p>
<p>I reimplemented the mozconfig finding and loading logic in Python and
with a nice shell wrapper that lets us more easily inspect side-effects
of execution. The overall goal is to speed up mozconfig loading (fewer
shell invocations) as well as to have a strong API for interacting with
mozconfigs so we can do things like better validation. As a side effect,
we now have test coverage of mozconfig behavior!</p>
<p>Anyway, because the logic for mozconfig finding and loading is going
through a completely new mechanism, you may notice some weird behavior.
Until a few minutes ago, $topsrcdir wasn't defined in the execution
environment. This is now fixed. I think most complaints stemmed from
this.</p>
<p>Another significant change is that mozconfig shell scripts are now
executed in a shell that has <em>set -e</em>. This means that failing commands
in your mozconfig will now abort execution. Before, execution would have
silently continued unless you checked the exit code in your mozconfig.
I think this is a change for the better, but it may break your
mozconfigs.</p>
<p>If you encounter an issue, please follow the instructions in mach's
output to file a bug. Please attach or link to your mozconfig.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Firefox Build System Presentation]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2012/11/30/firefox-build-system-presentation" />
    <id>http://gregoryszorc.com/blog/2012/11/30/firefox-build-system-presentation</id>
    <updated>2012-11-30T14:00:00Z</updated>
    <published>2012-11-30T14:00:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Firefox" />
    <category scheme="http://gregoryszorc.com/blog" term="build system" />
    <summary type="html"><![CDATA[Firefox Build System Presentation]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2012/11/30/firefox-build-system-presentation"><![CDATA[<p>In case you missed it, I gave a presentation on the state of Firefox's
build system yesterday.</p>
<p>You can <a href="https://air.mozilla.org/the-future-of-the-firefox-build-system/">watch</a>
it and <a href="http://gregoryszorc.com/presentations/2012-11-29-firefox-build-system/#1">view</a>
the slides online.</p>
<p>If you build Firefox from source regularly, you should definitely at
least skim through the slide deck.</p>
<p>I'm not an HTML expert, so my apogolies for bad UI on the interactive
slides. You may need to press <strong>enter</strong> to select items in
dropdown menus. Also, the interactive slides are a bit resource
intensive. If the slide deck is really slow, turn off those elements.
I've also only tested the slides in Firefox 19 and 20. My apologies if
they don't work everywhere.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Mach Has Landed]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2012/09/26/mach-has-landed" />
    <id>http://gregoryszorc.com/blog/2012/09/26/mach-has-landed</id>
    <updated>2012-09-26T17:30:00Z</updated>
    <published>2012-09-26T17:30:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Firefox" />
    <summary type="html"><![CDATA[Mach Has Landed]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2012/09/26/mach-has-landed"><![CDATA[<p>Hacking on Firefox is <em>hard</em>. Compiling the source tree for the first
time is a daunting experience. If you manage to do that, you still need
to figure out how to submit patches, write and run tests, etc. There is
no shortage of points where people can get confused, make mistakes, or
just give up because the barrier is too high.</p>
<p>I have strong convictions about making the overall developer experience
better (developers are users too, after all). The easier you make the
developer experience, the greater the chances of retaining developers.
And retaining developers means more contributions: more features and
fewer bugs. This translates to a better state for the Mozilla Project.
This makes the world a better place.</p>
<p>Since practically my first day working at Mozilla, I've been
experimenting with ways to make contributing to Firefox easier by
improving the build system or interaction with it.</p>
<p>With a lot of help, I've finally succeeded in landing something into the
Firefox source tree that I think will ultimately lead to a much better
developer experience.</p>
<p>It's called <strong>mach</strong> (German for <em>do</em>) and if you pull the latest
version of <a href="https://hg.mozilla.org/mozilla-central">mozilla-central</a>
(Firefox's main source code repository), you can run mach today.</p>
<h2>Running Mach</h2>
<p>You can run Mach by simply executing it from the root directory in the
repository:</p>
<pre><code>$ ./mach
</code></pre>
<p>Ideally, I shouldn't have to tell you anything else: mach's output
should provide you all the instruction you need to use it. If it
doesn't, that is a bug and it should be fixed.</p>
<p>Realistically, mach is still in early development and its user
experience still leaves a lot to be desired.</p>
<p>Because technical usage docs belong in a medium that is easily
discoverable and where the community can improve on them (not a
post on a personal blog), you can find additional usage information in
the
<a href="https://developer.mozilla.org/En/Developer_Guide/mach">mach article</a> on
MDN. The
<a href="https://hg.mozilla.org/mozilla-central/file/default/python/mach/README.rst">mach README</a>
holds more technical information for people wanting to poke at the inner
workings.</p>
<p>Mach does require Python 2.7. The build system will likely soon require
Python 2.7 as well. So, if you don't have Python 2.7, you should upgrade
now before you lose the ability to build the tree. Conveniently, the
tree now has a
<a href="http://gregoryszorc.com/blog/2012/09/18/bootstrap-your-system-to-build-firefox">bootstrap script</a>
which covers the installation of Python. So, Python 2.7 should just be a
simple command away.</p>
<h2>Features</h2>
<p>Why would you use mach? Good question! Compared to the existing
out-of-the-box experience, mach adds:</p>
<ul>
<li>Ability to run xpcshell and mochitest tests from the source directory.
  This means you can tab-complete test filenames in your shell and it
  <em>just works</em>.</li>
<li>Parsing of compiler warnings (currently supports Clang 3.1 and MSVC
  formats) into a unified warnings database (actually a JSON file).
  After builds you can run <em>./mach warnings-list</em> or <em>./mach
  warnings-summary</em> to get a concise list without having to look at
  build logs.</li>
<li>A single command-line interface where you can easily discover new
  functionality. Just run <em>./mach help</em> (try doing that with make!).</li>
</ul>
<p>Naysayers will say this is a paltry list. They are correct. I have
bigger plans. But, you have to start somewhere.</p>
<h2>Goals and Future Ideas</h2>
<p>The overall goal of mach is to improve the developer experience of
developing Firefox and other Gecko applications. It does this by
providing a convenient, central command in the root directory of
the repository that acts as both an oracle to discover new commands
and functionality (<em>./mach help</em>) as well as a proxy to execute them.
You don't need to worry about environment variables, working directories,
or finding some random script hidden in the bowells of the source tree.
You just run a single command and the world is brought to you. No build
documentation. No outdated wikis. No copying commands into your shell.
No having to scour random blogs for useful tools. You just clone the
repository, run a command, see what you can do, and get stuff done. Your
shell-literate grandmother could do it.</p>
<p>Mach should be your springboard to in-tree developer tools and increased
productivity. You shouldn't need anything except a copy of the source
tree and mach.</p>
<p>Like Git and Mercurial, mach is powered by the concept of
sub-commands/actions. So, one simply needs to register a new sub-command
with the mach driver. This involves writing a Python class. Once you do
that, people can discover and use that functionality. All batteries are
included with a copy of mozilla-central.</p>
<p>As stated above, the current set of commands is rather small. But, the
sky is the limit. Here are some of my ideas:</p>
<ul>
<li>Ability to upload, download, and apply patches from Bugzilla (Burak
  Yiit Kaya, Jeff Hammel, Clint Talbert and I have already talked about
  this -- progress tracked in
  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=774141">bug 774141</a>).</li>
<li>Automatically configure Mercurial with optimal settings (ensure user
  info is set, proper lines of diff context, enable mqext, etc). Tracked
  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=794580">bug 794580</a>.</li>
<li>Submit Try builds. The <a href="https://github.com/pbiggar/trychooser">trychooser</a>
  Mercurial extension could easily live as a mach subcommand! Tracked in
  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=774137">bug 774137</a>.</li>
<li>Identify Bugzilla components and/or reviewers from files touched by
  patch. It's all in the history of the touched files and the history of
  the old bugs referenced by those commits!
  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=774145">Bug 774145</a>.</li>
<li>Interaction with the <em>self-serve</em> build API. That thing on TBPL to
  control individual builds - we could make a CLI interface for it.
  (Steve Fink and/or Jeff Hammel already have
  <a href="https://hg.mozilla.org/users/josh_joshmatthews.net/self-serve-tools">code</a>
  for this - it just needs to be integrated).
  <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=774147">Bug 774147</a>.</li>
</ul>
<p>If you have an idea for a feature, please
<a href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Core&amp;component=mach">file a bug</a>.
Please note there are many features on file already. However, some
obvious ones such as integration with missing test suites have yet to be
filed (at least at the time I wrote this post).</p>
<p>If you wrote an awesome developer tool and would like others to use it
(without having to rely on people discovering it by reading a corner of the
Internet), add it to mach! Use mach as a wedge to get more exposure and
users. File a bug. I will happily r+ patches that add useful developer
functionality to the tree.</p>
<h2>What this Means / Longer Term Future</h2>
<p>While there is no timetable, mach will eventually replace <em>client.mk</em>.
client.mk, like mach, is essentially a CLI driver for the build
system. Having the driver implemented in Python rather than make has many
compelling advantages. I could probably write a whole post on it, but
I'll spare the world from my ranting.</p>
<p>Anyway, this all means that you may want to start re-training your
muscle memory now. Stop typing <em>make</em> and start typing <em>mach</em>. If you
need to type <em>make</em> because mach does not provide a feature, this is a
missing feature from mach.
<a href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Core&amp;component=mach">File a bug</a>
and request a new mach feature!</p>
<p>I want to condition people to stop typing <em>make</em>, especially in the object
directory. There are drastic changes to the build system in the works
(<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=784841">bug 784841</a> is
the tip of the iceburg). These changes will require the build system to
be treated as a black box. So, things like invoking make from the object
directory will eventually break. You'll need to go through an
intelligent tool to invoke the build system. Mach will be that tool.</p>
<h2>Thanks</h2>
<p>I would like to single out the following individuals for helping to land
mach:</p>
<ul>
<li>Jeff Hammel for doing the bulk of the reviewing. He shares my vision
  for mach and how it will make the overall developer experience much
  more pleasant and how this will translate to better things for The
  Project. In my mind, Jeff deserves as much credit for landing mach as
  I do.</li>
<li>Mike Hommey and Ms2ger for review help. Mike Hommey helped identify a
  lot of issues with build system integration. Ms2ger provided lots of
  general feedback on Python issues and API design.</li>
<li>Mike Connor (my manager) for allowing me to work on this. It's not
  related to my job description in any way so he <em>could</em> say I shouldn't
  be spending time on this. But, he realizes the positive impact this can
  have and has been supportive of it.</li>
</ul>
<p>I hope you find mach useful!</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Bootstrap Your System to Build Firefox]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2012/09/18/bootstrap-your-system-to-build-firefox" />
    <id>http://gregoryszorc.com/blog/2012/09/18/bootstrap-your-system-to-build-firefox</id>
    <updated>2012-09-18T17:00:00Z</updated>
    <published>2012-09-18T17:00:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Firefox" />
    <summary type="html"><![CDATA[Bootstrap Your System to Build Firefox]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2012/09/18/bootstrap-your-system-to-build-firefox"><![CDATA[<p>If you've looked at the
<a href="https://developer.mozilla.org/en-US/docs/Simple_Firefox_build">build instructions</a>
for Firefox lately, you may have noticed something new: support for
system bootstrapping!</p>
<p>Now checked in to mozilla-central is a
<a href="https://hg.mozilla.org/mozilla-central/file/default/python/mozboot/">framework</a>
for ensuring your system is capable of building mozilla-central and
Firefox. You just need to download and run a single Python script and it
performs magic.</p>
<p>Kudos go out to a community contributor, kmm (name wasn't revealed) for
doing the legwork for tracking down and verifying things worked on all
the Linux distros. Richard Newman and Jeff Hammel also helped with code
reviews. Just hours after it landed, Landry Breuil contributed support
for OpenBSD!</p>
<p>Currently, bootstrapping works for the following:</p>
<ul>
<li>Ubuntu Linux</li>
<li>Mint</li>
<li>CentOS 6.x</li>
<li>Fedora</li>
<li>OS X 10.6, 10.7, and 10.8</li>
<li>OpenBSD</li>
</ul>
<p>If you want to add support for an additional OS, please file a
<a href="https://bugzilla.mozilla.org/enter_bug.cgi?product=Core&amp;component=Build%20Config">Core : Build Config</a>
bug. Likewise, if you encounter an issue, please file a bug so others
don't get tripped up by it!</p>
<p>Bootstrap support is definitely in its infancy. It still needs features
like better prompting and opportunities for user choice (e.g. support
MacPorts on OS X - currently it only works with Homebrew). But, I think
it is much better than what existed previously, especially on OS X.</p>
<p>I consider this bootstrapping component just one piece in a larger
mission to make developing and building Firefox (and other Gecko
applications) easier. This should (hopefully) lead to more development
involvement. The next component to land will likely be
<a href="http://gregoryszorc.com/blog/2012/07/25/mozilla-build-system-plan-of-attack">mach</a>.
It's (finally) been getting some review love (thanks Jeff Hammel!), so
I'm optimistic it will land in the next few weeks.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Visual Studio Project Generation for mozilla-central]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2012/08/28/visual-studio-project-generation-for-mozilla-central" />
    <id>http://gregoryszorc.com/blog/2012/08/28/visual-studio-project-generation-for-mozilla-central</id>
    <updated>2012-08-28T12:00:00Z</updated>
    <published>2012-08-28T12:00:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Firefox" />
    <category scheme="http://gregoryszorc.com/blog" term="build system" />
    <summary type="html"><![CDATA[Visual Studio Project Generation for mozilla-central]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2012/08/28/visual-studio-project-generation-for-mozilla-central"><![CDATA[<p>I have very alpha support for Visual Studio project generation for
mozilla-central that daring people can dogfood.</p>
<p>I want to emphasize that this is extremely alpha. Normally, I wouldn't
release things as fragile as they are. But, I know Windows developers
sorely miss Visual Studio, especially IntelliSense. The current Visual
Studio projects support IntelliSense, so I want to get this in the hands
of Windows developers ASAP.</p>
<p>The current directions for making this all work are a bit hacky. Things
will change once things have matured. For now, please excuse the mess.</p>
<p>First, you will need to grab the code. If you use Git, set up a remote
to my repository:</p>
<pre><code>git remote add indygreg git://github.com/indygreg/mozilla-central.git
git fetch indygreg
</code></pre>
<p>The branch of interest is <em>build-splendid</em>. I periodically rebase this
branch on top of master. You have been warned.</p>
<p>You can switch to this branch:</p>
<pre><code>git checkout -b build-splendid indygreg/build-splendid
</code></pre>
<p>Alternatively, you can squash it down to a single commit and merge it
into your local branch. Once you've done that, you can record the SHA-1
of the commit and cherry-pick that wherever you like!</p>
<pre><code>git merge --squash indygreg/build-splendid
git commit
</code></pre>
<p>In the current state, you need to build the tree or the Visual Studio
projects will complain about missing files. It doesn't matter if you
build the tree before or after Visual Studio projects are generated.
But, we might as well get it out of the way. From your MozillaBuild
environment, run:</p>
<pre><code>./mach build
</code></pre>
<p>That should <em>just work</em>. If it doesn't, you may need to configure
mach.ini. See my <a href="http://gregoryszorc.com/blog/2012/08/15/build-firefox-faster-with-build-splendid/">previous post</a>
on how to configure mach.ini. As a reference, my Windows config is:</p>
<pre><code>[build]

configure_extra = --disable-webgl

[compiler]

[paths]
source_directory = c:\dev\src\mozilla-central-git
object_directory = c:\dev\src\mozilla-central-git\objdir
</code></pre>
<p>Now, to generate Visual Studio project files:</p>
<pre><code>./mach backendconfig visualstudio
</code></pre>
<p>That should take about a minute to finish. When it's done, it should
have created <em>objdir/msvc/mozilla.sln</em>. You should be able to load that
in Visual Studio!</p>
<p>You will need to regenerate Visual Studio project files when the build
config changes. As a rule of thumb, do this every time you pull source.
You don't need to perform a full build before you generate Visual Studio
files (you do need to perform configure, however). However, if you have
not performed a full build, Visual Studio may not be able to find some
files, like headers generated from IDLs.</p>
<p><strong>Please close the solution before regenerating the project files.</strong> If
you don't, Visual Studio puts up a modal dialog for each project file
that changed and you have to click through over a hundred of these. It's
extremely frustrating. I'm investigating workarounds.</p>
<h2>Current State</h2>
<p>Currently, it only generates projects for C/C++ compilation (libraries).
I still need to add support for IDL, headers, etc. However, each
project has proper compiler flags, header search paths, etc. So,
IntelliSense is happy and some things do manage to compile!</p>
<p>Many parts are broken and sub-par.</p>
<p>I've only tested on Visual Studio 2008. If you are running Visual Studio
\2010, you can try to upgrade the solution. This <em>may</em> work. The backend
supports generating solutions for different versions. But, I haven't
tested things work on non-2008 and I don't want to expose untested behavior.</p>
<p>Compiling within Visual Studio works for some things. On my system, I
get a lot of <em>nullptr not defined</em> errors. I'm not sure why. This will
hopefully be worked out soon.</p>
<p>If you do manager to compile within Visual Studio, the output files
don't go in the right places. So, if you do a build from the
command-line, it will have to re-compile to pick up changes.</p>
<p>Project names are based on the name of the library they produce. I'm not
sure if this is the best solution.</p>
<p>Project dependencies are not set up. They will be added later.</p>
<p>Projects for linking libxul or building firefox.exe are not yet
provided. Along the same vein, debugging support is not built-in. I'm
working on it.</p>
<p>Basically, IntelliSense works. You can now use Visual Studio as a rich
editor. Hopefully this is a step in the right direction.</p>
<p>I'm anxious to hear if this works for other people. Please leave
comments!</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Build Firefox Faster with Build Splendid]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2012/08/15/build-firefox-faster-with-build-splendid" />
    <id>http://gregoryszorc.com/blog/2012/08/15/build-firefox-faster-with-build-splendid</id>
    <updated>2012-08-15T14:30:00Z</updated>
    <published>2012-08-15T14:30:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <category scheme="http://gregoryszorc.com/blog" term="Firefox" />
    <category scheme="http://gregoryszorc.com/blog" term="build system" />
    <summary type="html"><![CDATA[Build Firefox Faster with Build Splendid]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2012/08/15/build-firefox-faster-with-build-splendid"><![CDATA[<p>Would you like to build Firefox faster? If so, do the following:</p>
<pre><code>hg qimport http://people.mozilla.org/~gszorc/build-splendid.patch
hg qpush
rm .mozconfig* (you may want to create a backup first)
./mach build
</code></pre>
<p>This should <em>just work</em> on OS X, Linux, and other Unix-style systems.
<strong>Windows support is currently broken, sorry.</strong></p>
<p><em>mach</em> can do much more than build. Run the following to see what:</p>
<pre><code>./mach --help
</code></pre>
<h2>Important Info</h2>
<p><em>mach</em> replaces client.mk. <em>mach</em> has its own configuration file. The
first time you run <em>mach</em>, it will create the file <em>mach.ini</em> in the
same directory as the <em>mach</em> script. This is your new <em>mozconfig</em> file.</p>
<p>The default <em>mach.ini</em> places the object directory into the directory
<em>objdir</em> under the top source directory. It also builds an optimized
binary without debug info.</p>
<p>Run the following to see which config settings you can add to
<em>mach.ini</em>:</p>
<pre><code>./mach settings-create
./mach settings-list
</code></pre>
<p>This <em>may</em> fail because I'm still working out the kinks with <em>gettext</em>.
If it doesn't work, open <em>python/mozbuild-bs/mozbuild/base.py</em> and search
for <em>_register_settings</em>. Open
<em>python/mozbuild-bs/mozbuild/locale/en-US/LC_MESSAGES/mozbuild.po</em> for
the help messages.</p>
<p>As a point of reference, my <em>mach.ini</em> looks like the following:</p>
<pre><code>[build]
application = browser

configure_extra = --enable-dtrace --enable-tests

[compiler]
cc = /usr/local/llvm/bin/clang
cxx = /usr/local/llvm/bin/clang++

cflags = -fcolor-diagnostics
cxxflags = -fcolor-diagnostics

[paths]
source_directory = /Users/gps/src/mozilla-central-git
object_directory = /Users/gps/src/mozilla-central-git/objdir
</code></pre>
<p>I am on OS X and am using a locally-built version of LLVM/Clang, which I
have installed to <em>/usr/local/llvm</em>.</p>
<p>You'll notice there are no options to configure make. The patch
automatically selects optimal settings for your platform!</p>
<h2>Known Issues and Caveats</h2>
<p>This is alpha. It works in scenarios in which I have tested it, mainly
building the <em>browser</em> application on OS X and Linux. There are many
features missing and likely many bugs.</p>
<p>I have been using this as part of my day-to-day development for weeks.
However, your mileage may vary.</p>
<p>As stated above, Windows support is lacking. It will appear to work, but
things will blow up during building. Don't even try to use it on
Windows.</p>
<p>There are likely many bugs. Please don't file Bugzilla bugs, as this
isn't part of the build system just yet.</p>
<p><strong>This patch takes over the build system. Do not attempt to use
client.mk or run make directly with this patch applied.</strong></p>
<p>If you encounter an issue, your methods of recourse are:</p>
<ol>
<li>Post a comment on this blog post</li>
<li>Ping me on irc.mozilla.org. My nick is <em>gps</em>. Try the #buildfaster
   channel.</li>
<li>Send an email to gps@mozilla.com</li>
</ol>
<p>I am particularly interested in exceptions and build failures.</p>
<p>If you encounter an issue building with this, just reverse the patch and
build like you have always done (don't forget to restore your mozconfig
file).</p>
<p>If <em>mach.ini</em> does not support everything you were doing in your
mozconfig, please send me a copy of your mozconfig so I can implement
whatever you need.</p>
<h2>Other Info</h2>
<p>I will likely write a follow-up post detailing what's going on. If you
are curious, the code lives in <em>python/mozbuild-bs</em>. The <em>backend</em> and
<em>frontend</em> sub-packages are where the magic is at. Once the backend has
been configured, check out <em>hybridmake.mk</em> and all of the <em>splendid.mk</em>
files in the object directory.</p>
<p>I am particularly interested in the real-world impact of this patch on
people's build times. In this early version of the patch, you likely
won't see drastic speed increases. On my MacBook Pro with an SSD, I see
end-to-end clobber build times decrease by over a minute. With a little
more work, I should be able to shave another minute or two off of that.</p>
<p>I will try to keep the patch up-to-date as I improve the build system.
Refresh early and often.</p>]]></content>
  </entry>
</feed>
