<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">Gregory Szorc's Digital Home</title>
  <subtitle type="text">Rambling on</subtitle>

  <updated>2024-03-18T03:55:04Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog" />
  <id>http://gregoryszorc.com/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://gregoryszorc.com/blog/feed/atom/" />
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[My Shifting Open Source Priorities]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2024/03/17/my-shifting-open-source-priorities" />
    <id>http://gregoryszorc.com/blog/2024/03/17/my-shifting-open-source-priorities</id>
    <updated>2024-03-17T21:00:00Z</updated>
    <published>2024-03-17T21:00:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Personal" />
    <category scheme="http://gregoryszorc.com/blog" term="PyOxidizer" />
    <summary type="html"><![CDATA[My Shifting Open Source Priorities]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2024/03/17/my-shifting-open-source-priorities"><![CDATA[<p>I'm a maintainer of a handful of open source projects, some of which have
millions of downloads and/or are used in important workloads, including in
production.</p>
<p>I have a full time job as a software engineer and my open source work is
effectively a side job. (Albeit one I try very hard to not let intersect
with my day job.)</p>
<p>Historically, my biggest contributions to my open source projects have come
when I'm not working full time:</p>
<ul>
<li><a href="https://github.com/indygreg/python-zstandard">python-zstandard</a> was started
  when I was on medical leave, recovering from a surgery.</li>
<li><a href="https://github.com/indygreg/python-build-standalone">python-build-standalone</a>
  and <a href="https://github.com/indygreg/PyOxidizer">PyOxidizer</a> were mainly built
  when I was between jobs, after leaving Mozilla.</li>
<li><a href="https://github.com/indygreg/apple-platform-rs/tree/main/apple-codesign">apple-codesign</a>
  was built in the height of COVID when I took a voluntary leave of absence
  from work to reconstitute my mental and physical health.</li>
</ul>
<p>When working full time, my time to contribute to open source has been carved out
of weekday nights and weekends, especially in the winter months. I believe
that code is an art form and programming a form of creative expression. My open
source contributions provide a relaxing avenue for me to express my artistic
creativity, when able.</p>
<p>My open source contributions reflect my personal priorities of where and what
to spend my free time on.</p>
<p>The only constant in life is change.</p>
<p>In the middle of 2022, I switched job roles and found myself reinvigorated by my
new role - Infrastructure Performance - which is at the intersection of some of
my strongest technical and professional skills. I found myself willingly
pouring more energy and time into my day job. That had the side effect of
reducing my open source contributions.</p>
<p>In 2023Q1 I got married. In the months leading up to and after, I chose to
prioritize spending time with my now wife and all the time commitments that
entails. This also reduced the amount of time available for open source
contributions.</p>
<p>In 2023Q4 I became a father to a beautiful baby girl. While on my employer's
generous-for-the-United-States fourteen week paternity leave, I somehow found
some time to contribute to open source. As refreshing as that was, it didn't
last. My <em>man cave</em> where my desktop computer resides has been converted into
a nursery. And for the past few months it has been occupied by my mother-in-law,
who has been generously effectively serving as a live-in nanny. Even when I'm
able to sit down at my desktop, it's hard to get into a state of flow due to
the added entropy from the additional three people now living with me.</p>
<p>After realizing the new normal in 2024Q1, I purchased a <a href="https://www.wahoofitness.com/devices/indoor-cycling/bike-trainers/kickr-move-buy">Wahoo KICKR MOVE</a>
bicycle trainer and now spend considerable time doing virtual bicycle rides on
<a href="https://www.zwift.com/">Zwift</a> because its one of the few <em>leisure</em> activities
I can do at home without drawing scrutiny from my wife and mother-in-law (but
98% my mother-in-law because I've observed that my wife is effectively
infallible). I now get excited about virtually summiting famous climbs instead of
contributing to open source. (Today's was
<a href="https://pjammcycling.com/climb/40.Mont-Ventoux-Bedoin">Mont Ventoux</a> - an
absolute beast of a climb that reminded me a lot of my real world ride up
<a href="https://pjammcycling.com/climb/11.Pikes-Peak">Pike's Peak</a> in 2020.)</p>
<p>Various changes in the past eighteen or so months have created additional
time constraints and prioritization changes that have resulted in my open
source contributions withering.</p>
<p>In addition, my technical interests have been shifting.</p>
<p>I've always gravitated to more systems-level areas of computers. My degree
is in Computer Engineering and I have a stereotypical engineer mindset: I
have an insatiable curiosity about how things work and interact and I want
to always be tinkering. I prefer to be closer to hardware instead of abstracted
far away from it. I enjoy interacting with the building blocks of software
ecosystems: operating systems, filesystems, runtimes, file formats, compilers,
etc.</p>
<p>Historically, my open source contributions to my preferred areas of
computing were limited. Again, to me open source is an enjoyable form of
creative expression. That means I do it for <em>fun</em>. Historically, the
<em>systems-level</em> programming space was limited to languages like C and
C++, which I consider frustrating and painful to use. If I'm going to subject
myself to misery when programming, you are going to have to pay me well to
do it.</p>
<p>As part of creating PyOxidizer, I learned Rust.</p>
<p>When I became proficient in Rust, I realized that Rust unlocks all kinds of
systems-level problems that were effectively off-limits for my open source
contributions. Would I <a href="/blog/2022/01/03/rust-implementation-of-debian-packaging-primitives/">implement</a>
Debian packaging primitives in Python? Or a <a href="/blog/2022/01/09/bulk-analyze-linux-packages-with-linux-package-analyzer/">tool</a>
to bulk analyze Linux packages and peek inside ELF binaries for insights
about what compiler/linker features are used in the wild in Python/C/C++?
Not unless you pay me to do it!</p>
<p>As I learned Rust, I also found myself being drawn away from Python, my
prior go-to language. As I wrote in <a href="/blog/2021/04/13/rust-is-for-professionals/">Rust is for Professionals</a>,
Rust feels surprisingly high level. It isn't as terse as Python but it is
a lot closer than I thought it would be. And Rust gives you vastly stronger
compile-time guarantees and run-time performance than Python. I felt like
Rust's tooling ecosystem was supporting me instead of standing in my way. I
felt that when you consider the overall software development lifecycle - not
just the edit-build-run loop that people tend to fixate on, likely because
it is the easiest to measure - Rust was vastly more productive and a joy to
work with than Python. All those countless hours debugging, fixing, and
authoring tests for <code>TypeError</code> and <code>ValueError</code> Python exceptions you see
in production just don't happen with Rust and that time can be better spent
iterating on core functionality, which is what actually matters. </p>
<p>On top of the Rust undercurrents, I've also become somewhat disenchanted with
the Python ecosystem. As I wrote in 2020's <a href="/blog/2020/01/13/mercurial's-journey-to-and-reflections-on-python-3/">Mercurial's Journey to and Reflections on
Python 3</a>,
the Python 3 transition was bungled and resulted in years - if not a full
decade - of lost opportunity. As I wrote in 2020's <a href="/blog/2023/10/30/my-user-experience-porting-off-setup.py/">My User Experience Porting Off
setup.py</a>, the Python
packaging story feels as discombobulated and frustrating as ever. PyOxidizer
additionally brushed up against <a href="/docs/pyoxidizer/0.24.0/pyoxidizer_technotes.html#desired-changes-from-python-to-aid-pyoxidizer">several limitations</a>
in how Python is designed and implemented, many of which are not trivially
fixable. As a <em>systems-level guy</em>, I am frequently questioning various aspects
of the Python ecosystem which I have contrasting opinions on, including the
importance of correctness and performance.</p>
<p>Starting in 2021, I started gravitating towards writing more Rust code and solving
problems in the systems domain that were previously off-limits to me, like Apple
code signing. Initially the work was in support of PyOxidizer: I was going to
implement all these packaging primitives in pure Rust and enable people to
distribute Python applications without requiring access to a Windows or macOS
machine! Over time, this work consumed me. Apple code signing turned into a major
time sink because of its complexity and the fact I was having to reverse
engineer a lot of its internals. But I was having a ton of fun doing it: more
fun than swimming upstream against decades of encrusted technical debts in the
Python ecosystem.</p>
<p>By late 2021, I realized I made a series of <em>mistakes</em> with PyOxidizer.</p>
<p>I started PyOxidizer as a science experiment to see if it was possible to achieve
a single file executable Python application without requiring a <em>temporary</em>
filesystem at run-time. I succeeded. But the cost was compatibility with the
larger pre-built Python package ecosystem. I built all this complexity into
PyOxidizer to allow people to tweak how Python resources are packaged so they
could choose to build a single file application if they wanted. This ballooned
into a hot mess and was obviously not user-friendly. It violated various
personal principles about optimizing for end-user experience.</p>
<p>Armed with knowledge of all the pitfalls, I realized that there was a 90%
use case for Python application packaging that was simple for end users and
technically achievable using all the code primitives - like the
<a href="https://crates.io/crates/pyembed">pyembed Rust crate</a> - that I built out for
PyOxidizer.</p>
<p>Thus the <a href="/blog/2022/05/10/announcing-the-pyoxy-python-runner/">PyOxy project</a> was born
and released in May 2022.</p>
<p>While I believe PyOxy is already a generally useful primitive to have in the
Python ecosystem, I had bigger goals in mind.</p>
<p>My intent with PyOxy was to build in a simplified and opinionated <em>PyOxidizer
lite</em> mode. The <code>pyoxy</code> executable is already a chameleon: if you rename it to
<code>python</code> it behaves like a <code>python</code> executable. I wanted to extend this so you
could do something like <code>pyoxy build-app</code> and it would collect all dependencies,
assemble a
<a href="https://gregoryszorc.com/docs/pyoxidizer/0.24.0/oxidized_importer_packed_resources.html">Python packed resources</a>
blob, and embed that in a copy of the <code>pyoxy</code> binary as an ELF, Mach-O, or PE
segment. Then at run-time, the variant executable binary would load the application
configuration and Python resources metadata from its own binary and execute the
application. Essentially, PyOxy would evolve into a self-packaging Python
application. I <em>just</em> needed to evolve the Python packed resources format,
implement a very crude ELF, Mach-O, and PE <em>linker</em> to append resources data to an
executable, and teach <code>pyembed</code> to read resources data from an ELF, Mach-O, or
PE segment. All within my sphere of technical competency. And I was excited to
build it and forever alter people's perceptions of how easy it could be to produce
a distributable Python application.</p>
<p>Then the roller coaster of my personal life took over. I felt newly invigorated
with a new job role. I got engaged and married. I became a father.</p>
<p>By early 2023, it was clear my ability to contribute to open source would be
vastly diminished for the foreseeable future. PyOxidizer and PyOxy fell into a
state of neglect. Weeks went by without me even tinkering on my local computer,
much less push commits or publish a release. Weeks turned into months. Months
into quarters. At this point, I haven't pushed a commit to
<a href="https://github.com/indygreg/PyOxidizer">indygreg/PyOxidizer</a> since January 2023.
And I'm not sure when I next will, if ever.</p>
<p>In my limited open source contribution time, I've prioritized other projects
over PyOxidizer.</p>
<p><a href="https://github.com/indygreg/python-build-standalone">python-build-standalone</a>
has gained a life outside PyOxidizer. It is now used by
<a href="https://github.com/astral-sh/rye">rye</a>, Bazel's
<a href="https://github.com/bazelbuild/rules_python">rules_python</a>,
<a href="https://beeware.org/project/projects/tools/briefcase/">briefcase</a>, and a myriad
of other consumers. The release assets have been downloaded over 23 million
times and the download rate appears to be accelerating. I still actively
support python-build-standalone and intend for the project to be actively
supported for the indefinite future: it has become too important to abandon. I'm
actively recruiting assistance to help maintain the project and I'm not concerned
about its future.</p>
<p>Apple code signing still actively draws my engagement. What I love about the
project is it either works or it doesn't: there's limited extra features we can
add to it since Apple mostly dictates the feature set. And I perceive the current
project to be mostly <em>done</em>.</p>
<p><a href="https://github.com/indygreg/python-zstandard">python-zstandard</a> is downloaded
~8 million times per month. The project is long overdue for some modernization.
I'm sitting on a pile of commits to improve it, but progress has been slow. I
just learned this weekend that the maintainer of the other popular zstandard
Python package deleted their GitHub account recently and now users are looking to
onboard to my package. Nothing quite like unanticipated distractions!</p>
<p><strong>That's a very long-winded way of saying that PyOxidizer and all the projects under
its umbrella are effectively in a zombie state.</strong> I'm hesitant to say <em>dead</em> because
if I suddenly found myself with lots of free time I'd love to brush off the cobwebs
and bring the projects back to life. But who am I kidding: they are effectively dead
at the moment because with everything happening in my personal life, I don't see where
I find the time to resuscitate the project. And that assumes I even want to: again,
I've become somewhat disenchanted by the state of Python. The main thing that draws
me to it is the size of the community and the potential for impact. But to realize
that impact I feel like I'd be pushing Python in directions it isn't well-equipped
to go in. Quite franky - and, yes, selfishly - I don't want to subject myself to
the misery unless I'm being well paid to do it. Again, I view my open source
contributions as a <em>fun</em> outlet for my creative expression and nudging Python
packaging in directions it is obviously ill-equipped to go in just isn't <em>fun</em>.</p>
<p><strong>If anyone reading has an interest in taking ownership or maintenance responsibilities
of PyOxidizer, any projects under its umbrella, or any of my other open source projects,
I'm receptive to proposals.</strong> Send me an <a href="mailto:gregory.szorc@gmail.com">email</a>
or create an issue or discussion on GitHub if you want to do it publicly.</p>
<p>But I'm going to assume that PyOxidizer is going to wither and die - or at least
incur some massive backwards incompatible breaks if it continues to live. I've already
filed issues against python-build-standalone - such as
<a href="https://github.com/indygreg/python-build-standalone/issues/221">removing Windows static builds</a> -
to make the project easier to support and less work for future maintainers.</p>
<p>If I have one regret about how this has played out, it is my failure to
communicate developments in my open source commitments / expectations in a timely manner.
I knew the future was bleak in early 2023 but didn't publicly say anything.
I still thought there was a chance that things were going to change and I didn't
want to make a hard decision prematurely. Writing this post has been on my mind
since the middle of 2023 but I just couldn't bring myself to write it. And -
surprise - having a newborn at home is a giant time and mental commitment! I'm
writing this now because people are (finally!) noticing my lack of contributions to
PyOxidizer and asking questions. And I'm home alone for a few days and actually
have time to sit down and compose this post. (Yes, I'm that stretched for time in
my personal life.)</p>
<p>In 2023, I struggled with the idea of letting people down by declaring PyOxidizer
<em>dead</em>. But when I wake up every morning, walk into the nursery, and cause my daughter
to smile and flail her arms and legs with unbridled excitement when she sees me, I'd
have it no other way. When it comes to choosing between open source and family, I
choose family.</p>
<p>It feels appropriate to end this post with a link to <a href="https://xkcd.com/2347/">XKCD 2347: Dependency</a>.
But I'm not the <em>random person in Nebraska</em>: I'm a husband and father.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[On Algorithms and Interviewing]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2019/01/17/on-algorithms-and-interviewing" />
    <id>http://gregoryszorc.com/blog/2019/01/17/on-algorithms-and-interviewing</id>
    <updated>2019-01-17T10:45:00Z</updated>
    <published>2019-01-17T10:45:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Personal" />
    <summary type="html"><![CDATA[On Algorithms and Interviewing]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2019/01/17/on-algorithms-and-interviewing"><![CDATA[<p>As I write this, I'm hours away from starting to interview for full-time
jobs in the software field. I've spoken with a number of recruiters and
hiring managers and have received interview preparation materials from
a handful of companies, many of which you've probably heard of.</p>
<p>I was hoping things would have changed since I last seriously underwent
this endeavor ~7.5 years ago (I did interview periodically when I was at
Mozilla in order to test waters, keep my interview skills sharp, etc). But
it appears the industry is still generally fixated on algorithms and
data structures in interviews. <strong>The way algorithms and similar coding tricks
are emphasized in the preparation materials I've received, you'd think people
in software spend a major part of their work days thinking about and
implementing algorithms</strong>. But from my experience, this is very far from
the case! So why are so many companies and interviewers fixated on
algorithms. And is this a good thing?</p>
<p>When they matter, efficient algorithms, data structures, and other tricks
are important and useful skills to have. But from my experience, they
matter far less than you would think. If I were to make a list of important
job skills and traits for software and programming, memorized knowledge of
algorithms and data structures is so far down the list that I don't think I
would even ask about algorithms fundamentals for most job candidates! (In
fact I don't.) I think it is vastly more important to focus on behavioral
qualities and potential to actually think and apply knowledge rather than
regurgitate it. Algorithms and data structures, after all, are learned
knowledge. All other things be equal, I'd rather have someone who knows
when to ask for help with an algorithms issue or can pick up the skill
than a curmudgeon algorithms genius who has an abrasive personality and
clings to old habits.</p>
<p>In the spirit of full disclosure, I should to state that my algorithms skills
are relatively weak. You can accuse me of writing this post to fulfill my
own selfish interests. You wouldn't be wrong. But I know there are others
like me who are good at programming yet struggle with algorithms and question
the utility of algorithms in interviews. I'm attempting to write this post
for all of us. </p>
<p>I have failed job interviews because the interviewer assessed my algorithms
abilities as weak. I'm able to work through this <em>deficiency</em> with interviewers
who care more about the behavioral traits I exhibit when in such a situation (I
try to be quick about admitting my technical weaknesses and to ask for help
when needed). But some interviewers aren't as interested in the behavioral
traits or insist on a baseline level of memorized algorithms knowledge beyond
my own. I feel like my relative algorithms weakness hasn't hurt me <em>on</em> the
job, as I hardly find myself caring about algorithms in the work I do. In the
majority of cases, the choice of an algorithm just doesn't matter for the size
of the data set. Or a standard algorithm or data structure available in the
standard library of the language I'm using is <em>good enough</em>. In the cases where
I realize algorithms and data structures would matter, I run my
technical questions past someone with more knowledge in the domain than me. Or
if I don't do that, it often comes up during code review.
Without strong algorithms and data structures knowledge, I'm able to maintain
the Firefox build system, become a core contributor to a version control
tool (something you think would require a lot of heavy algorithms knowledge),
maintain various open source projects, diagnose and address low-level
performance issues in complex software and systems. <strong>About the only impact that
being weak in algorithms and data structures has had on my career is that some
companies passed on hiring me because they perceived strength in this area to
be important.</strong></p>
<p>Albert Einstein once said, <em>I never commit to memory anything that can
easily be looked up in a book.</em> A modern adaptation of that quote may
go something like, <em>never memorize how to implement an algorithm or data
structure when you can just Google it or use a software library
implementing it.</em> If you have knowledge of how to implement various algorithms
in your head, that's good for you, I suppose. But I think the <em>bigger brain</em>
knowledge to possess is <em>when</em> algorithms matter and to a lesser extent, what
types of algorithms are appropriate for particular problems. Answering these
problems requires critical thinking. Actually implementing algorithms, by
contrast, merely requires knowledge <em>that can easily be looked up in a book</em> (the
algorithm or data structure itself) coupled with some programming knowledge for
how to apply it. A capable programmer will be able to do both these things and
pick up algorithms and data structure knowledge on the job, if necessary.</p>
<p>Some would say that algorithms are a good way to flush out coding
ability. And coding ability is important to assess as part of interviewing
a job candidate for a programming position! They aren't wrong. But there
are much better ways to receive stronger signals about an interviewee's
compatibility! On the coding front, there are infinite ways to assess
programming capability without involving algorithms. So why involve
algorithms as part of the interview?</p>
<p>One way I approach interviewing people is to imagine what the typical
work day of that role will be like. How much time do they spend coding,
investigating bugs, debugging, attending meetings, writing proposals,
politicking with managers, etc. This produces a conceptual pie chart
of that role's activities. I then try to structure the interview such
that the topics covered in the interview correlate with and somewhat
in proportion to activities in that job role. Is the role a heads down
junior coder? A team lead or manager? When you start trying to map the
time in various areas of the role to time spent in the interview, you
realize that the common technical interview overly emphasizes some areas
and often completely ignores others! One of the areas that is
over-emphasizes is algorithms. <strong>Again, your typical programmer is going
to be spending most of their typical day doing things unrelated to
algorithms. So why are you spending precious interview time asking about
algorithms when you could be probing an area that actually correlates
to typical job activities?</strong> When viewed through this lens, the prevalence
of algorithms in interviews just doesn't make much sense to me.</p>
<p>Perhaps knowledge of algorithms should be basic knowledge that every
programmer should possess. If so, then asking about algorithms is fair
game during an interview, I suppose. But I'm not comfortable with this
line of thought.</p>
<p>I've always found it fascinating the ways that people with different
backgrounds and degrees approach problems differently. From my experience,
some of the best ideas and perspectives come from people with backgrounds
and degrees which are minorities in the field. I've worked with
programmers with degrees in philosophy and history who were some of the
best programmers and overall minds in the room. One of the great things
about software and programming is it is accessible to anyone, regardless
of background. If you can code, you can land a (usually high-paying) job.
Yes, the field is highly technical. But you don't need formal education
or a degree to enter it like you do similar <em>high-end</em> professions, such
as medicine or law. You can argue whether this is a good thing or not. But
I think the accessibility of the software profession - the lack of formal
gatekeeping - is something to marvel at, something that we as an industry
should embrace and be proud of. Do arbitrary hurdles to joining the
industry help or hinder it?</p>
<p>A problem with emphasizing algorithms in interviews is that algorithms
are somewhat highly specialized and academic. There are entire areas of
programming and software where detailed knowledge of algorithms just
isn't that important. <strong>The bar for so much software is <em>it works</em> and it
quite frankly doesn't matter if you have a quadratic algorithm instead of
something better.</strong></p>
<p>Most people I know are exposed to algorithms fundamentals during their
university education as part of pursuing a degree in
computer science or engineering. You almost certainly aren't going to
have academic exposure to algorithms if you are say a liberal arts
major - never mind someone who doesn't attend university at all (I also
know plenty of terrific programmers who don't have degrees). From my
own experience, my degree is in computer engineering. Not computer
science or software engineering: computer engineering. I remember from
my university days that my computer science friends seemed to have a much
better grasp at algorithms and theory of software and programming
than I did. When I was taking classes about how hardware and electronics
work, they were learning all about the mathematical concepts underpinning
the field, different approaches to programming language design, etc. I
received very little of that. And on top of that, I struggled with my
single algorithms course at university. So I entered the workforce without
as good of a grasp on the computer science fundamentals as others I knew.
(But I still probably knew more than someone in an unrelated field.)
The point I'm trying to make is that because algorithms are somewhat highly
specialized and academic in nature, requiring knowledge in algorithms
will effectively bias your hiring towards people with strong computer
science backgrounds. Stated another way, <strong>screening on algorithms knowledge
undermines diversity and inclusion initiatives by excluding viable
candidates who don't have strong backgrounds in computer science.</strong>
Sure, if someone wants to enter the industry they can take the time to
study up on algorithms. But why force them to do that? It feels like
arbitrary gatekeeping given the relative non-importance of algorithms
given the typical activities of the typical programmer. So why do it?</p>
<p>I suspect major contributing reasons to why algorithms are so prevalent
in interviews are cargo culting, laziness, and lack of formal interview
training / caring about diversity. As an industry, the software
field is pretty bad at applying best practices and learning from our
mistakes. I suspect this will change once the relatively young
industry catches up to more-established industries and we're forced to
cope with the realities of legal and monetary liabilities the way
practically every other industry is. (We're starting to see this with
monetary damages for security breaches.) Anyway, we as an industry are pretty
bad at self-regulating and adopting practices with proven benefits. We
like to settle for what is known. Laziness and the comfort associated with
is easy. Seeking out and implementing change is harder. This is human
nature. We see this with well-known people in industry rejecting the
ideas of continuous testing (years ago) or fuzzing (more recently). We see
it in C/C++ programmers who are delusional about their abilities to write
secure code and decry e.g. Rust's safety guarantees as superfluous. The
industry is disproportionately white and male (at least in the United
States). And this brings with it certain personality tendencies. One is a
<em>macho</em> attitude, which can manifest in interviews via the interviewer
embarking on an ego trip proving they know some esoteric algorithm or
data structure the candidate does not. </p>
<p>As a clear example of this, Google was known for asking <em>brainteaser</em>
interview questions. (The practice may have been prevalent at Microsoft
before Google was the darling of Silicon Valley, but that was before I
entered industry.) This <em>trend</em> caught on and soon companies all over were
asking brainteasers! The problem was that these questions
<a href="https://www.newyorker.com/tech/annals-of-technology/why-brainteasers-dont-belong-in-job-interviews">didn't correlate to actual job performance</a>!
From a <a href="https://www.nytimes.com/2013/06/20/business/in-head-hunting-big-data-may-not-be-such-a-big-deal.html?pagewanted=all">2013 NYTimes interview with Google's VP of People Operations</a>:</p>
<pre><code>On the hiring side, we found that brainteasers are a complete waste of
time. How many golf balls can you fit into an airplane? How many gas
stations in Manhattan? A complete waste of time. They don’t predict
anything. They serve primarily to make the interviewer feel smart.
</code></pre>
<p>But the damage was done. I still heard these kinds of questions when
interviewing in the wild long after Google realized they were bad
questions and instructed interviewers not to ask them. I even believe I
got a brainteaser when interviewing at Google after the supposed
banning of these types of questions! And I won't be shocked if I'm
asked a brainteaser in 2019 as part of the several interviews I'll
be doing in the days ahead.</p>
<p>Asking questions with no correlation to job performance because a
popular company asked that type of question for a while: that's
textbook cargo culting. Failing to change your ways despite evidence
saying you should: laziness. Insisting that your way is correct and
others need to be like you: gatekeeping.</p>
<p>I'm not saying algorithms and data structures during interviews are
intrinsically bad and that we should stop asking about them. What I am
saying is that we as an industry need to examine how we interview. We need
to invest in scientifically proven techniques. (Research shows that
behavioral interview questions are <em>better</em>. <em>Tell me about a
time when</em>, etc.) And after more than ten years in industry, my experience
tells me that interviews place a disproportionate emphasis on algorithms
and data structures compared to the daily activities of the typical
programmer. And on top of that, due to their academic nature, I worry
that screening for algorithms and data structures knowledge is undermining
the diversity and inclusivity of our field by biasing towards people
with strong computer science backgrounds. I think it is time we
examine the role of algorithms and data structures in interviews and
consider focusing on other areas instead.</p>]]></content>
  </entry>
  <entry>
    <author>
      <name>Gregory Szorc</name>
      <uri>http://gregoryszorc.com/blog</uri>
    </author>
    <title type="html"><![CDATA[Seeking Employment]]></title>
    <link rel="alternate" type="text/html" href="http://gregoryszorc.com/blog/2019/01/07/seeking-employment" />
    <id>http://gregoryszorc.com/blog/2019/01/07/seeking-employment</id>
    <updated>2019-01-07T15:25:00Z</updated>
    <published>2019-01-07T15:25:00Z</published>
    <category scheme="http://gregoryszorc.com/blog" term="Personal" />
    <category scheme="http://gregoryszorc.com/blog" term="Mozilla" />
    <summary type="html"><![CDATA[Seeking Employment]]></summary>
    <content type="html" xml:base="http://gregoryszorc.com/blog/2019/01/07/seeking-employment"><![CDATA[<p>After almost seven and a half years as an employee of Mozilla Corporation,
I'm moving on. I have already worked my final day as an employee.</p>
<p>This post is the first time that I've publicly acknowledged my departure.
To any Mozillians reading this, I regret that I did not send out a
farewell email before I left. But the circumstances of my departure weren't
conducive to doing so. I've been drafting a proper farewell blog post. But
it has been very challenging to compose. Furthermore, each passing day
brings with it new insights into my time at Mozilla and a new wrinkle to
integrate into the reflective story I want to tell in that post. I vow to
eventually publish a proper goodbye that serves as the bookend to my
employment at Mozilla. Until then, just let me say that I'm already missing
working with many of you. I've connected with several people since I left
and still owe responses or messages to many more. If you want to get in
touch, my contact info is in my <a href="/resume.pdf">résumé</a>.</p>
<p>I left Mozilla without new employment lined up. That leads me to the
subject line of this post: I'm seeking employment. The remainder of this
post is thus tailored to potential employers.</p>
<p>My <a href="/resume.pdf">résumé</a> has been updated. But that two page summary
only scratches the surface of my experience and set of skills. The
<a href="/work.html">Body of Work</a> page of my website is a more detailed record
of the work I've done. But even it is not complete!</p>
<p>Perusing through my posts on this blog will reveal even more about the
work I've done and how I go about it. My résumé links to a few posts
that I think are great examples of the level of understanding and detail
that I'm capable of harnessing.</p>
<p>As far as the kind of work I want to do or the type of company I want
to work for, I'm trying to keep an open mind. But I do have some biases.</p>
<p>I prefer established companies to early start-ups for various reasons.
Dan Luu's <a href="https://danluu.com/startup-tradeoffs/">Big companies v. startups</a>
is aligned pretty well with my thinking.</p>
<p>One of the reasons I worked for Mozilla was because of my personal
alignment with the
<a href="https://www.mozilla.org/en-US/about/manifesto/">Mozilla Manifesto</a>. So
I gravitate towards employers that share those principles and am
somewhat turned off by those that counteract them. But I recognize that
the world is complex and that competing perspectives aren't intrinsically
evil. In other words, I try to maintain an open mind.</p>
<p>I'm attracted to employers that align their business with improving the
well-being of the planet, especially the people on it. The link
between the business and well-being can be tenuous: a B2B business for
example is presumably selling something that helps people, and that helping
is what matters to me. The tighter the link between the business and
improving the world will increase my attraction to a employer.</p>
<p>I started my university education as a biomedical engineer because I
liked the idea of being at the intersection of technology and medicine.
And part of me really wants to return to this space because there
are few things more noble than helping a fellow human being in need.</p>
<p>As for the kind of role or technical work I want to do, I could go in
any number of directions. I still enjoy doing individual contributor type
work and believe I could be an asset to an employer doing that work. But
I also crave working on a team, performing technical mentorship, and being
a leader of technical components. I enjoy participating in high-level
planning as well as implementing the low-level aspects. I recognize that
while my individual output can be substantial (I can provide data showing
that I was one of the most prolific technical contributors at Mozilla
during my time there) I can be more valuable to an employer when I
bestow skills and knowledge unto others through teaching, mentorship,
setting an example, etc.</p>
<p>I have what I would consider expertise in a few domains that may be
attractive to employers.</p>
<p>I was a technical maintainer of Firefox's build system and initiated a
transition away from an architecture that had been in place since the
Netscape days. I definitely geek out way too much on build systems.</p>
<p>I am a contributor to the Mercurial version control tool. I know way
too much about the internals of Mercurial, Git, and other version
control tools. I am intimately aware of scaling problems with these
tools. Some of the scaling work I did for Mercurial saved Mozilla tens
of thousands of dollars in direct operational costs and probably
hundreds of thousands of dollars in saved people time due to fewer
service disruptions and faster operations.</p>
<p>I have exposure to both client and server side work and the problems
encountered within each domain. I've dabbled in lots of technologies,
operating systems, and tools. I'm not afraid to learn something new.
Although as my experience increases, so does my skepticism of shiny
new things (I've been burned by technical fads too many times).</p>
<p>I have a keen fascination with optimization and scaling, whether it
be on a technical level or in terms of workflows and human behavior.
I like to ask <em>and then what</em> so I'm thinking a few steps out and am
prepared for the next problem or consequence of an immediate action.</p>
<p>I seem to have a knack for caring about user experience and interfaces.
(Although my own visual design skills aren't the greatest - see my
website design for proof.) I'm pretty passionate that tools that people
use should be simple and usable. Cognitive dissonance, latency, and
distractions are real and as an industry we don't do a great job
minimizing these disruptions so focus and productivity can be
maximized. I'm not saying I would be a good product manager or
UI designer. But it's something I've thought about because not many
engineers seem to exhibit the passion for good user experience that
I do and that intersection of skills could be valuable.</p>
<p>My favorite time at Mozilla was when I was working on a unified
<em>engineering productivity</em> team. The team controlled most of the tools
and infrastructure that Firefox developers interacted with in order
to do their jobs. I absolutely loved taking a whole-world view of
that problem space and identifying the high-level problems - and
low-hanging fruit - to improve the overall Firefox development
experience. I derived a lot of satisfaction from identifying pain
points, equating them to a dollar cost by extrapolating people time
wasted due to them, justifying working on them, and finally
celebrating - along with the overall engineering team - when improvements
were made. I think I would be a tremendous asset to a company working
in this space. And if my experience at Mozilla is any indicator, I
would more than offset my total employment cost by doing this kind
of work.</p>
<p>I've been entertaining the idea of contracting for a while before
I resume full-time employment with a single employer. However, I've
never contracted before and need to do some homework before I commit
to that. (Please leave a comment or email me if you have recommendations
on reading material.)</p>
<p>My dream contract gig would likely be to finish the Mercurial wire
protocol and storage work I started last year. I would need to type
up a formal proposal, but the gist of it is the work I started has the
potential to leapfrog Git in terms of both client-side and server-side
performance and scalability. Mercurial would be able to open Git
repositories on the local filesystem as well as consume them via the
Git wire protocol. Transparent Git interoperability would enable
Mercurial to be used as a drop-in replacement for Git, which would
benefit users who don't have control over the server (such as projects
that live on GitHub). Mercurial's new wire protocol is designed with
global scalability and distribution in mind. The goal is to enable
server operators to deploy scalable VCS servers in a turn-key manner
by relying on scalable key-value stores and content distribution
networks as much as possible (Mercurial and Git today require servers
to perform way too much work and aren't designed with modern distributed
systems best practices, which is why scaling them is hard). The new
protocol is being designed such that a <em>Mercurial</em> server could expose
Git data. It would then be possible to teach a Git client to speak the
<em>Mercurial</em> wire protocol, which would result in Mercurial being a more
scalable Git server than Git is today. If my vision is achieved, this
would make server-side VCS scaling problems go away and would eliminate
the religious debate between Git and Mercurial (the answer would be
<em>deploy a Mercurial server, allow data to be exposed to Git, and let
consumers choose</em>). I conservatively estimate that the benefits to
industry would be in the millions of dollars. How I would structure
a contract to deliver aspects of this, I'm not sure. But if you are
willing to invest six figures towards this bet, let's talk. A good
foundation of this work is already implemented in Mercurial and the
Mercurial core development team is already on-board with many aspects
of the vision, so I'm not spewing vapor.</p>
<p>Another potential contract opportunity would be funding
<a href="https://gregoryszorc.com/blog/category/pyoxidizer/">PyOxidizer</a>.
I started the project a few months back as a side-project as an
excuse to learn Rust while solving a <em>fun</em> problem that I thought
needed solving. I was hoping for the project to be useful for
Mercurial and Mozilla one day. But if social media activity is any
indication, there seems to be somewhat widespread interest in this
project. I have no doubt that once complete, companies will be using
PyOxidizer to ship products that generate revenue and that PyOxidizer
will save them engineering resources. I'd very much like to recapture
some of that value into my pockets, if possible. Again, I'm somewhat
naive about how to write contracts since I've never contracted, but I
imagine <em>deliver a tool that allows me to ship product X as a
standalone binary to platforms Y and Z</em> is definitely something that
could be structured as a contract. </p>
<p>As for the timeline, I was at Mozilla for what feels like an eternity
in Silicon Valley. And Mozilla's way of working is substantially
different from many companies. I need some time to decompress and
unlearn some Mozilla habits. My future employer will inherit a happier
and more productive employee by allowing me to take some much-needed
time off.</p>
<p>I'm looking to resume full-time work no sooner than March 1. I'd like
to figure out what the next step in my career is by the end of January.
Then I can sign some papers, pack up my skiis, and become a ski bum
for the month of February: if I don't use this unemployment opportunity
to have at least 20 days on the slopes this season and visit some new
mountains, I will be very disappointed in myself!</p>
<p>If you want to get in touch, my contact info is in my
<a href="/resume.pdf">résumé</a>. I tend not to answer incoming calls from
unknown numbers, so email is preferred. But if you leave a voicemail,
I'll try to get back to you.</p>
<p>I look forward to working for a great engineering organization in the
near future!</p>]]></content>
  </entry>
</feed>
