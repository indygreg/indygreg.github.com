


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
Design by Free CSS Templates
http://www.freecsstemplates.org
Released for free under a Creative Commons Attribution 2.5 License

Name       : Pollinating  
Description: A two-column, fixed-width design with dark color scheme.
Version    : 1.0
Released   : 20101114

-->
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    
  <title>Gregory Szorc's Digital Home
  | On Algorithms and Interviewing
</title>
<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
<link rel="alternate" type="application/atom+xml" title="Atom 1.0"
href="/blog/feed/atom" />
<link rel="stylesheet" href="/style/style.css" type="text/css" />
<link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />


  </head>
  <body>
    <div id="wrapper">
      
  <div id="menu">
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="/blog/">Blog</a></li>
    <li><a href="/notes">Notes</a></li>
    <li><a href="/work.html">Work</a></li>
    <li><a href="/skills.html">Skills</a></li>
    <li><a href="/thoughts.html">Thoughts</a></li>
    <li><a href="/resume.pdf">Resume</a></li>
  </ul>
</div>


      <div id="page">
        <div id="page-bgtop">
          <div id="page-bgbtm">
              <div id="content">
                

<div class="blog_post">
  <a name="on-algorithms-and-interviewing"></a>
  <h2 class="blog_post_title"><a href="/blog/2019/01/17/on-algorithms-and-interviewing" rel="bookmark" title="Permanent Link to On Algorithms and Interviewing">On Algorithms and Interviewing</a></h2>
  <small>January 17, 2019 at 10:45 AM | categories: 

<a href='/blog/category/personal'>Personal</a>
 | <a href="http://gregoryszorc.com/blog/2019/01/17/on-algorithms-and-interviewing#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>As I write this, I'm hours away from starting to interview for full-time
jobs in the software field. I've spoken with a number of recruiters and
hiring managers and have received interview preparation materials from
a handful of companies, many of which you've probably heard of.</p>
<p>I was hoping things would have changed since I last seriously underwent
this endeavor ~7.5 years ago (I did interview periodically when I was at
Mozilla in order to test waters, keep my interview skills sharp, etc). But
it appears the industry is still generally fixated on algorithms and
data structures in interviews. <strong>The way algorithms and similar coding tricks
are emphasized in the preparation materials I've received, you'd think people
in software spend a major part of their work days thinking about and
implementing algorithms</strong>. But from my experience, this is very far from
the case! So why are so many companies and interviewers fixated on
algorithms. And is this a good thing?</p>
<p>When they matter, efficient algorithms, data structures, and other tricks
are important and useful skills to have. But from my experience, they
matter far less than you would think. If I were to make a list of important
job skills and traits for software and programming, memorized knowledge of
algorithms and data structures is so far down the list that I don't think I
would even ask about algorithms fundamentals for most job candidates! (In
fact I don't.) I think it is vastly more important to focus on behavioral
qualities and potential to actually think and apply knowledge rather than
regurgitate it. Algorithms and data structures, after all, are learned
knowledge. All other things be equal, I'd rather have someone who knows
when to ask for help with an algorithms issue or can pick up the skill
than a curmudgeon algorithms genius who has an abrasive personality and
clings to old habits.</p>
<p>In the spirit of full disclosure, I should to state that my algorithms skills
are relatively weak. You can accuse me of writing this post to fulfill my
own selfish interests. You wouldn't be wrong. But I know there are others
like me who are good at programming yet struggle with algorithms and question
the utility of algorithms in interviews. I'm attempting to write this post
for all of us. </p>
<p>I have failed job interviews because the interviewer assessed my algorithms
abilities as weak. I'm able to work through this <em>deficiency</em> with interviewers
who care more about the behavioral traits I exhibit when in such a situation (I
try to be quick about admitting my technical weaknesses and to ask for help
when needed). But some interviewers aren't as interested in the behavioral
traits or insist on a baseline level of memorized algorithms knowledge beyond
my own. I feel like my relative algorithms weakness hasn't hurt me <em>on</em> the
job, as I hardly find myself caring about algorithms in the work I do. In the
majority of cases, the choice of an algorithm just doesn't matter for the size
of the data set. Or a standard algorithm or data structure available in the
standard library of the language I'm using is <em>good enough</em>. In the cases where
I realize algorithms and data structures would matter, I run my
technical questions past someone with more knowledge in the domain than me. Or
if I don't do that, it often comes up during code review.
Without strong algorithms and data structures knowledge, I'm able to maintain
the Firefox build system, become a core contributor to a version control
tool (something you think would require a lot of heavy algorithms knowledge),
maintain various open source projects, diagnose and address low-level
performance issues in complex software and systems. <strong>About the only impact that
being weak in algorithms and data structures has had on my career is that some
companies passed on hiring me because they perceived strength in this area to
be important.</strong></p>
<p>Albert Einstein once said, <em>I never commit to memory anything that can
easily be looked up in a book.</em> A modern adaptation of that quote may
go something like, <em>never memorize how to implement an algorithm or data
structure when you can just Google it or use a software library
implementing it.</em> If you have knowledge of how to implement various algorithms
in your head, that's good for you, I suppose. But I think the <em>bigger brain</em>
knowledge to possess is <em>when</em> algorithms matter and to a lesser extent, what
types of algorithms are appropriate for particular problems. Answering these
problems requires critical thinking. Actually implementing algorithms, by
contrast, merely requires knowledge <em>that can easily be looked up in a book</em> (the
algorithm or data structure itself) coupled with some programming knowledge for
how to apply it. A capable programmer will be able to do both these things and
pick up algorithms and data structure knowledge on the job, if necessary.</p>
<p>Some would say that algorithms are a good way to flush out coding
ability. And coding ability is important to assess as part of interviewing
a job candidate for a programming position! They aren't wrong. But there
are much better ways to receive stronger signals about an interviewee's
compatibility! On the coding front, there are infinite ways to assess
programming capability without involving algorithms. So why involve
algorithms as part of the interview?</p>
<p>One way I approach interviewing people is to imagine what the typical
work day of that role will be like. How much time do they spend coding,
investigating bugs, debugging, attending meetings, writing proposals,
politicking with managers, etc. This produces a conceptual pie chart
of that role's activities. I then try to structure the interview such
that the topics covered in the interview correlate with and somewhat
in proportion to activities in that job role. Is the role a heads down
junior coder? A team lead or manager? When you start trying to map the
time in various areas of the role to time spent in the interview, you
realize that the common technical interview overly emphasizes some areas
and often completely ignores others! One of the areas that is
over-emphasizes is algorithms. <strong>Again, your typical programmer is going
to be spending most of their typical day doing things unrelated to
algorithms. So why are you spending precious interview time asking about
algorithms when you could be probing an area that actually correlates
to typical job activities?</strong> When viewed through this lens, the prevalence
of algorithms in interviews just doesn't make much sense to me.</p>
<p>Perhaps knowledge of algorithms should be basic knowledge that every
programmer should possess. If so, then asking about algorithms is fair
game during an interview, I suppose. But I'm not comfortable with this
line of thought.</p>
<p>I've always found it fascinating the ways that people with different
backgrounds and degrees approach problems differently. From my experience,
some of the best ideas and perspectives come from people with backgrounds
and degrees which are minorities in the field. I've worked with
programmers with degrees in philosophy and history who were some of the
best programmers and overall minds in the room. One of the great things
about software and programming is it is accessible to anyone, regardless
of background. If you can code, you can land a (usually high-paying) job.
Yes, the field is highly technical. But you don't need formal education
or a degree to enter it like you do similar <em>high-end</em> professions, such
as medicine or law. You can argue whether this is a good thing or not. But
I think the accessibility of the software profession - the lack of formal
gatekeeping - is something to marvel at, something that we as an industry
should embrace and be proud of. Do arbitrary hurdles to joining the
industry help or hinder it?</p>
<p>A problem with emphasizing algorithms in interviews is that algorithms
are somewhat highly specialized and academic. There are entire areas of
programming and software where detailed knowledge of algorithms just
isn't that important. <strong>The bar for so much software is <em>it works</em> and it
quite frankly doesn't matter if you have a quadratic algorithm instead of
something better.</strong></p>
<p>Most people I know are exposed to algorithms fundamentals during their
university education as part of pursuing a degree in
computer science or engineering. You almost certainly aren't going to
have academic exposure to algorithms if you are say a liberal arts
major - never mind someone who doesn't attend university at all (I also
know plenty of terrific programmers who don't have degrees). From my
own experience, my degree is in computer engineering. Not computer
science or software engineering: computer engineering. I remember from
my university days that my computer science friends seemed to have a much
better grasp at algorithms and theory of software and programming
than I did. When I was taking classes about how hardware and electronics
work, they were learning all about the mathematical concepts underpinning
the field, different approaches to programming language design, etc. I
received very little of that. And on top of that, I struggled with my
single algorithms course at university. So I entered the workforce without
as good of a grasp on the computer science fundamentals as others I knew.
(But I still probably knew more than someone in an unrelated field.)
The point I'm trying to make is that because algorithms are somewhat highly
specialized and academic in nature, requiring knowledge in algorithms
will effectively bias your hiring towards people with strong computer
science backgrounds. Stated another way, <strong>screening on algorithms knowledge
undermines diversity and inclusion initiatives by excluding viable
candidates who don't have strong backgrounds in computer science.</strong>
Sure, if someone wants to enter the industry they can take the time to
study up on algorithms. But why force them to do that? It feels like
arbitrary gatekeeping given the relative non-importance of algorithms
given the typical activities of the typical programmer. So why do it?</p>
<p>I suspect major contributing reasons to why algorithms are so prevalent
in interviews are cargo culting, laziness, and lack of formal interview
training / caring about diversity. As an industry, the software
field is pretty bad at applying best practices and learning from our
mistakes. I suspect this will change once the relatively young
industry catches up to more-established industries and we're forced to
cope with the realities of legal and monetary liabilities the way
practically every other industry is. (We're starting to see this with
monetary damages for security breaches.) Anyway, we as an industry are pretty
bad at self-regulating and adopting practices with proven benefits. We
like to settle for what is known. Laziness and the comfort associated with
is easy. Seeking out and implementing change is harder. This is human
nature. We see this with well-known people in industry rejecting the
ideas of continuous testing (years ago) or fuzzing (more recently). We see
it in C/C++ programmers who are delusional about their abilities to write
secure code and decry e.g. Rust's safety guarantees as superfluous. The
industry is disproportionately white and male (at least in the United
States). And this brings with it certain personality tendencies. One is a
<em>macho</em> attitude, which can manifest in interviews via the interviewer
embarking on an ego trip proving they know some esoteric algorithm or
data structure the candidate does not. </p>
<p>As a clear example of this, Google was known for asking <em>brainteaser</em>
interview questions. (The practice may have been prevalent at Microsoft
before Google was the darling of Silicon Valley, but that was before I
entered industry.) This <em>trend</em> caught on and soon companies all over were
asking brainteasers! The problem was that these questions
<a href="https://www.newyorker.com/tech/annals-of-technology/why-brainteasers-dont-belong-in-job-interviews">didn't correlate to actual job performance</a>!
From a <a href="https://www.nytimes.com/2013/06/20/business/in-head-hunting-big-data-may-not-be-such-a-big-deal.html?pagewanted=all">2013 NYTimes interview with Google's VP of People Operations</a>:</p>
<pre><code>On the hiring side, we found that brainteasers are a complete waste of
time. How many golf balls can you fit into an airplane? How many gas
stations in Manhattan? A complete waste of time. They don’t predict
anything. They serve primarily to make the interviewer feel smart.
</code></pre>
<p>But the damage was done. I still heard these kinds of questions when
interviewing in the wild long after Google realized they were bad
questions and instructed interviewers not to ask them. I even believe I
got a brainteaser when interviewing at Google after the supposed
banning of these types of questions! And I won't be shocked if I'm
asked a brainteaser in 2019 as part of the several interviews I'll
be doing in the days ahead.</p>
<p>Asking questions with no correlation to job performance because a
popular company asked that type of question for a while: that's
textbook cargo culting. Failing to change your ways despite evidence
saying you should: laziness. Insisting that your way is correct and
others need to be like you: gatekeeping.</p>
<p>I'm not saying algorithms and data structures during interviews are
intrinsically bad and that we should stop asking about them. What I am
saying is that we as an industry need to examine how we interview. We need
to invest in scientifically proven techniques. (Research shows that
behavioral interview questions are <em>better</em>. <em>Tell me about a
time when</em>, etc.) And after more than ten years in industry, my experience
tells me that interviews place a disproportionate emphasis on algorithms
and data structures compared to the daily activities of the typical
programmer. And on top of that, due to their academic nature, I worry
that screening for algorithms and data structures knowledge is undermining
the diversity and inclusivity of our field by biasing towards people
with strong computer science backgrounds. I think it is time we
examine the role of algorithms and data structures in interviews and
consider focusing on other areas instead.</p>

  </div>
</div>



<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_url = "http://gregoryszorc.com/blog/2019/01/17/on-algorithms-and-interviewing";
</script>
<script type="text/javascript" src="https://disqus.com/forums/gregoryszorc/embed.js"></script>
<noscript><a href="https://gregoryszorc.disqus.com/?url=ref">View the discussion thread.</a></noscript><a href="https://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

              </div>
              
          <div id="sidebar">
          <ul>
            <li>
              <h2>Categories</h2>
              <ul>
                <li><a href="/blog/category/apple">Apple</a></li>
                <li><a href="/blog/category/bugzilla">Bugzilla</a></li>
                <li><a href="/blog/category/clang">Clang</a></li>
                <li><a href="/blog/category/docker">Docker</a></li>
                <li><a href="/blog/category/firefox">Firefox</a></li>
                <li><a href="/blog/category/git">Git</a></li>
                <li><a href="/blog/category/javascript">JavaScript</a></li>
                <li><a href="/blog/category/mercurial">Mercurial</a></li>
                <li><a href="/blog/category/mozreview">MozReview</a></li>
                <li><a href="/blog/category/mozilla">Mozilla</a></li>
                <li><a href="/blog/category/personal">Personal</a></li>
                <li><a href="/blog/category/puppet">Puppet</a></li>
                <li><a href="/blog/category/pyoxidizer">PyOxidizer</a></li>
                <li><a href="/blog/category/python">Python</a></li>
                <li><a href="/blog/category/review-board">Review Board</a></li>
                <li><a href="/blog/category/rust">Rust</a></li>
                <li><a href="/blog/category/sync">Sync</a></li>
                <li><a href="/blog/category/browsers">browsers</a></li>
                <li><a href="/blog/category/build-system">build system</a></li>
                <li><a href="/blog/category/code-review">code review</a></li>
                <li><a href="/blog/category/compilers">compilers</a></li>
                <li><a href="/blog/category/internet">internet</a></li>
                <li><a href="/blog/category/logging">logging</a></li>
                <li><a href="/blog/category/mach">mach</a></li>
                <li><a href="/blog/category/make">make</a></li>
                <li><a href="/blog/category/misc">misc</a></li>
                <li><a href="/blog/category/movies">movies</a></li>
                <li><a href="/blog/category/pymake">pymake</a></li>
                <li><a href="/blog/category/security">security</a></li>
                <li><a href="/blog/category/sysadmin">sysadmin</a></li>
                <li><a href="/blog/category/testing">testing</a></li>
              </ul>
            </li>
          </ul>
        </div>



              <div style="clear: both;">&nbsp;</div>
          </div>
        </div>
      </div>
      <div id="footer">
        
  <hr/>
  <p>Copyright (c) 2012- Gregory Szorc. All rights reserved. Design by <a href="http://www.freecsstemplates.org/"> CSS Templates</a>.</p>


      </div>
    </div>
  </body>
</html>





