


<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!--
Design by Free CSS Templates
http://www.freecsstemplates.org
Released for free under a Creative Commons Attribution 2.5 License

Name       : Pollinating  
Description: A two-column, fixed-width design with dark color scheme.
Version    : 1.0
Released   : 20101114

-->
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    
  <title>Gregory Szorc's Digital Home
  | End to End Testing with Docker
</title>
<link rel="alternate" type="application/rss+xml" title="RSS 2.0" href="/blog/feed" />
<link rel="alternate" type="application/atom+xml" title="Atom 1.0"
href="/blog/feed/atom" />
<link rel="stylesheet" href="/style/style.css" type="text/css" />
<link rel="stylesheet" href="/css/pygments_murphy.css" type="text/css" />


  </head>
  <body>
    <div id="wrapper">
      
  <div id="menu">
  <ul>
    <li><a href="/">Home</a></li>
    <li><a href="/blog/">Blog</a></li>
    <li><a href="/notes">Notes</a></li>
    <li><a href="/work.html">Work</a></li>
    <li><a href="/skills.html">Skills</a></li>
    <li><a href="/thoughts.html">Thoughts</a></li>
    <li><a href="/resume.pdf">Resume</a></li>
  </ul>
</div>


      <div id="page">
        <div id="page-bgtop">
          <div id="page-bgbtm">
              <div id="content">
                

<div class="blog_post">
  <a name="end-to-end-testing-with-docker"></a>
  <h2 class="blog_post_title"><a href="/blog/2015/01/24/end-to-end-testing-with-docker" rel="bookmark" title="Permanent Link to End to End Testing with Docker">End to End Testing with Docker</a></h2>
  <small>January 24, 2015 at 11:10 PM | categories: 

<a href='/blog/category/docker'>Docker</a>, <a href='/blog/category/mozilla'>Mozilla</a>, <a href='/blog/category/testing'>testing</a>
 | <a href="http://gregoryszorc.com/blog/2015/01/24/end-to-end-testing-with-docker#disqus_thread">View Comments</a>
</small><p/>
  <div class="post_prose">
    
  <p>I've written an extensive testing <em>framework</em> for Mozilla's
<a href="https://mozilla-version-control-tools.readthedocs.org/">version control tools</a>.
Despite it being a little rough around the edges, I'm a bit proud of it.</p>
<p>When you run tests for MozReview, Mozilla's heavily modified
<a href="https://www.reviewboard.org/">Review Board</a> code review tool, the
following things happen:</p>
<ul>
<li>A MySQL server is started in a Docker container.</li>
<li>A Bugzilla server (running the same code as
  <a href="https://bugzilla.mozilla.org/">bugzilla.mozilla.org</a>) is started on
  an Apache httpd server with mod_perl inside a Docker container.</li>
<li>A RabbitMQ server mimicking
  <a href="https://pulse.mozilla.org/">pulse.mozilla.org</a> is started in a Docker
  container.</li>
<li>A Review Board Django development server is started.</li>
<li>A Mercurial HTTP server is started</li>
</ul>
<p>In the future, we'll likely also need to add support for various other
services to support MozReview and other components of version control
tools:</p>
<ul>
<li>The Autoland HTTP service will be started in a Docker container, along
  with any other requirements it may have.</li>
<li>An IRC server will be started in a Docker container.</li>
<li>Zookeeper and Kafka will be started on multiple Docker containers</li>
</ul>
<p>The entire setup is pretty cool. You have actual services running on
your local machine. Mike Conley and Steven MacLeod even did some pair
coding of MozReview while on a plane last week. I think it's pretty cool
this is even possible.</p>
<p>There is very little mocking in the tests. If we need an external
service, we try to spin up an instance inside a local container.
This way, we can't have unexpected test successes or failures due to
bugs in mocking. We have very high confidence that if something works
against local containers, it will work in production.</p>
<p>I currently have each test file owning its own set of Docker
containers and processes. This way, we get full test isolation and can
run tests concurrently without race conditions. This drastically reduces
overall test execution time and makes individual tests easier to reason
about.</p>
<p>As cool as the test setup is, there's a bunch I wish were better.</p>
<p>Spinning up and shutting down all those containers and processes takes a
lot of time. We're currently sitting around 8s startup time and 2s
shutdown time. 10s overhead per test is unacceptable. When I make a one
line change, I want the tests to be instantenous. 10s is too long for
me to sit idly by. Unfortunately, I've already gone to great pains to
make test overhead as short as possible.
<a href="http://www.fig.sh/">Fig</a> wasn't good enough for me for various reasons.
I've reimplemented my own orchestration directly on top of the
<a href="https://docker-py.readthedocs.org/en/latest/">docker-py package</a> to
achieve some significant performance wins. Using
<a href="http://pythonhosted.org//futures/">concurrent.futures</a> to perform
operations against multiple containers concurrently was a big win.
<em>Bootstrapping</em> containers (running their first-run entrypoint scripts
and committing the result to be used later by tests) was a bigger win
(first run of Bugzilla is 20-25 seconds).</p>
<p>I'm at the point of optimizing startup where the longest pole is the
initialization of the services inside Docker containers themselves.
MySQL takes a few seconds to start accepting connections. Apache +
Bugzilla has a semi-involved initialization process. RabbitMQ takes
about 4 seconds to initialize. There are some cascading dependencies in
there, so the majority of startup time is waiting for processes to
finish their startup routine.</p>
<p>Another concern with running all these containers is memory usage. When
you start running 6+ instances of MySQL + Apache, RabbitMQ, + ..., it
becomes really easy to exhaust system memory, incur swapping, and have
performance fall off a cliff. I've spent a non-trivial amount of time
figuring out the minimal amount of memory I can make services consume
while still not sacrificing too much performance.</p>
<p>It is quite an experience having the problem of trying to minimize
resource usage and startup time for various applications. Searching the
internet will happily give you recommended settings for applications.
You can find out how to make a service start in 10s instead of 60s or
consume 100 MB of RSS instead of 1 GB. But what the internet won't tell
you is how to make the service start in 2s instead of 3s or consume as
little memory as possible. I reckon I'm past the point of diminishing
returns where most people don't care about any further performance wins.
But, because of how I'm using containers for end-to-end testing and I
have a surplus of short-lived containers, it is clearly I problem I need
to solve.</p>
<p>I might be able to squeeze out a few more seconds of reduction by
further optimizing startup and shutdown. But, I doubt I'll reduce things
below 5s. If you ask me, that's still not good enough. I want no more
than 2s overhead per test. And I don't think I'm going to get that
unless I start utilizing containers across multiple tests. And I really
don't want to do that because it sacrifices test purity. Engineering is
full of trade-offs.</p>
<p>Another takeaway from implementing this test harness is that the
pre-built Docker images available from the Docker Registry almost always
become useless. I eventually make a customization that can't be
shoehorned into the readily-available image and I find myself having
to reinvent the wheel. I'm not a fan of the <em>download and run a binary</em>
model, especially given Docker's less-than-stellar history on the
security and cryptography fronts (I'll trust Linux distributions to get
package distribution right, but I'm not going to be trusting the Docker
Registry quite yet), so it's not a huge loss. I'm at the point where
I've lost faith in Docker Registry images and my default position is to
implement my own builder. Containers are supposed to do one thing, so
it usually isn't that difficult to roll my own images.</p>
<p>There's a lot to love about Docker and containerized test execution. But
I feel like I'm foraging into new territory and solving problems
like startup time minimization that I shouldn't really have to be
solving. I think I can justify it given the increased accuracy from the
tests and the increased confidence that brings. I just wish the cost
weren't so high. Hopefully as others start leaning on containers and
Docker more for test execution, people start figuring out how to make
some of these problems disappear.</p>

  </div>
</div>



<div id="disqus_thread"></div>
<script type="text/javascript">
  var disqus_url = "http://gregoryszorc.com/blog/2015/01/24/end-to-end-testing-with-docker";
</script>
<script type="text/javascript" src="https://disqus.com/forums/gregoryszorc/embed.js"></script>
<noscript><a href="https://gregoryszorc.disqus.com/?url=ref">View the discussion thread.</a></noscript><a href="https://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>

              </div>
              
          <div id="sidebar">
          <ul>
            <li>
              <h2>Categories</h2>
              <ul>
                <li><a href="/blog/category/apple">Apple</a></li>
                <li><a href="/blog/category/bugzilla">Bugzilla</a></li>
                <li><a href="/blog/category/clang">Clang</a></li>
                <li><a href="/blog/category/docker">Docker</a></li>
                <li><a href="/blog/category/firefox">Firefox</a></li>
                <li><a href="/blog/category/git">Git</a></li>
                <li><a href="/blog/category/javascript">JavaScript</a></li>
                <li><a href="/blog/category/mercurial">Mercurial</a></li>
                <li><a href="/blog/category/mozreview">MozReview</a></li>
                <li><a href="/blog/category/mozilla">Mozilla</a></li>
                <li><a href="/blog/category/personal">Personal</a></li>
                <li><a href="/blog/category/puppet">Puppet</a></li>
                <li><a href="/blog/category/pyoxidizer">PyOxidizer</a></li>
                <li><a href="/blog/category/python">Python</a></li>
                <li><a href="/blog/category/review-board">Review Board</a></li>
                <li><a href="/blog/category/rust">Rust</a></li>
                <li><a href="/blog/category/sync">Sync</a></li>
                <li><a href="/blog/category/browsers">browsers</a></li>
                <li><a href="/blog/category/build-system">build system</a></li>
                <li><a href="/blog/category/code-review">code review</a></li>
                <li><a href="/blog/category/compilers">compilers</a></li>
                <li><a href="/blog/category/internet">internet</a></li>
                <li><a href="/blog/category/logging">logging</a></li>
                <li><a href="/blog/category/mach">mach</a></li>
                <li><a href="/blog/category/make">make</a></li>
                <li><a href="/blog/category/misc">misc</a></li>
                <li><a href="/blog/category/movies">movies</a></li>
                <li><a href="/blog/category/pymake">pymake</a></li>
                <li><a href="/blog/category/security">security</a></li>
                <li><a href="/blog/category/sysadmin">sysadmin</a></li>
                <li><a href="/blog/category/testing">testing</a></li>
              </ul>
            </li>
          </ul>
        </div>



              <div style="clear: both;">&nbsp;</div>
          </div>
        </div>
      </div>
      <div id="footer">
        
  <hr/>
  <p>Copyright (c) 2012- Gregory Szorc. All rights reserved. Design by <a href="http://www.freecsstemplates.org/"> CSS Templates</a>.</p>


      </div>
    </div>
  </body>
</html>





