<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>Gregory Szorc's Digital Home</title>
    <link>http://gregoryszorc.com/blog</link>
    <description>Rambling on</description>
    <pubDate>Wed, 14 Apr 2021 20:49:45 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Pure Rust Implementation of Apple Code Signing</title>
      <link>http://gregoryszorc.com/blog/2021/04/14/pure-rust-implementation-of-apple-code-signing</link>
      <pubDate>Wed, 14 Apr 2021 13:45:00 PDT</pubDate>
      <category><![CDATA[PyOxidizer]]></category>
      <category><![CDATA[Rust]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2021/04/14/pure-rust-implementation-of-apple-code-signing</guid>
      <description>Pure Rust Implementation of Apple Code Signing</description>
      <content:encoded><![CDATA[<p>A few weeks ago I (foolishly?) set out to implement Apple code signing
(what Apple's <code>codesign</code> tool does) in pure Rust.</p>
<p>I wanted to quickly announce on this blog the existence of the project and
the news that as of a few minutes ago, the <code>tugger-apple-codesign</code> crate
implementing the code signing functionality is now
<a href="https://crates.io/crates/tugger-apple-codesign">published on crates.io</a>!</p>
<p>So, you can now sign Apple binaries and bundles on non-Apple hardware by
doing something like this:</p>
<pre><code>$ cargo install tugger-apple-codesign
$ rcodesign sign /path/to/input /path/to/output
</code></pre>
<p>Current features include:</p>
<ul>
<li>Robust support for parsing embedded signatures and most related data
  structures. <code>rcodesign extract</code> can be used to extract various signature
  data in raw or human readable form.</li>
<li>Parse and verify RFC 5652 Cryptographic Message Syntax (CMS) signature
  data.</li>
<li>Sign binaries. If a code signing certificate key pair is provided,
  a CMS signature will be created. This includes support for Time-Stamp Protocol
  (TSP) / RFC 3161 tokens. If no key pair is provided, you get an ad-hoc
  signature.</li>
<li>Signing bundles. Nested bundles and binaries will automatically be signed.
  Non-code resources will be digested and a <code>CodeResources</code> XML file will be
  produced.</li>
</ul>
<p>The most notable missing features are:</p>
<ul>
<li>No support for obtaining signing keys from keychains. If you want to sign
  with a cryptographic key pair, you'll need to point the tool at a PEM encoded
  key pair and CA chain.</li>
<li>No support for parsing the Code Signing Requirements language. We can parse the
  binary encoding produced by <code>csreq -b</code> and convert it back to this DSL. But we
  don't parse the human friendly language.</li>
<li>No support for notarization.</li>
</ul>
<p>All of these could likely be implemented. However, I am not actively working on
any of these features. If you would like to contribute support, make noise in
the <a href="https://github.com/indygreg/PyOxidizer/issues">GitHub issue tracker</a>.</p>
<p>The Rust API, CLI, and documentation are still a bit rough around the edges. I
haven't performed thorough QA on aspects of the functionality. However, the
tool is able to produce signed binaries that Apple's canonical <code>codesign</code> tool
says are well-formed. So I'm reasonably confident some of the functionality
works as intended. If you find bugs or missing features, please
<a href="https://github.com/indygreg/PyOxidizer/issues">report them on GitHub</a>. Or even
better: submit pull requests!</p>
<p>As part of this project, I also created and published the
<a href="https://crates.io/crates/cryptographic-message-syntax">cryptographic-message-syntax</a>
crate, which is a pure Rust partial implementation of RFC 5652, which defines
the cryptographic message signing mechanism. This RFC is a bit dated and seems
to have been superseded by RPKI. So you may want to look elsewhere before
inventing new signing mechanisms that use this format.</p>
<p>Finally, it appears the Windows code signing mechanism (Authenticode) also uses
RFC 5652 (or a variant thereof) for cryptographic signatures. So by implementing
Apple code signatures, I believe I've done most of the legwork to implement
Windows/PE signing! I'll probably implement Windows signing in a new crate whenever
I hook up automatic code signing to PyOxidizer, which was the impetus for this work
(I want to make it possible to build distributable Apple programs without Apple
hardware, using as many open source Rust components as possible).</p>]]></content:encoded>
    </item>
    <item>
      <title>Rust is for Professionals</title>
      <link>http://gregoryszorc.com/blog/2021/04/13/rust-is-for-professionals</link>
      <pubDate>Tue, 13 Apr 2021 08:20:00 PDT</pubDate>
      <category><![CDATA[Programming]]></category>
      <category><![CDATA[Rust]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2021/04/13/rust-is-for-professionals</guid>
      <description>Rust is for Professionals</description>
      <content:encoded><![CDATA[<p>A professional programmer delivers value through the authoring and maintaining
of software that solves problems. (There are other important ways for
professional programmers to deliver value but this post is about
programming.)</p>
<p>Programmers rely on various tools to author software. Arguably the most
important and consequential choice of tool is the programming language.</p>
<p>In this post, I will articulate why I believe Rust is a highly compelling
choice of a programming language for software professionals. I will state
my case that Rust disposes software to a lower defect rate, reduces total
development and deployment costs, and is exceptionally satisfying to use.
In short, I hope to convince you to learn and deploy Rust.</p>
<h2>My Background and Disclaimers</h2>
<p>Before I go too far, I'm targeting this post towards <em>professional programmers</em> -
people who program (or support programming through roles like management) as
their primary line of work or who spend sufficient time programming outside of
work. I consider myself a <em>professional programmer</em> both because I am a full-time
engineer in the software industry and because I contribute to some significant
open source projects outside of my day job.</p>
<p>The statement <em>Rust is for Professionals</em> does not imply any logical variant
thereof. e.g. I am not implying <em>Rust is not for non-professionals</em>. Rather,
the subject/thesis merely defines the audience I want to speak to: people who
spend a lot of time authoring, maintaining, and supporting software and are
invested in its longer-term outcomes.</p>
<p>I think opinion pieces about programming languages benefit from knowing
the author's experience with programming. I first started hacking on code in
the late 1990's. I've been a full-time software developer since 2007 after
graduating with a degree in Computer Engineering (after an aborted attempt
at Biomedical Engineering - hence my affinities for hardware and biological
sciences). I've programmed in the following languages: C, C++ (only until
C++11), C#, Erlang, Go, JavaScript, Java, Lua, Perl, PHP, Python, Ruby,
Rust, shell, SQL, and Verilog. Notably missing from this list is a Lisp and
a Haskell/Scala type language. Of these languages, I've spent the most time
with C, C#, JavaScript, Perl, PHP, Python, and Rust.</p>
<p>I'm not that strong in computer science or language theory: many colleagues
can talk circles around me when it comes to describing computer science
and programming language concepts like algorithms, type theory, and common terms
used to describe languages. (I have failed many technical interviews because of
my limitations here.) In contrast, I perceive my technical strengths as applying
an engineering rigor and practicality to problem solving. I care vastly more
about how/why things work the way they do and the practical consequences of
decisions/choices we make when it comes to software. I find that I tend to
think about 2nd and 3rd order effects and broader or longer-term consequences
more often than others. Some would call this <em>systems engineering</em>.</p>
<p>I've programmed all kinds of different software. Backend web services,
desktop applications, web sites, Firefox browser internals, the Mercurial
version control tool, build systems, system/machine management. Notably missing
are mobile programming (e.g. iOS/Android) and serious embedded systems (I've
hacked around with Raspberry Pis and Arduinos, but those seem very friendly
compared to other embedded devices). My strongest affinity is probably towards
<em>systems software</em> and general purpose tools: I enjoy building software that
other people use to build things. <em>Infrastructure</em> if you will.</p>
<p>Finally, I am expressing my personal opinion in this post. I do not speak for
any employer, present or former. While I would love to see more Rust at my
current employer, this post is not an attempt to influence what happens behind
my employer's walls: there a better ways to conduct successful
<a href="https://en.wikipedia.org/wiki/Nemawashi">nemawashi / 根回し</a> than a public
blog post. I am not affiliated with the Rust Project in any capacity
beyond a very infrequent code contributor and issue filer: I view myself as a
normal Rust user. I did work at Mozilla - the company who bankrolled most of
Rust's initial development. I even briefly worked in the same small Vancouver
office as Graydon Hoare, Rust's primary credited inventor! While I was keen for
Rust to succeed because it was affiliated with my then employer, I was most
definitely not a Rust evangelist or fan boy while at Mozilla. I have little
to personally benefit from this post: I'm writing it because I enjoy writing
and I believe the message is important.</p>
<p>With that out of the way, let's talk about Rust!</p>
<h2>Rust Makes Me Irrationally Giddy</h2>
<p>When I look back at my professional self when I was in my 20s, I feel like I was
young and dumb and overly exuberant about computers, technology, new software, and
the like. An older, more grizzled professional, I now accept the reality that it is
a miracle computers and software work as well as they do as often as they do. Point
at any common task on a computer and an iceberg of complexity and nuance lingers
under the surface. Our industry is abound in the repetition of proven sub-optimal
ideas. You see practices cargo culted across the decades (like the
<a href="http://exple.tive.org/blarg/2019/10/23/80x25/">80 character terminal/line width</a> and
<a href="http://exple.tive.org/blarg/2020/11/26/punching-holes/">null-terminated strings</a>,
which can both be traced back to Hollerith punchcards from the late 19th century).
You witness cycles of pendulum swings, the same fads and trends, just with different
labels (microservices are the new SOA, YAML is the new XML, etc). I can definitely
relate to people in this industry who want to drop everything and move to a farm or
something (but I grew up in Indiana and had cows living down the street, so I
know this lifestyle isn't for me).</p>
<p><strong>Rust is the first programming language I've encountered in years that makes
me excited. And not just normal excited: irrationally excited. Like the kind
of excitement you have for something when you are naive about its limitations
and don't know any better (like many blockchain/cryptocurrency advocates). I
feel like the discovery of Rust is transporting me back to my younger self,
before I discovered the ugly realities of how computers and software work, and
is giving me hope that better tools, better ways of building software could
actually exist. To channel my inner Marie Kondo: Rust sparks joy.</strong></p>
<p>When I started learning Rust in earnest in 2018, I thought this was a fluke. <em>It
is just the butterflies you get when you think you fall in love,</em> I told myself.
<em>Give it time: your irrational excitement will fade.</em> But after using Rust for
~2.5 years now, my positive feelings about it have only grown <em>stronger</em>. There's
a reason Rust has
<a href="https://insights.stackoverflow.com/survey/2020#technology-most-loved-dreaded-and-wanted-languages-loved">claimed the top spot in Stack Overflow's most loved languages survey</a>
for 5 years and running. And not by the skin of its teeth: Rust is blowing
the competition out of the water. 19% over TypeScript and Python. 23% over Kotlin
and Go. If this were a Forrester report for a company-offered product, Rust
would be the <em>clear market leader</em> and marketers and salespeople would be using
this result to sign up new customers in droves and print money hand over fist.</p>
<p>Let me tell you why Rust excites me.</p>
<h2>Rust is Different (In a Good Way)</h2>
<p>After you've learned enough programming languages, you start to see common
patterns. Manual versus garbage collected memory management. Control flow
primitives like <code>if</code>, <code>else</code>, <code>do</code>, <code>while</code>, <code>for</code>, <code>unless</code>. Nullable types.
Variable declaration syntax. The list goes on.</p>
<p>To me, Rust introduced a number of new concepts, like <code>match</code> for control
flow, enums as algebraic types, the borrow checker, the <code>Option</code> and <code>Result</code>
types/enums and more. There were also behaviors of Rust that were different
from languages I knew: variables are immutable by default, <code>Result</code> types
must be checked they aren't an error to avoid a compiler warning, refusing
to compile if there are detectable memory access issues, and tons more.</p>
<p>Many of the new concepts weren't novel to Rust. But considering I've had exposure
to many popular programming languages, the fact many were new to me means these
aren't common features in <em>mainstream</em> languages. <strong>Learning Rust felt like fresh
air to me: here was a language designed to be general purpose and make inroads into
industry adoption while also willing to buck many of the trends of conventional
language design from the last several decades.</strong></p>
<p>When going against conventional practice, it is very easy to unintentionally
alienate yourself from potential users. Design a programming language too unlike
anything in common use and you are going to have a difficult time attracting
users. This is a problem with many <em>academic</em>/<em>opinionated</em> programming
languages (or so I hear). Rust does venture away from the tried and popular.
And that does contribute to a steeper learning curve. However, there is enough
familiarity in Rust's core language to give you a foothold when learning Rust.
(And Rust's <a href="https://www.rust-lang.org/learn">official learning resources</a> are
terrific.)</p>
<p>I feel like Rust's language designers set out to take a first principles
approach to the language using modern ideas and ignoring old, disproven ones,
realized they needed to ground the language in familiarity to achieve market
penetration, and produced reasonable compromises to yield something that was
new and novel but familiar enough to not completely alienate its large
potential user base.</p>
<p>If you don't like being exposed to new ideas and ways of working, Rust's
approach is probably a negative to you. But if you are like me and enjoy
continuously expanding your knowledge and testing new ideas, Rust's
novelty and willingness to <em>be different</em> is a much welcomed attribute.</p>
<h2>Rust: Toolbox Included</h2>
<p>It used to be that programming languages were just compilers or interpreters.
In recent years, we've seen more and more programming languages bundled
with other tools, such as build/packaging tools, code formatters, linters,
documentation generators, language servers, centralized package repositories,
and more.</p>
<p>I'm not sure what spurred this trend (maybe it was Go?), but I think it is
a good move. Programming languages are ecosystems and the compiler/interpreter
is just one part of a complex system. If you care about end-user experience
and adoption (especially if you are a new language), you want an as turnkey
on-boarding experience as possible. I think that's easier to pull off when
you offer a cohesive, multi-tool strategy to attract and retain users.</p>
<p>We refer to programming languages with a comprehensive standard library as
<em>batteries included</em>. I'm going to refer to programming languages with
additional included tools beyond the compiler/interpreter as <em>toolbox
included</em>.</p>
<p><strong>Rust, is very much a <em>toolbox included</em> language.</strong> (Unless you are installing
it via your Linux distribution: in that case Linux packagers have likely
unbundled all the tools into separate packages, making the experience a bit
more end-user hostile, as Linux packagers tend to do for reasons that
merit their own blog post. If you want to experience Rust the way its
maintainers intended - the <em>Director's Cut</em> if you will - install Rust via
<a href="https://rustup.rs/">rustup</a>.)</p>
<p>In addition to the Rust compiler (<code>rustc</code>) and the Rust standard library,
the following components are all officially developed and offered as part
of the Rust programming language <a href="https://github.com/rust-lang">on GitHub</a>:</p>
<ul>
<li>Cargo - Rust's package manager and build system.</li>
<li>Clippy - A Rust linter.</li>
<li><a href="https://doc.rust-lang.org/rustdoc/what-is-rustdoc.html">rustdoc</a> -
  Documentation generator for Rust projects.</li>
<li>rustfmt - A Rust code formatter.</li>
<li>rls - A Rust <a href="https://langserver.org/">Language Server Protocol</a> implementation.</li>
<li><a href="https://crates.io/">crates.io</a> - Rust's official, public package registry.</li>
<li>rustup - Previously mentioned Rust installer.</li>
<li><a href="https://github.com/rust-lang/vscode-rust">vscode-rust</a> - Visual Studio Code
  extension adding support for Rust. (JetBrains has their own high quality
  extension for their IDEs, which they develop themselves.)</li>
<li><a href="https://github.com/rust-lang/book">The Rust Programming Language</a> Book</li>
<li>And many more.</li>
</ul>
<p>As an end-user, having all these tools and resources at my fingertips,
maintained by the official Rust project is an absolute joy.</p>
<p>For the local tools, <code>rustup</code> ensures they are upgraded as a group, so I don't
have to worry about managing them. I periodically run <code>rustup update</code> to
ensure my Rust <em>toolbox</em> is up-to-date and that's all I have to do.</p>
<p>Contrast with say Node.js, <a href="https://xkcd.com/1987/">Python</a>, and Ruby, where
the package manager is on a separate release cadence from the core language
and I have to think about managing multiple tools. (Rust will likely have
to cross this bridge once there are multiple implementations of Rust or
multiple popular package managers. But until then, things are very simple.)</p>
<p>Further contrast with languages like JavaScript/Node.js, Python, and Ruby,
where tools like a code formatter, linter, and documentation generator
aren't always developed under the core project umbrella. As an end-user,
you have to know to seek out these additional value-add tools. Furthermore,
you have to know which ones to use and how to configure them. The
fragmentation also tends to yield varying levels of quality and end-user
experience, to the detriment of end-users. The Rust toolbox, by contrast,
feels simple and polished.</p>
<p><strong>Rust's <em>toolbox included</em> approach enables me to follow unified practices
(arguably best practices) while expending minimal effort.</strong> As a result,
the following tend to be very similar across nearly every Rust project you'll
run into:</p>
<ul>
<li>Code formatting. (Nearly everyone uses <code>rustfmt</code>.)</li>
<li>Adherence to common coding and style conventions. (Nearly everyone uses
  <code>clippy</code>.)</li>
<li>Project documentation. (Nearly everyone uses <code>rustdoc</code>.)</li>
</ul>
<p>Cargo could warrant its own dedicated section. But I'll briefly touch on it
here.</p>
<p>Cargo is Rust's official package manager and build system. With <code>cargo</code>, you
can:</p>
<ul>
<li>Create new Rust projects with a common project layout.</li>
<li>Build projects.</li>
<li>Run project tests.</li>
<li>Update project dependencies.</li>
<li>Generate project documentation (via <code>rustdoc</code>).</li>
<li>Install other Rust projects from source.</li>
<li>Publish packages to Rust package registries.</li>
</ul>
<p>As a build system, Cargo is generally a breeze to work with. Configuration
files are TOML. Adding dependencies is often a 1 line addition to a
<code>Cargo.toml</code> file. Dependencies often <em>just work</em> on the first try. It's
not like say C/C++, where taking on a new dependency can easily consume
a day or two to get it integrated in your build system and compatible with
your source code base. <strong>I can't emphasize enough how much joy it brings
to be able to leverage an <em>it just works</em> build tool for systems-level
programming: I'm finding myself doing things in Rust like parsing ELF, PE,
and Mach-O binaries because it is so easy to integrate low-level functionality
like this into any Rust program.</strong> Cargo is <em>boring</em>. And when it comes to
build systems, that's a massive compliment!</p>
<p>No other language I've used has as comprehensive and powerful of a
<em>toolbox</em> as Rust does. This <em>toolbox</em> is highly leveraged by the Rust
community, resulting is remarkable consistency across projects. This
consistency makes it easier to understand, use, and contribute back to
other Rust projects. Contrast this with say C/C++, where large code bases
often employ multiple tools in the same space on different parts of the
same code base, leading to cognitive dissonance and overhead.</p>
<p>As a professional programmer, Rust's powerful and friendly <em>toolbox</em>
enables me to build Rust software more easily than with other languages.
I spend less time wrangling tools and more time coding. That translates
to less overhead delivering value through software. Other languages
would be wise to emulate aspects of Rust's model.</p>
<h2>Rust is Humane</h2>
<p>Of all the programming languages I've used, Rust seems to empathize
with its users the most.</p>
<p>There's a few facets to this.</p>
<p>A lot of care seems to have gone into the end-user experience of the
Rust <em>toolbox</em>.</p>
<p>The Rust compiler often gives extremely actionable error and warning
messages. If something is wrong, it tells me why it is wrong, often
pointing out exactly where in source code the problem resides, drawing
carets to the source code where things went wrong. In many cases,
the compiler will emit a suggested fix, which I can incorporate
automatically by pressing a few keys in my IDE. Contrast this with
C/C++ and even Go, which tend to have either too-terse-to-be-actionable
or too-verbose-to-make-sense-of feedback. By comparison, output from
other compilers often comes across as condescending, as if they are
saying <em>git gud, idiot</em>. Rust's compiler output tends to come across
as <em>I'm sorry you had a problem: how can I help?</em> I feel like the
compiler actually cares about my [valuable] time and satisfaction.
It wants to keep me in
<a href="https://en.wikipedia.org/wiki/Flow_(psychology)">flow</a>.</p>
<p>Then there's <a href="https://github.com/rust-lang/rust-clippy">Clippy</a>, a
Rust linter maintained as part of the Rust project.</p>
<p>One thing I love about Clippy is - like the compiler - many of the lints
contain suggestions, which I can incorporate automatically through my
IDE. So many other linters just tell you what is wrong and don't seem
to go the extra mile to be respectful of my time by offering to fix it
for me.</p>
<p><strong>Another aspect of Clippy I love is it is like having an invisible Rust
mentor continuously providing constructive feedback to help me level-up my
Rust.</strong> I don't know how many times I've written Rust code similarly to how I
would write code in other languages and Clippy suggests a more <em>Rustic</em>
solution. Most of the time I'm like <em>oh, I didn't know about that: that's
a much better pattern/solution than what I wrote!</em></p>
<p>Do I agree with Clippy all the time? Nope. But I do find its signal to
noise ratio is exceptionally high compared to other linters I've used.
And Clippy is trivial to configure and override, so disagreements are
easy to manage. Like the Rust compiler, I feel that Clippy is respectful
of my time and has the long term maintainability and correctness of my
software at heart.</p>
<p>Then there's the Rust Community - the people behind the core Rust projects.
<strong>The Rust Community is one of the most professional and welcoming I've
seen.</strong> Their <a href="https://www.rust-lang.org/policies/code-of-conduct">Code of Conduct</a>
is sufficiently comprehensive and actionable. They have their vigorous
debates like any other community. But the conversation is civil. Bad
apples are discarded when they crop up.</p>
<p>At a talk I made about PyOxidizer at a Rust meetup a few years back,
I made a comment in passing about a negative comment I encountered on
a Rust sub-Reddit. After the talk, a moderator of that sub who was in
the audience (unbeknownst to me) approached for more information so they
could investigate, which they did.</p>
<p>I once tweeted about a somewhat confusing, not-very-actionable compiler
error I encountered. A few minutes later, some compiler developers were
conversing in replies. A few hours later, a pull request was created and
a much better error message was merged in short order. I'm not a special
one-off here either: I've stumbled across Stack Overflow questions and
other forums where Rust core developers see that someone is encountering
a confusing issue, question the process that got them to that point, and
then make refinements to minimize it from happening in the future. The
practice is very similar to what empathetic product managers and user
experience designers do.</p>
<p>Not many other communities (or companies for that matter) seem to
demonstrate such a high level of compassion and empathy for their
users. To be honest, I'm not sure how Rust manages to pull it off,
as this tends to be very expensive in terms of people time and it can
be very easy to not prioritize. One thing is for certain: <strong>the Rust Community
is loaded with empathetic people who care about the well-being of users
of their products. And it shows from the interaction in forums to
the software tools they produce. To everyone who has contributed in the
Rust Community: thank you for all that you have done and for setting an
example for the rest of us to live up to.</strong></p>
<h2>Rust is Surprisingly High Level</h2>
<p>One of the reasons I avoided learning Rust for years is that I perceived
it was too low level and therefore tedious. Rust was being advertised as
a <em>systems programming language</em> and you would hear stories of <em>fighting
the borrow checker</em>. I assumed I'd need to be thinking a lot about memory
and ownership. I assumed the cost to author and maintain Rust code would be
high. I thought Rust would be <em>a safer C/C++</em>, with many of the software
development lifecycle caveats that apply. And for the software I was
writing at a time, the value proposition of Rust seemed weak. I thought
a combination of C and say Python was <em>good enough</em>. When I started
writing <a href="https://github.com/indygreg/PyOxidizer">PyOxidizer</a>, I initially
thought only the run-time code calling into the Python interpreter C APIs
would be written in Rust and the rest would be Python.</p>
<p>How wrong I was!</p>
<p><strong>When I actually started coding Rust, I was shocked at how high-level it
felt.</strong> Now, depending on the space of your software, Rust code can be
very low-level and tedious (not unlike C/C++). However, <strong>for the
vast majority of code I author, Rust feels more like Python than C</strong>. And
even the lower-level code feels much higher level than C or even C++.</p>
<p>In my mind, <strong>the expressiveness of Rust comes very close to higher-level,
dynamic languages (like JavaScript, Python, and Ruby) while maintaining
the raw speed of C/C++ all without sacrificing low-level control for
cases when you need it. And it does all of this while maintaining strong
safety guarantees</strong> (unlike say Go, which has the
<a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">billion dollar mistake</a>:
null references).</p>
<p>I had a mental Venn diagram of the properties of programming languages
(gc versus non-gc, static versus dynamic typing, compiled versus interpreted,
etc) and which traits (like execution speed, development time, etc) would
be possible and Rust invalidated large parts of that model!</p>
<p><strong>You often don't need to think about memory management in Rust</strong>: once you
understand the rules the borrow checker enforces, memory is largely something
that exists but is managed for you by the language, just like in garbage
collected languages. Of course there are scenarios where you should
absolutely be thinking about memory and should have a grasp on what Rust
is doing under the hood. But in my experience, most code can be blissfully
ignorant of what is actually happening at the memory level. (However,
awareness of value <em>ownership</em> when programming Rust does add overhead, so
it's not like the cognitive load required for reasoning about memory
disappears completely.)</p>
<p>Rust has both a stack and a heap. But when programming you often don't
need to distinguish these locations. You can do things in Rust like
return a reference to a stack allocated value and pass this reference around
to other functions. This would be a CVE factory in C/C++. But because of
Rust's borrow checker, this is safe (and a common practice) in Rust.
It also predisposes the code towards better performance! Often in C/C++
you will allocate on the heap because you need to return a reference to
memory and returning a reference to a stack allocated value is extremely
dangerous. This heap allocation incurs run-time overhead. So Rust allowing
you to do the fast thing safely is a nice mini win.</p>
<p>In many statically typed languages, I feel like my programming speed
is substantially reduced by having to repeatedly spell out or think
about type names. In C, it feels like I'm always writing type names
so I can perform casting. Newer versions of C++ and Java have improved
matters significantly (e.g. the <code>auto</code> keyword). However, I haven't
programmed them enough recently to know how they compare to Rust on this
front. All I know is that I'm writing type names a lot less frequently
in Rust than I thought I would be and that my programming output isn't
limited by my typing speed as much as it historically was in C/C++.</p>
<p>Despite being compiled down to assembly and exposing extremely
low-level control, Rust often feels like a higher-level language. Equivalent
functionality in Rust is often more concise and/or readable than in C/C++,
while performing similarly, all while having substantially stronger safety
guarantees. <strong>As a professional programmer, the value proposition is
blinding: Rust enables me to do more with less, achieve a lower
defect rate, and not sacrifice on performance.</strong></p>
<h2>Correctness, Quality, Execution Speed, and Development Velocity: Pick 4</h2>
<p>The operation of computers and operating systems is exceptionally complex.</p>
<p>All programming languages justifiably attempt to abstract away aspects of
this complexity to make it easier to deliver value through software. For
example:</p>
<ul>
<li>Assembly is hard: here's a higher level language that compiles down to
  assembly or is implemented in a language that does.</li>
<li>Managing memory manually is hard: use garbage collection.</li>
<li>Concurrency is hard: only allow 1 thread to run at a time (JavaScript, Python,
  etc).</li>
<li>Text encoding is hard: <em>strings</em> are Unicode/UTF-8.</li>
<li>Operating systems have different interfaces: here's a pile of abstractions
  in the standard library for things like I/O, networking, filesystem paths,
  etc.</li>
<li>Strong, static typing isn't very flexible and can impose high change costs:
  use dynamic typing.</li>
<li>And tons more.</li>
</ul>
<p>These abstractions often have undesirable consequences/trade-offs:</p>
<ul>
<li>Garbage collection adds run-time overhead (10% is a number that's commonly
  cited).</li>
<li>Garbage collection adds random slowdowns/pauses, making it difficult to
  achieve consistency in long-tail latency optimization (i.e. ensuring
  consistency in P99.9, P99.99, and beyond percentiles).</li>
<li>Interpreted languages tend to be slower than compiled languages unless you
  invest lots of time into a JIT.</li>
<li>Limiting execution to a single thread limits the ability to harness
  the full power of modern CPUs, which tend to have several cores.</li>
<li>Primitives like environment variables, process arguments, and filenames
  aren't guaranteed to be UTF-8 and coercing them to UTF-8 can be lossy.</li>
<li>Dynamic typing doesn't catch as many bugs at <em>compile time</em> and you have
  to be more diligent about guarding against invariants.</li>
<li>And tons more.</li>
</ul>
<p><strong>In other words, there are trade-offs with nearly every decision in programming
language and [standard] library design. There are usually no obviously
correct and undesirable consequence-free decisions.</strong></p>
<p><strong>And we further have to consider the fallibility of people and the inevitability
that mistakes will be made, that bugs and regressions will be introduced and will
need addressing. As an industry, we generally accept that mistakes occur and
bugs are an unavoidable aspect of software development. If new features and
enhancements are value, bugs and defects are anti-value. Like financial debt,
existence of bugs and sub-optimal code can be tolerated to varying extents. But
this is a highly nuanced topic and different people, companies, and projects will
have different perspectives on it. We can all agree that bugs are an inevitable
fact of software.</strong></p>
<p>We also need to confront the reality that as an industry we have
very little empirical data that says much of significance about topics
like <a href="https://danluu.com/empirical-pl/">static versus dynamic typing</a>.
Although we do know some things. As Alex Gaynor informs us in
<a href="https://alexgaynor.net/2020/may/27/science-on-memory-unsafety-and-security/">What science can tell us about C and C++'s security</a>,
the result of ~2/3 of security vulnerabilities being caused by memory
unsafety seems to reproduce against a sufficiently diverse set of
projects and companies. That result and the implications of it are
worth paying attention to!</p>
<p>With that being said, let's dive into my take on the matter.</p>
<p><strong>Of all the programming languages I've used, I feel that Rust has the
strongest disposition towards authoring and maintaining correct, high-quality
software. It does this by offering a myriad of features that are designed
to prevent (or at least minimize) defects. In addition, I believe Rust
shifts the detection of defects to earlier in the software development
lifecycle, greatly reducing the cost to mitigate defects and therefore
develop software.</strong></p>
<p>(As an aside, every time the topic of Rust's safety and correctness comes
up, random people on the Internet rush to their keyboards to say things
along the lines of <em>C/C++ and other languages can be made to be just as
safe as Rust: it's the bad programmers who are using C/C++ wrong.</em> To
those people: please stop. Your belief implies the infallibility of people
and machines and that mistakes won't be made. If things like memory unsafety
bugs in C/C++ could be prevented, industry titans like Apple, Google, and
Microsoft would have found a way. These companies are likely taking many
more measures to prevent security vulnerabilities than you are and
yet the ~2/3 of security vulnerabilities being caused by memory unsafety
(read: humans and machines failing to reason about run-time behavior)
result still occurs. <strong>To the wiser among us, I urge you to call out
perpetrators of this <em>good programmers don't create bugs</em> myth when you see
it</strong>, just like you would/should if you encounter racist, sexist, or other
non-inclusive behaviors. The reason is that belief in this myth can lead to
physical or emotional harm, just like non-inclusive -isms. Security bugs,
for example, can lead to disclosure of private or sensitive data, which can
result in real world harm. Think a stalker or abusive former partner
learning where you now live. Or a memory unsafety error in a medical device
leading to device malfunction, injuring or killing a patient. Because this
is a sensitive topic, I want to be clear that I'm not trying to compare the
relative harms incurred by racism, sexism, other -isms, or the <em>mythical
perfect programmer</em>. Rather, all I'm saying is each of these surpass
the minimum threshold of harm incurred that justifies calling out and
stopping the harmful behavior. I believe that as professionals we have an
ethical and professional obligation to actively squash the <em>mythical
perfect programmer</em> fallacy when we encounter it. Debates on the merits
and limits of tools to prevent/find defects is fine: belief in the <em>perfect
programmer</em> is not. Sorry for the mini rant: I just get upset by people who
think software exists in a vacuum and doesn't have real-world implications
for people's safety.)</p>
<p>In the sections below, I'll outline some of Rust's features and behaviors
that support my assertion that Rust is biased towards correct and higher
quality outcomes and lowers total development cost.</p>
<h3>The Borrow Checker</h3>
<p>To the uninitiated, the borrow checker is perhaps Rust's most novel contribution
to programming. It is a compile time mechanism that enforces various rules about
how Rust code must behave. Think of these as <em>laws</em> that Rust code must obey.
But these are more like societal laws, not scientific laws (which are
irrefutable), as Rust's laws can be broken, often leading to negative
consequences, just like societal laws.</p>
<p>Rust's <a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html">ownership</a>
rules are as follows:</p>
<ul>
<li>Each value in Rust has a variable that's called its owner.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the value will be dropped / released.</li>
</ul>
<p>Then there are rules about
<a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html">references</a>
(think <em>intelligent pointers</em>) to owned values:</p>
<ul>
<li>At any given time, you can have either one mutable reference or any number of
  immutable references.</li>
<li>References must always be valid.</li>
</ul>
<p>Put together, these rules say:</p>
<ul>
<li>There is only a single canonical owner of any given value at any
  given time. The owner automatically releases/frees the value when it is
  no longer needed (just like a garbage collected language does when the
  reference count goes to 0).</li>
<li>If there are references to an owned value, that reference must be valid
  (the owned value hasn't been dropped/released) and you can only have
  either multiple readers or a single writer (not e.g. a reader and a
  writer).</li>
</ul>
<p>The implications of these rules on the behavior of Rust code are significant:</p>
<ul>
<li>Use after free isn't something you have to worry about because references
  can't point to dropped/released values.</li>
<li>Buffer underruns, overflows, and other illegal memory access can't
  exist because references must be valid and point to an owned value /
  memory range.</li>
<li>Memory level data races are prevented because the <em>single writer or multiple
  readers</em> rule prevents concurrent reading and writing. (An assertion here
  is any guards - like locks and mutexes - have appropriate barriers/fences
  in place to ensure correct behavior in multi-threaded contexts. The ones
  in the standard library should.)</li>
</ul>
<p>I used to think that these rules <em>limited</em> the behavior of Rust code. That
statement is true. However, as I've thought about it more, I've refined
my take to be that <strong>ownership and reference rules reinforce properties that
well-behaved software exhibits.</strong></p>
<p>If a C/C++ program had illegal memory access, you would say it is <em>buggy</em> and
the behavior is not <em>correct</em>. If a Java program attempted to mutate a value
on thread A without a lock or other synchronization primitive and thread B
raced to read it, leading to data inconsistency, you would also call that a
<em>bug</em> and <em>incorrect</em> behavior. If a JavaScript/Python/Ruby function were
changed such that it started mutating a value that should be constant, you
would call that a <em>bug</em> and <em>incorrect</em> behavior.</p>
<p><strong>While Rust's ownership and reference rules do limit what software can
do, the functionality they are limiting is often <em>unsafe</em> or <em>buggy</em>, so
losing this functionality is often desirable from a quality and correctness
standpoint. Put another way, Rust's borrow checker eliminates entire
classes of [common] bugs by preventing patterns that lead to incorrect,
buggy behavior.</strong></p>
<p>This. Is. Huge.</p>
<p><strong>Rust's borrow checker catches bugs for which other languages have no
automated mechanism or no low cost, low latency mechanism for detecting.</strong>
There are ways to achieve aspects of what the borrow checker does in other
languages. But they tend to require contorting your coding style to
accomplish and/or employing high cost tools (often running asynchronously
to the compiler) such as {address, memory, thread} sanitizers or fuzzing.
With Rust, you get this bug detection built into the language and compiler:
no additional tools needed. (I'm not saying you shouldn't run additional
tools like sanitizers or fuzz testing against Rust: just that you get a
significant benefit of these tools for a drastically lower cost since they
are built in to the core language.)</p>
<p>Rust's ownership and reference rules help ensure your software is more
well-behaved and bug-free. But, sometimes those rules are too strict.
Fortunately, Rust isn't dogmatic about enforcing them. There are legitimate
cases where you can't work in the confines of these rules.</p>
<p>Say you want to share a cache between multiple threads. Caches need to be
both readable and writable by multiple threads. This violates
the reference rules and maybe the single owner ownership rule, depending on
how things are implemented. Fortunately, there are primitives in the
<a href="https://doc.rust-lang.org/std/sync/index.html">std::sync</a> module like
<a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html">RwLock</a>
and <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">Arc</a> (atomically
reference counted) you can use here. <code>Arc</code> (and its non-threadsafe <code>Rc</code>
counterpart) give you reference counting, just like a garbage collected
language. Primitives like <code>RwLock</code> allow you to wrap an inner value
and temporarily <em>acquire</em> an appropriate reference to it, mutable or
non-mutable. There's a bit of slight of hand here, but the tricks
employed enable you to satisfy the ownership and reference rules and
use common programming techniques and patterns while still having the
<em>safety</em> and <em>correctness</em> protections the borrow checker enforces.</p>
<h3>Data Races: What Data Races?</h3>
<p>Multi-threaded and concurrent programming is hard. Really hard. Like it
is exceptionally easy to introduce hard-to-diagnose-and-debug bugs hard.</p>
<p>There are many reasons for this. We can all probably relate to the fact
that reasoning about multi-threaded code is just hard: instead of 1 call
stack to reason about there are N. Further complicating matters are that
many of us don't have a firm grasp on how memory works at a very low level.
Do you know all the ins and outs on how CPU caches work on the architecture
you are targeting? Me neither! (But
<a href="https://software.rajivprab.com/2018/04/29/myths-programmers-believe-about-cpu-caches/">this</a>
is a very good place to start excavating a rabbit hole.)</p>
<p>If you are like me, you've spent many years of your professional career
not having to care about multi-threading or concurrent programming because you
spend so much time in languages with single threads, are only implementing code
that runs in single threaded contexts, or you've recognized the reality that
implementing this code safely and correctly is hard and you've intentionally
avoided the space or chosen software architectures (like queue-based message
passing) to minimize risks. Or maybe if you are say a Java programmer you
sprinkle <code>synchronized</code> everywhere out of precaution or in response to race
conditions / bugs once they are found. (Everyone's personal experience is
different, of course.)</p>
<p>Long story short, <strong>the aforementioned ownership and reference rules enforced
by the borrow checker eliminate data races.</strong> This was a major <em>oh wow</em>
moment for me when I learned Rust: I had heard about memory safety but didn't
realize the same forces behind it were also responsible for making concurrency
safe!</p>
<p>This property is referred to as <em>fearless concurrency</em>. I encourage you
to read Aaron Turon's
<a href="https://blog.rust-lang.org/2015/04/10/Fearless-Concurrency.html">Fearless Concurrency</a>
as well as the
<a href="https://doc.rust-lang.org/book/ch16-00-concurrency.html">Fearless Concurrency</a>
chapter in the Rust Book as well.</p>
<h3>Operating Systems Abstractions Ground in Reality</h3>
<p>Rust is the only programming language I've used that attempts to expose
operating system primitives like environment variables, command arguments,
and filesystem paths and doesn't completely mess it up. Truth be told,
this is kind of a niche topic. But as I help maintain a version control
tool which needs to care about preserving content identically across
systems, this topic is near and dear to my heart.</p>
<p>In POSIX land, primitives like environment variables, command arguments,
and filesystem paths are <code>char*</code>, or a bag of null-terminated bytes.</p>
<p>On Windows, these primitives are <code>wchar_t*</code>, or wide bytes.</p>
<p>On both POSIX and Windows, the encoding of the raw bytes can be... complicated.</p>
<p>Nearly every programming language / standard library in existence attempts
to normalize these values to its native string type, which is typically
Unicode or UTF-8. That's doable and correct a lot of the time. Until it
isn't.</p>
<p>Rust, by contrast, has standard library APIs like
<a href="https://doc.rust-lang.org/stable/std/env/fn.vars.html">std::env::vars()</a>
that will coerce operating system values to Rust's UTF-8 backed <code>String</code>
type. But Rust also exposes the
<a href="https://doc.rust-lang.org/stable/std/ffi/struct.OsString.html">OsString</a>
type, which represents operating system native strings. And there are
function variants like
<a href="https://doc.rust-lang.org/stable/std/env/fn.vars_os.html">std::env::vars_os()</a>
to access the raw values instead of the UTF-8 normalized ones.</p>
<p>Rust <a href="https://doc.rust-lang.org/stable/std/path/index.html">paths</a> internally
are stored as <code>OsString</code>, as that as the value passed to the C API
to perform filesystem I/O. However, you can coerce paths to <code>String</code>
easily enough or define paths in terms of <code>String</code> without jumping through
hoops.</p>
<p>The point I'm trying to get across is that Rust's abstractions are ground
in the reality of how computers work. <strong>Given the choice, Rust will rarely
sacrifice the ability to do something correctly.</strong> In cases like operating
system interop, Rust gives you the choice of convenience or correctness,
rather than forcing inconvenience or incorrectness on you, like nearly
every other language.</p>
<h3>Encoding and Enforcing Invariants in the Type System</h3>
<p>Rust <a href="https://doc.rust-lang.org/std/keyword.enum.html">enums</a> are
<a href="https://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types</a>.
Rust enum variants can have values associated with them and Rust enums,
like structs (Rust's main way to define a type), can have
functions/methods hung off of them. Rust enums are effectively
fully-featured, specialized types, where value instances must be a
certain variant of that enum. <strong>This makes Rust enums much more powerful
than in other languages where enums simply map to integer values and/or
can't have associated functions. This power unlocks a lot of possibility
and harnessed the right way can drastically improve correctness of code
and lead to fewer defects.</strong></p>
<p>Programming inevitably needs to deal with invariants, the various
possibilities that can occur. Programmers will reach for control flow
operators to handle these: <em>if x do this</em>, <em>else if y do that</em>, <em>switch</em>
statements, and the like. Handling every possible invariant can be complex,
especially as software evolves over time and the ground beneath you is
constantly shifting.</p>
<p><strong>As you become more familiar with Rust, you'll find yourself encoding
and enforcing invariants in the type system more and more. And enums
are likely the main way you accomplish this.</strong></p>
<p>Let's start with a contrived example. In C/C++, if you had a function
that accepted either an <code>Apple</code> or an <code>Orange</code> value, you might do
something like: <code>void eat(Apple* apple, Orange* orange)</code>. Then you'd
have inline logic like <code>if apple != null</code>. In a dynamically typed
language, you could pass a single argument, but you'd perform inline
type comparison. e.g. with Python you'd write <code>if isinstance(fruit, Apple)</code>.</p>
<p>With Rust, you'd declare and use an enum. e.g.</p>
<div class="pygments_murphy"><pre><span></span><span class="k">struct</span> <span class="nc">Apple</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>
<span class="k">struct</span> <span class="nc">Orange</span><span class="w"> </span><span class="p">{}</span><span class="w"></span>

<span class="k">enum</span> <span class="nc">Fruit</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Apple</span><span class="p">(</span><span class="n">Apple</span><span class="p">),</span><span class="w"></span>
<span class="w">    </span><span class="n">Orange</span><span class="p">(</span><span class="n">Orange</span><span class="p">),</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">impl</span><span class="w"> </span><span class="n">Fruit</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">fn</span> <span class="nf">eat</span><span class="p">(</span><span class="o">&amp;</span><span class="bp">self</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">match</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">Self</span>::<span class="n">Apple</span><span class="p">(</span><span class="n">apple</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">            </span><span class="n">Self</span>::<span class="n">Orange</span><span class="p">(</span><span class="n">orange</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kd">let</span><span class="w"> </span><span class="n">apple</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Fruit</span>::<span class="n">Apple</span><span class="p">(</span><span class="n">Apple</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">});</span><span class="w"></span>
<span class="n">apple</span><span class="p">.</span><span class="n">eat</span><span class="p">();</span><span class="w"></span>
</pre></div>

<p>This (again contrived) example shows how we Rust enum variants can hold
inner values, how we can define methods on Rust enums (so they behave like
regular types), and introduces the <code>match</code> control flow operator.</p>
<p>Quickly, <a href="https://doc.rust-lang.org/book/ch06-02-match.html">match</a> is a
super powerful operator. It will compare its argument against provided
patterns and evaluate the arm that matches. Patterns <strong>must</strong> be comprehensive
or the compiler will error. In the case of enums, if you add a variant - say
<code>Banana</code> for our <code>Fruit</code> example - and fail to add that variant to existing
<code>match</code> expressions, you will get compiler errors!</p>
<p>As you become more proficient with Rust, you'll find yourself moving
lots of (often redundant) control flow expressions and conditional dispatch
(<em>if X do this, if Y do that</em>) into enum variants and encoding the dispatched
actions into that enum/type directly. Conceptually, this is logically
little different from having a base type or interface or by having a single
<em>wrapper</em> class holds various possible values. But the guarantees are stronger
because each distinct possibility is strongly defined as an enum variant.
And when combined with the <code>match</code> control flow operator, you can have
the Rust compiler verify that all variants are accounted for every time
you take conditional action based on the variant.</p>
<p>The 2 most common enums in Rust are <code>Option</code> and <code>Result</code>. The following
sections will explain how they work and further demonstrate how invariants
can be encoded and enforced in Rust's type system.</p>
<h3><code>Option</code>: A Better Way to Handle Nullability</h3>
<p>Many programming languages have the concept of
<a href="https://en.wikipedia.org/wiki/Nullable_type">nullable types</a>: the ability
for a value to be null or some null-like value. You will often find this
expressed in languages as <code>null</code>, <code>nil</code>, <code>None</code>, or some variant thereof.</p>
<p>When programming in these languages, nullable values <strong>must</strong> be accounted
or it could lead to errors. Languages like C/C++ and Go will attempt to
to resolve the address behind <code>null</code>/<code>nil</code>, leading to at least a program
crash and possibly a security vulnerability. Languages like Java and Python
will raise exceptions (<code>NullPointerException</code> in Java - frequently abbreviated
<code>NPE</code> because it is so common - and likely <code>TypeError</code> in Python).</p>
<p>The prevalence of failure to account for nullable values is a major reason
why null references were coined by their inventor as
<a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">the billion dollar mistake</a>.
(I suspect the real world value is much greater than $1B.)</p>
<p>Having an easy-to-ignore nullable invariant lingering in type systems seems
like a massive foot gun to me. And indeed every programmer with sufficient
experience has likely introduced a bug due to failure to account for null. I
sure have!</p>
<p><strong>Rust doesn't have a null value. Therefore no null references and no
<em>billion dollar mistake</em>. Instead, Rust's standard library has
<a href="https://doc.rust-lang.org/std/option/index.html">Option<T></a>, an enum
representing nullable types / values. And <code>Option</code> is vastly superior to
null values.</strong></p>
<p><code>Option&lt;T&gt;</code> is an enum with 2 variants, <code>Some(T)</code> or <code>None</code>: an instance of some
type or <em>nothing</em>. What makes <code>Option</code> different from languages with null
references is you have to explicitly ask for the inner value: there is no
automatic dereference. <strong>Rust forces you to confront the reality that a
value is nullable and by doing so can drastically reduce a very common bug
class.</strong> I say <em>drastically reduce</em> instead of <em>eliminate</em> because it is
still possible to shoot yourself in the foot. For example, you can call
<a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap">Option.unwrap()</a>
to obtain the inner value, triggering a panic if the <code>None</code> variant is
present. Despite the potential for programming errors, this solution is
strictly better than null references because <code>Option</code> forces you to confront
the reality of nullability and use of the <em>dangerous</em> access mechanisms is
relatively easy to audit for. (Clippy has some lints to encourage best
practices here.)</p>
<p>The existence of <code>Option&lt;T&gt;</code> means that if you are operating on a non-<code>Option</code>
value, that value is guaranteed to exist and not be null. If you are operating
on <code>Option</code>, the fact it is optional is explicitly encoded in the type and you
know you need to account for it. <strong>If the value passed into a function was once
always defined and a later refactor changed it to be optional (or vice versa), that
semantic change is reflected in the type system and Rust forces you to confront
the implications when that change is made,</strong> not after it was deployed to
production and you started seeing segfaults, NPEs, and the like.</p>
<p><strong>After using Rust's <code>Option&lt;T&gt;</code> to express nullability, you will look at
every other language with null references and bemoan how <em>primitive</em> and
<em>unsafe</em> it feels by comparison. You will yearn for Rust's safer approach
biasing towards correctness and higher quality software.</strong> <code>Option&lt;T&gt;</code> is
massive feature for the professional programmer who cares about these
traits.</p>
<h3><code>Result</code>: A Better Way to Handle Errors</h3>
<p>Different programming languages have different ways of handling errors.
Returning integers or booleans to express success or failure is common.
As is throwing and trapping/catching exceptions.</p>
<p>Like nullability, history has shown us that programmers often fail to
handle error invariants, with bugs of varying severity ensuing. Even Linux
filesystems
<a href="http://research.cs.wisc.edu/wind/Publications/iron-sosp05.pdf">fail</a> to
<a href="http://usenix.org/legacy/event/fast08/tech/full_papers/gunawi/gunawi_html/index.html">handle</a>
errors!</p>
<p><strong>I argue that the traditional programming patterns we use to handle errors bias
towards buggy outcomes, especially with the <em>return an integer/error value</em>
approach.</strong> It is easy to forget to check the return value of a function. In
C/C++, maybe a function once returned nothing (<code>void</code>) and was later refactored
to return an integer error code. You have to know to audit for existing callers
when making these changes or updating dependencies. Furthermore, handling errors
requires effort. That <code>if err != 0</code> or <code>if err != nil</code> pattern gets mighty
annoying to type all of the time! Plus, you have to know what value to compare
against: <em>success</em> can often be 0, -1, or 1 or any other arbitrary value.
<strong>Getting error handling correct 100% of the time is <em>hard</em>. You will fail and
this will lead to bugs.</strong></p>
<p><a href="https://doc.rust-lang.org/std/result/index.html">Result<T, E></a> is Rust's
primary/preferred mechanism for propagating errors and it is different
from traditional approaches.</p>
<p>Like <code>Option&lt;T&gt;</code>, <code>Result&lt;T, E&gt;</code> is an enum with 2 variants: <code>Ok(T)</code> and
<code>Err(E)</code>. That is, a value is either <em>success</em>, wrapping an inner value of
type <code>T</code> or <em>error</em>, wrapping an inner value of type <code>E</code> describing that
error.</p>
<p>Like <code>Option&lt;T&gt;</code>, <code>Result&lt;T, E&gt;</code> forces you to confront the existence of
invariants. Before operating on the value returned by a function, you need
to explicitly access it and that forces you to confront that an error could
have occurred. In addition, the <code>Result</code> type is
<a href="https://doc.rust-lang.org/std/result/index.html#results-must-be-used">annotated</a>
and the compiler will emit a warning when you don't check it. Scenarios like
changing an infallible function returning a type <code>T</code> to fallible returning a
<code>Result&lt;T, E&gt;</code> will fail to compile (due to typing violations) or make compiler
warning noise if there are call sites that fail to account for that change.</p>
<p>In addition to making it more likely that errors are acted upon correctly,
Rust also contains a
<a href="https://doc.rust-lang.org/std/result/index.html#the-question-mark-operator-">? operator</a>
for simplifying handling of errors.</p>
<p>As I said above, typing patterns like <code>if err != 0</code> or <code>if err != nil</code> can become
extremely tedious. Your brain knows what it needs to type to handle errors
but it takes precious seconds to do so, slowing you down. You may have code where
the majority of the lines are the same error handling boilerplate over and over,
increasing verbosity and arguably decreasing readability.</p>
<p>Rust's <code>?</code> operator will <code>return</code> an <code>Err(E)</code> variant or evaluate to the
inner value from the <code>Ok(T)</code> variant. So you can often add an <code>?</code>
operator after a function call returning a <code>Result&lt;T, E&gt;</code> to automatically
propagate an error. Typing a single character is vastly easier and simpler
than writing explicit control flow for error handling!</p>
<p>The benefits of <code>?</code> are blatantly apparent when you have functions calling
into multiple fallible functions. Long functions with multiple <code>if err != 0</code>
blocks followed by the next logical operation often reduce to a 1-liner. e.g.
<code>bar(foo()?)?</code> or <code>foo.do_x()?.do_y()?</code>. When I said earlier that Rust feels
like a higher level language, the <code>?</code> operator is a significant contributor to
that.</p>
<p>There are some downsides to <code>Result&lt;T, E&gt;</code> in terms of programming overhead
and consistency between Rust programs. I'll cover these later in the post.</p>
<p><strong><code>Result&lt;T, E&gt;</code> biases Rust code towards correctness by forcing programmers
to confront the reality that an error could exist and should be handled.
Once you program in Rust, you will look at error handling mechanisms like
returning an error integer or nullable value, realize how brittle and/or
tedious they are, and yearn for something better.</strong></p>
<h3>The <code>unsafe</code> Escape Hatch</h3>
<p>If some of Rust's limitations are too much for you, Rust has an
<em>in case of emergency break glass</em> feature called <code>unsafe</code>. This is kind of
like <em>C mode</em> where you can do things like access and manipulate raw memory
through pointers. You can <em>cast</em> a value to a pointer and back to a new Rust
reference/value, effectively short circuiting the borrow checker for that
particular reference/value.</p>
<p><strong>A common misconception is <code>unsafe</code> disables the borrow checker and/or loosens
type checking. This is incorrect: many of those features are still running
in <code>unsafe</code> code.</strong> However, because Rust can't fully reason about what's
happening (e.g. it doesn't know who owns a raw memory address and when
it will be freed), it can't properly enforce all of its rules that guarantee
safety, leading to, well, <em>unsafety</em>. (See
<a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">Unsafe Rust</a> for
more on this topic.)</p>
<p><code>unsafe</code> is a necessary evil. In many Rust programs, you won't have to
ever use it. But if you do have to use it, its presence will draw review
scrutiny like moths to light. So unlike say C/C++ where practically every
memory access is a potential security bug and it is effectively impossible
in many scenarios to comprehensively audit for memory safety (if there were
there would be no memory safety bugs), using <code>unsafe</code> safely is often viable
because scrutiny can be concentrated on its relatively few occurrences.
And more experienced Rust programmers know how to encapsulate <code>unsafe</code> into
<em>safe</em> wrappers, limiting how much code needs to be audited when code
around <code>unsafe</code> changes.</p>
<p>What I've personally been enlightened by is the myriad of operations
that Rust considers <em>unsafe</em>. As you learn more and more Rust, you'll
encounter random functions sprinkled across the standard library that
are <code>unsafe</code> and you'll wonder why. The docs usually tell you and that's
how you learn something new (and maybe horrifying) about how computers
actually work.</p>
<h3>Fearless Refactoring</h3>
<p>A significant portion of the software development lifecycle is evolving
existing code. Fixing bugs. Extending existing code with new
functionality. Refactoring code to fix bugs or prepare for new features.
Using code in new, unplanned ways.</p>
<p>In many code bases, the amount of people time spent evolving the code
dwarfs the time for creating actual greenfield code/features.
(Unfortunately, quantifying when you are doing <em>evolution</em> versus
greenfield coding is quite difficult, so both facets often get lumped
together into simply <em>software development time</em>. But in my mind they are
discrete - although highly interdependent - units of work and the evolution
time tends to dwarf the greenfield time on established projects.) <strong>So it
follows that long-term evolution/maintainability of code bases is more
important than initial code creation time.</strong></p>
<p><strong>There is a sufficient body of industry research demonstrating that the
cost to fix defects rises exponentially as you progress through the
software development lifecycle</strong> (do a search for say <em>software development
lifecycle cost of fixing a bug</em>).</p>
<p>Furthermore, human memory functions not unlike multi-tier caches and your
ability to recall information will diminish over time. (You probably know
what you were doing 5 minutes ago, might remember what you were doing at
this time yesterday, and probably have no clue what you were doing on this
date 20 years ago.)</p>
<p><strong>In terms of coding, the best way to address a defect is to not introduce
it in the first place. If you can't do that, your goal is to detect and
correct it as early in the development process as possible, as close as
possible to when the source code creating that defect came into existence.</strong>
Practically, in order of descending desirability:</p>
<ol>
<li>Don't introduce defect (this is impossible because humans are fallible).</li>
<li>Detect and correct defect as soon as the bad key press occurs (within
   reason: you don't want the programmer to lose too much flow) (milliseconds
   later).</li>
<li>At next build / test time (seconds or minutes later).</li>
<li>When code is shared with others (maybe you push a branch and CI tells
   you something is wrong) (minutes to days later).</li>
<li>During code review (minutes to days later).</li>
<li>When code is integrated (e.g. merged) (minutes to days later).</li>
<li>When code is deployed (minutes to days or even months later).</li>
<li>When a bug is reported long after the code has been deployed (weeks
   to years later).</li>
</ol>
<p>The earlier a defect is caught, the better the chances that the author
(or other involved parties) have relevant code <em>paged in</em> and can fix it
with less effort and with lower chances of introducing additional defects.
For me, authoring new code is relatively easy compared to refactoring old
code. That's because I have new code fully paged into my brain and I know
it like the back of my hand. I know where the sharp edges are and how
you'll get cut if you make certain changes. However, if several months
pass without revisiting the code, most of that heightened awareness
evaporates. If I need to change or review that code, my ability to do
that with a high degree of confidence and efficiency is drastically
eroded.</p>
<p>Generally speaking, the earlier a defect is caught, the less damage it can
do. Ideally, a defect is caught and fixed at local development time, before
you burden a reviewer with finding it and certainly before it causes harm or
anti-value after being deployed!</p>
<p>In addition, compressing the software development lifecycle allows you
to ship enhancements sooner, which enables you to deliver value sooner.
This is what we're trying to do as professional programmers after all!</p>
<p><strong>Because the cost to fix a defect rises exponentially as it moves through
the software development lifecycle, it follows that you want defect
detection to occur logarithmically to offset that cost.</strong> That means you
want as many defects as possible to be caught as early as possible.</p>
<p><strong>Compared to other programming languages I've used, Rust is exceptional
at detecting defects earlier in the development lifecycle and as a result
can drastically lower overall development costs.</strong> Here are the main factors
contributing to this belief:</p>
<ul>
<li>The type system is relatively strong and prevents many classes of bugs.</li>
<li>The borrow checker and the rules it enforces prevent <em>safety</em> issues
  at <em>compile</em> time. Some of these violations can be detected by other
  languages' compilers. However, in many cases sufficient auditing
  (like {address, memory, thread} sanitizers) is run much less frequently,
  often only in CI tests, which can be hours or days later.</li>
<li>Confidence that the above 2 function as advertised.</li>
<li>Invariants can be encoded and enforced in the type system through features
  like enums being algebraic data types.</li>
<li>Variables are immutable by default and must be explicitly annotated
  as mutable. This forces you to think about where and how data mutation
  occurs, enabling you to spot issues sooner.</li>
<li><code>Option&lt;T&gt;</code> significantly curtails the <em>billion dollar mistake</em>.</li>
<li><code>Result&lt;T, E&gt;</code> forces you to reckon about handling errors.</li>
</ul>
<p>The Rust compiler is just exceptional at detecting common defects.</p>
<p>Did your code refactor introduce a use-after-free or dangling reference?
Don't worry: the borrow checker will detect that. CVE prevented.</p>
<p>Did you introduce a race condition by performing a mutation somewhere
that was previously immutable? The borrow checker will detect that. You
potentially just saved hours of time debugging a hard-to-reproduce bug.</p>
<p>Did you add an enum variant but forget to add that variant to a
<code>match</code> expression? If you avoided using the <em>match all</em> <code>_</code>
expression, the compiler will tell you match arms aren't exhaustive
and give you an error.</p>
<p>Did a value that was previously always defined become nullable? Changing
the type from <code>T</code> to <code>Option&lt;T&gt;</code> will yield compiler errors due to type
mismatch.</p>
<p>Did an <code>Option&lt;T&gt;</code> that was previously always <code>Some(T)</code> suddenly
become <code>None</code>? Hopefully following Rust best practices mean your code
will just work. In the worst case you get a panic (with a stack trace).
But that's on par with say a Java NPE and is strictly better than a
null dereference that you get with languages like C/C++.</p>
<p>Did you change or add a function returning <code>Result&lt;T, E&gt;</code> but forget
to check if that <code>Result</code> is an <code>Ok(T)</code> or <code>Err(E)</code>, the compiler
will tell you.</p>
<p>I could go on. Rust is full of little examples like these where the
core language and standard library nudge you towards working code and
help detect defects earlier during development, saving vast amounts
of time and money later.</p>
<p><strong>The Rust compiler is so good at rooting out problems that many Rust
programmers have adopted the expression, <em>if it compiles it works</em>. This
statement is obviously falsifiable. But compared to every other programming
language I've used, I'm shocked by how often it is true.</strong></p>
<p>For other programming languages, a working compile is the beginning of your
verification or debugging journey. For Rust, it often feels like the hard
part is over and you are almost done. With other languages, you often
have an indefinite number of iterations to fix <em>language defects</em> (like
null dereferences or dynamic typing errors) beyond the compile step. You
need to address these in addition to any <em>logical/intent defects</em> in your
code. And fixing logical/intent defects could introduce more post-compile
defects. As a programmer, you just don't know when the process will be
done. With Rust, the compiler errors tell you exactly what the <em>language
defects</em> are. So by the time you appease the compiler, you are left with
just your <em>logical/intent</em> defects. I greatly prefer the Rust workflow
which separates these because I'm getting clearer feedback on my progress:
I know that once I've addressed all the <em>language defects</em> the compiler
complains about that is <em>just</em> a matter of fixing <em>logical/intent</em>
defects. I know I'm a giant step closer to victory.</p>
<p><a href="https://hbr.org/2011/05/the-power-of-small-wins">The Progress Principle</a>
is a psychological observation that people tend to prefer a series of
more smaller wins over fewer larger wins. And (unexpected) setbacks can
more than offset the benefits of wins. (The book is an easy read and
I've found its insights applicable to software development workflows.)
Whether Rust's language designers realized it or not, Rust's development
workflow plays into our psychological dispositions as described by <em>The
Progress Principle</em>: defects (setbacks) tend to occur earlier (at compile
time), not at unexpected later times (during code review, CI testing,
deploy, etc) and our progress towards a working solution is composed of
small wins, such as fixing compiler errors and knowing when you transition
from <em>language defects</em> into <em>logical/intent</em> defects. For me, this makes
iterating on Rust more <em>fulfilling</em> and <em>enjoyable</em> than other languages.</p>
<h2>Rust Makes You a Better Overall Programmer</h2>
<p>Whether you realize it or not, every programmer has a personal, generalized
model of how to program, how to reason about code, best practices, and
what not. When we program, we specialize that model to the language
and environment/project we're programming for. The mental model that
each of us has its shaped by our experience: which languages we know,
which concepts we've been exposed, mistakes we've made, people we've
worked with and the practices they've instilled.</p>
<p><strong>If for no other reason, you should learn Rust to expand your generalized
model of how to program so that you can apply Rust's principles outside
of Rust.</strong></p>
<p>Before I learned Rust, I had a mental model of the <em>lifetimes</em> of various
values/variables/memory and how they would be used. If I were coding C, I
would attempt to document these in function comments. e.g. if returning a
pointer, the comment would say how long the memory behind that pointer lives
or who is responsible for freeing it. So when I encountered Rust's ownership
and reference rules when learning Rust, they substantially overlapped with
my personal mental model of how you should reason about memory in order to avoid
bugs. I distinctly remember reading the Rust Book and thinking <em>wow, this
seems to be a formalization of some of the concepts and best practices living
in my head!</em></p>
<p>After using Rust for several months, I realized that my prior mental
model around reasoning about <em>safe</em> program behavior was woefully
incomplete and that Rust's was far superior.</p>
<p><strong>Rust's <em>different</em> ways of doing things will inevitably force you to
think about type design, data access patterns, control flow, etc more
than most other programming languages. In most other languages, it is much
easier to just write runnable code and defer the complexity around
ensuring the code is <em>safe</em>/<em>correct</em> and free from certain classes of
bugs, like memory access violations and race conditions. Rust's ways of
doing things forces you to confront many of these problems up-front,
before anything runs.</strong></p>
<p>Rust's stricter model and way about authoring software eventually percolates
into your personal generalized model of how to program in <em>any programming
language</em>. <strong>As you internalize patterns needed to program Rust proficiently,
you will subconsciously cherry-pick aspects of Rust and apply them when
programming in other languages, making you a better programmer in those
languages.</strong></p>
<p>For example, when you program C/C++, you will realize the minefield of
memory safety issues that linger in those languages. Many of those mines
never explode. But knowing Rust and the patterns needed to appease the
borrow checker and write <em>safe</em> code, you have a better sense of where the
mines are located, the patterns that lead to them exploding, and you can
take preemptive steps or apply extra scrutiny to avoid tripping
them. (If you are like me, you'll reach the conclusion that C/C++ is
intrinsically unsafe and is beyond saving, vowing to avoid it as much as
possible because it is just too dangerous to use safely/responsibly.)</p>
<p>Similarly, when programming in any language, you'll probably think more about
variable mutability and non-mutability, even if those languages don't have
the concept of mutability on variables. You'll be more attune to certain
patterns for mutating data: where mutation occurs, who has a mutable
reference, when there are both mutable and non-mutable references in
existence. Again, your knowledge from Rust will subconsciously raise your
awareness for classes of bugs, making you a better programmer.</p>
<p>The same thing applies to multi-threaded programming and race conditions.
After internalizing Rust's model of how to achieve multi-threading safely,
you will probably not look at multi-threading in other languages the same
way again. If you are like me, you will be horrified by how the lack of
Rust's enforced ownership/reference rules predisposes code to so many
horrible and hard-to-debug bugs. Again, you will probably find yourself
changing your approach to multi-threading to minimize risk.</p>
<p>Fun fact: while at Mozilla I heard multiple anecdotes of [very
intelligent] Firefox developers thinking they had found a bug in Rust's
borrow checker because they thought it was impossible for a flagged error
to occur. However, after sufficient investigation the result was always
(maybe with an exception or two because Mozilla adopted Rust very early)
that the Rust compiler was correct and the developer's assertions about
how code could behave was incorrect. In these cases, the Rust compiler
likely prevented hard-to-debug bugs or even exploitable security
vulnerabilities. I remember one developer exclaiming that if the
bug had shipped, it would have taken <em>weeks</em> to debug and would likely
have gone unfixed for <em>years</em> unless its severity warranted staffing.</p>
<p><strong>I strongly feel that I am a better programmer overall after learning
Rust because I find myself applying the [best] practices that Rust enforces
on me when programming in other languages. For this reason, even if you
don't plan to use Rust in any serious capacity, I encourage people to learn
Rust because exposure to its ideas will likely transform the ways you think
about programming for the better.</strong></p>
<h2>Rust Downsides and Dispelling Some Rust Myths</h2>
<p>This post has been rather positive about Rust so far. Rust, like
everything, is far from perfect and it has its downsides. Professionals
know the limitations of their tools and you should know some of the
issues you'll run into when using Rust.</p>
<p>In addition, Rust is still a relatively young and unpopular programming
language. Since relatively few people know Rust, there are a handful of
myths and inaccuracies circling about the language. I'll also dispel some
of those here.</p>
<h3>Steeper Learning Curve</h3>
<p>A common criticism levied against Rust is it is harder to learn than
other programming languages. I think this is a valid concern. My
experience is Rust took longer to learn and level-up than other
languages I've learned recently, notably Go, Kotlin, and Ruby.</p>
<p>I think the primary reason for this is the borrow checker and the
rules it enforces. Many programmers have never encountered forced
following of ownership and reference rules before and this concept is
completely foreign at first. I liken it to <em>a new way to program</em>.
If you only have experience with dynamically typed languages that
will allow you to compile a ham sandwich, there's a good chance you'll
be frustrated by Rust. Rust will likely challenge your conceptions of
how programming should work and may frustrate you in the process.</p>
<p>In addition to the borrow checker itself, there are a myriad of types
and patterns you'll encounter and eventually need to understand to
<em>appease</em> the borrow checker.</p>
<p>Beyond the borrow checker, Rust's standard library is comprehensive and
offers a lot of types and traits. It will take a while to be exposed
to many of them and know when/how to use each.</p>
<p>You will likely be adding 3rd party crates as dependencies to
your project for common functionality not (yet) in the standard library.
These expand the scope of concepts you need to learn.</p>
<p>I hope I'm not scaring anybody away: you can go pretty far in Rust without
encountering or understanding most of the standard library. That being
said, every new type, trait, concept, and crate you learn unlocks new
possibilities and avenues for delivering value through programming. So
there is an incentive to take the time to learn them sooner than later.</p>
<p>I learned Rust mostly independently for a personal project. While
learning resources such as <a href="https://www.rust-lang.org/learn">Learn Rust</a>,
the <a href="https://cheats.rs/">Rust Language Cheat Sheet</a>, and even Clippy
are fantastic, in hindsight I probably would have become more proficient
sooner had I contributed to an existing Rust project and/or had ongoing
technical collaboration with more experienced Rust developers. This is
probably no different than any other programming language. But because of
Rust's steeper learning curve, I think the benefits of peer exposure are
more significant. That being said, I've heard anecdotes of teams with no
Rust experience learning Rust together with successful results. So there's
no formal recipe for success here.</p>
<p>Finally, despite the steeper learning curve, I'd say the return on
investment pays off pretty quickly. As I've argued elsewhere in this
post, the Rust compiler and type system helps prevent many classes of
bugs. So while it may take longer to initially learn and compose idiomatic
Rust code, it won't take long for Rust to offset the time that you would
have spent chasing bugs, performance optimizations, and the like.</p>
<h3>Rust Moves Too Fast</h3>
<p>Rust releases a new version every 6 weeks. By contrast, many other
programming languages release ~yearly. This faster release cadence has
been a common complaint about Rust.</p>
<p>Quickly, I think people conflate release cadence with churn and hardship
from that release cadence. <strong>Generally speaking, release cadence isn't the
thing you care about: it's how disrupted you are from the releases.</strong> If
your old release continues to work just as well as the new release,
release cadence doesn't really matter (many major websites deploy/release
dozens of times per day and you don't care because you can't tell: you only
care when the UI or behavior changes). <strong>So the thing most of us care about
is how frequently Rust releases cause disruption.</strong> And disruption is often
caused by backwards incompatibility and the introduction of new features,
which when adopted, force upgrades.</p>
<p>A few years ago, I think the concern that <em>Rust moves too fast</em> was
valid: there were significant features in seemingly every release and
crates were eager to jump on the new features, forcing you to upgrade
if you wanted to keep your dependency tree up to date. I feel like I
caught the tail end of this relative chaos in 2018-2019.</p>
<p>But in the last 18-24 months, things seem to have quieted down. Many
of the major language features that people were eager to jump on have
landed. The only ongoing churn I'm aware of in Rust is in the async
ecosystem, and that seems to be stabilizing. New Rust releases are
generally pretty quiet in terms of <em>must use</em> features. The last
<em>milestone</em> release in my mind was 1.45 in July 2020, which stabilized
procedural macros. The community was pretty quick to jump on that
feature/release. My Rust projects have targeted 1.45+ for a while now
with minimal issues.</p>
<p>9 months with no major disruptions is on par with the release cadence
of other programming languages.</p>
<p><strong>In my opinion, the concern that <em>Rust moves too fast</em>, while once valid,
no longer generally applies.</strong> Pockets of truth for segments of users caring
about niche and lesser-used features, yes. But nothing that applies to the
entire Rust ecosystem.</p>
<h3>Compiling Is Too Slow</h3>
<p>A lot of people have commented that Rust builds take too long. It is
true: compiling Rust tends to take longer than C/C++, Go, Java, and
other languages requiring an ahead-of-time compile step.</p>
<p>While a lot has been done to make the Rust compiler faster (it feels
substantially faster than it was a few years ago), it still isn't
as fast as other languages.</p>
<p>Not to dismiss the problem, but in a lot of cases, the speed of Rust
compilation is <em>fast enough</em>. Incremental builds for small libraries
or programs will take a few hundred milliseconds to a second or two.
I suspect most of the people complaining about build times today are
developing very large Rust programs (tens of thousands of lines of
code and/or hundreds of dependencies).</p>
<p>A contributing problem to build times is dependency count. The simplicity
of Cargo makes it very easy to accumulate dependencies in Rust and
each additional crate will slow your build down. PyOxidizer has
~400 dependencies at this point in time, for example (I've been
throwing the kitchen sink at it in terms of features).</p>
<p>There are a few things under your control to mitigate this problem.</p>
<p>First, install <a href="https://github.com/mozilla/sccache">sccache</a>, a
transparent compiler cache. By default it caches to the local
filesystem. But you can also point it at Redis, Memcached, or blob
stores in AWS, Azure, or GCP. Firefox's CI uses an S3 backed cache and
the hit rate (for both Rust and C/C++) is 90-99% on nearly every build.
For PyOxidizer - a medium sized Rust project - sccache reduces full
build times from ~53s wall and ~572s CPU to ~32s wall to 225s CPU on
my 16 core Ryzen 5950X. The wall time savings on a lower CPU core count
machine are even more significant.</p>
<p>Speaking of CPU core counts, the second thing you can do is give
yourself access to more CPU cores. Laptops tend to have at most 4
CPU cores. Consider buying desktops or moving builds to remote
machines, often with dozens of CPU cores. This requires spending
money. But when you factor in people time saved and the cost of
that time and the value of someone's happiness/satisfaction, it
can often be justified.</p>
<p>I'm not trying to dismiss the problems that slow builds can impose,
but if you want to justify their cost, you can argue that the Rust
compiler does more at compilation time than other languages and that
this overhead brings benefits, such as preventing bugs earlier in
the software development lifecycle.
<a href="https://en.wikipedia.org/wiki/There_ain%27t_no_such_thing_as_a_free_lunch">There's no such thing as a free lunch</a>
and Rust's relatively slower builds are a <em>tax</em> you pay for the correctness
the compiler guarantees. To me, that's a justifiable trade-off.</p>
<h3>Rust is Too Young or Isn't Production Ready</h3>
<p>The <em>isn't production ready</em> concern is likely disproven by the
existence of Rust in production in critical roles at a sufficient
number of reputable companies. At this point, there are very few
technical reasons to say Rust isn't production ready. Non-technical reasons
such as lack of organizational knowledge or a limited talent pool for
hiring from, yes. But little on the technical front.</p>
<p>The <em>too young</em> part is ultimately a judgement call for how comfortable
you are with new technologies.</p>
<p>I'm generally pretty conservative/skeptical about adopting new technology.
If you are in this industry long enough you eventually get humbled by your
exuberance.</p>
<p>I was probably in the <em>Rust is too young</em> boat as late as 2017, maybe
2018. While I was cheering on Rust as a Mozillian, I was skeptical it
was going to take off. Birthing successfully languages is hard. The
language still seemed to move too fast and have too many missing
features. Things seemed to stabilize around the 2018 edition. That's
also when you started commonly hearing of companies adopting Rust. Lots
of startups at first. Then big companies started joining in.</p>
<p>Today, companies you have heard of like Amazon, Cloudflare,
Discord, Dropbox, Facebook, Google, and Microsoft are adopting Rust to
varying degrees. There are 58,750 published crates on
<a href="https://crates.io/">crates.io</a>.</p>
<p>I won't drop names, but I've heard of Rust <em>spreading like wildfire</em> at
some companies you've heard of. The stories are pretty similar: random
person or team wants to try Rust. Something small and isolated with a
minimal blast radius in case of disaster is tried first. Rust is an
overwhelming success. As more and more people are exposed to Rust, they
<em>see the light</em>, cries for Rust become louder, and it becomes even more
widely adopted.</p>
<h3>The <em>I'm Writing Fewer Bugs</em> Trap</h3>
<p>When I program in Rust, I strongly feel that my base rate of defect introduction
is substantially less than other programming languages. I have confidence that
the Rust compiler coupled with practices like encoding and enforcing invariants
in the type system leads to fewer defects. In some cases I feel like the surface
area for bugs is limited to <em>logical defects</em>, which are mis-expressions of the
human programmer's intent. And since no automated tool can reliably scan for
<em>human intent</em>, there's no way to prevent <em>logical bugs</em>, and that surface area
is the best we can ever expect from automated scanning.</p>
<p>Knowing what tests to write and how much effort to invest in test writing
is a difficult skill to level up and is full of trade-offs. With Rust, I find
myself writing fewer tests than in other languages because I have confidence
that the compiler will detect issues that would otherwise require explicit
testing.</p>
<p>I <em>feel</em> that my beliefs and practices are rooted in reality and justifiable. Yet I
recognize the danger in placing too much faith in my tools, in Rust.</p>
<p>In theory, Rust alleviates the need for running additional verification
tools, like {address, memory, thread} sanitizers because the safe subset
of Rust prevents the issues these tools detect. Many defects caught by
fuzzing are also similarly prevented by the design of Rust (but not all:
fuzzing is generally a good idea).</p>
<p><strong>What I'm trying to say is that it is really easy to fall into a trap where
you are over-confident about the abilities of Rust to prevent defects and
you find yourself letting your guard down and not maintaining testing and
other verification best practices.</strong></p>
<p>I'm still evolving my beliefs in this area. But my general opinion is that you
should still run things like {address, memory, thread} sanitizers and fuzzing
because <code>unsafe</code> likely exists <em>somewhere</em> in the compiled code, as likely does
C or assembly code. And because a chain is only as strong as its weakest link,
it only takes <em>any</em> bug to undermine the <em>safety</em> of the entire system.
So while these additional verification tools likely won't find as many issues
as they would in <em>unsafe</em> languages, I still think it is a good idea to continue
to run them against Rust, especially for <em>high value</em> code bases.</p>
<h3>Error Handling</h3>
<p><code>Result&lt;T, E&gt;</code> isn't a panacea. Because errors are full on types rather
than simple primitives like integers, you need to spend effort reasoning
and coding about how different error types interact. And often you need
to write a bit of boilerplate code to facilitate that interaction. This
can cancel out a lot of the efficiency benefits of Rust's <code>?</code> operator
for handling errors.</p>
<p>There are a handful of 3rd party Rust crates specializing in error
handling that you'll likely to encounter. These include
<a href="https://crates.io/crates/anyhow">anyhow</a>,
<a href="https://crates.io/crates/error-chain">error-chain</a>,
<a href="https://docs.rs/failure/0.1.8/failure/">failure</a>, and
<a href="https://crates.io/crates/thiserror">thiserror</a>.</p>
<p>Rust's error handling landscape can at times feel fragmented and make
you yearn for something more defined/opinionated in the standard library.
The Rust Community recognizes that this is an area that can be improved
and has <a href="https://blog.rust-lang.org/inside-rust/2020/09/18/error-handling-wg-announcement.html">formed</a>
an error handling project group to improve this space. So hopefully we see
some quality of life improvements to error handling in time.</p>
<h2>Conclusion</h2>
<p>I am irrationally effusive about Rust. When I see this level of excitement
in others, I am extremely skeptical. I was skeptical myself when my former
colleagues at Mozilla were talking up Rust years ago. But having used Rust
for 2.5 years now and authored tens of thousands of lines of Rust code, the
initial relationship euphoria has worn off and I am most definitely in love.</p>
<p><strong>Cynically, Rust has ruined in programming in other languages for me. Less
cynically, Rust has spoiled me.</strong></p>
<p>When I look at other languages without the rules enforced by Rust's borrow
checker, all I see are sharp edges waiting to materialize into bugs.</p>
<p>When I look at other languages with <em>weaker</em> type systems, I think about
all the time I spend having to defend against invariants and how much
cognitive load and programming/review effort I need to incur to maintain
the baseline of quality that I get with Rust.</p>
<p>When I look at programming languages like Python, Ruby, and TypeScript
where you can bolt a type system onto a language that doesn't have it, I
think <em>why would I want to do that when I can use an even better type
system while likely achieving much better performance with Rust?</em> (It's
tempting to reach for a metaphor involving lipstick and pigs.)</p>
<p>When I look at other languages, I generally see the same pile of decades
old ideas packaged in different boxes. Some of these ideas are good and
probably timeless (e.g. functions and variables). Some are demonstrably bad
and should be largely excised from common use (e.g. null references - the
<em>billion dollar mistake</em>).</p>
<p>When I interface with Rust's tooling, I feel like it is respectful of my
time and has my best interests (producing working software) at heart. I
feel the maintainers of the tooling care about me.</p>
<p>When I program in Rust, I feel that I'm producing fewer defects overall.
The compiler is catching defects that would otherwise be caught later
in the software development lifecycle, leading to increased software
development costs.</p>
<p>When I interact with Rust's community of people, respect and empathy
abounds.</p>
<p>Does Rust have its problems and limitations? Of course it does: nothing is
perfect! But in my opinion, its trade-offs are often strictly better than
those found in other programming languages I've used.</p>
<p>At the end of the day, Rust is a programming language and therefore a tool.
Adept professionals know not to get too attached to your tools: ultimately
it is the value you deliver, not how you deliver it. (Of course the choice
of tools can significantly impact the quality and timeline of value
delivery!) Will my thoughts on Rust and preferred languages change over time
as the landscape shifts: of course they will! But for the time being, <strong>Rust
brings so much to the table that its <em>competition</em> lacks that I'm overly
excited about Rust and its ability to advance the state of
software/programming and therefore the industry.</strong></p>
<p>In closing, my current CTO uses the phrase <em>commitment to craft</em> as a desired
mindset for their technical organization. That phrase translates to various
themes: higher quality / lower defect rate, build with the long-term in mind,
implement efficient solutions, etc. <strong>Like an artist reaches for a preferred
paintbrush or a chef for a preferred knife because their preferred tool enables
them to better express their craft, I feel that Rust often enables me to better
express the potential of my professional craft more than other programming languages.
I strongly feel that Rust predisposes software to higher quality outcomes - both
in terms of defect rate and run-time efficiency - while also reducing total
development and execution costs over the entire software development lifecycle.
That makes Rust my first choice language - my go-to tool - for many new
projects at this point in time. If you likewise value <em>commitment to craft</em>, I
urge you to explore Rust so that you too can better harness the potential
of our programming craft.</strong></p>
<p>But don't take my word on it, read what
<a href="https://kerkour.com/blog/rust-in-production-2021/">42 companies using Rust in production</a>
have to say.</p>]]></content:encoded>
    </item>
    <item>
      <title>Modern CI is Too Complex and Misdirected</title>
      <link>http://gregoryszorc.com/blog/2021/04/07/modern-ci-is-too-complex-and-misdirected</link>
      <pubDate>Wed, 07 Apr 2021 09:00:00 PDT</pubDate>
      <category><![CDATA[CI]]></category>
      <category><![CDATA[build system]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2021/04/07/modern-ci-is-too-complex-and-misdirected</guid>
      <description>Modern CI is Too Complex and Misdirected</description>
      <content:encoded><![CDATA[<p>The state of CI platforms is much stronger than it was just a few years ago.
Overall, this is a good thing: access to powerful CI platforms enables
software developers and companies to ship more reliable software more
frequently, which benefits its users/customers. Centralized CI platforms
like GitHub Actions, GitLab Pipelines, and Bitbucket provide benefits of
scale, as the Internet serves as a collective information repository for
how to use them. Do a search for <em>how to do X on CI platform Y</em> and
you'll typically find some code you can copy and paste. Nobody wants to
toil with wrangling their CI configuration after all: they just want
to ship.</p>
<h2>Modern CI Systems are Too Complex</h2>
<p>The advancements in CI platforms have come at a cost: increased complexity.
And the more I think about it, <strong>I'm coming around to the belief that
modern CI systems are too complex</strong>. Let me explain.</p>
<p>At its core, a CI platform is a specialized <em>remote code execution as a
service</em> (it's a feature, not a CVE!) where the code being executed is
in pursuit of building, testing, and shipping software (unless you
<a href="https://dev.to/thibaultduponchelle/the-github-action-mining-attack-through-pull-request-2lmc">abuse it to mine cryptocurrency</a>).
So, CI platforms typically throw in a bunch of value-add features to enable
you to ship software more easily. There are vastly different approaches and
business models here. (I must tip my hat to GitHub Actions leveraging network
effects via community maintained <em>actions</em>: this lowers TCO for GitHub as they
don't need to maintain many <em>actions</em>, creates vendor lock-in as users develop
a dependence on platform-proprietary <em>actions</em>, all while increasing the
value of the platform for end-users - a rare product trifecta.) A common
value-add property of CI platforms is some kind of configuration file
(often YAML) which itself offers common functionality, such as configuring
the version control checkout and specifying what commands to run. This is
where we start to get into problems.</p>
<p>(I'm going to focus on GitHub Actions here, not because they are the worst
(far from it), but because they seem to be the most popular and readers can
relate more easily. But my commentary applies to other platforms like GitLab
as well.)</p>
<p>The YAML configuration of modern CI platforms is... powerful. Here are features
present in <a href="https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions">GitHub Actions workflow YAML</a>:</p>
<ul>
<li>An embedded templating system that results in the source YAML being
  expanded into a final YAML document that is actually evaluated. This
  includes a custom <a href="https://docs.github.com/en/actions/reference/context-and-expression-syntax-for-github-actions">expression mini language</a>.</li>
<li>Triggers for when to run jobs.</li>
<li>Named variables.</li>
<li>Conditional job execution.</li>
<li>Dependencies between jobs.</li>
<li>Defining Docker-based run-time environment.</li>
<li>Encrypted secrets.</li>
<li>Steps constituting each job and what actions those steps should take.</li>
</ul>
<p>If we expand scope slightly to include actions maintained by GitHub, we also have
steps/actions features for:</p>
<ul>
<li>Performing Git checkouts.</li>
<li>Storing artifacts used by workflows/jobs.</li>
<li>Caching artifacts used by workflows/jobs.</li>
<li>Installing common programming languages and environments (like Java, Node.js,
  Python, and Ruby).</li>
<li>And a whole lot more.</li>
</ul>
<p>And then of course there are 3rd party Actions. And there's a lot of them!</p>
<p>There's a lot of functionality here and a lot of it is arguably necessary:
I'm hard pressed to name a feature to cut. (Although I'm no fan of using YAML
as a programming language but I concede it use is a fair compromise compared
to forcing people to write code to produce YAML or make equivalent API calls
to do what the YAML would do.) All these features seem necessary for a
sufficiently powerful CI offering. Nobody would use your offering if it didn't
offer turnkey functionality after all.</p>
<p>So what's my complaint?</p>
<p>I posit that <strong>a sufficiently complex CI system becomes indistinguishable from
a build system</strong>. I challenge you: try to convince me or yourself that GitHub
Actions, GitLab CI, and other CI systems aren't build systems. The basic
primitives are all there. GitHub Actions Workflows comprised of jobs comprised
of steps are little different from say Makefiles comprised of rules comprised
of commands to execute for that rule, with dependencies gluing everything
together. The main difference is the <em>form factor</em> and the execution model (build
systems are traditionally local and single machine but CI systems are
remote/distributed).</p>
<p>Then we have a similar conjecture: <strong>a sufficiently complex build system becomes
indistinguishable from a CI system</strong>. Earlier I said that CI systems are
<em>remote code execution as a service</em>. While build systems are historically
things that run locally (and therefore not a <em>service</em>), modern build systems
like Bazel (or Buck or Gradle) are completely different animals. For example,
Bazel has
<a href="https://docs.bazel.build/versions/master/remote-execution.html">remote execution</a>
and
<a href="https://docs.bazel.build/versions/master/remote-caching.html">remote caching</a> as
built-in features. Hey - those are built-in features of modern CI systems too!
<strong>So here's a thought experiment: if I define a build system in Bazel and then
define a server-side Git push hook so the remote server triggers Bazel to build,
run tests, and post the results somewhere, is that a CI system? I think it is!</strong>
A crude one. But I think that qualifies as a CI system.</p>
<p><strong>If you squint hard enough, sufficiently complex CI systems and sufficiently
complex build systems start to look like the same thing to me.</strong> At a very high
level, both are providing a pool of servers offering general compute/execute
functionality with specialized features in the domain of building/shipping software,
like inter-task artifact exchange, caching, dependencies, and a frontend language
to define how everything works.</p>
<p>(If you squint really hard you can start to see a value proposition of Kubernetes
for even more general compute scheduling, but I'm not going to go that far in this
post because it is a much harder point to make and I don't necessarily believe in
it myself. But I thought I'd mention it as an interesting thought experiment. But
an easier leap to make is to throw batch job execution (as is often found in data
warehouses) in with build and CI systems as belonging in the same bucket: batch
job execution also tends to have dependencies, exchange of artifacts between jobs,
and I think can strongly resemble a CI system and therefore a build system.)</p>
<p><strong>The thing that bugs me about modern CI systems is that I inevitably feel like
I'm reinventing a build system and fragmenting build system logic.</strong> Your CI
configuration inevitably devolves into a bunch of complex YAML with all kinds of
caching and dependency optimizations to keep execution time low and reliability
in check - just like your build system. You find yourself contorting your
project's build system to work in the context of CI and vice versa. You end up
managing two complex DAGs and platforms/systems instead of one.</p>
<p><strong>Because build systems are more generic than CI systems (I think a sufficiently
advanced build system can do a superset of the things that a sufficiently complex
CI system can do), that means that CI systems are redundant with sufficiently
advanced build systems. So going beyond the section title: CI systems aren't
too complex: they shouldn't need to exist. Your CI functionality should be an
extension of the build system.</strong></p>
<p>In addition to the redundancy argument, I think unified systems are more
user friendly. By integrating your CI system into your build system
(which by definition can be driven locally as part of regular development
workflows), you can expose the full power of the CI system to developers
more easily. Think running ad-hoc CI jobs without having to push your changes
to a remote server first, just like you can with <em>local</em> builds or tests. This
is huge for ergonomics and can drastically compress the cycle time for changes
to these systems (which are often brittle to change/test).</p>
<p>Don't get me wrong, aspects of CI systems not traditionally found in build
systems (such as centralized results reporting and a UI/API for (re)triggering
jobs) absolutely need to exist. Instead, it is the remote compute and work
definition aspects that are completely redundant with build systems.</p>
<p>Let's explore the implications of build and CI systems being more of the
same.</p>
<h2>Modern CI Offerings are Targeting the Wrong Abstraction</h2>
<p>If you assume that build and CI systems can be / are more of the same, then it
follows that many modern CI offerings like GitHub Actions, GitLab CI, and
others are targeting the wrong abstraction: they are defined as domain
specific platforms for running CI systems when instead they should take a step
back and target the broader general compute platform that is also needed for
build systems (and maybe batch job execution, such as what's commonly found
in data warehouses/pipelines).</p>
<p>Every CI offering is somewhere different on the spectrum here. I would
go so far as to argue that GitHub Actions is more a <em>CI product</em> than a
<em>platform</em>. Let me explain.</p>
<p>In my ideal <em>CI platform</em>, I have the ability to schedule an ad-hoc graph of
tasks against that platform. I have the ability to hit some APIs with definitions
of the tasks I want that platform to run and it accepts them, executes them,
uploads artifacts somewhere, reports task results so dependent tasks can execute,
etc.</p>
<p>There is a <a href="https://docs.github.com/en/rest/reference/actions">GitHub Actions API</a>
that allows you to interact with the service. But the critical feature it
doesn't let me do is define ad-hoc units of work: the actual <em>remote execute
as a service</em>. Rather, the only way to define units of work is via workflow YAML
files checked into your repository. That's so constraining!</p>
<p>GitLab Pipelines is a lot better. GitLab Pipelines supports features like
<a href="https://docs.gitlab.com/ee/ci/parent_child_pipelines.html">parent-child pipelines</a>
(dependencies between different pipelines),
<a href="https://docs.gitlab.com/ee/ci/multi_project_pipelines.html">multi-project pipelines</a>
(dependencies between different projects/repos), and
<a href="https://docs.gitlab.com/ee/ci/parent_child_pipelines.html#dynamic-child-pipelines">dynamic child pipelines</a>
(generate YAML files in pipeline job that defines a new pipeline). (I don't
believe GitHub Actions supports any of these features.) Dynamic child
pipelines are an important feature, as they mostly divorce the checked-in YAML
configuration from the <em>remote execute as a service</em> feature. The main missing
feature here is a generic API that allows you achieve this functionality without
having to go through a parent pipeline / YAML first. If that API existed, you
could build your own build/CI/batch execute system on top of GitLab Pipelines
with fewer constraints imposed on you by GitLab Pipeline's opinionated YAML
configuration files and the intended use of its creators. (Generally, I think
a good litmus test for a well-designed platform or tool is when its authors
are surprised by someone's unintended use for it. Of course this knife cuts
both ways, as sometimes people do undesirable things, like mine
cryptocurrency.)</p>
<p><strong>CI offerings like GitHub Actions and GitLab Pipelines are more products
than platforms because they tightly couple an opinionated configuration
mechanism (YAML files) and web UI (and corresponding APIs) on top of a
theoretically generic <em>remote execute as a service</em> offering.</strong> For me to
consider these offerings as platforms, they need to grow the ability to
schedule arbitrary compute via an API, without being constrained by the
YAML officially supported out of the box. GitLab is <em>almost</em> there (the
critical missing link is a <em>schedule an inline-defined pipeline</em> API). It
is unknown if GitHub is - or is even interested in - pursuing this
direction. (More on this later.)</p>
<h2>Taskcluster: The Most Powerful CI Platform You've Never Heard Of</h2>
<p>I wanted to just mention Taskcluster in passing as a counterexample to the
CI offerings that GitHub, GitLab, and others are pursuing. But I found myself
heaping praises towards it, so you get a full section on Taskcluster. This
content isn't critical to the overall post, so feel free to skip. But if
you want to know what a CI platform built for engineers looks like or you
are a developer of CI platforms and would like to read about some worthwhile
ideas to steal, keep reading.</p>
<p>Mozilla's <a href="https://docs.taskcluster.net/docs">Taskcluster</a> is a generic CI
platform originally built for Firefox. At the time it was conceived and
initially built out in 2014-2015, there was nothing else quite like it.
And I'm still not aware of anything that can match its raw capabilities.
There might be something proprietary behind corporate walls. But nothing
close to it in the open source domain. And even the proprietary CI platforms
I'm aware of often fall short of Taskcluster's feature list.</p>
<p><strong>To my knowledge, Taskcluster is the only publicly available, mega
project scale, true <em>CI platform</em> in existence.</strong></p>
<p>Germane to this post, one thing I love about Taskcluster is its core
primitives around defining execution units. The core execute primitive in
Taskcluster is a <a href="https://docs.taskcluster.net/docs/manual/tasks">task</a>.
Tasks are connected together to form a DAG. (This is not unlike how a
build system works.)</p>
<p>A <em>task</em> is created by issuing an API request to a <em>queue service</em>. That
API request essentially says <em>schedule this unit of work</em>.</p>
<p>Tasks are
<a href="https://docs.taskcluster.net/docs/reference/platform/queue/task-schema">defined</a>
somewhat generically, essentially as units of arbitrary compute along with metadata,
such as task dependencies, permissions/scopes that task has, etc. That
<a href="https://docs.taskcluster.net/docs/reference/workers/docker-worker/payload">unit of work</a>
has many of the primitives that are familiar to you if you use GitHub Actions,
GitLab Pipelines, etc: a list of commands to execute, which Docker image to
execute in, paths to files constituting artifacts, retry settings, etc.</p>
<p>Taskcluster has features far beyond what are offered by GitHub, GitLab, and
others today.</p>
<p>For example, Taskcluster offers an IAM-like
<a href="https://docs.taskcluster.net/docs/manual/tasks/scopes">scopes</a> feature that
moderates access control. Scopes control what actions you can perform, what
services you have access to, which runner features you can use (e.g. whether
you can use ptrace), which secrets you have access to, and more. As a concrete
example, Firefox's Taskcluster settings are such that the cryptographic
keys/secrets used to sign Firefox builds are inaccessible to untrusted tasks
(like the equivalent of tasks initiated by PRs - the <em>Try Server</em> in Mozilla
speak). Taskcluster is the only CI platform I'm aware of that has sufficient
protections in place to mitigate the fact that CI platforms are gaping <em>remote
code execution as a service</em> risks that can and should keep your internal
security and risk teams up at night. Taskcluster's security model makes
GitHub Actions, GitLab Pipelines, and other commonly used CI services look
like data exfiltration and software supply chain vulnerability factories by
comparison.</p>
<p>Taskcluster does support
<a href="https://docs.taskcluster.net/docs/reference/integrations/github/taskcluster-yml-v1">adding a YAML file to your repository to define tasks</a>.
However, because there's a generic scheduling API, you don't need to use it and
you aren't constrained by its features. You could roll your own
configuration/frontend for defining tasks: Taskcluster doesn't care because it is
a true <em>platform</em>. In fact, Firefox mostly eschews this Taskcluster YAML, instead
building out its own functionality for defining tasks. There's a pile of code
checked into the Firefox repository that when run will derive the thousands of
discrete tasks constituting Firefox's build and release DAG and will register the
appropriate sub-graph as Taskcluster tasks. (This also happens to be a
<a href="https://hg.mozilla.org/mozilla-central/file/tip/taskcluster/ci">pile of YAML</a>.
But the programming primitives and control flow are largely absent from YAML files,
making it a bit cleaner than the <em>YAML DSL</em> that e.g. GitHub and GitLab CI
YAML has evolved into.) This functionality is its own mini build system where
the Taskcluster platform is the execution/evaluation mechanism.</p>
<p>Taskcluster's model and capabilities are vastly beyond anything in GitHub
Actions or GitLab Pipelines today. There's a lot of great ideas worth copying.</p>
<p>Unfortunately, Taskcluster is very much a power user CI offering. There's no
centralized instance that anyone can use (unlike GitHub or GitLab). The learning
curve is quite steep. All that power comes at a cost of complexity. I can't in
good faith recommend Taskcluster to casual users. But if you want to host your
own CI platform, other CI offerings don't quite cut it for you, and you can
afford a few people to support your CI platform on an ongoing basis (i.e. your
total cost to operate CI including people and machines is &gt;$1M annually), then
Taskcluster is worth considering.</p>
<p>Let's get back to the post at hand.</p>
<h2>Looking to the Future</h2>
<p>In my ideal world there exists a single <em>remote code execution as a service</em>
platform purpose built for servicing both near real time and batch/delayed
execution. It is probably tailored towards supporting software development,
as those domain specific features set it apart from generic compute as a
service tools like Kubernetes, Lambda, and others. But something more
generic could potentially work.</p>
<p>The concept of a DAG is strongly baked into the execution model so you can
define execution units as a graph, capturing dependencies. Sure, you could
define isolated, ad-hoc units of work. But if you wanted to define a set
of units, you could do that without having to run a persistent agent to
coordinate execution through completion like build systems typically do.
(Think of this as <em>uploading your DAG to an execution service</em>.)</p>
<p>In my ideal world, there is a single DAG dictating all build, testing, and
release tasks. There is no DAG fragmentation at the build, CI, and other
batch execute boundaries. No N+1 system or configuration to manage and
additional platform to maintain because everything is unified. Economies
of scale applies and overall efficiency improves through consolidation.</p>
<p>The platform consists of pools of workers running agents capable of
performing work. There are probably pools for near real time / synchronous
RPC style invocations and pools for scheduled / delayed / asynchronous
execution. You can define your own worker pools and bring your own workers.
Advanced customers will likely throw autoscaling groups consisting of
highly ephemeral workers (such as EC2 spot instances) at these pools,
scaling capacity to meet demand relatively cheaply, terminating workers
and machines when capacity is no longer needed to save on billing
costs (this is what Firefox's Taskcluster instance has been doing for at
least 6 years).</p>
<p>To end-users, a <em>local build</em> consists of driving or scheduling the subset
of the complete task graph necessary to produce the build artifacts you
need. A <em>CI build/test</em> consists of the subset of the task graph necessary
to achieve that (it is probably a superset of the <em>local build</em> graph). Same
for releasing.</p>
<p>As for the configuration frontend and how execution units are defined, this
platform only needs to provide a single thing: an API that can be used to
schedule/execute work. However, for this product offering to be user-friendly,
it should offer something like YAML configuration files like CI systems do
today. That's fine: many (most?) users will stick to using the simplified
YAML interface. Just as long as power users have an escape/scaling vector
and can use the low-level schedule/execute API to write their own driver.
People will write plug-ins for their build systems enabling it to integrate
with this platform. Someone will coerce existing extensible build systems
like Bazel, Buck, and Gradle to convert nodes in the build graph to
compute tasks in this platform. This unlocks the unification of the build
and CI systems (and maybe things like data pipelines too).</p>
<p>Finally, because we're talking about a specialized system tailored for
software development, we need robust result/reporting APIs and interfaces.
What good is all this fancy distributed remote compute if nobody can see
what it is doing? This is probably the most specialized service of the bunch,
as how you track results is exceptionally domain specific. Power users may
want to build their own result tracking service, so keep that in mind. But
the platform should provide a generic one (like what GitHub Actions and GitLab
Pipelines do today) because it is a massive value add and few will use
your product without such a feature.</p>
<p>Quickly, my proposed unified world will not alleviate the CI complexity concerns
raised above: sufficiently large build/CI systems will always have an intrinsic
complexity to them and possibly require specialists to maintain. However,
because a complex CI system is almost always attached to a complex build system,
by consolidating build and CI systems, you reduce the surface area of complexity
(you don't have to worry about build/CI interop as much). Lower fragmentation
reduces overall complexity, and is therefore a new win. (A similar line of
thinking applies to justifying monorepositories.)</p>
<p><strong>All of the components for my vision exist in some working form today.</strong>
Bazel, Gradle Enterprise, and other modern build systems have RPCs for
remote execute and/or caching. They are even extensible and you can write
your own plugins to change core functionality for how the build system runs
(to varying degrees of course). CI offerings like Taskcluster and GitLab
Pipelines support scheduling DAGs of tasks (with Taskcluster's support far
more suited for the desired end state). There are batch job execution
frameworks like Airflow that look an awful lot like a domain-specific,
specialized versions of Taskcluster. <strong>What we don't have a is a single
product or service with all these features bundled as a cohesive offering.</strong></p>
<p><strong>I'm convinced that building what I'd like to see is not a question of
<em>if it can be done</em> but <em>whether we should</em> and <em>who will do it</em>.</strong></p>
<p>And this is where we probably run into problems. I hate to say it, but
I'm skeptical this will exist as a widely available service outside a few
corporations' walls any time soon. The reason is the total addressable market.</p>
<p>The value of my vision is through unification of discrete systems (build,
CI, and maybe some one-offs like data pipelines) that are themselves
complex enough that unification is something you'd want to do for
business/efficiency reasons. After all, if it isn't complex/inefficient,
you probably don't care about making it simpler/faster. Right here we
are probably filtering out &gt;90% of the market because their systems
just aren't complex enough for this to matter.</p>
<p>This vision requires adoption of a sufficiently advanced build system so it
can serve as the brains behind a unified DAG driving remote execute. Some
companies and projects will adopt compatible, advanced build systems like Bazel
because they have the resources, technical know-how, and efficiency incentives
to pull it off. But many won't. The benefit of a more advanced build system
over something simpler is often marginal. Factor in that many companies perceive
build and CI support as product development overhead and a virtual cost center
whose line item needs to be minimized. If you can get by on a less advanced
build system that is <em>good enough</em> for a fraction of the cost without excessive
hardship, that's the path many companies and projects will follow. Again,
people and companies generally don't care about wrangling build and CI
systems: they just want to ship.</p>
<p>The total addressable market for this idea seems too small for me to see
any major player with the technical know-how to implement and offer such
a service in the next few years. After all, we're not even over the hurdle
that what I propose (unifying build and CI systems) is a good idea. Having
worked in this space for a decade, witnessed the potential of Taskcluster's
model, and seen former, present, and potential employers all struggling in
this space to varying degrees, I know that this idea would be extremely
valuable to some. (For some companies multiple millions of dollars could be
saved annually by eliminating redundant human capital maintaining similar
systems, reducing machine idle/run costs, and improving turnaround times of
critical development loops.) As important as this would be to some companies,
my intuition is they represent such a small sliver of the total addressable
market that this slice of pie is too small for an existing CI operator like
GitHub or GitLab to care about at this time. There are far more lucrative
opportunities. (Such as security scanning, as laws/regulation/litigation are
finally catching up to the software industry and forcing companies to take
security and privacy more seriously, which translates to spending money on
security services. This is why GitHub and GitLab have been stumbling over
each other to announce new security features over the past 1-2 years.)</p>
<p>I don't think a startup in this area would be a good idea: customer acquisition
is too hard. And because much of the core tech already exists in existing tools,
there's not much of a moat in the way of proprietary IP to keep copycats
with deep pockets at bay. Your best exit here is likely an early acquisition
by a Microsoft/GitHub, GitLab, or wannabe player in this space like Amazon/AWS.</p>
<p>Rather, I think our best hope for seeing this vision realized is an operator
of an existing major CI platform (either private or public) who also has major
build system or other ad-hoc batch execute challenges will implement it and
release it upon the world, either as open source or as a service offering.
GitHub, GitLab, and other code hosting providers are the ideal candidates since
their community effect could help drive industry adoption. But I'd happily
accept pretty much any high quality offering from a reputable company!</p>
<p>I'm not sure when, but my money is on GitHub/Microsoft executing on this vision
first. They have a stronger incentive in the form of broader market/product
tie-ins (think integrated build and CI in Visual Studio or GitHub Workspaces
[for Enterprises]). Furthermore, they'll feel the call from within. Microsoft
has some really massive build systems and CI challenges (notably Windows). It
is clear that elements of Microsoft are conducting development on GitHub, in
the open even (at this point Satya Nadella's Microsoft has frozen over so many
levels of hell that Dante's classics need new revisions). Microsoft engineers
will feel the pain and limitations of discrete build and CI systems. Eventually
there will be calls for at least a build system remote execute service/offering
on GitHub. (This would naturally fall under GitHub's existing apparent market
strategy of capturing more and more of the software development lifecycle.) My
hope is GitHub (or whomever) will implement this as a unified
platform/service/product rather than discrete services because as I've argued
they are practically the same problem. But a unified offering isn't the path of
least resistance, so who knows what will happen.</p>
<h2>Conclusion</h2>
<p>If I could snap my fingers and move industry's discrete build, CI, and
maybe batch execute (e.g. data pipelines) ahead 10 years, I would:</p>
<ol>
<li>Take Mozilla's Taskcluster and its best-in-class specialized <em>remote execute
  as a service</em> platform.</li>
<li>Add support for a real-time, synchronous execute API (like Bazel's remote
   execute API) to supplement the existing batch/asynchronous functionality.</li>
<li>Define Starlark dialects so you define CI/release like primitives in build
   tools like Bazel. (You could also do YAML here. But if your configuration
   files devolve into DSL, just use a real programming language already.)</li>
<li>Teach build tools like Bazel to work better when units of work that can
   take minutes or even hours to run (a synchronous/online driver model such
   as classically employed by build systems isn't appropriate for long-running
   test, release, or say data pipelines).</li>
<li>Throw a polished web UI for platform interaction, result reporting, etc on
   top.</li>
<li>Release it to the world.</li>
</ol>
<p>Will this dream become a reality any time soon? Probably not. But I can dream.
And maybe I'll have convinced a reader to pursue it.</p>]]></content:encoded>
    </item>
    <item>
      <title>Surprisingly Slow</title>
      <link>http://gregoryszorc.com/blog/2021/04/06/surprisingly-slow</link>
      <pubDate>Tue, 06 Apr 2021 07:00:00 PDT</pubDate>
      <category><![CDATA[Programming]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2021/04/06/surprisingly-slow</guid>
      <description>Surprisingly Slow</description>
      <content:encoded><![CDATA[<p>I have an affinity for performance optimization and making software as
efficient as possible. Over the years, I've encountered specific instances
and common patterns that make software or computers slow. In this post,
I'll shine a spotlight on some of them.</p>
<p>I'm titling this post <em>Surprisingly Slow</em> because the slowness was either
surprising to me or the sub-optimal practices leading to slowness are
prevalent enough that I think many programmers would be surprised by
their existence.</p>
<p>The sections below are largely independent. So feel free to cherry pick
the ones that interest you.</p>
<h1>Environment Detection in Build Systems (e.g. configure and cmake)</h1>
<p>This is the topic that inspired this post.</p>
<p>Build systems often feature an <em>environment detection</em> / <em>configuration</em>
phase before the <em>build phase</em>. In UNIX land, autoconf generated <code>configure</code>
scripts are prevalent. CMake is also popular. These tools run a bunch of code
to probe the state of the current system so that the build configuration is
appropriate for the current build environment. For example, they'll probe for
which compiler to use, its version, and what bugs and capabilities it has.</p>
<p>This environment detection and configuration is a necessary evil because
machines and environments often vary substantially and you need to account
for those variances.</p>
<p><strong>The problem is that this configuration step often takes longer to run than
the build itself!</strong> Build systems for small programs or libraries will often
spend 10+ seconds running <code>configure</code> and complete the actual compilation
and linking in a fraction of that time. In other words, the setup to perform
the build takes longer than the build itself!</p>
<p>Depending on how many CPU cores you have, the discrepancy may not be obvious.
But I have a 16 core / 32 thread Ryzen 5950X as my primary PC and the relative
slowness of the configuration step is painful to observe.</p>
<p><strong>What I find even more shocking is that <em>configuration</em> time often still
eclipses actual build time even for large projects.</strong> I'm not sure if this
is still true, but a few years ago Mozilla observed that building LLVM/Clang
on a 96 vCPU EC2 instance resulted in more time spent in cmake/configuring
than compiling and linking! And that's a very large C++ project with thousands
of source files being compiled!</p>
<p>Build configuration is often a discrete step that executes serially before
what most people consider the actual build. To improve efficiency, build
configuration needs to be parallelized. Even better, it should be integrated
into the main build DAG itself so parts of the build can start running without
having to wait for all build configuration. Unfortunately, many common tools
performing build configuration can't easily be adapted to this model. So there's
not much many of us can do.</p>
<p>Another solution to this problem is avoiding the problem of environment detection
in the first place. If you have deterministic and reproducible build
environments, you can take a lot of shortcuts to skip environment detection
that just isn't needed any more. This is more or less the approach of modern
build tools like Bazel. I do wonder how much of the speed gains from tools
like Bazel are due to eliminating environment configuration. I suspect it is
a lot!</p>
<h1>New Process Overhead on Windows</h1>
<p>New processes on Windows can't be spawned as quickly as they can on POSIX
based operating systems, like Linux. On Windows, assume a new process will
take 10-30ms to spawn. On Linux, new processes (often via <code>fork()</code> + <code>exec()</code>
will take single digit milliseconds to spawn, if that).</p>
<p>However, thread creation on Windows is very fast (~dozens of microseconds).</p>
<p>These
<a href="https://stackoverflow.com/questions/10710912/what-is-the-process-creation-overhead-in-windows">Stack</a>
<a href="https://stackoverflow.com/questions/47845/why-is-creating-a-new-process-more-expensive-on-windows-than-linux">Overflow</a>
have some more details.</p>
<p>A few dozen milliseconds is an eternity in CPU time. And it is long enough
that it eats into a large percentage of the time budget for people to perceive
something as instantaneous. So this may contribute to the perception that
<em>Windows is slower than Linux</em>.</p>
<p>If your program architecture consists of spawning new processes left and
right (this is common in UNIX land), this can pose performance problems on
Windows, as the overhead of new process creation on Windows can really add
up:</p>
<ul>
<li>10ms * 1,000 invocations = 10s</li>
<li>20ms * 10,000 invocations = 200s</li>
<li>30ms * 100,000 invocations = 3,000s</li>
</ul>
<p>Using the example of configure above, configure files are often shell
scripts. And shell scripts often do a lot of their work by spawning other
processes like <code>grep</code>, <code>sed</code>, and <code>sort</code>. Even the <code>[</code> operator could be a
new process (seriously: there's probably a <code>/usr/bin/[</code> executable in your
POSIX environment). (Although <code>[</code> might be a shell built-in.) Command
pipe chains (e.g. <code>command | grep | awk</code>) spawn multiple processes serially
and can be visually slow to run. Anyway, it is not uncommon for a configure
script to spawn thousands of new processes. Assuming 10ms per process, at
1,000 invocations that is 10s of overhead just spawning new processes! This
further exacerbates the problem in the previous section!</p>
<p>If your software runs on Windows, consider the impact that relatively
slow process spawning will have. Consider a multi-threaded architecture
or using longer-lived daemon/background processes instead.</p>
<h1>Closing File Handles on Windows</h1>
<p>Many years ago I was profiling Mercurial to help improve the working
directory checkout speed on Windows, as users were observing that checkout
times on Windows were much slower than on Linux, even on the same machine.</p>
<p>I thought I could chalk this up to NTFS versus Linux filesystems or
general kernel/OS level efficiency differences. What I actually learned
was much more surprising.</p>
<p>When I started profiling Mercurial on Windows, I observed that most I/O
APIs were completing in a few dozen microseconds, maybe a single millisecond
or two ever now and then. Windows/NTFS performance seemed great!</p>
<p>Except for <code>CloseHandle()</code>. These calls were often taking 1-10+ milliseconds
to complete. It seemed odd to me that file writes - even sustained file writes
that were sufficient to blow past any write buffering capacity - were fast
but closes slow. It was even more perplexing that <code>CloseHandle()</code> was slow
even if you were using completion ports (i.e. async I/O). This behavior for
completion ports was counter to what the MSDN documentation said should happen
(the function should return immediately and its status can be retrieved later).</p>
<p>While I didn't realize it at the time, the cause for this was/is Windows
Defender. Windows Defender (and other anti-virus / scanning software)
typically work on Windows by installing what's called a filesystem filter
driver. This is a kernel driver that essentially hooks itself into the kernel
and receives callbacks on I/O and filesystem events. It turns out the <em>close
file</em> callback triggers scanning of written data. And this scanning appears
to occur synchronously, blocking <code>CloseHandle()</code> from returning. This adds
milliseconds of overhead. The net effect is that file mutation I/O on Windows
is drastically reduced by Windows Defender and other A/V scanners.</p>
<p>As far as I can tell, as long as Windows Defender (and presumably other A/V
scanners) are running, there's no way to make the Windows I/O APIs consistently
fast. You can disable A/V scanning (at your own peril). But the trick that
Mercurial <a href="https://www.mercurial-scm.org/repo/hg/rev/2fdbf22a1b63f7b4c94393dbf45ad417da257fe0">employs</a>
(which has later been emulated by rustup among other tools) is to use a
thread pool for calling <code>CloseHandle()</code>. Even if you perform all file
open and write I/O on a single thread and use a background thread pool only
for calling <code>CloseHandle()</code>, you can see a &gt;3x speedup in time to write files.
<strong>This optimization should ideally be employed by any software that creates
or mutates as little as a few hundred files on Windows.</strong> This includes
version control tools, installers, and archive extraction tools. Fun fact:
<code>rustup</code> can extract tar files on Windows faster than open source and commercial
<em>fast</em> extraction/copy tools because it employs this trick and more. I believe
<code>rustup</code> on Windows is actually faster at extracting tar archives than it is
on Linux!</p>
<p>The artificial I/O latency added by scanning software such as Windows Defender
is super annoying. But the performance gains from working around it by using
a thread pool for background is often worth the complexity. I have no doubt
that if this optimization were baked into popular Windows tools (namely
installers), people would be shocked by how much faster things could be.</p>
<h1>Writing to Terminals</h1>
<p>As a maintainer of Firefox's build system, I fielded a handful of reports
from people complaining about builds being slower than their peers on
identical hardware. While there are many causes for this, one of the most
surprising was the impact the terminal has on build performance.</p>
<p>Writing to the terminal is usually fast. Until it isn't.</p>
<p>What I learned is that writing tons of output or getting clever with
writing to the terminal (e.g. writing colors, moving the cursor position
to write over existing content) can drastically slow down applications.</p>
<p>Writing to the terminal via stderr/stdout is likely performed via blocking
I/O. So if the thing handling your <code>write()</code> (the terminal emulator) doesn't
finish its handling promptly, your process just sits around waiting on
the terminal to do its thing.</p>
<p>We discovered that different terminals have their own quirks. Historically,
the Windows Command Prompt and the built-in Terminal.app on macOS were
very slow at handling tons of output. I remember (but can't find the bug or
commit to Firefox) when we made the build system quiet by default and that
reduced build times by <em>minutes</em> in some configurations.</p>
<p>A few years ago, npm infamously had a
<a href="https://github.com/npm/npm/issues/11283">performance sucking progress spinner</a>.
While I'm not sure how much of this was terminal slowness versus calling
progress update code too frequently, the terminal likely played a part because
terminals do have a limit to how often they can accept input to draw.</p>
<p>I've found that modern terminals are better about writing a ton of plain text
than they were in ~2012, when I was tackling these problems in Firefox's build
system. But I would still exercise extreme caution when doing fancy things
with the terminal, like coloring text, drawing footers, etc. Always use buffered
I/O to minimize the number of <code>write()</code> actually going to the terminal, flushing
as needed (hopefully sparingly). Consider using an async thread for writing to
stdout/stderr. Record the total time spent in blocking I/O to stdout/stderr so you
can measure terminal I/O latency. And periodically compare the wall time delta
between stdout/stderr connected to a terminal and /dev/null when running your
program to see if there is a discrepancy worth caring about. Finally, consider
throttling writes to the terminal. Instead of writing a footer after every line
of output, consider buffering lines for a few milliseconds and emitting all
lines plus the new footer in batches. If drawing a progress bar or spinner or
something of that nature, I would limit drawing to ~10 Hz to minimize
terminal overhead.</p>
<h1>Thermal Throttling / ACPI C/P-States / Processor Throttling Behavior</h1>
<p>We like to think that a computer and its processors are either on or off.
If only things were that simple.</p>
<p>Processors are constantly changing their operating envelope as they are
running. The following statements are all true (although not every item applies
to all machines or CPU models):</p>
<ul>
<li>The MHz each CPU core is running at can fluctuate wildly from 1 second to
  the next.</li>
<li>CPU cores may go to sleep or enter a very low power mode, even if others are
  running.</li>
<li>Cores may underclock significantly if temperature goes beyond a threshold.
  They may refuse to run faster until the temperature drops. Faulty sensors
  can lead to premature behavior.</li>
<li>Cores may only reach their maximum frequency if other cores are also
  running. The physical proximity of that other core may matter.</li>
<li>It could take dozens, hundreds, or even thousands of milliseconds for an
  idling core to ramp up to its full speed.</li>
<li>The behavior of power scaling can vary substantially depending on whether
  a machine is connected to external power or running off the battery.</li>
<li>The behavior of power scaling can vary substantially depending on whether
  the battery is fully charged or nearly empty.</li>
<li>Apple laptops may exhibit thermal throttling when
  <a href="https://apple.stackexchange.com/questions/363337/how-to-find-cause-of-high-kernel-task-cpu-usage">charging from the left side</a>.
  (Yes, seriously: always charge your MacBook Pro from the right. And if
  your employees use Apple laptops for CPU heavy tasks, consider an awareness
  campaign to encourage charging from the right side. Even better, deploy
  software that checks for left side charging and alert accordingly. Although
  I have yet to find any software or API to detect this.)</li>
<li>A core may slow down in order to process certain instructions (like
  <a href="https://travisdowns.github.io/blog/2020/01/17/avxfreq1.html">AVX-512</a>).</li>
</ul>
<p>Modern CPUs are really dynamic beasts and their operating behavior is often
seemingly unpredictable. Furthermore, CPU models can vary from one to the
next. For example, an EPYC or Xeon processor will likely behave differently
from a Ryzen or Core i7/i9 which will behave differently depending on
whether you are running in a desktop or laptop. (I observed a few years ago
that Xeon cores won't turbo as <em>easily</em> as consumer grade CPUs.)</p>
<p>Power fluctuations and their impact on performance are one of the reasons
why it is extremely difficult to conduct proper benchmarks. When
benchmarking, you need to control the power variable or at least report its
state so results are qualified appropriately. I am very skeptical of benchmark
results that don't report the power configuration/methodology (this is
most of them, sadly) and especially of benchmarks conducted on laptops, as
battery operated devices are much more susceptible to power throttling than
desktops or servers.</p>
<p>I have personally had a MacBook Pro become thermal throttled because an
internal screw came loose and blocked a fan from spinning. macOS didn't
warn me: all I knew was that my Firefox builds become 2-3x slower for no
apparent reason! I have also observed my MacBook Pro becoming hot due to
left side charging. Charging from the right magically made things faster.</p>
<p>At Mozilla, when we started rolling out Xeon desktops to employees,
we had reports of wildly varying build speeds. On some operating systems
(Mozilla had very lax central machine provisioning and allowed people full
domain of their company issued hardware), the default ACPI C/P-States were
such that CPU cores were scaling differently.</p>
<p>What we observed was the <em>compile</em> phase of the build was fine. But some
people were reporting linking times 2-4x longer (dozens of seconds to minutes)
than others on equivalent configurations! This was a big deal because the wall
time of an incremental/non-full build is dominated by linking time. We
eventually discovered that on the slow machines, the CPU core doing the linking
was only running at 25-50% of its potential. Think 1.0-1.5 GHz. But if you
started additional CPU heavy tasks, that core ramped up. We discovered that
different operating systems had different defaults for the ACPI C/P-States.
The more conservative settings would result in CPU cores not scaling their
frequency unless there was sufficient CPU load to merit it. Changing to more
aggressive power settings ensured better and consistent results.</p>
<p>Laptops are highly susceptible to thermal throttling and aggressive power
throttling to conserve battery. I hold the general opinion that laptops are
just too variable to have reliable performance. Given the choice, I want
CPU heavy workloads running in controlled and observed desktops or server
environments.</p>
<p>But servers aren't immune: their ACPI C-State and P-State settings can
drastically impact performance. Dialing these up to max so all the cores
run at full (or are ready to run at full in a few milliseconds) is possible.
However, this may greatly increase your power consumption. You can do this
on some cloud providers (like AWS) for no additional direct cost to you.
However, higher energy consumption is bad for the environment. Data centers
already have a
<a href="https://www.datacenterknowledge.com/energy/study-data-centers-responsible-1-percent-all-electricity-consumed-worldwide">carbon footprint about the size of the airline industry</a>
(during non-pandemic times) and that footprint is growing. So think about
your ethical responsibilities to the environment before having your server
fleet consume potentially megawatts more power.</p>
<h1>Python, Node.js, Ruby, and other Interpreter Startup Overhead</h1>
<p>Complex systems will often execute Python, Node.js, and other interpreters
thousands or more times during their execution. For example, the Firefox
build system invokes thousands of Python processes performing common tasks,
such as wrapping the compiler invocation. And the Mercurial test harness invokes
thousands of Python processes by running <code>hg</code> as part of its testing. I've
heard of similar stories involving Node.js, Ruby, and other interpreters,
often in the context of use in build systems.</p>
<p>An oft ignored fact about launching a new interpreter process is that each
invocation often takes single to dozens of milliseconds to initialize the
interpreter. i.e. the new process spends time at the beginning of process
execution just getting to the code you are telling it to run. Sometimes the
new process overhead is so bad that the slowdown is obvious and rules out
the use of a technology. The JVM historically has been notorious for this,
which is why use of Java typically entails fewer, longer-running processes
over more, domain-limited processes.</p>
<p>I've <a href="https://mail.python.org/pipermail/python-dev/2018-May/153296.html">written</a>
<a href="https://mail.python.org/pipermail/python-dev/2014-May/134528.html">about</a>
Python's startup overhead before. In 2014 I measured that Mercurial's test
harness spends 10-18% of its total CPU time just getting to the point where
the interpreter/process can run custom bytecode and 30-38% of its total CPU
time getting to the point where Mercurial performs command dispatch
(additional time here is mostly module importing overhead).</p>
<p>You may think that a few milliseconds of overhead can't matter that much.
But if you multiply by 1,000, 10,000, 100,000 or more, milliseconds matter:</p>
<ul>
<li>1ms * 1,000 invocations = 1s</li>
<li>10ms * 10,000 invocations = 100s</li>
<li>100ms * 100,000 invocations = 10,000s (2.77 hours)</li>
</ul>
<p>On Windows, this problem is compounded because of it relatively slow new
process startup (see section above).</p>
<p>Programmers need to think long and hard about your process invocation model.
Consider the use of fewer processes and/or consider alternative programming
languages that don't have significant startup overhead if this could become
a problem (anything that compiles down to assembly is usually fine).</p>
<h1>Pretty Much all Storage I/O</h1>
<p>Of my general affinity for performance optimization, I have a special
affinity for I/O optimization. I think the main reason is that the disconnect
between the potential for modern storage devices and what is actually
achieved is so wide. On paper, software should be getting ~10x the
performance from modern storage devices than what we typically see.</p>
<p>Modern storage devices are absurdly fast. The NVMe storage in my primary
PC can sustain reads at &gt;3 GB/s (&gt;6 GB/s sequential), writes at ~1
GB/s (4+ GB/s sequential), can perform &gt;500,000 I/O operations per
second, and can service many I/O operations in the ~10 microsecond latency
range. Modern NVMe storage is roughly on par with the performance of DDR2
DRAM (launched in 2003) in terms of throughput (latency still trails but
~10us is nothing to scoff at).</p>
<p>For comparison, the 1 TB Western Digital Caviar Black spinning disk I
retired from my PC a few weeks ago can only do ~90 MB/s sequential reads
and writes, 1-2 MB/s random reads and writes, ~12 ms access times. I'm unsure
what IOPS is, but considering ~12 ms access times and the physical
nature of spinning disks, it can't be more than a few hundred.</p>
<p>Modern NVMe storage is 1.5-3 <strong>magnitudes</strong> faster than the best
spinning disks from little over a decade ago. So why isn't all storage
I/O ~instantaneous?</p>
<p>The short answer is that most software fails to utilize the potential
of modern storage devices or even worse actively undermines it through
bad practices.</p>
<p>For the former, I'll refer you to the excellent
<a href="https://itnext.io/modern-storage-is-plenty-fast-it-is-the-apis-that-are-bad-6a68319fbc1a">Modern Storage is Plenty Fast. It is the APIs That are Bad</a>.
tl;dr you can harness the full power of your modern storage device
if you bypass the standard OS/kernel I/O primitives and issue I/O
operations directly against the device. So, software abstractions in
the OS/kernel are eating a lot of potential.</p>
<p>For the software undermining storage device potential aspect, I'll briefly
touch on the <code>fsync()</code> POSIX function. By calling this function, you effectively
say <em>be sure the state of this file descriptor is persisted to the storage
device</em> or <em>I don't want to lose any changes I've made</em>.</p>
<p>Data consistency and durability are important. But the cost to achieving
them can be absurdly high. And as it turns out, it is also subtly difficult
to do correctly in practice. I'll refer you to Dan Luu's excellent
<a href="https://danluu.com/file-consistency/">Files are Hard</a>. The papers linked
offer a sobering assessment. I'll reinforce the message with
<a href="https://lwn.net/Articles/752063/">PostgreSQL's fsync() surprise</a>, which
chronicles how PostgreSQL maintainers learned about how Linux can flat
out drop errors when performing device I/O, leading to data corruption.
Yikes!</p>
<p>Anyway, about <code>fsync()</code>. The concept of <code>fsync()</code> is sound: <em>ensure this
thing is persisted to the storage device</em>. But the implementation is often
a pile of inefficiency leading to slowness.</p>
<p>On many Linux filesystems (including ext4), the implementation of <code>fsync()</code>
is such that upon calls, <em>all</em> unflushed writes are persisted to storage.
So if process A writes out a 1 GB file and process B writes 1 byte to another
file and calls <code>fsync()</code> on that single byte write, Linux/ext4 will need to
write 1 GB to the storage device, not 1 byte. So on Linux/ext4, all it takes
is a random process somewhere to issue <code>fsync()</code> and all dirty page cache
entries need to be flushed. On most systems, there's usually something
continuously incurring write I/O, so the amount of storage device I/O incurred
by <code>fsync()</code> is almost always larger than just the mutated file/directory
you actually want persisted.</p>
<p>This behavior can cause a ton of problems. For starters, it artificially
increases I/O latency. You'd think that calling <code>fsync()</code> after a minimal
change would be ~instantaneous. But if there are lots of dirty pages to be
flushed, it could take seconds. At my current employer, we ran into this
exact problem with GitHub Enterprise, which has a monolithic architecture.
A MySQL database was running off the same ext4 filesystem as the Git
repositories. MySQL will call <code>fsync()</code> frequently to ensure transactions and
the transaction journal are persisted to storage. But if a Git GC were running
and Git just finished writing a multi-gigabyte packfile, MySQL's <code>fsync()</code> would
be stuck waiting on Git's large write to finish persisting. This led to
slowness of future MySQL transactions and even some application-level timeouts.
When people say databases and other stores should be isolated to their own
volumes/filesystems, <code>fsync()</code>'s wonky behavior is a big reason why.</p>
<p>Fortunately, newer versions of Linux/ext4 contain a
<a href="https://lwn.net/Articles/842385/">fast commits feature</a> that changes
behavior and enables more granular flushing of <code>fsync()</code> to storage, just
like it is documented to do. But as the feature is pretty new, it could
take a while to stabilize and make its way to distros. I can't wait for
it though!</p>
<p>Another problem with <code>fsync()</code> is that it is called more often than it
needs to be. Now, if you have mission critical data and need consistency
and durability, you should absolutely be calling <code>fsync()</code> appropriately.
But the reality is that many data workloads and machine environments don't
actually need strong data guarantees!</p>
<p>Take for example Kubernetes pods or CI runners. Or even servers for a
<em>stateless</em> service. Ask yourself, <em>what's the worst that could happen if
the machine loses power and there is data loss on the local filesystem?</em> In a
lot of scenarios the answer is <em>nothing</em>. You've designed your system to be
stateless and fault tolerant. You manage your servers as cattle. You treat local
filesystems as ephemeral. So if a machine fails, you provision a new one to
replace it. In these scenarios, <code>fsync()</code> buys you little to nothing but
can cost you a lot!</p>
<p>The cost of avoidable <code>fsync()</code> can be substantial. Combined with the
inefficient global flushing behavior of Linux/ext4, it can be a performance
sapper, especially on slower storage devices. Fortunately, there are
options. Many databases and other popular software has a way to prevent
the issuance of <code>fsync()</code>. If your data is ephemeral, consider disabling
<code>fsync()</code> for a likely significant performance boost! For software that
doesn't support disabling <code>fsync()</code>, the aptly named
<a href="https://www.flamingspork.com/projects/libeatmydata/">eatmydata</a> tool and
LD_PRELOAD library can be used to nerf <code>fsync()</code> and other similar
functionality by intercepting the function calls and making them no-op.
Last but not least, for ephemeral machines, consider building a patched
Linux kernel that turns <code>fsync()</code> and friends into no-ops. (I'm not sure
of anyone who does this. But I've considered it because getting eatmydata
to work in places like launched containers can be a bit of a pain.)</p>
<p>I'll close this section with a link to my favorite commit to the Firefox
repository: <a href="https://hg.mozilla.org/mozilla-central/rev/6b064f9f6e10b25bf2edc916b1b9a8b78cff0465">Disable Places during reftests, preventing 50 GB of I/O</a>.
While this commit goes beyond disabling <code>fsync()</code>, <code>fsync()</code> (and its
Windows equivalent) was responsible for some of the performance loss.
Excessive I/O and needless persisting of changes to device can really
sap performance. Storage software usually errors on the side of consistency
(this is the correct default in my opinion). Given the costs that consistency
imposes, you should seriously consider nerfing the guarantees and speeding
up I/O when that option is viable for you.</p>
<h1>Data Compression</h1>
<p>I could write an entire post on the topic of data compression and its
widespread suboptimal use. Here is the concise version.</p>
<p>At its core, data compression is a trade-off between CPU and I/O usage.
Typically it involves one of the following scenarios:</p>
<ol>
<li>I/O (either storage or network) is the bottleneck, so we want to trade
   more CPU to reduce I/O throughput.</li>
<li>At rest storage is expensive, so we want to trade more CPU for lower
   storage utilization/costs.</li>
</ol>
<p>Since the early days of computing, a maxim has been that storage is
slow and expensive compared to CPU. So trading CPU to reduce storage
utilization seemed like a solid bet.</p>
<p>Fast forward to 2021.</p>
<p>As I wrote in the previous section, modern storage I/O is absurdly fast.
It is also historically cheap.</p>
<p>Networks have also gotten faster. 1 gbps (125 MB/s) is pretty universal at
this point. 2.5 gbps (312 MB/s) is getting deployed in consumer and office
environments. 10 gbps (1250 MB/s) is common in data centers. And faster than
10 gbps is possible.</p>
<p>Meanwhile CPUs have somewhat plateaued in their single core <em>performance</em>
in the past decade. We've been <em>stuck</em> at ~4 GHz for years. All of the
performance gains from CPUs have come from adding more CPU cores to the package
and instructions per cycle (IPC) efficiency wins (we've also gotten some
agonizing security vulnerabilities like Spectre and Meltdown out of this IPC
work as well).</p>
<p>What this all means is that the relative performance difference between
CPUs and I/O has compressed significantly (pardon my pun). ~30 years ago,
CPUs ran at ~100 MHz and Internet was using dial-up at say 50 kbps, or 0.05 mbps,
or 6.25 kBps. That's 16,000 cycles per byte. Today, we're at ~4 GHz with say 1
Gbps / 125 MB/s networks. That's 32 cycles per byte, a decrease of 500x. (In
fairness, the ratio closes when you consider that we likely have &gt;1 CPU core
competing for I/O and factor in IPC gains. But we're still talking about the
relative difference in CPU and I/O decreasing by 1-1.5 magnitudes.) <strong>Years ago,
trading CPU to lessen the I/O load was often <em>obviously correct</em>. Today,
because of the advancements in I/O performance relative to CPU and a
substantially reduced cycles per I/O byte budget, the answer is a lot murkier.</strong></p>
<p>Not helping is the prevalence of ancient compression algorithms. DEFLATE - the
algorithm behind the ubiquitous zlib library and gzip data format - is ~30
years old. DEFLATE was designed in an era when computers had like 1 MB RAM and
100 MB hard drives. Different times.</p>
<p>DEFLATE/zlib became very popular in a world where I/O was much slower and
compression was often a necessity. Not using compression on a dial-up modem
resulted in massive performance differences! And because of its popularity in
the early days of the Internet, DEFLATE/zlib is available in the standard library
of many programming languages. It seems to be the first compression format people
reach for when someone says/thinks <em>add compression</em>.</p>
<p>The ubiquity of zlib is good from a dependency perspective: <em>everyone can read
zlib/gzip</em>. But for scenarios where you control the reader and writer, <strong>use of
zlib in 2021 constitutes negligence because its performance lags contemporary
solutions</strong>. Modern compression libraries (<a href="https://github.com/facebook/zstd">zstandard</a>
is my favorite) can yield substantially faster compression and decompression speed
while delivering better compression ratios in most data sets. My
2017 <a href="https://gregoryszorc.com/blog/2017/03/07/better-compression-with-zstandard/">Better Compression with Zstandard</a>
post dives into the numbers. (I've been meaning to revisit that post since zstandard
has since seen multiple 10+% speedups in subsequent releases, making it even more
compelling.) If you don't need the ubiquity of zlib (e.g. you control the writers
and readers), there's little reason to use zlib over something more modern.
Compared to zlib, modern compression libraries like zstandard are the closest thing to
magical pixie dust that you can sprinkle on your software for free performance.</p>
<p>If you are using compression (especially zlib) for real-time compression (sending
compressed data somewhere where it will be decompressed immediately), you need
to measure the line speed of the compressor and decompressor. Then compare that
to the uncompressed line speed. Are you bottlenecked by I/O in the uncompressed
case? If not, do you need the bandwidth or I/O capacity being saved by
compression? If not, why are you using compression at all? You just measured that
all compression did was artificially slow down your software for no reason!
Given that zlib compression will often fail to saturate a 1 gbps link, there's
a very real chance your use of compression introduces an artificial CPU bottleneck!</p>
<p>If you are using compression (especially zlib) for data archiving (storing
compressed data somewhere where it will be decompressed eventually), you need
to measure and compare compression ratios and line speeds of different compression
formats and their settings. Like the real-time compression scenario, if
decompression reduces your line speed from uncompressed, you are artificially
slowing down access to your data. Maybe that's justified to save on storage costs.
But in many cases, you can swap in a different compression library and get
similar to better compression ratios while achieving better (de)compression speeds.
Who wouldn't want free performance and storage cost reductions?</p>
<p>As an aside, one of the reasons I love zstandard is it can be tuned from something
that is screaming fast (GB/s at compression and decompression ends) to something
that is very slow on the compression side but yields terrific compression ratios,
while still preserving GB/s decompression speeds. This enables you to use the same
format for vastly different use cases. You can also dynamically change the storage
characteristics of your data. For example, you can initially write data with a <em>fast</em>
setting so you aren't CPU constrained on the writer. Then you can have some batch
job come around and recompress your data with more aggressive settings, making it
much smaller. It's not like zlib where the range of compression settings goes from
<em>kinda slow and not very good compression ratios</em> to <em>pretty slow and still not very
good compression ratios</em>.</p>
<p><strong>When you know to look for it, inefficiency due to unjustified use of compression or
failure to leverage modern compression libraries is everywhere.</strong> Here are some common
operations in my daily workflow that are bottlenecked by use of slow compression
formats and could be made faster by using a different compression format:</p>
<ul>
<li>Installing Apt packages (packages are gzip compressed). (Fun fact, installing apt
  packages is also subject to <code>fsync()</code> slowness as described above because the package
  manager will issue an <code>fsync()</code> at least once for each package.)</li>
<li>Installing Homebrew packages (packages are gzip compressed).</li>
<li>Installing Python packages via pip (source archives are gzip tarballs and wheels are
  zip files, which use zlib compression).</li>
<li>Pushing/pulling Docker images (layers inside Docker images are gzip compressed).</li>
<li>Git (wire protocol data exchange and on-disk storage is using zlib). (When I added
  zstandard support to Mercurial, it reduced the transfer size from servers to ~89%
  of original while using ~60% of the server-side CPU.)</li>
</ul>
<p>In the corporate world, there's probably multiple petabyte scale data warehouses,
data lakes, data coliseums (I can't keep up with what we're calling them now) storing
data in gzip. Dozens of terabytes could likely be shaved by moving to something
like zstandard. If using LZMA (which has extremely slow decompression speeds),
storage costs are cheap, but data access is extremely slow, making your
data querying slow. I haven't had the opportunity to measure it, but I suspect
some of the reputation Hadoop and other Big Data systems have for being slow is
because they are CPU constrained by suboptimal use of compression.</p>
<p>My experience is that many programmers don't understand the trade-offs and
nuances of compression and/or lack knowledge about the existence of more modern,
superior compression libraries. Instead, the collective opinion is <em>compression
is good, use [zlib] compression</em>. Like many things in software, the real world
is complex and nuanced. The dynamics of the relative power and cost of computer
components has shifted the pendulum towards compression adding more cost than
it saves. And it hasn't helped that industry still widely uses a ~30 year old
compression format (DEFLATE/zlib) that is far from ideal for modern computers.
If you take the time to measure, I'm sure you'll find many cases where use of
compression is either ill-advised or would benefit from a more modern compression
library (like zstandard).</p>
<h1>x86_64 Binaries in Linux Distribution Packages</h1>
<p>Linux distributions often provide pre-built binaries to install via
packaging tools (e.g. <code>apt install</code> or <code>yum install</code>).</p>
<p>To keep things simpler and to ensure maximum compatibility, these pre-built
binaries are built such that they run on as many computers as possible.
Currently, many Linux distributions (including RHEL and Debian) have binary
compatibility with the <em>first</em> x86_64 processor, the AMD K8, launched in 2003.
These processors featured <em>modern</em> instruction sets, like MMX, 3DNow!, SSE,
and SSE2.</p>
<p>What this means is that by default, binaries provided by many Linux
distributions won't contain instructions from modern Instruction Set
Architectures (ISAs). No SSE4. No AVX. No AVX2. And more. (Well,
technically binaries can contain newer instructions. But they likely won't
be in default code paths and there will likely be run-time dispatching
code to opt into using them.)</p>
<p>Furthermore, C/C++ compilers (like Clang and GCC) will also target an
ancient x86_64 microarchitecture level by default (this is where the
distribution's binary compatibility defaults come from). So if you compile
your own code and don't specify settings like <code>-march</code> or <code>-mtune</code> to
change the default targeting settings, your compiled binaries won't
leverage SSE4, AVX, etc. You can still force your application to emit
these instructions in dynamic code paths without <code>-march</code>/<code>-mtune</code>
overrides. But you have to opt in and add additional code complexity to
do that.</p>
<p>Because of the conservative microarchitecture targeting settings of compilers
and distribution binaries by extension, that's nearly 20 years of ISA work
and efficiency gains from more powerful ISAs (like superlinear vectorized
instructions) left on the table. And here I get frustrated when my PRs linger
unreviewed for more than a day. Imagine what it is like to be an AMD or
Intel engineer and have your ISA work take ~decades to be adopted at scale!</p>
<p>Truth be told, I'm unsure how much of a performance impact this ISA
backwards compatibility sacrifices. It will vary heavily from workload
to workload. But I have no doubt there are some very large datacenters
running CPU intensive workloads that could see massive efficiency gains
by leveraging modern ISAs. If you are running thousands of servers and your
CPU load isn't coming from a JIT'ed language like Java (JITs can emit
instructions for the machine they are running on... because they compile
<em>just in time</em>), it might very well be worth compiling CPU heavy packages
(and their dependencies of course) from source targeting a modern
microarchitecture level so you don't leave the benefits of modern ISAs on
the table. And be forewarned: use of modern ISAs isn't a silver bullet!
Some instructions can actually result in the CPU underclocking in order to
run them, making code using those instructions fast but other code slow.</p>
<p>Maintaining binary compatibility with a vanishingly small number of ancient
CPUs at the expense of performance on modern CPUs seems... questionable.
Fortunately, Linux distributions and Clang/GCC are paying attention.</p>
<p>GCC 11 and Clang 12 define <code>x86_64-{v2, v3, v4}</code> architecture levels targeting
~Nehalem (released 2008), ~Haswell (released 2013), and AVX-512 (~2015),
respectively. So you can add e.g. <code>-march=x86_64-v3</code> to target Haswell era
and newer and have the compiler emit SSE4, AVX, AVX2, and other modern
instructions.</p>
<p>RHEL9 will be raising their minimum architecture requirement from
<code>x86_64</code> to <code>x86_64-v2</code>, effectively requiring CPUs from 2008+ instead of 2003+.</p>
<p>If you'd like to learn more about this topic, start at
<a href="https://www.phoronix.com/scan.php?page=news_item&amp;px=RHEL-9-x86-64-v2-Plans">this Pharonix article</a>
and follow the links to other articles and mailing list discussions.</p>
<p>It's worth noting that at the time I write this, AWS 4th generation EC2 instances
(<code>c4</code>, <code>m4</code>, and <code>r4</code>) all support AVX2 and I believe are compatible with
GCC/Clang's <code>x86_64-v3</code> target. And 5th generation Intel instances have AVX-512,
presumably making them compatible with <code>x86_64-v4</code>. So even if your distribution
targets <code>x86_64-v2</code>, there is still potential <em>free</em> performance from newer ISAs on
the table.</p>
<p>If I were operating a server fleet consisting of thousands of machines,
I would be very tempted to compile all packages from source targeting a modern
microarchitecture level. This would be costly in terms of complexity. But
for some workloads, the performance gains could be worth the effort. And
this conservative targeting approach <em>may</em> provide justification for running
modern-optimized Linux distributions or cloud vendor specific Linux
distributions (e.g. Amazon Linux). I'm unsure if distributions like Amazon
Linux take advantage of this. If not, they should look into it!</p>
<p>Read the next section for an example of where failure to leverage modern
ISAs translates to a performance loss.</p>
<h1>Many Implementations of Myers Diff and Other Line Based Diffing Algorithms</h1>
<p>This one is rather domain specific but I find it an illustrious example
because the behavior is quite counter-intuitive!</p>
<p>Various classes of software need to take two text documents and emit
a textual <em>diff</em> of their contents. Think what <code>git diff</code> displays.</p>
<p>There are various algorithms for generating a diff of text. Myers Diff
is probably the most famous. The run-time of the algorithms is proportional
to the number of lines. Probably <code>O(nlog(n))</code> or <code>O(n^2)</code>.</p>
<p>These text-based diffing algorithms often operate at the line level (rather than
say the byte or codepoint level) because it drastically limits the search
space and minimizes <code>n</code> to keep the algorithm run-time in check.</p>
<p>Over the years, various people have realized that when diffing two text
documents, large parts of the inputs are often identical (why would you diff
unrelated content after all). So most implementations of diff algorithms have
a myriad of <em>optimizations</em> to limit the number of lines compared. Two common
optimizations are to identify and exclude the common prefix and suffix of the
input.</p>
<p>This is over-simplified, but text-based diffing algorithms often do the
following:</p>
<ol>
<li>Split the input into lines.</li>
<li>Hash each line to facilitate fast line equivalence testing (comparing a
   <code>u32</code> or <code>u64</code> checksum is a <strong>ton</strong> faster than <code>memcmp()</code> or <code>strcmp()</code>).</li>
<li>Identity and exclude common prefix and suffix lines.</li>
<li>Feed remaining lines into diffing algorithm.</li>
</ol>
<p>The idea is that steps 1-3 - which should be <code>O(n)</code> - reduce work for an
algorithm (step 4) with run-time complexity worse than <code>O(n)</code>. Sounds good
on paper.</p>
<p>So what actually happens?</p>
<p>If you profile a number of these diff implementations, you find that steps
1-3 actually take <em>more</em> time than the supposedly slow/expensive algorithm!
How can this be?!</p>
<p>One culprit is the line splitting. Even assuming we can use memory 0-copy /
references for storing the line contents (as opposed to allocating a new
string to hold each parsed line, which can be much less efficient), splitting
text into lines can be grossly inefficient!</p>
<p>There are various reasons for this. Maybe you are decoding the text into
code points rather than operate in the domain of bytes (you shouldn't need
to decode the entire input to search for newlines). Maybe you are traversing
the file one character/byte at a time looking for LF.</p>
<p>An efficient solution to this problem employs the use of vectorized CPU
instructions (like AVX/AVX2) which can scan several bytes at a time looking
for a sentinel value or matching a byte mask. So instead of 1 instruction
per input byte, you have 1/n. Your C runtime library probably has assembly
implementations of <code>memchr()</code>, <code>strchr()</code>, and similar functions and
automatically chooses the newest/fastest assembly/instructions supported
by the run-time CPU (glibc does).</p>
<p>In theory, compilers recognize such patterns and emit modern vectorized
instructions automagically. In reality, because the default target ISA of
compilers is relatively ancient compared to what your CPU is capable of
(see previous section), you are stuck with <em>old</em> instructions and linear
scanning. Your best bet is to stick with functions in the C runtime that
are probably backed by assembly. (Although watch out for function call
overhead.)</p>
<p>Another culprit causing inefficiency is hashing each line. The hashing is
performed to reduce equivalence testing to a <code>u32</code>/<code>u64</code> compare rather than
<code>strcmp()</code>. Many implementations don't seem to give much consideration to
the hashing algorithm, using something like crc32 or djb2. An inefficiency here
is many older hashing algorithms operate at the byte level: you need to feed in
1 byte at a time, update state (XOR if often employed), then feed in the next
byte. This is inefficient because it throws away the instruction pipelining
and superscalar properties of modern CPUs. A better approach is to use a
hashing algorithm that digests 4, 8, or more bytes at a time. Again, this
lowers run-time from <em>~n</em> cycles per byte to <em>~1/n</em>.</p>
<p>Another common inefficiency is computing the lines and hashes of content in
the common prefix and suffix. Use of <code>memcmp()</code> (or even better: hand-rolled
assembly to give you the offset of the first divergence) is more efficient, as
again, your C runtime library probably has assembly implementations of
<code>memcmp()</code> which can compare input at near native memory speed.</p>
<p>I quite enjoy this example because it demonstrates that something that is
seemingly <code>O(n)</code> is slower than <code>O(nlog(n))</code>/<code>O(n^2)</code>. This is because often
the result of the optimization reduces the <code>n</code> of the expensive algorithm to
such a small value that the computational complexity is trivial. Compilers
targeting ancient microarchitectures and failing to leverage vectorized
instructions which unlock superlinear performance further shift the time
towards the <code>O(n)</code> optimizations.</p>
<h1>Conclusion</h1>
<p>Computers and software can be surprisingly slow for surprising reasons. While
this post was long and touched on a number of topics, it only scratched the
surface of potential topics. I could easily find another 10 topics to write
about. But that will have to be for another post.</p>
<p>Before I go, if you find inaccuracies in this post, please shoot me an email
(address in resume in site header) so I can correct the post, as I don't want
to unintentionally mislead others.</p>
<p>Also, computers and software are complex. When it comes to performance and
optimizations, always be measuring. The issues I described could be manifesting
in your software and environments but the effort to address them may not be worth
the reward. Computers and software, like life, are full of trade-offs.
Performance is just one trade-off. Please don't cargo cult my advice without
measuring and applying critical thinking first.</p>]]></content:encoded>
    </item>
    <item>
      <title>Announcing the 0.9 Release of PyOxidizer</title>
      <link>http://gregoryszorc.com/blog/2020/10/18/announcing-the-0.9-release-of-pyoxidizer</link>
      <pubDate>Sun, 18 Oct 2020 22:00:00 PDT</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[PyOxidizer]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2020/10/18/announcing-the-0.9-release-of-pyoxidizer</guid>
      <description>Announcing the 0.9 Release of PyOxidizer</description>
      <content:encoded><![CDATA[<p>I have decided to make up for the 6 month lull between PyOxidizer's
0.7 and 0.8 releases by releasing
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/">PyOxidizer</a> 0.9 just 1 week
after 0.8!</p>
<p>The full 0.9 changelog is found
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/history.html#version-0-9-0">in the docs</a>.
First time user? See the
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/getting_started.html">Getting Started</a>
documentation.</p>
<p>While the 0.9 release is far smaller in terms of features compared to 0.8,
it is an important release because of progress closing compatibility gaps.</p>
<h2>Build a <code>python</code> Executable</h2>
<p>PyOxidizer 0.8 quietly shipped the ability to build executables that
behave like <code>python</code> executables via enhancements to the configurability of
embedded Python interpreters.</p>
<p>PyOxidizer 0.9 made some minor changes to make this scenario work better
and there is even
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/packaging_python_executable.html">official documentation</a>
on how to achieve this. So now you can emit a <code>python</code> executable next to your
application's executable. Or you could use PyOxidizer to build a highly portable,
self-contained <code>python</code> executable and ship your Python scripts next to it,
using PyOxidizer's <code>python</code> in your <code>#!</code>.</p>
<h2>Support Packaging Files as Files for Maximum Compatibility</h2>
<p>There is a long-tail of Python packages that don't <em>just work</em> with
PyOxidizer. A subset of these packages don't work because of bugs with how
PyOxidizer attempts to classify files as specific types of Python resources.</p>
<p>The way that normal Python works is you materialize a bunch of files on
the filesystem and at run-time the filesystem-based importer <code>stat()</code>s a
bunch of paths until it finds a candidate file satisfying the <code>import</code>
request. This works of course. But it is inefficient. Since PyOxidizer has
awareness of every resource being packaged at build time, it attempts to
index all known resources and serialize them to an efficient data structure
so finding and loading a resource can be extremely quick (effectively just a
hashmap lookup in Rust code to resolve the memory address of data).</p>
<p>PyOxidizer's approach does work in the majority of cases. But there are
edge cases. For example, NumPy's binary wheels have installed file paths
like <code>numpy.libs/libopenblasp-r0-ae94cfde.3.9.dev.so</code>. The <code>numpy.libs</code>
directory is not a valid Python package directory since it has a <code>.</code> and
since it doesn't have an <code>__init__.py[c]</code> file. This is a case where
PyOxidizer's code for turning files into <em>resources</em> is currently confused.</p>
<p>It is tempting to argue that file layouts like NumPy's are <em>wrong</em>. But
there doesn't seem to be any formal specification preventing the use of
such layouts. The arbiter of truth here is what Python packaging tools
accept and the current code for installing <em>wheels</em> gladly accepts file
layouts like these. So I've accepted that PyOxidizer is just going to have
to support edge cases like this. (I've captured more details about this
particular issue
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/technotes.html#ambiguous-file-classification">in the docs</a>).</p>
<p>Anyway, PyOxidizer 0.9 ships a new, simpler mode for handling files:
<em>files mode</em>. In <a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/packaging_resources.html#classified-resources-versus-files">files mode</a>,
PyOxidizer disables its code for <em>classifying</em> files as typed Python
resources (like module sources and extension modules) and instead treats
a file as... a file.</p>
<p>When in files mode, actions that invoke Python packaging tools return
files objects instead of classified resources. If you then add these files
for packaging, those files are materialized on the filesystem next to your
built executable. You can then use Python's standard filesystem importer
to load these files at run-time.</p>
<p>This allows you to use PyOxidizer with packages like NumPy that were
previously incompatible due to bugs with file/resource classification.
In fact, getting NumPy working with PyOxidizer is
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/packaging_additional_files.html#installing-unclassified-files-on-the-filesystem">now in the official documentation</a>!</p>
<p><em>Files mode</em> is still in its infancy. There exists code for embedding
files data in the produced executable. I plan to eventually teach PyOxidizer's
run-time code to extract these embedded files to a temporary directory,
SquashFS FUSE filesystem, etc. This is the approach that other Python
packaging tools like PyInstaller and XAR use. While it is less efficient, this
approach is highly compatible with Python code in the wild since you sidestep
issues with <code>__file__</code> and other assumptions about installed file layouts. So
it makes sense for PyOxidizer to provide support for this so you can still
achieve the friendliness of a self-contained executable without worrying
about compatibility. Look for improvements to <em>files mode</em> in future releases.</p>
<p>And to help debug issues with PyOxidizer's file handling and resource
classification, the new
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/managing_projects.html#debugging-resource-scanning-and-identification-with-find-resources">pyoxidizer find-resources</a>
command can be used to invoke PyOxidizer's code for scanning and classifying
files. Hopefully this makes it easier to diagnose bugs in this critical
component of PyOxidizer!</p>
<h2>Some Important Bug Fixes</h2>
<p>PyOxidizer 0.8 shipped with some pretty annoying bugs and behavior quirks.</p>
<p>The ability to set custom <code>sys.path</code> values via Starlark was broken. How I
managed to ship that, I'm not sure. But it is fixed in 0.9.</p>
<p>Another bug I can't believe I shipped was
the <code>PythonExecutable.read_virtualenv()</code> Starlark method being broken due to
a typo. You can read from virtualenvs again in PyOxidizer 0.9.</p>
<p>Another important improvement is in the default Python interpreter
configuration. We now automatically initialize Python's locales configuration
by default. Without this, the encoding of filesystem paths and <code>sys.argv</code> may
not have been correct. If someone passed a non-ASCII argument, the Python <code>str</code>
value was likely mangled. PyOxidizer built binaries should behave reasonably
by default now. The <a href="https://github.com/indygreg/PyOxidizer/issues/294">issue</a>
is a good read if the subtle behaviors of how encodings work in Python and on
different operating systems is interesting to you.</p>
<h2>Better Binary Portability Documentation</h2>
<p>The documentation on
<a href="https://pyoxidizer.readthedocs.io/en/v0.9.0/packaging_binary_compatibility.html">binary portability</a>
has been overhauled. Hopefully it is much more clear about the capabilities
of PyOxidizer to produce a binary that <em>just works</em> on other machines.</p>
<p>I eventually want to get PyOxidizer to a point where users don't have to
think about binary portability. But until PyOxidizer starts generating
installers and providing the ability to run builds in deterministic and
reproducible environments, it is sadly a problem that is being externalized
to end users.</p>
<h2>In Conclusion</h2>
<p>PyOxidizer 0.9 is a small release representing just 1 week of work. But
it contains some notable features that I wanted to get out the door.</p>
<p>As always, please report any issues or feedback in the
<a href="https://github.com/indygreg/PyOxidizer/issues/new">GitHub issue tracker</a>
or the <a href="https://groups.google.com/forum/#!forum/pyoxidizer-users">users mailing list</a>.</p>]]></content:encoded>
    </item>
    <item>
      <title>Announcing the 0.8 Release of PyOxidizer</title>
      <link>http://gregoryszorc.com/blog/2020/10/12/announcing-the-0.8-release-of-pyoxidizer</link>
      <pubDate>Mon, 12 Oct 2020 00:45:00 PDT</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[PyOxidizer]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2020/10/12/announcing-the-0.8-release-of-pyoxidizer</guid>
      <description>Announcing the 0.8 Release of PyOxidizer</description>
      <content:encoded><![CDATA[<p>I am very excited to announce the 0.8 release of
<a href="https://pyoxidizer.readthedocs.io/en/stable/">PyOxidizer</a>, a modern
Python application packaging tool. You can find the full changelog
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/history.html">in the docs</a>.
First time user? See the
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/getting_started.html">Getting Started</a>
documentation.</p>
<p>Foremost, I apologize that this release took so long to publish (0.7 was
released on 2020-04-09). I fervently believe that frequent releases are
a healthy software development practice. And 6 months between PyOxidizer
releases was way too long. Part of the delay was due to world events
(it has proven difficult to focus on... anything given a global pandemic,
social unrest, and wildfires further undermining any resemblance of
lifestyle normalcy in California). Another contributing factor was I was
waiting on a few 3rd party Rust crates to have new versions published to
crates.io (you can't release a crate to crates.io unless all your
dependencies are also published there).</p>
<p>Release delay and general life hardships aside, the 0.8 release is here
and it is full of notable improvements!</p>
<h2>Python 3.8 and 3.9 Support</h2>
<p><strong>PyOxidizer 0.8 now targets Python 3.8 by default and support for Python
3.9 is available</strong> by tweaking configuration files. Previously, we only
supported Python 3.7 and this release drops support for Python 3.7. I feel
a bit bad for dropping compatibility. But Python 3.8 introduced a
<a href="https://docs.python.org/3/c-api/init_config.html">new C API</a> for initializing
Python interpreters (thank you Victor Stinner!) and this makes PyOxidizer's
run-time code for interfacing with Python interpreters vastly simpler.
I decided that given the beta nature of PyOxidizer, it wasn't worth
maintaining complexity to continue to support Python 3.7. I'm optimistic
that I'll be able to support Python 3.8 as a baseline for a while.</p>
<h1>Better Default Packaging Settings</h1>
<p>PyOxidizer started as a science experiment of sorts to see if I could
achieve the elusive goal of producing a single file executable providing
a Python application. I was successful in proving this hypothesis. But the
cost to achieving this outcome was rather high in terms of end-user
experience: in order to produce single file executables, you had to break
a lot of assumptions about how Python typically works and this in turn broke
a lot of Python code and packages in the wild.</p>
<p>In other words, <strong>PyOxidizer's opinionated defaults of producing a single file
executable were externalizing hardship on end-users and preventing them from
using PyOxidizer.</strong></p>
<p>PyOxidizer 0.8 contains a handful of changes to defaults that should hopefully
lessen the friction.</p>
<p>On Windows, the default Python distribution now has a more traditional
build configuration (using <code>.pyd</code> extension modules and a <code>pythonXY.dll</code>
file). <strong>This means that PyOxidizer can consume pre-built extension modules
without having to recompile them from source.</strong> If you publish a Windows
binary wheel on PyPI, in many cases it will <em>just work</em> with PyOxidizer
0.8! (There are some notable exceptions to this, such as <em>numpy</em>, which is
doing wonky things with the location of shared libraries in wheels - but
I aim to fix this soon.)</p>
<p>Also on Windows, we no longer attempt to embed Python extension modules
(<code>.pyd</code> files) and their shared library dependencies in the produced
binary and load them from memory by default. This is because PyOxidizer's
from-memory library loader didn't work in all cases. For example, some
OpenSSL functionality used by the <code>_ssl</code> module in the standard library
didn't work, preventing Python from establishing TLS connections. The old
mode enabling you to produce a single file executable on Windows is still
available. But you have to opt in to it (at the likely cost of more
packaging and compatibility pain).</p>
<h2>Starlark Configuration Overhaul</h2>
<p>PyOxidizer 0.8 contains a <strong>ton</strong> of changes to its Starlark configuration
files. There are so many changes that you may find it easier to port to
PyOxidizer 0.8 by creating a new configuration file rather than attempting
to port an existing one.</p>
<p>I apologize for this churn and recognize it will be disruptive. However,
this churn needed to happen for various reasons.</p>
<p>Much of the old Starlark configuration semantics was rooted in the days
when configuration files were static TOML files. Now that configuration
files provide the power of a (Python-inspired) programming language, we
are free to expose much more flexibility. But that flexibility requires
refactoring things so the experience feels more <em>native</em>.</p>
<p>Many changes to Starlark were rooted in necessity. For example,
the methods for invoking <code>setup.py</code> or <code>pip install</code> used to live on a
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/config_type_python_distribution.html">Python distribution type</a>
and have been moved to a
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/config_type_python_executable.html">type representing executables</a>.
This is because the binary we are targeting influences how
packaging actions behave. For example, if the binary only supports
loading resources from memory (as opposed to standalone files), we need
to know that when invoking the packaging tool so we can produce files
(notably Python extension modules) compatible with the destination.</p>
<p>A major change to Starlark in 0.8 is around resource location handling.
Before, you could define a static string denoting the <em>resources policy</em>
for where things should be placed. And there were 10+ methods for
adding different resource types (source, bytecode, extensions, package
data) to different load locations (memory, filesystem). This mechanism
is vastly simplified and more powerful in PyOxidizer 0.8!</p>
<p>In PyOxidizer 0.8, there is a single
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/config_type_python_executable.html#pythonexecutable-add-python-resource">add_python_resource()</a>
method for adding a resource to a binary and the Starlark objects you add
can denote where they should be added by
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/config_resource_add_attributes.html">defining attributes on those objects</a>.</p>
<p>Furthermore, you can
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/packaging_resources.html#using-callbacks-to-influence-resource-attributes">define a Starlark function</a>
that is called when resource objects are created to apply custom packaging
<em>rules</em> using custom Starlark code defined in your PyOxidizer config file.
So rather than having everyone try to abide by a few pre-canned <em>policies</em> for
packaging resources, you can define a proper function in your config file
that can be as complex as you want/need it to be! I feel this is vastly simpler
and more powerful than implementing a custom DSL in static configuration files
(like TOML, JSON, YAML, etc).</p>
<p>While the ability to implement your own arbitrarily complex packaging
policies is useful, there is a new
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/config_type_python_packaging_policy.html">PythonPackagingPolicy</a>
Starlark type with enough flexibility to suit most needs.</p>
<h2>Shipping <code>oxidized_importer</code></h2>
<p>During the development of PyOxidizer 0.8, I broke out the custom
Rust-based Python <em>meta-path importer</em> used by PyOxidizer's run-time code
into a standalone Python package. This sub-project is called
<code>oxidized_importer</code> and I previously
<a href="/blog/2020/05/10/using-rust-to-power-python-importing-with-oxidized_importer/">blogged about it</a>.</p>
<p>PyOxidizer 0.8 ships <code>oxidized_importer</code> and all of its useful APIs
available to Python. Read more in the
<a href="https://pyoxidizer.readthedocs.io/v0.8.0/latest/oxidized_importer.html">official docs</a>.
The new Python APIs should make debugging issues with PyOxidizer-packaged
applications vastly simpler: I found them invaluable when tracking down
user-reported bugs!</p>
<h2>Tons of New Tests and Refactored Code</h2>
<p>PyOxidizer was my first non-toy Rust project. And the quality of the Rust
code I produced in early versions of PyOxidizer clearly showed it. And when I
was in the rapid-prototyping phase of PyOxidizer, I eschewed writing tests
in favor of short-term progress.</p>
<p>PyOxidizer 0.8 pays down a ton of technical debt in the code base. Lots of
Rust code has been refactored and is using somewhat reasonable practices.
I'm not yet a Rust guru. But I'm at the point where I cringe when I look at
some of the early code I wrote, which is a good sign. I do have to say that
Rust has been a dream to work with during this transition. Despite being a
low-level language, my early <em>misuse</em> of Rust did not result in crashes like
you would see in languages like C/C++. And Rust's seemingly omniscient compiler
and IDE tools facilitating refactoring have ensured that code changes aren't
accompanied by subtle random bugs that would occur in dynamic programming
languages. I really need to write a dedicated post espousing the virtues of
Rust...</p>
<p>There are a <strong>ton</strong> of new tests in PyOxidizer 0.8 and I now feel somewhat
confident that the <code>main</code> branch of PyOxidizer should be considered
<em>production-ready</em> at any time assuming the tests pass. This will hopefully
lead to more rapid releases in the future.</p>
<p>There are now tests for the <code>pyembed</code> Rust crate, which provides the
run-time code for PyOxidizer-built binaries. We even have
<a href="https://github.com/indygreg/PyOxidizer/tree/main/pyembed/src/test">Python-based unit tests</a>
for validating the Python-exposed APIs behave as expected. These tests have
been invaluable for ensuring that the run-time code works as expected. So now
when someone files a bug I can easily write a test to capture it and keep
the code working as intended through various refactors.</p>
<p>The packaging-time Rust code has also gained its fair share of tests.
We now have fairly comprehensive test coverage around how resources
are added/packaged. Python extension modules have proved to be highly
nuanced in how they are handled. Tremendously helping testing of extension
modules is that we're able to run tests for platform non-native extensions!
While not yet exposed/supported by Starlark configuration files, <strong>I've taught
PyOxidizer's core Rust code to be cross-compiling aware</strong> so that we can
e.g. test Windows or macOS behavior from Linux. Before, I'd have to test
Windows wheel handling on Windows. But after writing a wheel parser in Rust
and teaching PyOxidizer to use a different Python distribution for the
host architecture from the target architecture, I'm now able to write
tests for platform-specific functionality that run on any platform that
PyOxidizer can run on. This <em>may</em> eventually lead to proper cross-compiling
support (at least in some configuration). Time will tell. But the foundation
is definitely there!</p>
<h2>New Rust Crates</h2>
<p>As part of the aforementioned refactoring of PyOxidizer's Rust code, I've
been extracting some useful/generic functionality built as part of
developing PyOxidizer to their own Rust crates.</p>
<p>As part of this release, I'm publishing the initial 0.1 release of the
<a href="https://crates.io/crates/python-packaging">python-packaging</a> crate
(<a href="https://docs.rs/python-packaging/0.1.0/python_packaging/">docs</a>). This crate
provides pure Rust code for various Python <em>packaging</em> related functionality.
This includes:</p>
<ul>
<li>Rust types representing Python resource types (source modules, bytecode
  modules, extension modules, package resources, etc).</li>
<li>Scanning the filesystem for Python resource files .</li>
<li>Configuring an embedded Python interpreter.</li>
<li>Parsing <code>PKG-INFO</code> and related files.</li>
<li>Parsing wheel files.</li>
<li>Collecting Python resources and serializing them to a data structure.</li>
</ul>
<p>The crate is somewhat PyOxidizer centric. But if others are interested
in improving its utility, I'll happily accept pull requests!</p>
<p>PyOxidizer's crates footprint now includes:</p>
<ul>
<li><a href="https://crates.io/crates/python-packed-resources">python-packed-resources</a></li>
<li><a href="https://crates.io/crates/python-packaging">python-packaging</a></li>
<li><a href="https://crates.io/crates/pyembed">pyembed</a></li>
<li><a href="https://crates.io/crates/pyoxidizer">pyoxidizer</a></li>
</ul>
<h2>Major Documentation Updates</h2>
<p>I strongly believe that software should be documented thoroughly and I strive
for PyOxidizer's documentation to be useful and comprehensive.</p>
<p>There have been a lot of changes to PyOxidizer's documentation since the
0.7 release.</p>
<p>All <a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/config.html">configuration file documentation</a>
has been consolidated.</p>
<p>Likewise, I've attempted to consolidate a lot of the <em>paved road</em> documentation
for how to use PyOxidizer in the
<a href="https://pyoxidizer.readthedocs.io/en/v0.8.0/packaging.html">Packaging User Guide</a>
section of the docs.</p>
<p>I'll be honest, since I have so much of PyOxidizer's workings internalized,
it can be difficult for me to empathize with PyOxidizer's users. So if you
have difficult with the <em>readability</em> of the documentation, please
<a href="https://github.com/indygreg/PyOxidizer/issues/new">file an issue</a> and report
what is confusing so the documentation can be improved!</p>
<h2>Mercurial Shipping With PyOxidizer 0.8</h2>
<p>PyOxidizer is arguably an epic yak shave of mine to help the
<a href="https://www.mercurial-scm.org/">Mercurial version control tool</a> transition
to Python 3 and Rust.</p>
<p>I'm pleased to report that Mercurial is
<a href="https://www.mercurial-scm.org/pipermail/mercurial/2020-October/052395.html">now shipping</a>
PyOxidizer-built distributions on Windows as of the 5.2.2 release a few days
ago! If a complex Python application like Mercurial can be
<a href="https://www.mercurial-scm.org/repo/hg/file/0627cd03b1e9/rust/hgcli/pyoxidizer.bzl">configured</a>
to work with PyOxidizer, chances are your Python application will work as
well.</p>
<h2>Whats Next</h2>
<p>I view PyOxidizer 0.8 as a pivotal release where PyOxidizer is turning the
corner from a prototyping science experiment to something more generally
usable. The investments in test coverage and refactoring of the Rust
internals are paving the way towards future features and bug fixes.</p>
<p>In upcoming releases, I'd like to close remaining known compatibility
gaps with popular Python packages (such as <em>numpy</em> and other packages in
the <em>scientific/data</em> space). I have a general idea of what work needs to
be done and I've been laying the ground work via various refactorings to
execute here.</p>
<p><strong>I want a general theme of future releases to be eliminating reasons why
people can't use PyOxidizer.</strong> PyOxidizer's historical origin was as a
science experiment to see if single file Python applications were possible.
It is clear that achieving this is fundamentally incompatible with
compatibility with tons of Python packages in the wild. I'd like to find a
way where PyOxidizer can achieve 99% package compatibility by default
so new users don't get discouraged when using PyOxidizer. And for the
subset of users who want single file executables, they can spend the
magnitude of additional effort to achieve that.</p>
<p>At some point, I also want to make a pivot towards focusing on producing
distributable artifacts (Debian/RPM packages, MSI installers, macOS DMG
files, etc). I'm slightly bummed that I haven't made much progress here.
But I have a vision in my mind of where I want to go (I'll be making
a standalone Rust crate + Starlark dialect to facilitate producing
distributable artifacts for <em>any</em> application) and I'm anticipating
starting this work in the next few months. In the mean time, PyOxidizer
0.8 should be able to give people a directory tree that they can coerce
into distributable artifacts using existing packaging tooling. That's not as
turnkey as I would like it to be. But the technical problems around
building a distributable Python application binary still needs some work
and I view that as the most pressing need for the Python ecosystem. So
I'll continue to focus there so there is a solid foundation to build upon.</p>
<p>In conclusion, I hope you enjoy the new release! Please report any issues
or feedback in the
<a href="https://github.com/indygreg/PyOxidizer/issues/new">GitHub issue tracker</a>.</p>]]></content:encoded>
    </item>
    <item>
      <title>Using Rust to Power Python Importing With oxidized_importer</title>
      <link>http://gregoryszorc.com/blog/2020/05/10/using-rust-to-power-python-importing-with-oxidized_importer</link>
      <pubDate>Sun, 10 May 2020 13:15:00 PDT</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[PyOxidizer]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2020/05/10/using-rust-to-power-python-importing-with-oxidized_importer</guid>
      <description>Using Rust to Power Python Importing With oxidized_importer</description>
      <content:encoded><![CDATA[<p>I'm pleased to announce the availability of the <code>oxidized_importer</code>
Python package, a standalone version of the custom Python module importer
used by <a href="https://github.com/indygreg/PyOxidizer">PyOxidizer</a>.
<code>oxidized_importer</code> - a Python extension module implemented in Rust - enables
Python applications to start and run quicker by providing an alternate,
more efficient mechanism for loading Python resources (such as source
and bytecode modules).</p>
<p>Installation instructions and detailed usage information are available
<a href="https://pyoxidizer.readthedocs.io/en/oxidized_importer-0.1/oxidized_importer.html">in the official documentation</a>.
The rest of this post hopefully answers the questions of <em>why are you doing
this</em> and <em>why should I care</em>.</p>
<p>In a traditional Python process, Python's module importer inspects the
filesystem at run-time to find and load resources like Python source and
bytecode modules. It is highly dynamic in nature and relies on the filesystem
as a point-in-time source of truth for resource availability.</p>
<p><code>oxidized_importer</code> takes a different approach to resource loading that is
more static in nature and more suitable to application environments (where
Python resources aren't changing). Instead of dynamically probing the
filesystem for available resources, resources are instead <em>indexed</em> ahead
of time. When Python goes to resolve a resource (say it is looking to
<code>import</code> a module), <code>oxidized_importer</code> simply needs to perform a lookup
in an in-memory data structure to locate said resource. This means
<code>oxidized_importer</code> only has marginal reliance on the filesystem, <strong>which
can make it much faster than Python's traditional importer</strong>. (Performance
benefits of binaries built with PyOxidizer have already been
<a href="https://pyoxidizer.readthedocs.io/en/oxidized_importer-0.1/packaging_performance.html">clearly demonstrated</a>.)</p>
<p>The <code>oxidized_importer</code> Python extension module exposes parts of
PyOxidizer's packaging and run-time functionality to Python code, <strong>without
requiring the full use of PyOxidizer for application packaging</strong>.
Specifically, <code>oxidized_importer</code> allows you to:</p>
<ul>
<li>Install a custom, high-performance module importer
  (<a href="https://pyoxidizer.readthedocs.io/en/oxidized_importer-0.1/oxidized_importer_oxidized_finder.html">OxidizedFinder</a>)
  to service Python <code>import</code> statements and resource loading (potentially
  from memory, using zero-copy).</li>
<li><a href="https://pyoxidizer.readthedocs.io/en/oxidized_importer-0.1/oxidized_importer_resource_scanning.html">Scan the filesystem for Python resources</a>
  (source modules, bytecode files, package resources, distribution metadata,
  etc) and turn them into Python objects, which can be loaded into
  <code>OxidizedFinder</code> instances.</li>
<li>Serialize Python resource data into an efficient binary data structure
  for loading into an <code>OxidizedFinder</code> instance. This facilitates
  producing a standalone <em>resources blob</em> that can be distributed with
  a Python application which contains all the Python modules, bytecode,
  etc required to power that application. See the docs on
  <a href="https://pyoxidizer.readthedocs.io/en/oxidized_importer-0.1/oxidized_importer_freezing_applications.html">freezing an application with oxidized_importer</a>.</li>
</ul>
<p><code>oxidized_importer</code> can be thought of as PyOxidizer-lite: it provides just
enough functionality to allow Python application maintainers to leverage some
of the technical advancements of PyOxidizer (such as in-memory module imports)
without using PyOxidizer for application packaging. <strong><code>oxidized_importer</code> can
work with the Python distribution already installed on your system. You just
<code>pip install</code> it like any other Python package.</strong></p>
<p>By releasing <code>oxidized_importer</code> as a standalone Python package, my hope is
to allow more people to leverage some of the technical achievements and
performance benefits coming out of PyOxidizer. I also hope that having more
users of PyOxidizer's underlying code will help uncover bugs and conformance
issues, raising the quality and viability of the projects.</p>
<p>I would also like to use <code>oxidized_importer</code> as an opportunity to advance the
discourse around Python's resource loading mechanism. Filesystem I/O can be
extremely slow, especially in mobile and embedded environments. Dynamically
probing the filesystem to service module imports can therefore be slow. (The
Python standard library has the <code>zipimport</code> module for importing Python resources
from a zip file. But in my opinion, we can do much better.) <strong>I would like to
see Python move towards leveraging immutable, serialized data structures for
loading resources as efficiently as possible.</strong> After all, Python resources
like the Python standard library are likely not changing between Python process
invocations. The performance zealot in me cringes thinking of all the overhead
that Python's filesystem probing approach incurs - all of the excessive <code>stat()</code>
and other filesystem I/O calls that must be performed to answer questions about
state that is easily indexed and often doesn't change. <code>oxidized_importer</code>
represents my vision for what a high-performance Python resource loader should
look like. I hope it can be successful in steering Python towards a better
approach for resource loading.</p>
<p>I plan to release <code>oxidized_importer</code> independently from <code>PyOxidizer</code>. While
the projects will continue to be developed in the same
<a href="https://github.com/indygreg/PyOxidizer">repository</a> and will leverage the
same underlying Rust code, I view them as somewhat independent and serving
different audiences.</p>
<p>While <code>oxidized_importer</code> evolved from facilitating PyOxidizer's run-time use
cases, I'm not opposed to taking it in new directions. For example, I would
entertain implementing Python's dynamic filesystem probing logic in
<code>oxidized_importer</code>, allowing it to serve as a functional stand-in for the
official importer shipped with the Python standard library. I have little
doubt an importer implemented in 100% Rust would outperform the official
importer, which is implemented in Python. There's all kinds of possibilities
here, such as using a background thread to index <code>sys.path</code> outside the
constraints of the GIL. But I don't want to get ahead of myself...</p>
<p>If you are a Python application maintainer and want to make your Python
processes execute a bit faster by leveraging a pre-built index of available
Python resources and/or taking advantage of in-memory module importing,
I highly encourage you to take a look at <code>oxidized_importer</code>!</p>]]></content:encoded>
    </item>
    <item>
      <title>PyOxidizer 0.7</title>
      <link>http://gregoryszorc.com/blog/2020/04/09/pyoxidizer-0.7</link>
      <pubDate>Thu, 09 Apr 2020 21:00:00 PDT</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[PyOxidizer]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2020/04/09/pyoxidizer-0.7</guid>
      <description>PyOxidizer 0.7</description>
      <content:encoded><![CDATA[<p>I am very pleased to announce the 0.7 release of
<a href="https://pyoxidizer.readthedocs.io/en/stable/">PyOxidizer</a>, a modern
Python application packaging tool.</p>
<p>There are a host of notable new features in this release. You can
read all about them in the project
<a href="https://pyoxidizer.readthedocs.io/en/stable/history.html">history</a>.</p>
<p>I want to use this blog post to call out the more meaningful ones.</p>
<p>I started PyOxidizer as a science experiment of sorts: I sat out to
prove the hypothesis that it was possible to produce high performance
single file executables embedding Python and all of its resources
(Python modules, non-module resource files, compiled extensions, etc).
PyOxidizer has achieved this on Windows, Linux, and macOS since its
very earliest releases. Hypothesis confirmed!</p>
<p>In order to actually achieve single file executables, you have to
fundamentally change aspects of Python's behavior. Some of these
changes invalidate deeply rooted assumptions about how Python works,
such as the existence of <code>__file__</code> in modules. As you can imagine,
these broken assumptions translated to numerous compatibility issues
and PyOxidizer didn't work with many popular Python packages.</p>
<p>With the science experiment phase of PyOxidizer out of the way, I
have been making a concerted effort to broaden the user base of
PyOxidizer. While single file executables can be an amazing property,
it isn't critical for many use cases and the issues it was causing
were preventing people from exploring PyOxidizer.</p>
<p>This brings us to what I think are the major new features in
PyOxidizer 0.7.</p>
<h2>Better Support for Loading Extension Modules</h2>
<p>Earlier versions of PyOxidizer insisted that you compile Python
(C) extension modules from source and statically link them into
a produced binary. This requirement prevented the use of pre-built
extension modules (commonly found in Python binary wheels available
on PyPI) with PyOxidizer, forcing people to compile them locally.
While this often <em>just worked</em> for many extension modules, it
frequently failed on complex extension modules and it frequently
failed on Windows.</p>
<p>PyOxidizer now supports loading compiled extension modules from
standalone files (typically <code>.so</code> or <code>.pyd</code> files, which are actually
shared libraries). There are still some sharp edges and known
deficiencies. But in many cases, if you tell PyOxidizer to run
<code>pip install</code> and package the result, pre-built wheels can be
installed and PyOxidizer will pick up the standalone files.</p>
<p>On Windows, PyOxidizer even supports embedding the shared library
data into the produced <code>.exe</code> and loading the <code>.pyd</code>/DLL directly
from memory.</p>
<h2>Loading Resources from the Filesystem</h2>
<p>Binaries built with PyOxidizer contain a blob holding an index
of available Python resources along with their data.</p>
<p>Earlier versions of PyOxidizer only allowed you to define resources
as <em>in-memory</em>. If the resource was defined in this blob, it was
imported from memory. Otherwise it wasn't known to PyOxidizer.
You could still install files next to the produced binary and
tell PyOxidizer to enable Python's default filesystem-based
importer. But PyOxidizer didn't explicitly know about these
files on the filesystem.</p>
<p>In PyOxidizer 0.7, the blob index of Python resources is able to
express different <em>locations</em> for that resource. Currently, a
resource can have its data made available <em>in-memory</em> or
<em>filesystem-relative</em>. <em>in-memory</em> works as before: the raw
data is embedded next to the next in memory and loaded from
there (using 0-copy). <em>filesystem-relative</em> encodes a filesystem
path to the resource. During packaging, PyOxidizer will place
the resource next to the executable (using a typical Python
file layout scheme) and store the relative path to that resource
in the resources index.</p>
<p>The <em>filesystem-relative</em> resource indexing feature has a few
implications for PyOxidizer.</p>
<p>First, it is more standard. When PyOxidizer loads a Python
module from the filesystem, it sets <code>__file__</code>, <code>__path__</code>,
etc and the module semantics should behave as if the file
were imported by Python's standard importer. This means that
if a package is having issues with <em>in-memory</em> importing, you
can simply fall back to <em>filesystem-relative</em> to get standard
Python behavior and everything should <em>just work</em>.</p>
<p>Second, PyOxidizer's filesystem resource loading is faster
than Python's! When Python's standard importer goes to
<code>import</code> a module, it needs to <code>stat()</code> various paths to
first locate the file. It then performs some sanity checking
and other minor actions before actually importing the module.
All of this has overhead. Since the goal of PyOxidizer is
to produce standalone applications and applications should
be immutable, PyOxidizer can avoid most of this overhead.
PyOxidizer simply tries to <code>open()</code> and <code>read()</code> the relative
path baked into the resource index at build time. If that
works, the resource is loaded. Else there is a failure.
The code path in PyOxidizer to locate a Python resource
is effectively a lookup in a Rust <code>HashMap&lt;&amp;str, T&gt;</code>.</p>
<p>I thought it would be interesting to isolate the performance
benefits of this new feature. I ran Mercurial's test harness
with different variants of <code>hg</code> on Linux on my Ryzen 3950X.</p>
<ul>
<li><em>traditional</em> - A <code>hg</code> script with a <code>#!/path/to/python3.7</code> shebang.</li>
<li><em>oxidized</em> - A <code>hg</code> executable built with PyOxidizer, without
  PyOxidizer's custom module importer.</li>
<li><em>filesystem</em> - A <code>hg</code> executable built with PyOxidizer using the
  new filesystem-relative resource index.</li>
<li><em>in-memory</em> - A <code>hg</code> executable built with PyOxidizer with all
  resources loaded from memory (how PyOxidizer has traditionally worked).</li>
</ul>
<p>The results are quite clear:</p>
<table border="1">
  <thead>
    <tr>
      <th>Variant</th><th>CPU Time (s)</th><th>Delta (s)</th><th>% Orig</th>
    </tr>
  </thead>
  <tbody>
    <tr><td>traditional</td><td style="text-align: right">11,287</td><td style="text-align: right">-552</td><td style="text-align: right">100</td></tr>
    <tr><td>oxidized</td><td style="text-align: right">10,735</td><td style="text-align: right">-552</td><td style="text-align: right">95.1</td></tr>
    <tr><td>filesystem</td><td style="text-align: right">10,186</td><td style="text-align: right">-1,101</td><td style="text-align: right">90.2</td></tr>
    <tr><td>in-memory</td><td style="text-align: right">9,883</td><td style="text-align: right">-1,404</td><td style="text-align: right">87.6</td></tr>
  </tbody>
</table>

<p>We see a nice win just from using a native executable built
with PyOxidizer (<em>traditional</em> to <em>oxidized</em>).</p>
<p>Then from <em>oxidized</em> to <em>filesystem</em> we see another jump of
~5%. This difference is attributed to using PyOxidizer's
Rust-powered importer with an index of resources available
on the filesystem. In other words, all that work that Python's
standard importer is doing to discover files and then operate
on them is non-trivial!</p>
<p>Finally, the smaller jump from <em>filesystem</em> to <em>in-memory</em>
isolates the benefits of importing resource data from
memory instead of involving filesystem I/O. (Filesystems
are generally slow.) While I haven't measured explicitly,
I hypothesize that macOS and Windows will see a bigger
jump between these two variants, as the filesystem
performance on these platforms generally isn't as good
as it is on Linux.</p>
<h2>PyOxidizer's Future</h2>
<p>With PyOxidizer now supporting a couple of much-needed
features to support a broader set of users, I'm hoping that
future releases of PyOxidizer continue to broaden the utility
of PyOxidizer.</p>
<p>The over-arching goal of PyOxidizer is to solve large aspects
of the Python application packaging and distribution problem.
So far a lot of focus has been spent on the former. PyOxidizer
in its current form can materialize files on the filesystem
that you can copy or package up manually and distribute. But
I want these processes to be part of PyOxidizer: I want it to
be possible for PyOxidizer to emit a Windows MSI installer, a
macOS dmg, a Debian package, etc for a Python application.</p>
<p>In order to support the aforementioned marquee features
of this PyOxidizer release, I had to pay down a lot of
technical debt in the code base left over from the science
experiment phase of PyOxidizer's inception.</p>
<p>In the short term, I plan to continue shoring up the code base
and rounding out support for features requested in the
issue tracker on GitHub. The next release of PyOxidizer will
also <a href="https://github.com/indygreg/PyOxidizer/issues/234">likely require</a>
Python 3.8, as this will improve run-time control over the
embedded Python interpreter and enable PyOxidizer to better
support package metadata (<code>importlib.metadata</code>), enabling
support for features like <em>entry points</em>.</p>
<p>I've also been thinking about extracting PyOxidizer's custom
module importer to be usable as a standalone Python extension
module. I think there's some value in publishing a
<code>pyoxidizer_importer</code> package on PyPI that you can easily
add to your installed packages to speed up Python's
standard filesystem importer by a few percent. If nothing else,
this may drum up interest in the larger Python community for
standardizing a format for serializing Python resources in a
single file. Perhaps we can get other Python packaging tools
producing the same
<a href="https://crates.io/crates/python-packed-resources">packed resources data</a>
blob that PyOxidizer uses so we can all standardize on a
more efficient mechanism for loading Python modules. Time
will tell.</p>
<p>Enjoy the new release. File issues at
<a href="https://github.com/indygreg/PyOxidizer">https://github.com/indygreg/PyOxidizer</a>
as you encounter them.</p>]]></content:encoded>
    </item>
    <item>
      <title>Mercurial's Journey to and Reflections on Python 3</title>
      <link>http://gregoryszorc.com/blog/2020/01/13/mercurial's-journey-to-and-reflections-on-python-3</link>
      <pubDate>Mon, 13 Jan 2020 08:45:00 PST</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[Mercurial]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2020/01/13/mercurial's-journey-to-and-reflections-on-python-3</guid>
      <description>Mercurial's Journey to and Reflections on Python 3</description>
      <content:encoded><![CDATA[<p>Mercurial 5.2 was released on November 5, 2019. It is the first version
of Mercurial that supports Python 3. This milestone comes nearly 11 years
after Python 3.0 was first released on December 3, 2008.</p>
<p>Speaking as a maintainer of Mercurial and an avid user of Python, I
feel like the experience of making Mercurial work with Python 3 is
worth sharing because there are a number of lessons to be learned.</p>
<p>This post is logically divided into two sections: a mostly factual recount
of Mercurial's Python 3 porting effort and a more opinionated commentary
of the transition to Python 3 and the Python language ecosystem as a whole.
Those who don't care about the mechanics of porting a large Python project
to Python 3 may want to skip the next section or two.</p>
<h2>Porting Mercurial to Python 3</h2>
<p>Let's start with a brief history lesson of Mercurial's support for
Python 3 as told by its own commit history.</p>
<p>The Mercurial version control tool was first released in April 2005
(the same month that Git was initially released). Version 1.0 came out
in March 2008. The first reference to Python 3 I found in the code base
was in <a href="https://www.mercurial-scm.org/repo/hg/rev/8fee8ff13d37">September 2008</a>.
Then not much happens for a while until
<a href="https://www.mercurial-scm.org/repo/hg/rev/4494fb02d549">June 2010</a>, when
someone authors a bunch of changes to make the Python C extensions
start to recognize Python 3. Then things were again quiet for a while
until <a href="https://www.mercurial-scm.org/repo/hg/rev/56ef99fbd6f2">January 2013</a>,
when a handful of changes landed to remove 2 argument <code>raise</code>. There were
a handful of commits in 2014 but nothing worth calling out.</p>
<p>Mercurial's meaningful journey to Python 3 started in 2015. In code,
the work started in
<a href="https://www.mercurial-scm.org/repo/hg/rev/af6e6a0781d7">April 2015</a>, with
effort to make Mercurial's test harness run with Python 3. Part of
this was a <a href="https://www.mercurial-scm.org/repo/hg/rev/fefc72523491">decision</a>
that Python 3.5 (to be released several months later in September 2015)
would be the minimum Python 3 version that Mercurial would support.</p>
<p>Once the Mercurial Project decided it wanted to port to Python 3 (as opposed
to another language), one of the earliest decisions was how to perform that
port. <strong>Mercurial's code base was too large to attempt a flag day conversion</strong>
where there would be a Python 2 version and a Python 3 version and one day
everyone would switch from Python 2 to 3. <strong>Mercurial needed a way to run the
same code (or as much of the same code) on both Python 2 and 3.</strong> We would
maintain a single code base and users would gradually switch from running with
Python 2 to Python 3.</p>
<p>In <a href="https://www.mercurial-scm.org/repo/hg/rev/e1fb276d4619">May 2015</a>,
Mercurial dropped support for Python 2.4 and 2.5. Dropping support for
these older Python versions was critical, as it was effectively impossible to
write Python code that ran on this wide gamut of versions because of
incompatibilities in syntax and language features. For example, you needed
Python 2.6 to get <code>print()</code> via <code>from __future__ import print_function</code>.
The project's late start at a Python 3 port can be significantly attributed
to Python 2.4 and 2.5 compatibility holding us back.</p>
<p>The main goal with Mercurial's early porting work was just getting the code base
to a point where <code>import mercurial</code> would work. There were a myriad of places
where Mercurial used syntax that was invalid on Python 3 and Python 3
couldn't even parse the source code, let alone compile it to bytecode and
execute it.</p>
<p>This effort began in earnest in
<a href="https://www.mercurial-scm.org/repo/hg/rev/e93036747902">June 2015</a>
with global source code rewrites like using modern octal syntax,
modern exception catching syntax (<code>except Exception as e</code> instead of
<code>except Exception, e</code>), <code>print()</code> instead of <code>print</code>, and a
<a href="https://www.mercurial-scm.org/repo/hg/rev/1a6a117d0b95">modern import convention</a>
along with the use of <code>from __future__ import absolute_import</code>.</p>
<p>In the early days of the port, our first goal was to get all source code
parsing as valid Python 3. The next step was to get all the modules <code>import</code>ing
cleanly. This entailed fixing code that ran at <code>import</code> time to work on
Python 3. Our thinking was that we would need the code base to be <code>import</code>
clean on Python 3 before seriously thinking about run-time behavior. In reality,
we quickly ported a lot of modules to <code>import</code> cleanly and then moved on
to higher-level porting, leaving a long-tail of modules with <code>import</code> failures.</p>
<p>This initial porting effort played out over months. There weren't many
people working on it in the early days: a few people would basically hack on
Python 3 as a form of itch scratching and most of the project's energy was
focused on improving the existing Python 2 based product. You can get a rough
idea of the timeline and participation in the early porting effort through the
<a href="https://www.mercurial-scm.org/repo/hg/log/081a77df7bc6/tests/test-check-py3-compat.t?revcount=960">history of test-check-py3-compat.t</a>.
We see the test being added in <a href="https://www.mercurial-scm.org/repo/hg/rev/40eb385f798f">December 2015</a>,
By June 2016, most of the code base was ported to our modern import convention
and we were ready to move on to more meaningful porting.</p>
<p>One of the biggest early hurdles in our porting effort was how to overcome
the string literals type mismatch between Python 2 and 3. In Python 2, a
<code>''</code> string literal is a sequence of bytes. In Python 3, a <code>''</code> string literal
is a sequence of Unicode code points. These are fundamentally different types.
And in Mercurial's code base, <strong>most of our <em>string</em> types are binary by design:
use of a Unicode based <code>str</code> for representing data is flat out wrong for our use
case</strong>. We knew that Mercurial would need to eventually switch many string
literals from <code>''</code> to <code>b''</code> to preserve type compatibility. But doing so would
be problematic.</p>
<p>In the early days of Mercurial's Python 3 port in 2015, Mercurial's project
maintainer (Matt Mackall) set a ground rule that the Python 3 port shouldn't overly
disrupt others: he wanted the Python 3 port to more or less happen in the background
and not require every developer to be aware of Python 3's low-level behavior in order
to get work done on the existing Python 2 code base. This may seem like a questionable
decision (and I probably disagreed with him to some extent at the time because I was
doing Python 3 porting work and the decision constrained this work). But it was the
correct decision. Matt knew that it would be years before the Python 3 port was either
necessary or resulted in a meaningful return on investment (the value proposition of
Python 3 has always been weak to Mercurial because Python 3 doesn't demonstrate a
compelling advantage over Python 2 for our use case). What Matt was trying to do was
minimize the externalized costs that a Python 3 port would inflict on the project.
He correctly recognized that maintaining the existing product and supporting
existing users was more important than a long-term bet in its infancy.</p>
<p>This ground rule meant that a mass insertion of <code>b''</code> prefixes everywhere
was not desirable, as that would require developers to think about whether
a type was a <code>bytes</code> or <code>str</code>, a distinction they didn't have to worry about
on Python 2 because we practically never used the Unicode-based string type in
Mercurial.</p>
<p>In addition, there were some other practical issues with doing a bulk <code>b''</code>
prefix insertion. One was that the added <code>b</code> characters would cause a lot of lines
to grow beyond our length limits and we'd have to reformat code. That would
require manual intervention and would significantly slow down porting. And
a sub-issue of adding all the <code>b</code> prefixes and reformatting code is that it would
<em>break</em> annotate/blame more than was tolerable. The latter issue was addressed
by teaching Mercurial's annotate/blame feature to <em>skip</em> revisions. The project
now has a convention of annotating commit messages with <code># skip-blame &lt;reason&gt;</code>
so structural only changes can easily be ignored when performing an
annotate/blame.</p>
<p>A stop-gap solution to the <code>b''</code> everywhere issue came in
<a href="https://www.mercurial-scm.org/repo/hg/rev/1c22400db72d">July 2016</a>, when I
introduced a custom Python module importer that rewrote source code as part
of <code>import</code> when running on Python 3. (I have
<a href="/blog/2017/03/13/from-__past__-import-bytes_literals/">previously blogged</a>
about this hack.) What this did was transparently add <code>b''</code> prefixes to all
un-prefixed string literals as well as modify how a few common functions were
called so that we wouldn't need to modify source code so things would run natively
on Python 3. The source transformer allowed us to have the benefits of progressing
in our Python 3 port without having to rewrite tens of thousands of lines of
source code. The solution was hacky. But it enabled us to make significant
progress on the Python 3 port without externalizing a lot of cost onto others.</p>
<p>I thought the source transformer would be relatively short-lived and would be
removed shortly after the project inevitably decided to go all in on Python 3.
To my surprise, others built additional transforms over the years and the source
transformer persisted all the way until
<a href="https://www.mercurial-scm.org/repo/hg/rev/d783f945a701">October 2019</a>, when
I removed it just before the first non-alpha Python 3 compatible version
of Mercurial was released.</p>
<p>A common problem Mercurial faced with making the code base dual Python 2/3 native
was dealing with standard library differences. Most of the problems stemmed
from changes between Python 2.7 and 3.5+. But there are changes within the
versions of Python 3 that we had to wallpaper over as well. In
<a href="https://www.mercurial-scm.org/repo/hg/rev/6041fb8f2da8">April 2016</a>, the
<code>mercurial.pycompat</code> module was introduced to export aliases or wrappers around
standard library functionality to abstract the differences between Python
versions. This file <a href="https://www.mercurial-scm.org/repo/hg/log/66af68d4c751/mercurial/pycompat.py?revcount=240">grew over time</a>
and <a href="https://www.mercurial-scm.org/repo/hg/file/66af68d4c751/mercurial/pycompat.py">eventually became</a>
Mercurial's version of <a href="https://six.readthedocs.io/">six</a>. To be honest, I'm
not sure if we should have used <code>six</code> from the beginning. <code>six</code> probably would
have saved some work. But we had to eventually write a lot of shims for
converting between <code>str</code> and <code>bytes</code> and would have needed to invent a
<code>pycompat</code> layer in some form anyway. So I'm not sure <code>six</code> would have saved
enough effort to justify the baggage of integrating a 3rd party package into
Mercurial. (When Mercurial accepts a 3rd party package, downstream packagers
like Debian get all hot and bothered and end up making questionable patches
to our source code. So we prefer to minimize the surface area for
problems by minimizing dependencies on 3rd party packages.)</p>
<p>Once we had a source transforming module importer and the <code>pycompat</code>
compatibility shim, we started to focus in earnest on making core
functionality actually work on Python 3. We established a convention of
annotating changesets needed for Python 3 with <code>py3</code>, so a
<a href="https://www.mercurial-scm.org/repo/hg/log?rev=desc(py3)&amp;revcount=4000">commit message search</a>
yields a lot of the history. (But it isn't a full history since not every Python 3
oriented change used this convention). We see from that history that after
the source importer landed, a lot of porting effort was spent on things
very early in the <code>hg</code> process lifetime. This included handling environment
variables, loading config files, and argument parsing. We introduced a
<a href="https://www.mercurial-scm.org/repo/hg/log/@/tests/test-check-py3-commands.t">test-check-py3-commands.t</a>
test to track the progress of <code>hg</code> commands working in Python 3. The very early
history of that file shows the various error messages changing, as underlying
early process functionality was slowly ported to work on Python 3. By
<a href="https://www.mercurial-scm.org/repo/hg/rev/2d555d753f0e">December 2016</a>, we
had <code>hg version</code> working on Python 3!</p>
<p>With basic <code>hg</code> command dispatch ported to Python 3 at the end of 2016,
2017 represented an inflection point in the Python 3 porting effort. With the
early process functionality working, different people could pick up different
commands and code paths and start making code work with Python 3. By
<a href="https://www.mercurial-scm.org/repo/hg/rev/52ee1b5ac277">March 2017</a>, basic
repository opening and <code>hg files</code> worked. Shortly thereafter,
<a href="https://www.mercurial-scm.org/repo/hg/rev/ed23f929af38">hg init started working as well</a>.
And <a href="https://www.mercurial-scm.org/repo/hg/rev/935a1b1117c7">hg status</a> and
<a href="https://www.mercurial-scm.org/repo/hg/rev/aea8ec3f7dd1">hg commit</a> did as well.</p>
<p>Within a few months, enough of Mercurial's functionality was working with Python
3 that we started to <a href="https://www.mercurial-scm.org/repo/hg/rev/7a877e569ed6">track which tests passed on Python 3</a>.
The <a href="https://www.mercurial-scm.org/repo/hg/log/@/contrib/python3-whitelist?revcount=480">evolution of this file</a>
shows a reasonable history of the porting velocity.</p>
<p>In <a href="https://www.mercurial-scm.org/repo/hg/rev/feb910d2f59b">May 2017</a>, we dropped
support for Python 2.6. This significantly reduced the complexity of supporting
Python 3, as there was tons of functionality in Python 2.7 that made it easier
to target both Python 2 and 3 and now our hands were untied to utilize it.</p>
<p>In <a href="https://www.mercurial-scm.org/repo/hg/rev/bd8875b6473c">November 2017</a>, I
landed a test harness feature to report exceptions seen during test runs. I
later <a href="https://www.mercurial-scm.org/repo/hg/rev/8de90e006c78">refined the output</a>
so the most frequent failures were reported more prominently. This feature
greatly enabled our ability to target the most common exceptions, allowing
us to write patches to fix the most prevalent issues on Python 3 and uncover
previously unknown failures.</p>
<p>By the end of 2017, we had most of the structural pieces in place to complete
the port. Essentially all that was required at that point was time and labor.
We didn't have a formal mechanism in place to target porting efforts. Instead,
people would pick up a component or test that they wanted to hack on and then
make incremental changes towards making that work. All the while, we didn't
have a strict policy on not regressing Python 3 and regressions in Python 3
porting progress were semi-frequent. Although we did tend to correct
regressions quickly. And over time, developers saw a flurry of Python 3
patches and slowly grew awareness of how to accommodate Python 3, and the
number of Python 3 regressions became less frequent.</p>
<p>As useful as the source-transforming module importer was, it incurred some
additional burden for the porting effort. The source transformer effectively
converted all un-prefixed string literals (<code>''</code>) to bytes literals (<code>b''</code>)
to preserve string type behavior with Python 2. But various aspects of Python
3 didn't like the existence of <code>bytes</code>. Various standard library functionality
now wanted unicode <code>str</code> and didn't accept <code>bytes</code>, even though the Python
2 implementation used the equivalent of <code>bytes</code>. So our <code>pycompat</code> layer
grew pretty large to accommodate calling into various standard library
functionality. Another side-effect which we didn't initially anticipate
was the <code>**kwargs</code> calling convention. Python allows you to use <code>**</code>
with a dict with string keys to turn those keys into named arguments
in a function call. But Python 3 requires these <code>dict</code> keys to be
<code>str</code> and outright rejects <code>bytes</code> keys, even if the <code>bytes</code> instance
is ASCII safe and has the same underlying byte representation of the
string data as the <code>str</code> instance would. So we had to invent support
functions that would convert <code>dict</code> keys from <code>bytes</code> to <code>str</code> for
use with <code>**kwargs</code> and another to convert a <code>**kwargs</code> dict from
<code>str</code> keys to <code>bytes</code> keys so we could use <code>''</code> syntax to access keys
in our source code! Also on the string type front, we had to sprinkle
the codebase with raw string literals (<code>r''</code>) to force the use of
<code>str</code> irregardless of which Python version you were running on (our
source transformer only changed unprefixed string literals, so existing
<code>r''</code> strings would be preserved as <code>str</code>).</p>
<p>Blind transformation of all string literals to <code>bytes</code> was less than ideal
and it did impose some unwanted side-effects. But, again, most <em>strings</em>
in Mercurial are bytes by design, so we thought it would be easier to
<em>byteify</em> all strings then selectively undo that where native strings
were actually warranted (like keys in most <code>dict</code>s) than to take the
up-front cost to examine every string and make an intelligent determination
as to what type it should be. I go back and forth as to whether this was the
correct call. But when you factor in that the source transforming
module importer unblocked Python 3 porting at a time in the project's
history when there was so much focus on improving the core product and it
did so without externalizing many costs onto the people doing the critical
core product work, I think it was the right call.</p>
<p>By mid 2019, the number of test failures in Python 3 had been whittled
down to a reasonable, less daunting number. It felt like victory was
in grasp and inevitable. But a few significant issues lingered.</p>
<p>One remaining question was around addressing differences between Python
3 versions. At the time, Python 3.5, 3.6, and 3.7 were released and 3.8
was scheduled for release by the end of the year. We had a surprising
number of issues with differences in Python 3 versions. Many of us
were running Python 3.7, so it had the fewest failures. We had to spend
extra effort to get Python 3.5 and 3.6 working as well as 3.7. Same for
3.8.</p>
<p>Another task we deferred until the second half of 2019 was standing up
robust CI for Python 3. We had some coverage, but it was minimal. Wanting
a distraction from PyOxidizer for a bit and wanting to overhaul Mercurial's
CI system (which is officially built on Buildbot), I cobbled together a
<em>serverless</em> CI system built on top of AWS DynamoDB and S3 for storage,
Lambda functions and CloudWatch events for all business logic, and EC2 spot
instances for job execution. This CI system executed Python 3.5, 3.6, 3.7,
and 3.8 variants of our test harness on Linux and Python 3.7 on Windows.
This gave developers insight into version-specific failures. More
importantly, it also gave insight into Windows failures, which was
previously not well tested. It was discovered that Python 3 on Windows was
lagging significantly behind POSIX.</p>
<p>By the time of the Mercurial developer meetup in October 2019, nearly
all tests were passing on POSIX platforms and we were confident that
we could declare Python 3 support as at least beta quality for the
Mercurial 5.2 release, planned for early November.</p>
<p>One of our blockers for ripping off the alpha label on Python 3 support
was removing our source-transforming module importer. It had performance
implications and it wasn't something we wanted to ship because it felt
too hacky. A blocker for this was we wanted to automatically format
our source tree with <a href="https://black.readthedocs.io/en/stable/">black</a>
because if we removed the source transformer, we'd have to rewrite
a lot of source code to apply changes the transformer was performing,
which would necessitate wrapping a lot of lines, which would involve a lot
of manual effort. We wanted to <em>blacken</em> our code base first so that
mass rewriting source code wouldn't involve a lot of tedious reformatting
since <code>black</code> would handle that for us automatically. And rewriting the
source tree with <code>black</code> was blocked on a specific feature landing in
<code>black</code>! (We did not agree with <code>black</code>'s behavior of
unwrapping comma-delimited lists of items if they could fit on a single
line. So one of our core contributors wrote a patch to <code>black</code> that
changed its behavior so a trailing <code>,</code> in a list of items will force
items to be formatted on multiple lines. I personally find the multiple line
formatting much easier to read. And the behavior is arguably better for
code review and <em>annotation</em>, which is line based.) Once this feature
landed in <code>black</code>, we reformatted our source tree and started ripping
out the source transformations, starting by inserting <code>b''</code> literals
everywhere. By late October, the source transformer was no more and
we were ready to release beta quality support for Python 3 (at least
on UNIX-like platforms).</p>
<p>Having described a mostly factual overview of Mercurial's port to Python
3, it is now time to shift gears to the speculative and opinionated
parts of this post. <strong>I want to underscore that the opinions reflected
here are my own and do not reflect the overall Mercurial Project or even
a consensus within it.</strong></p>
<h2>The Future of Python 3 and Mercurial</h2>
<p>Mercurial's port to Python 3 is still ongoing. While we've shipped
Python 3 support and the test harness is clean on Python 3, I view shipping
as only a milestone - arguably <em>the</em> most important one - in a longer
journey. There's still a lot of work to do.</p>
<p>It is now 2020 and Python 2 support is now officially dead from the
perspective of the Python language maintainers. Linux distributions are
starting to rip out Python 2. Packages are dropping Python 2 support in
new versions. The world is moving to Python 3 only. But <strong>Mercurial still
officially supports Python 2</strong>. And it is still yet to be determined how
long we will retain support for Python 2 in the code base. We've only had
one release supporting Python 3. Our users still need to port their
extensions (implemented in Python). Our users still need to start widely
using Mercurial with Python 3. Even our own developers need to switch to
Python 3 (old habits are hard to break).</p>
<p>I anticipate a long tail of random bugs in Mercurial on Python 3. While
the tests may pass, our code coverage is not 100%. And even if it were,
Python is a dynamic language and there are tons of invariants that aren't
caught at compile time and can only be discovered at run time. <strong>These
invariants cannot all be detected by tests, no matter how good your test
coverage is.</strong> This is a <em>feature</em>/<em>limitation</em> of dynamic languages. Our
users will likely be finding a long tail of miscellaneous bugs on Python
3 for <em>years</em>.</p>
<p>At present, our code base is littered with tons of random hacks to bridge
the gap between Python 2 and 3. Once Python 2 support is dropped, we'll
need to remove these hacks and make the source tree Python 3 native, with
minimal shims to wallpaper over differences in Python 3 versions. <strong>Removing
this Python version bridge code will likely require hundreds of commits and
will be a non-trivial effort.</strong> It's likely to be deemed a low priority (it
is glorified busy work after all), and code for the express purpose of
supporting Python 2 will likely linger for years.</p>
<p>We are also still shoring up our packaging and distribution story on
Python 3. This is easier on some platforms than others. I created
<a href="https://github.com/indygreg/PyOxidizer">PyOxidizer</a> partially because
of the poor experience I had with Python application packaging and
distribution through the Mercurial Project. The Mercurial Project has
already signed off on using PyOxidizer for distributing Mercurial in
the future. So look for an <em>oxidized</em> Mercurial distribution in the
near future! (You could argue PyOxidizer is an epic yak shave to better
support Mercurial. But that's for another post.)</p>
<p>Then there's Windows support. A Python 3 powered Mercurial on Windows
still has a handful of known issues. It may require a few more releases
before we consider Python 3 on Windows to be stable.</p>
<p>Because we're still on a code base that must support Python 2, our
adoption of Python 3 features is very limited. The only Python 3
feature that Mercurial developers seem to almost universally get excited
about is type annotations. We already have some people playing around
with <code>pytype</code> using comment-based annotations and <code>pytype</code> has already
caught a few bugs. We're eager to go all in on type annotations and
uncover lots of dynamic typing bugs and poorly implemented APIs.
Beyond type annotations, I can't name any feature that people are screaming
to adopt and which makes a lot of sense for Mercurial. There's a long
tail of minor features I'm sure will get utilized. But none of the
marquee features that define major language releases seem that interesting
to us. Time will tell.</p>
<h2>Commentary on Python 3</h2>
<p>Having described Mercurial's ongoing journey to Python 3, I now want to
focus more on Python itself. Again, the opinions here are my own and
don't reflect those of the Mercurial Project.</p>
<p><strong>Succinctly, my experience porting Mercurial and other projects to
Python 3 has significantly soured my perceptions of Python. As much as
I have historically loved Python - from the language to the welcoming
community - I am still struggling to understand how Python could manage
to inflict so much hardship on the community by choosing the transition
plan that they did.</strong> I believe Python's choices represent a terrific
example of what not to do when managing a large project or ecosystem.
Maintainers of other largely-deployed systems would benefit from taking
the time to understand and reflect on Python's missteps.</p>
<p>Python 3.0 was released on December 3, 2008. And it took the better part of
a decade for the community to embrace it. <strong>This should be universally
recognized as a failure.</strong> While hindsight is 20/20, many of the issues
with Python 3 were obvious at the time and could have been mitigated had
the language maintainers been more accommodating - and dare I say
empathetic - to its users.</p>
<p>Initially, Python 3 had a rather cavalier attitude towards backwards and
forwards compatibility. In the early years of Python 3, the attitude of
Python's maintainers was <em>Python 3 is a new, better language: you should
target it explicitly</em>. There were some tools and methods to ease the
transition. But nothing super polished, especially in the early years.
Adoption of Python 3 in the overall community was slow. Python developers
in the wild justifiably complained that the value proposition of Python 3
was too weak to justify porting effort. Not helping was that the early
advice for targeting Python 3 was to rewrite the source code to become
Python 3 native. This is in contrast with using the same source to run on both
Python 2 and 3. For library and application maintainers, this potentially
meant maintaining separate versions of your code or forcing end-users to
make a giant leap, which would realistically orphan users on an old version,
fragmenting your user base. Neither of those were great alternatives, so
you can understand why many projects didn't bite.</p>
<p>For many projects of non-trivial size, flag day transitions from Python 2 to
3 were simply not viable: the pathway to Python 3 was to make code dual
Python 2/3 compatible and gradually switch over the runtime to Python 3.
But initial versions of Python 3 made this effectively impossible! Let me
give a few specific examples.</p>
<p>In Python 2, a string literal <code>''</code> is effectively an array of bytes. In
Python 3, it is a series of Unicode code points - a fundamentally different
type! In Python 2, you could write <code>b''</code> to be explicit that a string literal
was bytes or you could write <code>u''</code> to indicate a Unicode literal, mimicking
Python 3's behavior. In Python 3, you could write <code>b''</code> to create a <code>bytes</code>
instance. But for whatever reason, Python 3 initially removed the <code>u''</code> syntax,
meaning there wasn't as easy way to explicitly denote the type of each
string literal so that it was consistent between Python 2 and 3! Python 3.3
(released September 2012) restored <code>u''</code> support, making it more viable to
write Python source code that worked on both Python 2 and 3. <strong>For nearly 4
years, Python 3 took away the consistent syntax for denoting bytes/Unicode
string literals.</strong></p>
<p>Another feature was <code>%</code> formatting of strings. Python 2 allowed use of the
<code>%</code> formatting operator on both its string types. But Python 3 initially
removed the implementation of <code>%</code> from <code>bytes</code>. Why, I have no clue. It
is perfectly reasonable to splice byte sequences into a buffer via use of
a formatting string. But the Python language maintainers insisted otherwise.
And it wasn't until the community complained about its absence loudly enough
that this feature was
<a href="https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-461">restored in Python 3.5</a>,
which was released in September 2015. Fun fact: the lack of this feature was
once considered a blocker for Mercurial moving to Python 3 because
Mercurial uses <code>bytes</code> almost universally, which meant that nearly every use
of <code>%</code> would have to be changed to something else. And to this day, Python
3's <code>bytes</code> still doesn't have a <code>format()</code> method, so the alternative was
effectively string concatenation, which is a massive step backwards from the
expressiveness of <code>%</code> formatting.</p>
<p><strong>The initial approach of Python 3 mirrors a folly that many developers
and projects make: attempting a rewrite instead of performing incremental
evolution.</strong> For established projects, large scale rewrites often go poorly.
And Python 3 is no exception. Yes, from a code level, CPython (and likely
other Python implementations) were incremental changes over Python 2 using
the same code base. But from a language and standard library level, the
differences in Python 3 were significant enough that I - and even Python's
core maintainers - considered it a new language, and therefore a rewrite.
When your random project attempts a rewrite and fails, the blast radius of that is
often contained to that project. Maybe you don't publish a new release
as soon as you otherwise would. <strong>But when you are powering an ecosystem,
the ripple effects from a failed rewrite percolate throughout that ecosystem
and last for years and have many second order effects. We see this with
Python 3, where poor choices made in the late 2000s are inflicting significant
hardship still in 2020.</strong></p>
<p>From the initial restrained adoption of Python 3, it is obvious that the
Python ecosystem overwhelmingly rejected the initial boil the oceans approach
of Python 3. Python's maintainers eventually got the message and started
restoring features like <code>u''</code> and <code>bytes</code> <code>%</code> formatting back into the
language to placate the community. All the while Python 3 had been accumulating
new features and the cumulative sum of those features was compelling enough
to win over users.</p>
<p>For many projects (including Mercurial), Python 3.4/3.5 was the first viable
porting target for Python 3. Python 3.5 was released in September 2015, almost
7 years after Python 3.0 was released in December 2008. <strong>Seven. Years.</strong>
An ecosystem that falters for that long is generally not healthy. What may have
saved Python from total collapse here is that Python 2 was still going strong and
people were generally happy with it. I really do think Python dodged a bullet
here, because there was a massive window where the language could have
hemorrhaged a critical amount of its user base and been relegated to an
afterthought. One could draw an analogy to Perl, which lost out to PHP,
Python, and Ruby, and whose fall from grace aligned with a lengthy
transition from Perl 5 to 6.</p>
<p>If you look back at the early history of Python 3, <strong>I think you are forced
to conclude that Python effectively kneecapped itself for 5-7 years
through questionable implementation choices that prevented users from
incurring incremental transitions between the major language versions. 2008
to 2013-2015 should be known as the <em>lost years of Python</em> because so much
opportunity and energy was squandered.</strong> Yes, Python is still healthy today
and Python 3 is (finally) being adopted at scale. But had earlier versions
of Python 3 been more <em>empathetic</em> towards Python 2 users porting to it,
Python and Python 3 in 2020 would be even stronger than it is. The community
was artificially hindered for years. And we won't know until 2023-2025 what
things could have looked like in 2020 had the Python core language team
spent more time paving a smoother road between the major language versions.</p>
<p>To be clear, I do think Python 3 is generally a better language than Python 2.
It has fewer warts, more compelling features, and better performance (except
for startup time, which is still slower than Python 2). I am ecstatic the
community is finally rallying around Python 3! For my Python coding, it has
reached the point where I curse under my breath when I need to support
Python 2 or even older versions of Python 3, like 3.5 or 3.6: I just wish
the world would move on and adopt the future already!</p>
<p>But I would be remiss if I failed to mention some of my gripes with Python
3 beyond the transition shenanigans.</p>
<p>Perhaps my least favorite <em>feature</em> of Python 3 is its insistence that the
world is Unicode. In Python 2, the default string type was backed by
bytes. In Python 3, the default string type is backed by Unicode code
points. As part of that transition, large parts of the standard library
now operate in the Unicode space instead of the domain of bytes. I understand
why Python does this: they want <em>strings</em> to be Unicode and don't want
users to have to spend that much energy thinking about when to use
<code>str</code> versus <code>bytes</code>. This approach is admirable and somewhat defensible
because it takes a stand on a solution that is arguably <em>good enough</em> for
most users. However, <strong>the approach of assuming the world is Unicode is
flat out wrong and has significant implications for systems level
applications</strong> (like version control tools).</p>
<p>There are a myriad of places in Python's standard library where Python
insists on using the Unicode-backed <code>str</code> type and rejects <code>bytes</code>. For
example, various networking modules refuse to accept <code>bytes</code> for hostnames
or URLs. HTTP libraries won't accept <code>bytes</code> for HTTP header names or values.
Functions that are proxies to POSIX-defined functions won't accept <code>bytes</code>
even though the POSIX function it calls into is using <code>char *</code> and isn't
Unicode aware. Then there's filename handling, where Python assumes the
existence of a global encoding for filenames and uses this encoding to convert
between <code>str</code> and <code>bytes</code>. And it does this despite POSIX filesystem paths
being a bag of bytes where the only rules are that <code>\0</code> terminates the
filename and <code>/</code> is special.</p>
<p>In cases like Python refusing to accept <code>bytes</code> for things like HTTP
header names (which will just be spit out over the wire as bytes), Python's
pendulum has swung too far towards Unicode only. In my opinion, Python needs
to be more accommodating and allow <code>bytes</code> when it makes sense. I hope the
pendulum knocks some sense into people when it swings back towards a more
reasonable solution that better acknowledges the realities of the world we
live in.</p>
<p>For areas like filename handling, the world is more complicated. Python
is effectively an abstraction layer over the operating system APIs exposing
this functionality. And there is often an impedance mismatch between operating
systems. For example, POSIX (Linux) tends to use <code>char *</code> for everything
and doesn't care about encoding and Windows tends to use 16 bit character
types where the encoding is... a can of worms.</p>
<p><strong>The reality here is that it is impossible to abstract over differences
between operating system behavior without compromises that can result in data
loss, outright wrong behavior, or loss of functionality. But Python 3 attempts
to do it anyway, making Python 3 unsuitable (or at least highly undesirable) for
certain systems level applications that rely on it</strong> (like a version control
tool).</p>
<p>In fairness to Python, it isn't the only programming language that gets
this wrong. The only language I've seen <em>properly</em> implement higher-order
abstractions on top of operating system facilities is Rust, whose approach can
be generalized as <em>use Python 3's solution of normalizing to Unicode/UTF-8 by
default</em>, but expose <em>escape hatches</em> which allow access to the raw underlying
types and APIs used by the operating system for the advanced consumers who
require it. For example, Rust's <code>Path</code> type which represents a filesystem path
<a href="https://doc.rust-lang.org/std/path/struct.Path.html#method.as_os_str">allows access</a>
to the raw <a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html">OsStr</a> value
used by the operating system, not a normalization of it to bytes or Unicode,
which may be lossy. This allows consumers to e.g. create and retrieve
OS-native filesystem paths without data loss. This functionality is critical
in some domains. Python 3's awareness/insistence that the world is
Unicode (which it isn't universally) reduces Python's applicability in these
domains.</p>
<p>Speaking of Rust, at the Mercurial developer meetup in October 2019, we were
discussing the use of Rust in Mercurial and one of the core maintainers blurted
out something along the lines of <em>if Rust were at its current state 5 years ago,
Mercurial would have likely ported from Python 2 to Rust instead of Python 3</em>.
As crazy as it initially sounded, I think I agree with that assessment. With the
benefit of hindsight, having been a key player in the Python 3 porting effort,
seeing all the complications and headaches Python 3 is introducing, and
having learned Rust and witnessed its benefits for performance, control,
and correctness firsthand, porting to Rust would likely have been the correct
move for the project at that point in time. 2020 is not 2014, however, and I'm
not sure if I would opt for a rewrite in Rust today. (Most rewrites are follies
after all.) But I know one thing: I certainly wouldn't implement a new version
control tool in Python 3 and I would probably choose Rust as an implementation
language for most new projects in the systems level space or with an expected
shelf life of 10+ years. (I really should blog about how awesome Rust is.)</p>
<p>Back to the topic of Python itself, <strong>I'm really soured on Python at this
point in time. The effort required to port to Python 3 was staggering. For
Mercurial, Python 3 introduces a ton of problems and doesn't really solve
many. We effectively sludged through mud for several years only to wind
up in a state that feels strictly worse than where we started. I'm sure it will
be strictly better in a few years. But at that point, we're talking about a
5+ year transition. To call the Python 3 transition disruptive and
distracting for the project would be an understatement. As a project maintainer,
it's natural to ask what we could have accomplished if we weren't forced
to carry out this sideshow.</strong></p>
<p>I can't shake the feeling that a lot of the pain afflicted by the Python 3
transition could have been avoided had Python's language leadership made
a different set of decisions and more highly prioritized the transition
experience. (Like not initially removing features like <code>u''</code> and <code>bytes %</code>
and not introducing gratuitous backwards compatibility breaks, like with
<code>items()/iteritems()</code>. I would have also liked to see a feature like
<code>from __future__</code> - maybe <code>from __past__</code> - that would make it easier for
Python 3 code to target semantics in earlier versions in order to provide
a more turnkey on-ramp onto new versions.) I simultaneously see Python 3
losing its position as a justifiable tool in some domains (like systems
level tooling) due to ongoing design decisions and poor implementation (like
startup overhead problems). (In contrast, I see Rust excelling where Python
is faltering and find Rust code surprisingly expressive to write and maintain
given how low-level it is and therefore feel that Rust is a compelling
alternative to Python in a surprisingly large number of domains.)</p>
<p>Look, I know it is easy for me to armchair quarterback and critique with the
benefit of hindsight/ignorance. I'm sure there is a lot of nuance here. I'm
sure there was disagreement within the Python community over a lot of these
issues. Maintaining a large and successful programming language and community
like Python's is hard and you aren't going to please all the people all the
time. And speaking as a maintainer, I have mad respect for the people leading
such a large community. But niceties aside, everyone knows the Python 3
transition was rough and could have gone better. It should not have taken 11
years to get to where we are today.</p>
<p><strong>I'd like to encourage the Python Project to conduct a thorough postmortem on
the transition to Python 3.</strong> Identify what went well, what could have gone
better, and what should be done next time such a large language change is wanted.
Speaking as a Python user, a maintainer of a Python project, and as someone in
industry who is now skeptical about use of Python at work due to risks of
potentially company crippling high-effort migrations in the future, a postmortem
would help restore my confidence that Python's maintainers learned from the
various missteps on the road to Python 3 and these potentially ecosystem
crippling mistakes won't be made again.</p>
<p>Python had a wildly successful past few decades. And it can continue to
thrive for several more. But the Python 3 migration was painful for all
involved. And as much as we need to move on and leave Python 2 behind us,
there are some important lessons to be learned. I hope the Python community
takes the opportunity to reflect and am confident it will grow stronger by
taking the time to do so.</p>]]></content:encoded>
    </item>
    <item>
      <title>Problems with Pull Requests and How to Fix Them</title>
      <link>http://gregoryszorc.com/blog/2020/01/07/problems-with-pull-requests-and-how-to-fix-them</link>
      <pubDate>Tue, 07 Jan 2020 12:10:00 PST</pubDate>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Git]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2020/01/07/problems-with-pull-requests-and-how-to-fix-them</guid>
      <description>Problems with Pull Requests and How to Fix Them</description>
      <content:encoded><![CDATA[<p>You've probably used or at least heard of <em>pull requests</em>: the <em>pull
request</em> is the contribution workflow practiced on and made popular by
[code] collaboration sites like GitHub, GitLab, Bitbucket, and others.
Someone (optionally) creates a <em>fork</em>, authors some commits, pushes them
to a branch, then creates a <em>pull request</em> to track integrating those commits
into a target repository and branch. The <em>pull request</em> is then used as a
vehicle for code review, tracking automated checks, and discussion until
it is ready to be integrated. Integration is usually performed by a
project maintainer, often with the click of a <em>merge</em> button on the pull
request's web page.</p>
<p>It's worth noting that the term <em>pull request</em> is not universally used:
GitLab calls them <em>merge requests</em> for example. Furthermore I regard the
terms <em>pull request</em> and <em>merge request</em> to be poorly named, as the terms
can be conflated with terminology used by your version control tool (e.g.
<code>git pull</code> or <code>git merge</code>. And the implementations of a <em>pull</em> or <em>merge</em>
request may not even perform a <em>pull</em> or a <em>merge</em> (you can also <em>rebase</em> a
<em>pull</em>/<em>merge</em> request, but nobody is calling them <em>rebase requests</em>). A
modern day <em>pull request</em> is so much more than a version control tool
operation or even a simple request to <em>pull</em> or <em>merge</em> a branch: it is a
nexus to track the integration of a proposed change before during and after
that change is integrated. But alas. Because GitHub coined the term and is
the most popular collaboration platform implementing this functionality, I'll
refer to this general workflow as implemented on GitHub, GitLab, Bitbucket,
and others as <em>pull requests</em> for the remainder of this post.</p>
<p>Pull requests have existed in essentially their current form for over
a decade. The core workflow has remained mostly unchanged.
What is different are the addition of value-add features, such as integrating
status checks like CI results, the ability to rebase or squash commits
instead of merging, code review tooling improvements, and lots of UI
polish. GitLab deserves a call out here, as their implementation of
<em>merge requests</em> tracks so much more than other tools do. (This is a
side-effect of GitLab having more built-in features than comparable tools.)
I will also give kudos to GitLab for adding new features to pull requests
when GitHub was asleep at the wheel as a company a few years ago. (Not having
a CEO for clear product/company leadership really showed.) Fortunately,
both companies (and others) are now churning out new, useful features at a
terrific clip, greatly benefiting the industry!</p>
<p>While I don't have evidence of this, I suspect pull requests (and the forking
model used by services that implement them) came into existence when someone
thought <em>how do I design a collaboration web site built on top of Git's new and
novel distributed nature and branching features</em>. They then proceeded to invent
<em>forking</em> and <em>pull requests</em>. After all, the pull request as implemented by
GitHub was initially a veneer over a common Git workflow of <em>create a clone,
create a branch, and send it somewhere.</em> Without GitHub, you would run <code>git
clone</code>, <code>git branch</code>, then some other command like
<a href="https://git-scm.com/docs/git-request-pull">git request-pull</a> (where have I seen
those words before) to generate/send your branch somewhere. On GitHub, the
comparable steps are roughly <em>create a fork</em>, <em>create a branch to your fork</em>,
and <em>submit a pull request</em>. Today, you can even do all of this straight from
the web interface without having to run <code>git</code> directly! This means that GitHub
can conceptually be thought of as a purely server-side abstraction/implementation
of the Git feature branch workflow.</p>
<p><strong>At its core, the pull request is fundamentally a nice UI and feature layer
built around the common Git feature branch workflow.</strong> It was likely initially
conceived as polish and value-add features over this historically client-side
workflow. And this core property of pull requests from its very first days has
been copied by vendors like Bitbucket and GitLab (and in Bitbucket's case it
was implemented for Mercurial - not Git - as Bitbucket was initially Mercurial
only).</p>
<p>A decade is an eternity in the computer industry. As they say, if you
aren't moving forward, you are moving backward. <strong>I think it is time
for industry to scrutinize the pull request model and to evolve it into
something better.</strong></p>
<p>I know what you are thinking: you are thinking that pull requests
work great and that they are popular because they are a superior model
compared to what came before. These statements - aside from some nuance -
are true. But if you live in the version control space (like I do) or
are paid to deliver tools and workflows to developers to improve
productivity and code/product quality (which I am), the deficiencies
in the pull request workflow and implementation of that workflow among
vendors like GitHub, GitLab, Bitbucket, etc are obvious and begging to be
overhauled if not replaced wholesale.</p>
<p>So buckle in: you've started a ten thousand word adventure about everything
you didn't think you wanted to know about pull requests!</p>
<h2>Problems with Pull Requests</h2>
<p>To build a better workflow, we first have to understand what is
wrong/sub-optimal with pull requests.</p>
<p><strong>I posit that the foremost goal of an pull request is to foster the
incorporation of a high quality and desired change into a target
repository with minimal overhead and complexity for submitter,
integrator, and everyone in between.</strong> Pull requests achieve this
goal by fostering collaboration to discuss the change (including code
review), tracking automated checks against the change, linking to related
issues, etc. In other words, the way I see the world is that a specific
vendor's pull request implementation is just that: an implementation detail.
And like all implementation details, they should be frequently scrutinized
and changed, if necessary.</p>
<p>Let's start dissecting the problems with pull requests by focusing on
the size of review units. Research by
<a href="https://sback.it/publications/icse2018seip.pdf">Google</a>,
Microsoft <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/bosu2015useful.pdf">here</a>,
and <a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2015/05/PID3556473.pdf">here</a>,
and others has shown an inverse correlation with review unit size
and defect rate. In Google's words (emphasis mine):</p>
<p>The size distribution of changes is an important factor in the
   quality of the code review process. <strong>Previous studies have found that
   the number of useful comments decreases and the review latency
   increases as the size of the change increases.</strong> Size also
   influences developers' perception of the code review process; a
   survey of Mozilla contributors found that <strong>developers feel that
   size-related factors have the greatest effect on review latency</strong>.
   A correlation between change size and review quality is
   acknowledged by Google and <strong>developers are strongly encouraged to
   make small, incremental changes</strong> (with the exception of large
   deletions and automated refactoring). These findings and our study
   support the value of reviewing small changes and the need for
   research and tools to help developers create such small,
   self-contained code changes for review.</p>
<p>Succinctly, larger changes result in fewer useful comments during
review (meaning quality is undermined) and make reviews take longer
(meaning productivity is undermined). <strong>Takeaway: if you care about
defect rate / quality and/or velocity, you should be authoring and
reviewing more, smaller changes as opposed to fewer, larger changes.</strong></p>
<p>I stronger agree with Google's opinion on this matter and wholeheartedly
endorse writing more, smaller changes. Having practiced both forms of
change authorship, I can say without a doubt that more, smaller changes
is superior: superior for authors, superior for code reviewers, and
superior for people looking at repository history later. The main downside
with this model is that it requires a bit more knowledge of your version
control tool to execute. And, it requires corresponding tooling to play
well with this change authorship model and to introduce as little
friction as possible along the way since the number of interactions
with tooling will increase as change size decreases, velocity
increases, and there are more distinct units of change being considered
for integration.</p>
<p>That last point is important and is germane to this post because the
common implementation of pull requests today is not very compatible
with the <em>many small changes</em> workflow. As I'll argue, <strong>the current
implementation of pull requests actively discourages the many smaller
changes workflow. And since smaller changes result in higher quality
and faster reviews, today's implementations of pull requests are
undermining quality and velocity.</strong></p>
<p>I don't mean to pick on them, but since they are the most popular and
the people who made pull requests popular, let's use GitHub's implementation
of pull requests to demonstrate my point.</p>
<p><strong>I posit that in order for us to author more, smaller changes, we must
either a) create more, smaller pull requests or b) have pull request
reviews put emphasis on the individual commits (as opposed to the
overall <em>merge diff</em>).</strong> Let's examine these individually.</p>
<p>If we were to author more, smaller pull requests, this would seemingly
necessitate the need for dependencies between pull requests in order
to maintain velocity. And dependencies between pull requests adds
a potentially prohibitive amount of overhead. Let me explain. We don't
want to sacrifice the overall rate at which authors and maintainers are
able to integrate proposed changes. If we were to split existing proposed
changes into more, smaller pull requests, we would have a lot more pull
requests. Without dependencies between them, authors could wait for each
pull request to be integrated before sending the next one. But this would
incur more round trips between author and integrator and would almost
certainly slow down the overall process. That's not desirable. The
obvious mitigation to that is to allow multiple, related pull requests
in flight simultaneously. But this would necessitate the invention of
dependencies between pull requests in order to track relationships so
one pull request doesn't integrate before another it logically depends on.
This is certainly technically doable. But it imposes considerable
overhead of its own. How do you define dependencies? Are dependencies
automatically detected or updated based on commits in a DAG? If yes,
what happens when you force push and it is ambiguous whether a <em>new</em>
commit is a logically new commit or a successor of a previous one? If
no, do you really want to impose additional hurdles on submitters to
define dependencies between every pull request? In the extreme case of
one pull request per commit, do you make someone submitting a series of
say twenty commits and pull requests really annotate nineteen dependencies?
That's crazy!</p>
<p>There's another, more practical issue at play: the interplay between
Git branches and pull requests. As implemented on GitHub, a pull request
is tracked by a Git branch. If we have N inter-dependent pull requests,
that means N Git branches. In the worst case, we have one Git branch for
every Git commit. Managing N in-flight Git branches would be absurd.
It would impose considerable overhead on pull request submitters. It
would perfectly highlight the inefficiency in Git's
<a href="/blog/2017/12/11/high-level-problems-with-git-and-how-to-fix-them/">game of refs</a>
branch management that I blogged about two years ago. (Succinctly,
once you are accustomed to workflows - like Mercurial's - which don't
require you to name commits or branches, Git's forced naming of branches
and all the commands requiring those branch names feels grossly inefficient
and a mountain of overhead.) Some tooling could certainly be implemented
to enable efficient submission of pull requests. (See
<a href="https://github.com/ezyang/ghstack">ghstack</a> for an example.) But I
think the interplay between Git branches and GitHub pull requests is
sufficiently complex that the tooling and workflow would be intractable
for anything but the most trivial and best-case scenarios. Keep in mind
that any sufficiently user-friendly solution to this problem would
also entail improving <code>git rebase</code> so it moves branches on rewritten
ancestor commits instead of leaving them on the old versions of
commits. (Seriously, someone should implement this feature: it arguably
makes sense as the default behavior for local branches.) In other
words, <strong>I don't think you can implement the multiple pull request model
reliably and without causing excessive burden on people without
fundamentally changing the requirement that a pull request be a Git
branch</strong>. (I'd love to be proven wrong.)</p>
<p>Therefore, <strong>I don't think the more, smaller changes workflow can be easily
practiced with multiple pull requests using the common GitHub model without
effectively moving the definition of a pull request away from
equivalence with a Git branch</strong> (more on this later). And I also
don't mean to imply that dependencies between pull requests can't be
implemented: they can and
<a href="https://docs.gitlab.com/ee/user/project/merge_requests/merge_request_dependencies.html">GitLab is evidence</a>.
But GitLab's implementation is somewhat simple and crude (possibly
because doing anything more complicated is really hard as I speculate).</p>
<p>So without fundamentally changing the relationship between a pull
request and a branch, that leaves us with our alternative of pull
requests putting more emphasis on the individual changes rather than
the <em>merge diff</em>. Let's talk about that now.</p>
<p>Pull requests have historically placed emphasis on the <em>merge diff</em>.
That is, GitHub (or another provider) takes the Git branch you have
submitted, runs a <code>git merge</code> against the target branch behind the
scenes, and displays that diff front and center for review as the main
proposed unit of change: if you click the <em>Files changed</em> tab to
commence review, you are seeing this overall <em>merge diff</em>. You can
click on the <em>Commits</em> tab then select an individual commit to review
just that commit. Or you can use the dropdown on the <em>Files changed</em>
tab to select an individual commit to review it. These (relatively
new) features are a very welcome improvement and do facilitate
performing a commit-by-commit review, which is a requirement to realize
the benefits of a more, smaller changes workflow. Unfortunately, they
are far from sufficient to fully realize the benefits of that workflow.</p>
<p>Defaults matter and GitHub's default is to show the <em>merge diff</em> when
conducting review. (I bet a large percentage of users don't even know
it is possible to review individual commits.) <strong>Since larger changes
result in a higher defect rate and slower review, GitHub's default
of showing the <em>merge diff</em> effectively means GitHub is defaulting to
lower quality, longer-lasting reviews.</strong> (I suppose this is good for
engagement numbers, as it inflates service usage both immediately and
in the long-term due to subsequent bugs driving further usage. But I
sincerely hope no product manager is thinking <em>let's design a product
that undermines quality to drive engagement</em>.)</p>
<p>Unfortunately, a trivial change of the default to show individual commits
instead of the <em>merge diff</em> is not so simple, as many authors and
projects don't practice clean commit authorship practices, where
individual commits are authored such that they can be reviewed in isolation.</p>
<p>(One way of classifying commit authorship styles is by whether a series
of commits is authored such that each commit is good in isolation or
whether the effect of applying the overall series is what matters. A
handful of mature projects - like the Linux kernel, Firefox, Chrome,
Git, and Mercurial - practice the <em>series of individually-good commits</em>
model, which I'll call a <em>commit-centric workflow</em>. I would wager the
majority of projects on GitHub and similar services practice the <em>we only
care about the final result of the series of commits</em> model. A litmus
test for practicing the latter model is whether pull requests contain commits
like <em>fixup foo</em> or if subsequent revisions to pull requests create new
commits instead of amending existing ones. I'm a strong proponent of
a clean commit history where each commit in the final repository history
stands as <em>good</em> in isolation. But I tend to favor more <em>grown-up</em>
software development practices and am a version control guru. That
being said, the subject/debate is fodder for another post.)</p>
<p>If GitHub (or someone else) switched the pull request default to a
per-commit review without otherwise changing the relationship between a
pull request and a Git branch, that would force a lot of less experienced
users to familiarize themselves with history rewriting in Git. This would
impose considerable pain and suffering on pull request authors, which
would in turn upset users, hurt engagement, etc. Therefore, I don't think
this is a feasible <em>global</em> default that can be changed. Maybe if Git's
user experience for history rewriting were better or we didn't have a
decade of behavior to undo we'd be in a better position... But pull
request implementations don't need to make a <em>global</em> change: <strong>they could
<em>right the ship</em> by offering projects that practice <em>clean commit
practices</em> an option to change the review default so it emphasizes
individual commits instead of the <em>merge diff</em>.</strong> This would go a long way
towards encouraging authoring and reviewing individual commits, which
should have positive benefits on review velocity and code quality
outcomes.</p>
<p>But even if these services did emphasize individual commits by default in
pull request reviews, there's still a handful of significant
deficiencies that would undermine the more, smaller changes workflow
that we desire.</p>
<p>While it is possible to review individual commits, all the review comments
are still funneled into a single per pull request <em>timeline</em> view of
activity. <strong>If submitter and reviewer make the effort to craft and
subsequently review individual commits, your reward is that all the feedback
for the discrete units of change gets lumped together into one massive pile
of feedback for the pull request as a whole.</strong> This unified pile of feedback
(currently) does a poor job of identifying which commit it applies to and
gives the author little assistance in knowing which commits need amending to
address the feedback. This undermines the value of commit-centric workflows
and effectively pushes commit authors towards the <em>fixup</em> style of commit
authorship. <strong>In order to execute per-commit review effectively, review
comments and discussion need to be bucketed by commit and not combined into a
unified pull request timeline.</strong> This would be a massive change to the pull
request user interface and would be a daunting undertaking, so it is
understandable why it hasn't happened yet. And such an undertaking would also
require addressing subtly complex issues like how to preserve reviews in the
face of force pushes. Today, GitHub's review comments can <em>lose context</em> when
force pushes occur. Things are better than they used to be, when review comments
left on individual commits would flat out be deleted (yes: GitHub really did
effectively lose code review comments for several years.) But even with tooling
improvements, problems still remain and should adoption of commit-level review
tracking occur, these technical problems would likely need resolution to
appease users of this workflow.</p>
<p>Even if GitHub (or someone else) implements robust per-commit review
for pull requests, there's still a problem with velocity. And that problem
is that <strong>if the pull request is your unit of integration (read: <em>merging</em>),
then you have to wait until every commit is reviewed before integration
can occur</strong>. This may sound tolerable (it's what we practice today after
all). But I argue this is less optimal than a world where a change
integrates as soon as it is ready to, without having to wait for the
changes after it. <strong>As an author and maintainer, if I see a change that
is ready to integrate, I prefer to integrate it as soon as possible, without
delay.</strong> The longer a ready-to-integrate change lingers, the longer it is
susceptible to bit rot (when the change is no longer valid/good due to
other changes in the system). Integrating a judged-good change sooner also
reduces the time to meaningful feedback: if there is a fundamental
problem early in a series of changes that isn't caught before integration,
integrating earlier changes sooner without waiting for the ones following
will expose problems sooner. This minimizes deltas in changed systems
(often making regression hunting easier), often minimizes the blast radius if
something goes wrong, and gives the author more time and less pressure to
amend subsequent commits that haven't been integrated yet. And in addition
to all of this, <strong>integrating more often just feels better</strong>.
<a href="https://hbr.org/2011/05/the-power-of-small-wins">The Progress Principle</a>
states that people feel better and perform better work when they are
making continuous progress. But setbacks more than offset the power of
small wins. While I'm not aware of any explicit research in this area,
my interpretation of the Progress Principle to change authorship and project
maintenance(which is supported by anecdotal observation) is
that a steady stream of integrated changes feels a hell of a lot better
than a single monolithic change lingering in review purgatory for what can
often seem like an eternity. <strong>While you need to be cognizant to not
confuse movement with meaningful progress, I think there is real power
to the Progress Principle and that we should aim to incorporate changes
as soon as they are ready and not any later.</strong> Applied to version control
and code review, this means integrating a commit as soon as author,
reviewer, and our machine overlords reporting status checks all agree it
is ready, without having to wait for a larger unit of work, like the
pull request. Succinctly, move forward as soon as you are able to!</p>
<p>This desire to <em>integrate faster</em> has significant implications for
pull requests. Again, looking at GitHub's implementation of pull
requests, I don't see how today's pull requests could adapt to this
desired end state without significant structural changes. For starters,
review <strong>must</strong> grow the ability to track per-commit state otherwise
integrating individual commits without the entirety of the parts makes
little sense. But this entails all the complexity I described above.
Then there's the problem of Git branches effectively defining a pull
request. What happens when some commits in a pull request are integrated
and the author rebases or merges their local branch against their new
changes? This may or may not <em>just work</em>. And when it doesn't <em>just work</em>,
the author can easily find themselves in <em>merge conflict hell</em>, where
one commit after the other fails to apply cleanly and their carefully
curated stack of commits quickly becomes a liability and impediment to
forward progress. (As an aside, the Mercurial version control tool has
a concept called <em>changeset evolution</em> where it tracks which commits -
changesets in Mercurial parlance - have been rewritten as other commits
and gracefully reacts in situations like a rebase. For example, if you
have commits <code>X</code> and <code>Y</code> and <code>X</code> is integrated via a rebase as <code>X'</code>, an
<code>hg rebase</code> of <code>Y</code> onto <code>X'</code> will see that <code>X</code> was rewritten as <code>X'</code> and
skip attempting to rebase <code>X</code> because it is already applied! This cleanly
sidesteps a lot of the problems with history rewriting - like merge
conflicts - and can make the end-user experience much more pleasant as
a result.) While it is certainly possible to integrate changes as soon
as they are <em>ready</em> with a pull request workflow, I think that it is
awkward and that by the time you've made enough changes to accommodate
the workflow, very little is left of the pull request workflow as we
know it and it is effectively a different workflow altogether.</p>
<p><strong>The above arguments overly hinge on the assumption that more smaller
changes is superior for quality and/or velocity and that we should
design workflows around this assertion.</strong> While I strongly believe
in the merits of smaller units of change, others may disagree. (If
you do disagree, you should ask yourself whether you believe the
converse: that larger units of change are better for quality and
velocity. I suspect most people can't justify this. But I do believe
there is merit to the argument that smaller units of change impose
additional per-unit costs or have second order effects that undermine
their touted quality or velocity benefits.)</p>
<p><strong>But even if you don't buy into the change size arguments, there's
still a very valid reason why we should think beyond pull requests as
they are implemented today: tool scalability.</strong></p>
<p>The implementation of pull requests today is strongly coupled with
how Git works out of the box. A pull request is initiated from a Git
branch pushed to a remote Git repository. When the pull request is
created, the server creates a Git branch/ref referring to that pull
request's <em>head</em> commits. On GitHub, these refs are
<a href="https://help.github.com/en/github/collaborating-with-issues-and-pull-requests/checking-out-pull-requests-locally">named</a>
<code>pull/ID/head</code> (you can fetch these from the remote Git repository but
they are not fetched by default). Also when a pull request is created
or updated, a <code>git merge</code> is performed to produce a diff for review.
On GitHub, the resulting merge commit is <em>saved</em> and pointed to on
the open pull request via a <code>pull/ID/merge</code> ref, which can also be
fetched locally. (The <em>merge</em> ref is deleted when the pull request is
closed.)</p>
<p>Herein resides our scalability problem: unbound growth of Git refs
and ever-increasing rate of a change for a growing project.
Each Git ref adds overhead to graph walking operations and data exchange.
While involved operations are continuously getting optimized (often through
the use of more advanced data structures or algorithms), there are
intrinsic scaling challenges with this unbound growth that - speaking as
a version control tool maintainer - I want no part of. Are technical
solutions enabling things to scale to millions of Git refs viable?
Yes'ish. But it requires high-effort solutions like
<a href="https://git.eclipse.org/r/#/c/146568/">JGit's Reftable</a>, which
required ~90 review rounds spanned across ~4 months to land. And that's
after design of the feature was first proposed at least as far back
as <a href="https://public-inbox.org/git/CAJo=hJtyof=HRy=2sLP0ng0uZ4=S-DpZ5dR1aF+VHVETKG20OQ@mail.gmail.com/">July 2017</a>.
Don't get me wrong: am I glad Reftable exists: yes. It is a fantastic
solution to a real problem and reading how it works will probably
make you a better engineer. But simultaneously, it is a solution to a
problem that does not need to exist. There is a space for scaling graph
data structures and algorithms to millions or even billions of nodes, edges,
and paths: your version control tool should not be it. Millions or billions
of commits and files: that's fine. But scaling the number of distinct paths
through that graph by introducing millions of DAG heads is insane given how much
complexity it introduces in random areas of the tool. In my opinion it
requires unjustifiably large amounts of investment to make work
at scale. As an engineer, my inclination when posed with problems like
these is to avoid them in the first place. The easiest problems to solve
are those you don't have.</p>
<p><strong>Unfortunately, the tight coupling of pull requests to Git branches/refs
introduces unbound growth and a myriad of problems associated with it.</strong>
Most projects may not grow to a size that experiences these problems. But
as someone who has experience with this problem space at multiple companies,
I can tell you the problem is very real and the performance and scalability
issues it creates undermines the viability of using today's implementation of
pull requests once you've reached a certain scale. Since we can likely fix the
underlying scaling issues with Git, I don't think the explosion of Git refs
is a long-term deal breaker for scaling pull requests. But it is today and
will remain so until Git and the tools built on top of it improve.</p>
<p>In summary, some high-level problems with pull requests are as follows:</p>
<ul>
<li>Review of <em>merge diff</em> by default encourages larger units of review,
  which undermines quality and velocity outcomes.</li>
<li>Inability to incrementally integrate commits within a pull request,
  which slows down velocity, time to meaningful feedback, and can
  lower morale.</li>
<li>Tight coupling of pull requests with Git branches adds rigidity to
  workflows and shoehorns into less flexible and less desired workflows.</li>
<li>Deficiencies in the Git user experience - particular around what happens
  when rewrites (including rebase) occur - significantly curtail what
  workflows can be safely practiced with pull requests.</li>
<li>Tight coupling of pull requests with Git branches can lead to performance
  issues at scale.</li>
</ul>
<p>We can invert language to arrive at a set of more ideal outcomes:</p>
<ul>
<li>Review experience is optimized for individual commits - not the <em>merge
  diff</em> - so review units are smaller and quality and velocity outcomes
  are improved.</li>
<li>Ability to incrementally integrate individual commits from a larger
  set so ready-to-go changes are incorporated sooner, improving velocity,
  time to meaningful feedback, and morale.</li>
<li>How you use Git branches does not impose significant restrictions on
  handling of pull requests.</li>
<li>You can use your version control tool how you want, without having to
  worry about your workflow being shoehorned by how pull requests
  work.</li>
<li>Pull request server can scale to the most demanding use cases with
  relative ease.</li>
</ul>
<p>Let's talk about how we could achieve these more desirable outcomes.</p>
<h2>Exploring Alternative Models</h2>
<p>A <em>pull request</em> is merely an implementation pattern for the general problem
space of <em>integrating a proposed change</em>. There are other patterns used by other
tools. Before I describe them, I want to coin the term <em>integration request</em> to
refer to the generic concept of requesting some change being <em>integrated</em>
elsewhere. GitHub pull requests and GitLab merge requests are implementations
of <em>integration requests</em>, for example.</p>
<p>Rather than describe alternative tools in detail, I will outline the key
areas where different tools differ from pull requests and assess the benefits
and drawbacks to the different approaches.</p>
<h3>Use of the VCS for Data Exchange</h3>
<p>One can classify implementations of <em>integration requests</em> by how they utilize
the underlying version control tools.</p>
<p>Before Git and GitHub came along, you were probably running a centralized version
control tool which didn't support offline commits or feature branches (e.g. CVS
or Subversion). In this world, the common mechanism for <em>integration requests</em>
was exchanging diffs or patches through various media - email, post to a web
service of a code review tool, etc. Your version control tool didn't speak
directly to a VCS server to initiate an <em>integration request</em>. Instead, you
would run a command which would export a text-based representation of the
change and then send it somewhere.</p>
<p>Today, we can classify <em>integration requests</em> by whether or not they speak
the version control tool's native protocol for exchanging data or whether
they exchange patches through some other mechanism. Pull requests speak the
VCS native protocol. Tools like Review Board and Phabricator exchange patches
via custom HTTP web services. Typically, tools using non-native exchange
will require additional client-side configuration, including potentially the
installation of a custom tool (e.g. <code>RBTools</code> for Review Board or <code>Arcanist</code>
for Phabricator). Although modern version control tools sometimes have
this functionality built-in. (e.g. Git and Mercurial fulfill
<a href="https://en.wikipedia.org/wiki/Jamie_Zawinski#Principles">Zawinski's law</a> and
Mercurial has a Phabricator extension in its official distribution).</p>
<p>An interesting outlier is Gerrit, which ingests its <em>integration requests</em> via
<code>git push</code>. (See
<a href="https://gerrit-review.googlesource.com/Documentation/user-upload.html">the docs</a>.)
But the way Gerrit's ingestion via <code>git push</code> works is fundamentally different
from how pull requests work! With pull requests, you are pushing your local
branch to a remote branch and a pull request is built around that remote branch.
With Gerrit, your push command is like <code>git push gerrit HEAD:refs/for/master</code>.
For the non-gurus, that <code>HEAD:refs/for/master</code> syntax means, <em>push the <code>HEAD</code>
commit (effectively the commit corresponding to the working directory) to the
<code>refs/for/master</code> ref on the <code>gerrit</code> remote</em> (the <code>SOURCE:DEST</code>
syntax specifies a mapping of local revision identifier to remote ref). The
wizard behind the curtain here is that Gerrit runs a special Git server that
implements non-standard behavior for the <code>refs/for/*</code> refs. When you push to
<code>refs/for/master</code>, Gerrit receives your Git push like a normal Git server would.
But instead of writing a ref named <code>refs/for/master</code>, it takes the incoming commits
and ingests them into a code review request! Gerrit will create Git refs for the
pushed commits. But it mainly does that for its internal tracking (Gerrit stores
all its data in Git - from Git data to review comments). And if
that functionality isn't too magical for you, you can also pass parameters to
Gerrit via the ref name! e.g. <code>git push gerrit HEAD refs/for/master%private</code>
will create a private review request that requires special permissions to see.
(It is debatable whether overloading the ref name for additional functionality
is a good user experience for average users. But you can't argue that this isn't
a cool hack!)</p>
<p>On the surface, it may seem like using the version control tool's native data
exchange is a superior workflow because it is <em>more native</em> and more modern.
(<em>Emailing patches is so old school.</em>) Gone are the days of having to configure
client-side tools to export and submit patches. Instead, you run <code>git push</code> and
your changes can be turned into an <em>integration request</em> automatically or with
a few mouse clicks. And from a technical level, this exchange methodology is
likely safer, as round-tripping a text-based representation of a change without
data loss is surprisingly finicky. (e.g. JSON's lack of lossless binary data
exchange without encoding to e.g. base64 first often means that many services
exchanging text-based patches are lossy, especially in the presence of content
which doesn't conform to UTF-8, which can be commonplace in tests. You would be
surprised how many tools experience data loss when converting version control
commits/diffs to text. But I digress). Having Git's wire protocol exchange
binary data is safer than exchanging text patches and probably easier to use
since it doesn't require any additional client-side configuration.</p>
<p>But despite being more native, modern, and arguably robust, exchange via the
version control tool may not be <em>better</em>.</p>
<p>For starters, use of the version control tool's native wire protocol inhibits
use of arbitrary version control tools on the client. When your <em>integration
request</em> requires the use of a version control tool's wire protocol, the client
likely needs to be running that version control tool. With other approaches like
exchange of text based patches, the client could be running any software it
wanted: as long as it could spit out a patch or API request in the format the
server needed, an <em>integration request</em> could be created! This meant there was
less potential for <em>lock-in</em>, as people could use their own tools on their
machines if they wanted and they (hopefully) wouldn't be inflicting their choice
on others. Case in point, a majority of Firefox developers use Mercurial - the
VCS of the canonical repository - but a large number use Git on the client. Because
Firefox is using Phabricator (Review Board and Bugzilla before that) for code
review and because Phabricator ingests text-based patches, the choice of the
VCS on the client doesn't matter that much and the choice of the server VCS
can be made without inciting a holy war among developers who would be forced
to use a tool they don't prefer. Yes, there are good reasons for using a
consistent tool (including organizational overhead) and sometimes mandates for
tool use are justified. But in many cases (such as random open source
contributions), it probably doesn't or shouldn't matter. And in cases like
Git and Mercurial, where tools like the fantastic
<a href="https://github.com/glandium/git-cinnabar">git-cinnabar</a> make it
possible to easily convert between the repositories without data loss and
acceptable overhead, adoption of the version control tool's native wire
protocol can exclude or inhibit the productivity of contributors since it can
mandate use of specific, undesired tooling.</p>
<p>Another issue with using the version control tool's wire protocol is that it
often forces or strongly encourages you to work a certain way. Take GitHub
pull requests for example. The pull request is defined around the remote Git
branch that you <code>git push</code>. If you want to update that branch, you need to know
its name. So that requires some overhead to either create and track that branch
or find its name when you want to update it. Contrast with Gerrit, where you
don't have an explicit remote branch you push to: you simply <code>git push gerrit
HEAD:refs/for/master</code> and it figures things out automatically (more on this
later). With Gerrit, I don't have to create a local Git branch to initiate an
<em>integration request</em>. With pull requests, I'm compelled to. And this can undermine
my productivity by compelling me to practice less-efficient workflows!</p>
<p>Our final point of comparison involves scalability. <strong>When you use the version
control tool wire protocol as part of <em>integration requests</em>, you have
introduced the problem of scaling your version control server.</strong> Take it from
someone who has had multiple jobs involving scaling version control servers
and who is intimately aware of the low-level details of both the
Git and Mercurial wire protocols: you don't want to be in the business of
scaling a version control server. The wire protocols for both Git and
Mercurial were designed in a now-ancient era of computing and weren't designed
by network protocol experts. They are fundamentally difficult to scale at
just the wire protocol level. I've heard stories that at one time, the
most expensive single server at Google was their Perforce or Perforce-derived
server (this was several years ago - Google has since moved on to a better
architecture).</p>
<p>The poor network protocols of version control tools have many side-effects,
including the inability or sheer difficulty of using distributed storage
on the server. So in order to scale compute horizontally, you need to invest
in expensive network storage solutions or devise a replication and
synchronization strategy. And take it from someone who worked on data
synchronization products (outside of the source control space) at three
companies: this is a problem you don't want to solve yourself. Data
synchronization is intrinsically difficult and rife with difficult trade-offs.
It's almost always a problem best avoided if you have a choice in the matter.</p>
<p>If creating Git refs is part of creating an <em>integration request</em>, you've
introduced a scaling challenge with the number of Git refs. Do these Git
refs live forever? What happens when you have thousands of developers -
possibly all working in the same repository - and the number of refs or ref
mutations grows to the hundreds of thousands or millions per year?</p>
<p>Can your version control server handle ingesting a push every second or two
with reasonable performance? Unless you are Google, Facebook, or a handful of
other companies I'm aware of, it can't. And before you cry that I'm talking
about problems that only plague the 0.01% of companies out there, I can name a
handful of companies under 10% the size of these behemoths where this is a
problem for them. And I also guarantee that many people don't have client-side
metrics for their <code>git push</code> P99 times or reliability and don't even realize
there is a problem! Scaling version control is probably not a core part of your
company's business. Unfortunately, it all too often becomes something companies
have to allocate resources for because of poorly designed or utilized tools.</p>
<p>Contrast the challenges of scaling <em>integration requests</em> with a native
version control server versus just exchanging patches. With the more
<em>primitive</em> approach, you are probably sending the patch over HTTP to a web
service. And with tools like Phabricator and Review Board, that patch gets
turned into rows in a relational database. <strong>I guarantee it will be easier
to scale an HTTP web service fronting a relational database than it will
be your version control server.</strong> If nothing else, it should be easier to manage
and debug, as there are tons more experts in these domains than in the
version control server domain!</p>
<p>Yes, it is true that many will not hit the scaling limits of the version
control server. And some nifty solutions for scaling do exist. But large
segments of this problem space - including the version control tool maintainers
having to support <em>crazy</em> scaling vectors in their tools - could be avoided
completely if <em>integration requests</em> didn't lean so heavily on the version
control tools's default mode of operation. Unfortunately, solutions like
GitHub pull requests and Gerrit's use of Git refs for storing <em>everything</em>
exert a lot of pressure on scaling the version control server and make this
a very real problem once you reach a certain scale.</p>
<p>Hopefully the above paragraphs enlightened you to some of the implications
that the choice of a data exchange mechanism has on <em>integration requests</em>!
Let's move on to another point of comparison.</p>
<h3>Commit Tracking</h3>
<p>One can classify implementations of <em>integration requests</em> by how they <em>track</em>
commits through their integration lifecycle. What I mean by this is how the
<em>integration request</em> follows the same logical change as it evolves. For
example, if you submit a commit then amend it, how does the system know that the
commit <em>evolved</em> from commit <code>X</code> to <code>X'</code>.</p>
<p>Pull requests don't track commits directly. Instead, a commit is part of a Git
branch and that branch is tracked as the entity the pull request is built
around. The review interface presents the <em>merge diff</em> front and center.
It is possible to view individual commits. But as far as I know, none of
these tools have smarts to explicitly track or map commits across new
submissions. Instead, they simply assume that the commit order will be the
same. If commits are reordered or added or removed in the middle of an
existing series, the tool can get confused quite easily. (With GitHub, it
was once possible for a review comment left on a commit to disappear entirely.
The behavior has since been corrected and if GitHub doesn't know where to
print a comment from a previous commit, it renders it as part of the pull
request's timeline view.)</p>
<p>If all you are familiar with is pull requests, you may not realize there are
alternatives to commit tracking! In fact, the most common alternative (which
isn't <em>do nothing</em>) predates pull requests entirely and is still practiced by
various tools today.</p>
<p>The way that Gerrit, Phabricator, and Review Board work is the commit message
contains a unique token identifying the <em>integration request</em> for that commit.
e.g. a commit message for a Phabricator review will contain the line
<code>Differential Revision: https://phab.mercurial-scm.org/D7543</code>. Gerrit will
have something like <code>Change-Id: Id9bfca21f7697ebf85d6a6fa7bac7de4358d7a43</code>.</p>
<p>The way this annotation appears in the commit message differs by tool.
Gerrit's web UI advertises a shell one-liner to clone repositories which
not only performs a <code>git clone</code> but also uses <code>curl</code> to download a shell
script from the Gerrit server and install it as Git's <code>commit-msg</code> hook in the
newly-cloned repositories. This Git hook will ensure that any newly-created
commit has a <code>Change-ID: XXX</code> line containing a randomly generated, hopefully
unique identifier. Phabricator and Review Board leverage client-side tooling
to rewrite commit messages after submission to their respective tool so
the commit message contains the URL of the code review. One can debate
which approach is <em>better</em> - they each have advantages and drawbacks.
Fortunately, this debate is not germane to this post, so we won't cover it here.</p>
<p>What is important is how this metadata in commit messages is used.</p>
<p>The commit message metadata comes into play when a commit is being ingested
into an <em>integration request</em>. If a commit message lacks metadata or references
an entity that doesn't exist, the receiving system assumes it is new. If the
metadata matches an entity on file, the incoming commit is often automatically
matched up to an existing commit, even if its Git SHA is different!</p>
<p>This approach of inserting a tracking identifier into commit messages works
surprisingly well for tracking the evolution of commits! Even if you amend,
reorder, insert, or remove commits, the tool can often figure out what matches
up to previous submissions and reconcile state accordingly. Although support
for this varies by tool. Mercurial's extension for submitting to Phabricator
is smart enough to take the local commit DAG into account and change dependencies
of review units in Phabricator to reflect the new DAG <em>shape</em>, for example.</p>
<p><strong>The tracking of commits is another one of those areas where the simpler and
more modern features of pull requests often don't work as well as the
solutions that came before.</strong> Yes, inserting an identifier into commit messages
feels hacky and can be brittle at times (some tools don't implement commit
rewriting very well and this can lead to a poor user experience). But you
can't argue with the results: <strong>using explicit, stable identifiers to track
commits is far more robust than the heuristics that pull requests rely on</strong>.
The false negative/positive rate is so much lower. (I know this from first hand
experience because we attempted to implement commit tracking heuristics for
a code review tool at Mozilla before Phabricator was deployed and there were
a surprising number of corner cases we couldn't handle properly. And this was
using Mercurial's <em>obsolescence markers</em>, which gave us commit evolution data
generated directly by the version control tool! If that didn't work well enough,
it's hard to imagine an heuristic that would. We eventually gave up and used
stable identifiers in commit messages, which fixed most of the annoying
corner cases.)</p>
<p>The use of explicit commit tracking identifiers may not seem like it makes a
meaningful difference. But it's impact is profound.</p>
<p>The obvious benefit of tracking identifiers is that they allow rewriting commits
without <em>confusing</em> the <em>integration request</em> tool. <strong>This means that people
can perform advanced history rewriting with near impunity as to how it would
affect the <em>integration request</em>.</strong> I am a heavy history rewriter. I like
curating a series of individually high-quality commits that can each stand
in isolation. When I submit a series like this to a GitHub pull request and
receive feedback on something I need to change, when I enact those changes I have
to think <em>will my rewriting history here make re-review harder</em>? (I try to be
empathetic with the reviewer and make their life easier whenever possible. I
ask what I would appreciate someone doing if I were reviewing their change and
tend to do that.) With GitHub pull requests, if I reorder commits or add or remove
a commit in the middle of a series, I realize that this may make review comments
left on those commits hard to find since GitHub won't be able to sort out the
history rewriting. And this may mean those review comments get <em>lost</em> and are
ultimately not acted upon, leading to bugs or otherwise deficient changes. <strong>This
is a textbook example of tooling deficiencies dictating a sub-optimal workflow
and outcome: because pull requests don't track commits explicitly, I'm
forced to adopt a non-ideal workflow or sacrifice something like commit
quality in order to minimize risks that the review tool won't get confused.</strong>
In general, tools should not externalize these kinds of costs or trade-offs onto
users: they should <em>just work</em> and optimize for generally agreed-upon ideal
outcomes.</p>
<p><strong>Another benefit to tracking identifiers is that they enable per-commit review
to be viable.</strong> Once you can track the logical evolution of a single commit,
you can start to associate things like review comments with individual commits
with a high degree of confidence. With pull requests (as they are implemented
today), you can attempt to associate comments with commits. But because you are
unable to track commits across rewrites with an acceptably high degree of
success, rewritten commits often <em>fall through the cracks</em>, orphaning data
like review comments with them. Data loss is bad, so you need a place to
collect this orphaned data. The main pull request activity timeline facilitates
this function.</p>
<p>But once you can track commits reliably (and tools like Gerrit and Phabricator
prove this is possible), you don't have this severe problem of data loss and
therefore don't need to worry about finding a place to collect orphaned data!
You are then able to create per-commit review units, each as loosely coupled
with other commits and an overall series as you want to make it!</p>
<p>It is interesting to note the different approaches in different tools here.
it is doubly interesting to note behavior that is possible with the review
tool itself and what it does by default!</p>
<p>Let's examine Phabricator. Phabricator's review unit is the
<em>Differential revision</em>. (<em>Differential</em> is the name of the code review tool
in Phabricator, which is actually a suite of functionality - like GitLab,
but not nearly as feature complete.) A <em>Differential revision</em> represents a
single diff. <em>Differential revisions</em> can have parent-child relationships
with others. Multiple revisions associated like this form a conceptual
<em>stack</em> in Phabricator's terminology. Go to
<a href="https://phab.mercurial-scm.org/D4414">https://phab.mercurial-scm.org/D4414</a>
and search for <em>stack</em> to see it in action. (<em>Stack</em> is a bit misleading name
because the parent-child relationships actually form a DAG and Phabricator is
capable of rendering things like multiple children in its graphical view.)
Phabricator's official client side tool for
submitting to Phabricator - Arcanist or <code>arc</code> - has default behavior
of collapsing all Git commits into a single <em>Differential revision</em>.</p>
<p>Phabricator can preserve metadata from the individual commits (it can render
at least the commit messages in the web UI so you can see where the <em>Differential
revision</em> came from). In other words, by default Arcanist does <em>not</em> construct
multiple <em>Differential revisions</em> for each commit and therefore does not construct
parent-child relationships for them. So there is no <em>stack</em> to render here.
To be honest, I'm not sure if modern versions of Arcanist even support doing
this. I do know both Mercurial and Mozilla authored custom client side
tools for submitting to Phabricator to work around deficiencies like this in
Arcanist. Mozilla's may or may not be generally suitable for users outside
of Mozilla - I'm not sure.</p>
<p>Another interesting aspect of Phabricator is that there is no concept of an
over-arching series. Instead, each <em>Differential revision</em> stands in isolation.
They can form parent-child relationships and constitute a <em>stack</em>. But there
is no primary UI or APIs for <em>stacks</em> (the last I looked anyway). This may seem
radical. You may be asking questions like <em>how do I track the overall state
of a series</em> or <em>how do I convey information pertinent to the series as a whole</em>.
These are good questions. But without diving into them, the answer is that
as radical as it sounds to not have an overall tracking entity for a series of
<em>Differential revisions</em>, it does work. And having used this workflow with the
Mercurial Project for a few years, I can say I'm not missing the functionality
that much.</p>
<p>Gerrit is also worth examining. Like Phabricator, Gerrit uses an identifier
in commit messages to track the commit. But whereas Phabricator rewrites
commit messages at initially submission time to contain the URL that was
created as part of that submission, Gerrit peppers the commit message with
a unique identifier at commit creation time. The server then maintains a
mapping of commit identifier to review unit. Implementation details aside,
the end result is similar: individual commits can be tracked more easily.</p>
<p>What distinguishes Gerrit from Phabricator is that Gerrit does have a stronger
grouping around multiple commits. Gerrit will track when commits are submitted
together and will render both a <em>relation chain</em> and <em>submitted together</em> list
automatically. While it lacks the visual beauty of Phabricator's implementation,
it is effective and is shown in the UI by default, unlike Phabricator.</p>
<p>Another difference from Phabricator is that Gerrit uses per-commit review
by default. Whereas you need a non-official client for Phabricator to submit
a series of commits to constitute a linked chain, Gerrit does this by default.
And as far as I can tell, there's no way to tell Gerrit to squash your local
commits down to a single diff for review: if you want a single review to appear,
you must first squash commits locally then push the squashed commit. (More
on this topic later in the post.) </p>
<p><strong>A secondary benefit of per-commit review is that this model enables incremental
integration workflows, where some commits in a series or set can integrate before
others, without having to wait for the entire batch.</strong> Incremental integration
of commits can drastically speed up certain workflows, as commits can integrate
as soon as they are <em>ready</em> and not any longer. The benefits of this model can
be incredible. But actually deploying this workflow can be tricky. One problem
is that your version control tool may get confused when you rebase or merge
partially landed state. Another problem is it can increase the overall change
rate of the repository, which may strain systems from version control to CI
to deployment mechanisms. Another potential problem involves communicating
review sign-off from integration sign-off. Many tools/workflows conflate <em>I
sign off on this change</em> and <em>I sign off on landing this change</em>. While they
are effectively identical in many cases, there are some valid cases where you
want to track these distinctly. And adopting a workflow where commits can
integrate incrementally will expose these corner cases. So before you go down
this path, you want to be thinking about who integrates commits and when
they are integrated. (You should probably be thinking about this anyway because
it is important.)</p>
<h2>Designing a Better Integration Request</h2>
<p>Having described some problems with pull requests and alternate ways of going
about solving the general problem of <em>integration requests</em>, it is time to answer
the million dollar problem: designing a better <em>integration request</em>. (When you
factor in the time people spend in pull requests and the cost of bugs / low
quality changes that slip through due to design of existing tooling, improving
integration requests industry wide would be a <strong>lot</strong> more valuable than $1M.)</p>
<p>As a reminder, the pull request is fundamentally a nice UI and set of features
built around the common Git feature branch workflow. This property is preserved
from the earliest days of pull requests in 2007-2008 and has been copied by
vendors like Bitbucket and GitLab in the years since. In my mind, pull requests
should be ripe for overhaul.</p>
<h3>Replace Forks</h3>
<p><strong>The first change I would make to pull requests is to move away from <em>forks</em>
being a required part of the workflow.</strong> This may seem radical. But it isn't!</p>
<p>A <em>fork</em> on services like GitHub is a fully fledged project - just like the
canonical project it was forked from. It has its own issues, wiki, releases,
pull requests, etc. Now show of hands: how often do you use these features
on a fork? Me neither. <strong>In the overwhelming majority of cases, a <em>fork</em>
exists solely as a vehicle to initiate a pull request against the repository
it was forked from.</strong> It serves little to no additional meaningful
functionality. Now, I'm not saying <em>forks</em> don't serve a purpose - they
certainly do! <strong>But in the case of someone wanting to propose a change to
a repository, a <em>fork</em> is not strictly required and its existence is imposed
on us by the current implementation of pull requests.</strong></p>
<p>I said <em>impose</em> in the previous sentence because <em>forks</em> introduce overhead
and confusion. The existence of a <em>fork</em> may confuse someone as to where a
canonical project lives. <em>Forks</em> also add overhead in the version control
tool. Their existence forces the user to manage an additional Git remote
and branches. It forces people to remember to keep their branches in sync on
their fork. As if remembering to keep your local repository in sync wasn't
hard enough! And if pushing to a <em>fork</em>, you need to re-push data that was
already pushed to the canonical repository, even though that data already
exists on the server (just in a different view of the Git repository). (I
believe Git is working on wire protocol improvements to mitigate this.)</p>
<p><strong>When merely used as a vehicle to initiate <em>integration requests</em>, I do not
believe <em>forks</em> offer enough value to justify their existence.</strong> Should forks
exist: yes. Should people be forced to use them in order to contribute
changes, no. (Valid use cases for a <em>fork</em> would be to perform a community
splinter of a project and to create an independent entity for reasons such as
better guarantees of data availability and integrity.)</p>
<p><em>Forks</em> are essentially a veneer on top of a server-side <code>git clone</code>. And the
reason why a separate Git repository is used at all is probably because the
earliest versions of GitHub were just a pile of abstractions over <code>git</code>
commands. The service took off in popularity, people copied its features
almost verbatim, and nobody ever looked back and thought <em>why are we doing
things like this in the first place.</em></p>
<p>To answer what we would replace <em>forks</em> with, we have to go back to first
principles and ask <em>what are we trying to do.</em> And that is <em>propose a unit
a change against an existing project</em>. And for version control tools, all
you need to propose a change is a patch/commit. So to replace <em>forks</em>, we
<em>just</em> need an alternate mechanism to submit patches/commits to an existing
project.</p>
<p><strong>My preferred alternative to forks is to use <code>git push</code> directly to the
canonical repository.</strong> This could be implemented like Gerrit where you push
to a special ref. e.g. <code>git push origin HEAD:refs/for/master</code>. Or - and this is
my preferred solution - version control servers could grow more smarts about
how <em>pushes</em> work - possibly even changing what commands like <code>git push</code> do if
the server is operating in special modes.</p>
<p>One idea would be for the Git server to expose different refs <em>namespaces</em>
depending on the authenticated user. For example, I'm <code>indygreg</code> on GitHub.
If I wanted to propose a change to a project - let's say <code>python/cpython</code> -
I would <code>git clone git@github.com:python/cpython</code>. I would create a branch -
say <code>indygreg/proposed-change</code>. I would then
<code>git push origin indygreg/proposed-change</code> and because the branch prefix matches
my authenticated username, the server lets it through. I can then open a
pull request without a fork! (Using branch prefixes is less than ideal, but
it should be relatively easy to implement on the server. A better approach
would rely on remapping Git ref names. But this may require a bit more
configuration with current versions of Git than users are willing to stomach.
An even better solution would be for Git to grow some functionality to make
this easier. e.g. <code>git push --workspace origin proposed-change</code> would push
<code>proposed-change</code> to a <em>workspace</em> on the <code>origin</code> remote, which Git would
know how to translate to a proper remote ref update.)</p>
<p>Another idea would be for the version control server to invent a new concept
for exchanging commits - one based on <em>sets of commits</em> instead of DAG
synchronization. Essentially, instead of doing a complicated discovery
dance to synchronize commits with the underlying Git repository, the server
would ingest and expose representations of <em>sets of commits</em> stored next
to - but not within - the repository itself. This way you are not scaling the
repository DAG to infinite heads - which is a hard problem! A concrete
implementation of this might have the client run a <code>git push --workspace
origin proposed-change</code> to tell the remote server to store your
<code>proposed-change</code> branch in your personal <em>workspace</em> (sorry for reusing the term
from the previous paragraph). The Git server would receive your commits,
generate a standalone blob to hold them, save that blob to a key-value
store like S3, then update a mapping of which commits/branches are in
which blobs in a data store such as a relational database somewhere. This
would effectively segment the core project data from the more transient
branch data, keeping the core repository clean and pure. It allows the server
to lean on easier-to-scale data stores such as key-value blob stores and
relational databases instead of the version control tool. I know this idea
is feasible because Facebook implemented it for Mercurial. The <code>infinitepush</code>
extension essentially siphons Mercurial <em>bundles</em> (standalone files holding
commit data) off to a blob store when pushes come in over the wire. At
<code>hg pull</code> time, if a requested revision is not present in the repository, the
server asks the database-backed blob index if the revision exists anywhere.
If it does, the blob/bundle is fetched, dynamically overlayed onto the
repository in memory, and served to the client. While the <code>infinitepush</code>
extension in the official Mercurial project is somewhat lacking (through no
fault of Facebook's), the core idea is solid and I wish someone would spend
the time to flush out the design a bit more because it really could lead
to logically scaling repositories to <em>infinite</em> DAG heads without the
complexities of actually scaling scaling DAG algorithms, repository storage,
and version control tool algorithms to <em>infinite</em> heads. Getting back to the
subject of <em>integration requests</em>, one could imagine having a <em>target</em> for
<em>workspace pushes</em>. For example, <code>git push --workspace=review origin</code> would
push to the <code>review</code> workspace, which would automatically initiate a code
review.</p>
<p>Astute readers of this blog may find these ideas familiar. I proposed
<em>user namespaces</em> in my
<a href="High-level problems with Git and how to fix them">/blog/2017/12/11/high-level-problems-with-git-and-how-to-fix-them/</a>
post a few years ago. So read there for more on implications of doing
away with <em>forks</em>.</p>
<p>Could <em>forks</em> be done away with as a requirement to submit pull requests?
Yes! Gerrit's <code>git push origin HEAD:refs/for/master</code> mechanism proves it.
Is Gerrit's approach too much magic or confusing for normal users? I'm not
sure. Could Git grow features to make the user experience much better so
users don't need to be burdened with complexity or magic and could
simply run commands like <code>git submit --for review</code>? Definitely!</p>
<h3>Shift Focus From Branches to Individual Commits</h3>
<p><strong>My ideal <em>integration request</em> revolves around individual commits, not
branches.</strong> While the client may submit a branch to initiate or update
an <em>integration request</em>, the <em>integration request</em> is composed of a set
of loosely coupled commits, where parent-child relationships can exist to
express a dependency between commits. Each commit is evaluated
individually. Although someone may need to inspect multiple commits to
gain a full understanding of the proposed change. And some UI enabling
operations against a group of related commits (such as mass deleting
abandoned commits) may be warranted.</p>
<p>In this world, the branch would not matter. Instead, commits are king.
Because we would be abandoning the branch name as a tracker for the
<em>integration request</em>, we would need something to replace it, otherwise we
have no way of knowing how to update an existing <em>integration request</em>!
We should do what tools like Phabricator, Gerrit, and Review Board do and
add a persistent identifier to commits which survive history rewriting.
(Branch-based pull requests should do this anyway so history rewrites don't
confuse the review tool and e.g. cause comments to get orphaned - see
above.)</p>
<p><strong>It's worth noting that a commit-centric <em>integration request</em> model does
not imply that everyone is writing or reviewing series of smaller commits!</strong>
While titans of industry and I strongly encourage the authorship of smaller
commits, commit-centric <em>integration requests</em> don't intrinsically force you
to do so. This is because commit-centric <em>integration requests</em> aren't forcing
you to change your local workflow! If you are the type of person who doesn't
want to curate a ton of small, good-in-isolation commits (it does take a bit
more work after all), nobody would be forcing you to do so. Instead, if this
is your commit authorship pattern, the submission of the proposed change
could <em>squash</em> these commits together as part of the submission, <em>optionally</em>
rewriting your local history in the process. If you want to keep dozens of
<em>fixup commits</em> around in your local history, that's fine: just have the
tooling collapse them all together on submission. While I don't think those
<em>fixup commits</em> are that valuable and shouldn't be seen by reviewers, if
we wanted, we could have tools continue to submit them and make them visible
(like they are in e.g. GitHub pull requests today). But they wouldn't be the
focus of review (again like GitHub pull requests today). <strong>Making <em>integration
requests</em> commit-centric doesn't force people to adopt a different commit
authorship workflow. But it does enable projects that wish to adopt more
<em>mature</em> commit hygiene to do so.</strong> That being said, hows tools are
implemented can impose restrictions. But that's nothing about commit-centric
review that fundamentally prohibits the use of <em>fixup commits</em> in local
workflows.</p>
<p>While I should create a dedicated post espousing the virtues of commit-centric
workflows, I'll state my case through proxy by noting that some projects aren't
using modern pull requests precisely because commit-centric workflows are not
viable. When I was at Mozilla, one of the blockers to <em>moving to GitHub</em> was
the pull request review tooling wasn't compatible with our world view that
review units should be small. (This view is generally shared by Google, Facebook,
and some prominent open source projects, among others.) And for reasons
outlined earlier in this post, I think that as long as pull requests revolve
around branches / <em>merge diffs</em> and aren't robust in the face of history rewriting
(due to the lack of robust commit tracking), projects that insist on more
<em>refined</em> practices will continue to eschew pull requests. Again, a link between
review size and quality has been established. And better quality - along
with its long-term effect of lowering development costs due to fewer bugs -
can tip the scales in its favor, even against all the benefits you receive
when using a product like GitHub, GitLab, or Bitbucket.</p>
<h2>The Best of What's Around</h2>
<p>Aspects of a better <em>integration request</em> exist in tools today. Unfortunately,
many of these features are not present on pull requests as implemented by
GitHub, GitLab, Bitbucket, etc. So to improve the pull request, these products
will need to borrow ideas from other tools.</p>
<p><em>Integration requests</em> not built around Git branches (Gerrit, Phabricattor,
Review Board, etc) use identifiers in commit messages to track commits.
This helps tracking commits across changes. There are compelling advantages
to this model. Robust commit tracking is a requirement for commit-centric
workflows. And it would even improve the functionality of branch-based pull
requests. A well-designed <em>integration request</em> would have a robust commit
tracking mechanism.</p>
<p>Gerrit has the best-in-class experience for commit-centric workflows. It is
the only popular implementation of <em>integration requests</em> I'm aware of that
supports and caters to this workflow by default. In fact, I don't think you
can change this! (This behavior is user hostile in some cases since it forces
users to know how to rewrite commits, which is often perilous in Git land. It
would be nice if you could have Gerrit squash commits into the same review unit
automatically on the server. But I understand the unwillingness to implement
this feature because this has its own set of challenges around commit tracking,
which I won't bore you with.) Gerrit also shows groups of related commits
front and center when viewing a proposed change.</p>
<p>Phabricator is the only other tool I know of where one can achieve a reasonable
commit-centric workflow without the pitfalls of orphaned comments, context
overload, etc mentioned earlier in this post. But this requires non-standard
submission tooling and commit series aren't featured prominently in the web UI.
So Phabricator's implementation is not as solid as Gerrit's.</p>
<p>Another Gerrit feature worth lauding is the submission mechanism. You simply
<code>git push</code> to a special ref. That's it. There's no fork to create. No need to
create a Git branch. No need to create a separate pull request after the push.
Gerrit just takes the commits you pushed and turns them into a request for
review. And it doesn't require any additional client-side tooling!</p>
<p>Using a single common <code>git</code> command to submit and update an <em>integration
request</em> is simpler and arguably more intuitive than other tools. Is Gerrit's
submission perfect? No. The <code>git push origin HEAD:refs/for/master</code> syntax is
not intuitive. And overloading submission options by effectively encoding URL
parameters on the ref name is a gross - albeit effective - hack. But users will
likely quickly learn the one-liner's or create more intuitive aliases.</p>
<p>The elegance of using just a <code>git push</code> to initiate an <em>integration request</em>
puts Gerrit in a league of its own. I would be ecstatic if the GitHubs of the
world reduced the complexity of submitting pull requests to simply <em>clone the
canonical repository, create some commits, and run a <code>git</code> command. The future
of submitting </em>integration requests* hopefully looks more like Gerrit than
other alternatives.</p>
<h2>What Needs Built</h2>
<p>Some aspects of the better <em>integration request</em> don't yet exist or need
considerable work before I consider them viable.</p>
<p>For tools which leverage the native version control tool for submission
(e.g. via <code>git push</code>), there needs to be some work to support submission
via a more generic, HTTP endpoint. I'm fine with leveraging <code>git push</code> as a
submission mechanism because it makes the end-user experience so
turnkey. But making it the only submission mechanism is a bit unfortunate.
There is some support for this: I believe you can cobble together a pull
request from scratch via GitHub's APIs, for example. But it isn't as simple
as <em>submit a patch to an endpoint</em>, which it arguably should be. Even
Gerrit's
<a href="https://gerrit-review.googlesource.com/Documentation/rest-api.html">robust HTTP API</a>,
does not seem to allow creating new commits/diffs via that API. Anyway, this
limitation not only excludes non-Git tools from using these tools, but also
limits other tooling from submitting without using Git. For example, you may
want to write a bot that proposes automated changes and it is much easier
to produce a diff than to use <code>git</code> since the former does not require a
filesystem (this matters in <em>serverless</em> environments for example).</p>
<p>A larger issue with many implementations is the over-reliance on Git for server
storage. This is most pronounced in Gerrit, where not only are your <code>git push</code>es
stored in a Git repository on the Gerrit server, but every code review comment
and reply is stored in Git as well! Git <em>is</em> a generic key-value store and you
can store any data you want in it if you shoehorn it properly. And it is cool
that all your Gerrit data can be replicated via <code>git clone</code> - this pretty much
eliminates the <em>we took a decentralized tool and centralized it via GitHub</em>
series of arguments. But if you apply this <em>store everything in Git</em> approach
at scale, it means you will be running a Git server at scale. And not just any
Git server - a write load heavy Git server! And if you have thousands of
developers possibly all working out of the same repository, then you are looking
at potentially millions of new Git refs per year. While the Git, Gerrit, and
JGit people have done some fantastic work making these tools scale, I'd feel
much better if we eschewed the <em>make Git scale to infinite pushes and refs</em>
problem and used a more scalable approach, like an HTTP ingestion endpoint
which writes data to key-value stores or relational databases. In order words,
use of a version control tool for servicing <em>integration requests</em> at scale
is a self-imposed footgun and could be avoided.</p>
<h2>Conclusion</h2>
<p>Congratulations on making it through my brain dump! As massive as the wall
of text is, there are still plenty of topics I could have covered but didn't.
This includes the more specific topic of code review and the various features
that entails. I also largely ignored some general topics like the value that
an <em>integration request</em> can serve on the overall development lifecycle:
<em>integration requests</em> are more than just code review - they serve as a nexus
to track the evolution of a change throughout time.</p>
<p>Hopefully this post gave you some idea at some of the structural issues at
play with the integration of pull requests and <em>integration requests</em>. And
if you are someone in a position to design or implement a better
<em>integration request</em> or tooling around them (including in version control
tools themselves), hopefully it gave you some good ideas or where to go next.</p>]]></content:encoded>
    </item>
  </channel>
</rss>
