<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>Gregory Szorc's Digital Home</title>
    <link>http://gregoryszorc.com/blog</link>
    <description>Rambling on</description>
    <pubDate>Thu, 17 Jan 2019 20:02:19 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>On Algorithms and Interviewing</title>
      <link>http://gregoryszorc.com/blog/2019/01/17/on-algorithms-and-interviewing</link>
      <pubDate>Thu, 17 Jan 2019 10:45:00 PST</pubDate>
      <category><![CDATA[Personal]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2019/01/17/on-algorithms-and-interviewing</guid>
      <description>On Algorithms and Interviewing</description>
      <content:encoded><![CDATA[<p>As I write this, I'm hours away from starting to interview for full-time
jobs in the software field. I've spoken with a number of recruiters and
hiring managers and have received interview preparation materials from
a handful of companies, many of which you've probably heard of.</p>
<p>I was hoping things would have changed since I last seriously underwent
this endeavor ~7.5 years ago (I did interview periodically when I was at
Mozilla in order to test waters, keep my interview skills sharp, etc). But
it appears the industry is still generally fixated on algorithms and
data structures in interviews. <strong>The way algorithms and similar coding tricks
are emphasized in the preparation materials I've received, you'd think people
in software spend a major part of their work days thinking about and
implementing algorithms</strong>. But from my experience, this is very far from
the case! So why are so many companies and interviewers fixated on
algorithms. And is this a good thing?</p>
<p>When they matter, efficient algorithms, data structures, and other tricks
are important and useful skills to have. But from my experience, they
matter far less than you would think. If I were to make a list of important
job skills and traits for software and programming, memorized knowledge of
algorithms and data structures is so far down the list that I don't think I
would even ask about algorithms fundamentals for most job candidates! (In
fact I don't.) I think it is vastly more important to focus on behavioral
qualities and potential to actually think and apply knowledge rather than
regurgitate it. Algorithms and data structures, after all, are learned
knowledge. All other things be equal, I'd rather have someone who knows
when to ask for help with an algorithms issue or can pick up the skill
than a curmudgeon algorithms genius who has an abrasive personality and
clings to old habits.</p>
<p>In the spirit of full disclosure, I should to state that my algorithms skills
are relatively weak. You can accuse me of writing this post to fulfill my
own selfish interests. You wouldn't be wrong. But I know there are others
like me who are good at programming yet struggle with algorithms and question
the utility of algorithms in interviews. I'm attempting to write this post
for all of us. </p>
<p>I have failed job interviews because the interviewer assessed my algorithms
abilities as weak. I'm able to work through this <em>deficiency</em> with interviewers
who care more about the behavioral traits I exhibit when in such a situation (I
try to be quick about admitting my technical weaknesses and to ask for help
when needed). But some interviewers aren't as interested in the behavioral
traits or insist on a baseline level of memorized algorithms knowledge beyond
my own. I feel like my relative algorithms weakness hasn't hurt me <em>on</em> the
job, as I hardly find myself caring about algorithms in the work I do. In the
majority of cases, the choice of an algorithm just doesn't matter for the size
of the data set. Or a standard algorithm or data structure available in the
standard library of the language I'm using is <em>good enough</em>. In the cases where
I realize algorithms and data structures would matter, I run my
technical questions past someone with more knowledge in the domain than me. Or
if I don't do that, it often comes up during code review.
Without strong algorithms and data structures knowledge, I'm able to maintain
the Firefox build system, become a core contributor to a version control
tool (something you think would require a lot of heavy algorithms knowledge),
maintain various open source projects, diagnose and address low-level
performance issues in complex software and systems. <strong>About the only impact that
being weak in algorithms and data structures has had on my career is that some
companies passed on hiring me because they perceived strength in this area to
be important.</strong></p>
<p>Albert Einstein once said, <em>I never commit to memory anything that can
easily be looked up in a book.</em> A modern adaptation of that quote may
go something like, <em>never memorize how to implement an algorithm or data
structure when you can just Google it or use a software library
implementing it.</em> If you have knowledge of how to implement various algorithms
in your head, that's good for you, I suppose. But I think the <em>bigger brain</em>
knowledge to possess is <em>when</em> algorithms matter and to a lesser extent, what
types of algorithms are appropriate for particular problems. Answering these
problems requires critical thinking. Actually implementing algorithms, by
contrast, merely requires knowledge <em>that can easily be looked up in a book</em> (the
algorithm or data structure itself) coupled with some programming knowledge for
how to apply it. A capable programmer will be able to do both these things and
pick up algorithms and data structure knowledge on the job, if necessary.</p>
<p>Some would say that algorithms are a good way to flush out coding
ability. And coding ability is important to assess as part of interviewing
a job candidate for a programming position! They aren't wrong. But there
are much better ways to receive stronger signals about an interviewee's
compatibility! On the coding front, there are infinite ways to assess
programming capability without involving algorithms. So why involve
algorithms as part of the interview?</p>
<p>One way I approach interviewing people is to imagine what the typical
work day of that role will be like. How much time do they spend coding,
investigating bugs, debugging, attending meetings, writing proposals,
politicking with managers, etc. This produces a conceptual pie chart
of that role's activities. I then try to structure the interview such
that the topics covered in the interview correlate with and somewhat
in proportion to activities in that job role. Is the role a heads down
junior coder? A team lead or manager? When you start trying to map the
time in various areas of the role to time spent in the interview, you
realize that the common technical interview overly emphasizes some areas
and often completely ignores others! One of the areas that is
over-emphasizes is algorithms. <strong>Again, your typical programmer is going
to be spending most of their typical day doing things unrelated to
algorithms. So why are you spending precious interview time asking about
algorithms when you could be probing an area that actually correlates
to typical job activities?</strong> When viewed through this lens, the prevalence
of algorithms in interviews just doesn't make much sense to me.</p>
<p>Perhaps knowledge of algorithms should be basic knowledge that every
programmer should possess. If so, then asking about algorithms is fair
game during an interview, I suppose. But I'm not comfortable with this
line of thought.</p>
<p>I've always found it fascinating the ways that people with different
backgrounds and degrees approach problems differently. From my experience,
some of the best ideas and perspectives come from people with backgrounds
and degrees which are minorities in the field. I've worked with
programmers with degrees in philosophy and history who were some of the
best programmers and overall minds in the room. One of the great things
about software and programming is it is accessible to anyone, regardless
of background. If you can code, you can land a (usually high-paying) job.
Yes, the field is highly technical. But you don't need formal education
or a degree to enter it like you do similar <em>high-end</em> professions, such
as medicine or law. You can argue whether this is a good thing or not. But
I think the accessibility of the software profession - the lack of formal
gatekeeping - is something to marvel at, something that we as an industry
should embrace and be proud of. Do arbitrary hurdles to joining the
industry help or hinder it?</p>
<p>A problem with emphasizing algorithms in interviews is that algorithms
are somewhat highly specialized and academic. There are entire areas of
programming and software where detailed knowledge of algorithms just
isn't that important. <strong>The bar for so much software is <em>it works</em> and it
quite frankly doesn't matter if you have a quadratic algorithm instead of
something better.</strong></p>
<p>Most people I know are exposed to algorithms fundamentals during their
university education as part of pursuing a degree in
computer science or engineering. You almost certainly aren't going to
have academic exposure to algorithms if you are say a liberal arts
major - never mind someone who doesn't attend university at all (I also
know plenty of terrific programmers who don't have degrees). From my
own experience, my degree is in computer engineering. Not computer
science or software engineering: computer engineering. I remember from
my university days that my computer science friends seemed to have a much
better grasp at algorithms and theory of software and programming
than I did. When I was taking classes about how hardware and electronics
work, they were learning all about the mathematical concepts underpinning
the field, different approaches to programming language design, etc. I
received very little of that. And on top of that, I struggled with my
single algorithms course at university. So I entered the workforce without
as good of a grasp on the computer science fundamentals as others I knew.
(But I still probably knew more than someone in an unrelated field.)
The point I'm trying to make is that because algorithms are somewhat highly
specialized and academic in nature, requiring knowledge in algorithms
will effectively bias your hiring towards people with strong computer
science backgrounds. Stated another way, <strong>screening on algorithms knowledge
undermines diversity and inclusion initiatives by excluding viable
candidates who don't have strong backgrounds in computer science.</strong>
Sure, if someone wants to enter the industry they can take the time to
study up on algorithms. But why force them to do that? It feels like
arbitrary gatekeeping given the relative non-importance of algorithms
given the typical activities of the typical programmer. So why do it?</p>
<p>I suspect major contributing reasons to why algorithms are so prevalent
in interviews are cargo culting, laziness, and lack of formal interview
training / caring about diversity. As an industry, the software
field is pretty bad at applying best practices and learning from our
mistakes. I suspect this will change once the relatively young
industry catches up to more-established industries and we're forced to
cope with the realities of legal and monetary liabilities the way
practically every other industry is. (We're starting to see this with
monetary damages for security breaches.) Anyway, we as an industry are pretty
bad at self-regulating and adopting practices with proven benefits. We
like to settle for what is known. Laziness and the comfort associated with
is easy. Seeking out and implementing change is harder. This is human
nature. We see this with well-known people in industry rejecting the
ideas of continuous testing (years ago) or fuzzing (more recently). We see
it in C/C++ programmers who are delusional about their abilities to write
secure code and decry e.g. Rust's safety guarantees as superfluous. The
industry is disproportionately white and male (at least in the United
States). And this brings with it certain personality tendencies. One is a
<em>macho</em> attitude, which can manifest in interviews via the interviewer
embarking on an ego trip proving they know some esoteric algorithm or
data structure the candidate does not. </p>
<p>As a clear example of this, Google was known for asking <em>brainteaser</em>
interview questions. (The practice may have been prevalent at Microsoft
before Google was the darling of Silicon Valley, but that was before I
entered industry.) This <em>trend</em> caught on and soon companies all over were
asking brainteasers! The problem was that these questions
<a href="https://www.newyorker.com/tech/annals-of-technology/why-brainteasers-dont-belong-in-job-interviews">didn't correlate to actual job performance</a>!
From a <a href="https://www.nytimes.com/2013/06/20/business/in-head-hunting-big-data-may-not-be-such-a-big-deal.html?pagewanted=all">2013 NYTimes interview with Google's VP of People Operations</a>:</p>
<pre><code>On the hiring side, we found that brainteasers are a complete waste of
time. How many golf balls can you fit into an airplane? How many gas
stations in Manhattan? A complete waste of time. They don’t predict
anything. They serve primarily to make the interviewer feel smart.
</code></pre>
<p>But the damage was done. I still heard these kinds of questions when
interviewing in the wild long after Google realized they were bad
questions and instructed interviewers not to ask them. I even believe I
got a brainteaser when interviewing at Google after the supposed
banning of these types of questions! And I won't be shocked if I'm
asked a brainteaser in 2019 as part of the several interviews I'll
be doing in the days ahead.</p>
<p>Asking questions with no correlation to job performance because a
popular company asked that type of question for a while: that's
textbook cargo culting. Failing to change your ways despite evidence
saying you should: laziness. Insisting that your way is correct and
others need to be like you: gatekeeping.</p>
<p>I'm not saying algorithms and data structures during interviews are
intrinsically bad and that we should stop asking about them. What I am
saying is that we as an industry need to examine how we interview. We need
to invest in scientifically proven techniques. (Research shows that
behavioral interview questions are <em>better</em>. <em>Tell me about a
time when</em>, etc.) And after more than ten years in industry, my experience
tells me that interviews place a disproportionate emphasis on algorithms
and data structures compared to the daily activities of the typical
programmer. And on top of that, due to their academic nature, I worry
that screening for algorithms and data structures knowledge is undermining
the diversity and inclusivity of our field by biasing towards people
with strong computer science backgrounds. I think it is time we
examine the role of algorithms and data structures in interviews and
consider focusing on other areas instead.</p>]]></content:encoded>
    </item>
    <item>
      <title>What I've Learned About Optimizing Python</title>
      <link>http://gregoryszorc.com/blog/2019/01/10/what-i've-learned-about-optimizing-python</link>
      <pubDate>Thu, 10 Jan 2019 15:00:00 PST</pubDate>
      <category><![CDATA[Python]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2019/01/10/what-i've-learned-about-optimizing-python</guid>
      <description>What I've Learned About Optimizing Python</description>
      <content:encoded><![CDATA[<p>I've used Python more than any other programming language in the past
4-5 years. Python is the lingua franca for Firefox's build, test, and
CI tooling. Mercurial is written in mostly Python. Many of my
side-projects are in Python.</p>
<p>Along the way, I've accrued a bit of knowledge about Python
performance and how to optimize Python. This post is about sharing
that knowledge with the larger community.</p>
<p>My experience with Python is mostly with the CPython interpreter,
specifically CPython 2.7. Not all observations apply to all Python
distributions or have the same characteristics across Python versions.
I'll try to call this out when relevant. And this post is in no
way a thorough survey of the Python performance landscape. I mainly
want to highlight areas that have particularly plagued me.</p>
<h2>Startup and Module Importing Overhead</h2>
<p>Starting a Python interpreter and importing Python modules is
relatively slow if you care about milliseconds.</p>
<p>If you need to start hundreds or thousands of Python processes
as part of a workload, this overhead will amount to several seconds
of overhead.</p>
<p>If you use Python to provide CLI tools, the overhead can cause
enough lag to be noticeable by people. If you want <em>instantaneous</em>
CLI tools, launching a Python interpreter on every invocation will
make it very difficult to achieve that with a sufficiently complex
tool.</p>
<p>I've written about this problem extensively. My
<a href="https://mail.python.org/pipermail/python-dev/2014-May/134528.html">2014 post on python-dev</a>
outlines the problem. Posts in
<a href="https://mail.python.org/pipermail/python-dev/2018-May/153296.html">May 2018</a>
and <a href="https://mail.python.org/pipermail/python-dev/2018-October/155466.html">October 2018</a>
restate and refine it.</p>
<p>There's not much you can do to alleviate interpreter startup overhead:
fixing this mostly resides with the maintainers of the Python
interpreter because they control the code that is taking precious
milliseconds to complete. About the best you can do is
<a href="https://docs.python.org/3/using/cmdline.html#id3">disable the site import</a>
in your shebangs and invocations to avoid some extra Python code
running at startup. However, many applications rely on functionality
provided by <code>site.py</code>, so use at your own risk.</p>
<p>Related to this is the problem of module importing. What good is a
Python interpreter if it doesn't have code to run! And the way code
is made available to the interpreter is often through importing
modules.</p>
<p>There are multiple steps to importing modules. And there are sources
of overhead in each one.</p>
<p>There is overhead in finding modules and reading their data. As
I've <a href="/blog/2019/01/06/pyoxidizer-support-for-windows/">demonstrated with PyOxidizer</a>,
replacing the default <em>find and load a module from the filesystem</em>
with an architecturally simpler solution of <em>read the module data
from an in-memory data structure</em> makes importing the Python standard
library take 70-80% of its original time! Having a single module
per filesystem file introduces filesystem overhead and can slow
down Python applications in the critical first milliseconds of
execution. Solutions like PyOxidizer can mitigate this. And hopefully
the Python community sees the overhead in the current approach
and considers moving towards module distribution mechanisms that
don't rely so much on separate files per module.</p>
<p>Another source of module importing overhead is executing code in
that module at import time. Some modules have code in the module
scope outside of functions and classes that runs when the module
is imported. This code execution can add overhead to importing. A
mitigation for this is to not run as much code at import time: only
run code as needed. Python 3.7 supports a module <code>__getattr__</code>
that will be called when a module attribute is not found. This can
be used to lazily populate module attributes on first access.</p>
<p>Another workaround for module importing slowness is lazy module
importing. Instead of actually loading a module when it is imported,
you register a custom module importer that returns a <em>stub</em> for
that module instead. When that stub is first accessed, it will
load the actual module and mutate itself to be that module.</p>
<p>By avoiding the filesystem and module running overhead for unused
modules (modules are typically imported globally and then only
used by certain functions in a module), you can easily shave
dozens of milliseconds from applications importing several dozens
of modules.</p>
<p>But lazy module importers are a bit fragile. Lots of modules
have a pattern where they <code>try: import foo; except ImportError:</code>.
A lazy module importer may never raise <code>ImportError</code> here because
to do so, it would need to search the filesystem for a module
to know if it exists and searching the filesystem would add overhead,
so they don't do it! You work around this by accessing an attribute
on the imported module. This forces the <code>ImportError</code> to be raised
if the module doesn't exist but undermines the laziness of the module
import! This problem is quite nasty. Mercurial's lazy module
importer has to maintain a list of modules that are known to not
be lazy importable to work around it. Another issue is the
<code>from foo import x, y</code> syntax, which also undermines lazy module
importing in cases where <code>foo</code> is a module (as opposed to a package)
because in order to return a reference to <code>x</code> and <code>y</code>, the module
has to be imported.</p>
<p>PyOxidizer, having a fixed set of modules <em>frozen</em> into the binary,
can be efficient about raising <code>ImportError</code>. And Python 3.7's
module <code>__getattr__</code> provides additional flexibility for lazy
module importers. I hope to integrate a robust lazy module importer
into <code>PyOxidizer</code> so these gains are realized automatically.</p>
<p>The best solution to avoiding the interpreter startup and module
import overhead problem is to run a persistent Python process.
If you run Python in a daemon process (say for a web server), you
pretty much get this for free. Mercurial's solution to this is to
run a persistent Python process in the background which exposes a
<a href="https://www.mercurial-scm.org/wiki/CommandServer">command server</a>
protocol. <code>hg</code> is aliased to a C (or now Rust) executable
which connects to that persistent process and dispatches a
command. The command server approach is a lot of work and can
be a bit fragile and has security concerns. I'm exploring the
idea of shipping a command server with <code>PyOxidizer</code> so
executable can easily gain its benefits and the cost to solving
the problem only needs to be paid in one central place: the
<code>PyOxidizer</code> project.</p>
<h2>Function Call Overhead</h2>
<p>Function calls in Python are relatively slow. (This observation
applies less to PyPy, which can JIT code execution.)</p>
<p>I've seen literally dozens of patches to Mercurial where we inline
code or combine Python functions in order to avoid function
call overhead. In the current development cycle, some effort was
made to reduce the number of functions called when updating
progress bars. (We try to use progress bars for any operation
that could take a while so users know what is going on.) The
old progress bar update code would dispatch to a handful of
functions.
<a href="https://www.mercurial-scm.org/repo/hg/rev/6603de284b0a">Caching function call results</a>
and <a href="https://www.mercurial-scm.org/repo/hg/rev/963462786f6e">avoiding simple lookups via functions</a>
shaves dozens to hundreds of milliseconds off execution when we're
talking about 1 million executions.</p>
<p>If you have tight loops or recursive functions in Python where
hundreds of thousands or more function calls could be in play, you
need to be aware of the overhead of calling an individual function,
as it can add up quickly! Consider in-lining simple functions
and combining functions to avoid the overhead.</p>
<h2>Attribute Lookup Overhead</h2>
<p>This problem is similar to function call overhead because it
can actually be the same problem!</p>
<p>Resolving an attribute in Python can be relatively slow. (Again,
this observation applies less to PyPy.)</p>
<p>Again, working around this issue is something we do a lot in
Mercurial.</p>
<p>Say you have the following code:</p>
<div class="pygments_murphy"><pre><span></span><span class="n">obj</span> <span class="o">=</span> <span class="n">MyObject</span><span class="p">()</span>
<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">member</span><span class="p">):</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">obj</span><span class="o">.</span><span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>

<p>Ignoring that there are better ways to write this example
(<code>total = sum(obj.member)</code> should work), as written, the loop
here will need to resolve <code>obj.member</code> on every iteration.
Python has a relatively complex mechanism for
<a href="https://docs.python.org/3/reference/datamodel.html">resolving attributes</a>.
For simple types, it can be quite fast. But for complex types,
that attribute access can silently be invoking <code>__getattr__</code>,
<code>__getattribute__</code>, various other <em>dunder</em> methods, and even
custom <code>@property</code> functions. What looks like it should be
a fast attribute lookup can silently be several function calls,
leading to function call overhead! And this overhead can compound
if you are doing things like <code>obj.member1.member2.member3</code> etc.</p>
<p>Each attribute lookup adds overhead. And since nearly everything
in Python is a dictionary, it is somewhat accurate to equate
each attribute lookup as a dictionary lookup. And we know from
basic data structures that dictionary lookups are intrinsically not
as fast as having say a pointer. Yes, there are some tricks in
CPython to avoid the dictionary lookup overhead. But the general
theme I want to get across is that each attribute lookup is a
potential performance sink.</p>
<p>For tight loops - especially those over potentially hundreds of
thousands of iterations - you can avoid this measurable attribute
lookup overhead by aliasing the value to a local. We would write the
example above as:</p>
<div class="pygments_murphy"><pre><span></span><span class="n">obj</span> <span class="o">=</span> <span class="n">MyObject</span><span class="p">()</span>
<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">member</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">member</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">len</span><span class="p">(</span><span class="n">member</span><span class="p">):</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">member</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>

<p>Of course, this is only safe when the aliased item isn't
replaced inside the loop! If that happens, your iterator will
hold a reference to the old item and things may blow up.</p>
<p>The same trick can be used when calling a method of an object.
Instead of:</p>
<div class="pygments_murphy"><pre><span></span><span class="n">obj</span> <span class="o">=</span> <span class="n">MyObject</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">):</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>

<p>Do the following:</p>
<div class="pygments_murphy"><pre><span></span><span class="n">obj</span> <span class="o">=</span> <span class="n">MyObject</span><span class="p">()</span>
<span class="n">fn</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">process</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">:)</span>
    <span class="n">fn</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>

<p>It's also worth noting that in cases where the attribute lookup
is used to call a method (such as the previous example),
Python 3.7 is
<a href="https://bugs.python.org/issue26110">significantly faster</a>
than previous releases. But I'm pretty sure this is due to
dispatch overhead to the method function itself, not attribute
lookup overhead. So things will be faster yet by avoiding the
attribute lookup.</p>
<p>Finally, unless attribute lookup is calling functions to
resolve the attribute, attribute lookup is generally less of
a problem than function call overhead. And it generally requires
eliminating a lot of attribute lookups for you to notice a
meaningful improvement. That being said, once you add up all
attribute accesses inside a loop, you may be talking about
10 or 20 attributes in the loop alone - before function calls.
And loops with only thousands or low tens of thousands of iterations
can quickly provide hundreds of thousands or millions of attribute
lookups. So be on the lookout!</p>
<h2>Object Overhead</h2>
<p>From the perspective of the Python interpreter, every value is
an object. In CPython, each value is a <code>PyObject</code> struct. Each
object managed by the interpreter is on the heap and needs to have
its own memory holding its reference count, its type, and other
state. Every object is garbage collected. This means that each
new object introduces overhead for the reference counting / garbage
collection mechanism to process. (Again, PyPy can avoid some of
this overhead by being more intelligent about the <em>lifetimes</em> of
short-lived values.)</p>
<p>As a general rule of thumb, the more unique Python values/objects
you create, the slower things are.</p>
<p>For example, say you are iterating over a collection of 1 million
objects. You call a function to process that object into a tuple:</p>
<div class="pygments_murphy"><pre><span></span><span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">my_collection</span><span class="p">:</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>

<p>In this example, <code>process()</code> returns an <code>8-tuple</code>. It doesn't
matter of we destructure the return value or not: this tuple requires
the creation of at least 9 Python values: 1 for the tuple itself
and 8 for its inner members. OK, in reality there could be fewer
values if <code>process()</code> returns a reference to an existing value.
Or there could be more if the types aren't simple types and require
multiple <code>PyObject</code> to represent. My point is that under the hood
the interpreter is having to juggle multiple objects to represent
things.</p>
<p>From my experience, this overhead is only relevant for operations
that benefit from speedups when implemented in a native language
like C or Rust. The reason is the CPython interpreter is just
unable to execute bytecode fast enough for object overhead itself
to matter. Instead, you will likely hit performance issues with
function call overhead, processing overhead, etc long before
object overhead. But there are some exceptions to this, such as
constructing tuples or dicts with several members.</p>
<p>As a concrete example of this overhead, Mercurial has C code for
parsing some of the lower-level data structures. In terms of
raw parsing speed, the C code runs on an order of two magnitudes
faster than CPython. But once we have that C code create
<code>PyObject</code> to present the result, the speedup drops to just a
few times faster, if that. In other words, the overhead is coming
from creating and managing Python values so they can be used
by Python code.</p>
<p>A workaround for this is to produce fewer Python values. If you
only need to access a single value, have a function return that
single value instead of say a tuple or dict with N values. However,
watch out for function call overhead!</p>
<p>When you have a lot of speedup code using the CPython C API and
values need to be shared across different modules, pass around Python
types that expose data as C structs and have the compiled code
access those C structs instead of going through the CPython
C API. By avoiding the Python C API for data access, you will
be avoiding most of its overhead.</p>
<p>Treating values as data (instead of having functions for accessing
everything) is more Pythonic. So another workaround for compiled
code is is to lazily create
<code>PyObject</code> instances. If you create a custom Python
type (<code>PyTypeObject</code>) to represent your complex values, you
can define the
<a href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_members">tp_members</a>
and/or <a href="https://docs.python.org/3/c-api/typeobj.html#c.PyTypeObject.tp_getset">tp_getset</a>
fields to register custom C functions to resolve the value for
an attribute. If you are say writing a parser and you know that
consumers will only access a subset of the parsed fields, you can
quickly construct a type holding the raw data, return that type,
and have the Python attribute lookup call a C function which
resolves the <code>PyObject</code>. You can even defer parsing until this
function is called, saving additional overhead if a parse is
never required! This technique is quite rare (because it requires
writing a non-trivial amount of code against the Python C API).
But it can result in substantial wins.</p>
<h2>Pre-Sizing Collections</h2>
<p>This one applies to the CPython C API.</p>
<p>When creating collections like lists or dicts, use e.g.
<code>PyList_New()</code> + <code>PyList_SET_ITEM()</code> to populate new
collections when their size is known at collection creation
time. This will pre-size the collection to have capacity to hold
the final number of elements. And it skips checks when inserting
elements that the collection is large enough to hold them. When
creating collections of thousands of elements, this can save a
bit of overhead!</p>
<h2>Using Zero-copy in the C API</h2>
<p>The CPython C API really likes to make copies of things rather
than return references. For example,
<a href="https://docs.python.org/3.7/c-api/bytes.html#c.PyBytes_FromStringAndSize">PyBytes_FromStringAndSize()</a>
copies a <code>char*</code> to memory <em>owned</em> by Python. If you are doing
this for a large number of values or sufficiently large data,
we could be talking about gigabytes of memory I/O and associated
allocator overhead.</p>
<p>If writing high-performance code against the C API, you'll want
to become familiar with the
<a href="https://docs.python.org/3.7/c-api/buffer.html">buffer protocol</a>
and related types, like
<a href="https://docs.python.org/3.7/c-api/memoryview.html">memoryview</a>.</p>
<p>The <em>buffer protocol</em> is implemented by Python types and allows
the Python interpreter to <em>cast</em> a type to/from bytes. It essentially
allows the interpreter's C code to get a handle on a
<code>void*</code> of certain size representing the object. This allows you
to associate any address in memory with a <code>PyObject</code>. Many
functions operating on binary data transparently accept any
object implementing the <em>buffer protocol</em>. And if you are coding
against the C API and want to accept any object that can be
treated as bytes, you should be using the
<code>s*</code>, <code>y*</code> or <code>w*</code>
<a href="https://docs.python.org/3/c-api/arg.html#strings-and-buffers">format units</a>
when parsing function arguments.</p>
<p>By using the buffer protocol, you give the interpreter the
best opportunity possible to be using zero-copy operations and
avoiding having to copy bytes around in memory.</p>
<p>By using Python types like
<a href="https://docs.python.org/3.7/library/stdtypes.html#memoryview">memoryview</a>,
you are also allowing Python to reference slices of memory by
reference instead of by copy.</p>
<p>When you have gigabytes of data flowing through your Python
program, astute use of Python types that support zero-copy can
make a world of difference on performance. I once measured
that <a href="https://github.com/indygreg/python-zstandard">python-zstandard</a>
was faster than some Python LZ4 bindings (LZ4 should be faster
than zstandard) because I made heavy use of the buffer protocol
and avoiding excessive memory I/O in python-zstandard!</p>
<h2>Conclusion</h2>
<p>This post has outlined some of the things I've learned optimizing
Python programs over the years. This post is by no means
a comprehensive overview of Python performance techniques and
gotchas. I recognize that my use of Python is probably more
demanding than most and that the recommendations I made are
not applicable to many Python programs. <strong>You should not
mass update your Python code to e.g. inline functions and
remove attribute lookups after reading this post.</strong> As always,
when it comes to performance optimization, measure first and
optimize where things are observed to be slow. I highly recommend
<a href="https://github.com/benfred/py-spy">py-spy</a> for profiling Python
applications. That being said, it's hard to attach a time value
to low-level activity in the Python interpreter such as calling
functions and looking up attributes. So if you e.g. have a loop 
that you know is tight, experiment with suggestions in this post,
and see if you can measure an improvement!</p>
<p>Finally this post should not be interpreted as a dig against Python
or its performance properties. Yes, you can make arguments that
Python should or shouldn't be used in particular areas because of
performance properties. But Python is extremely versatile -
especially with PyPy delivering exceptional performance for a
dynamic programming language. The performance of Python is probably
<em>good enough</em> for most people. For better or worse, I have used
Python for uses cases that often feel like outliers across all
users. And I wanted to share my experiences such that others
know what life at the frontier is like. And maybe, just maybe, I
can cause the smart people who actually maintain Python distributions
to think about the issues I've had in more detail and provide
improvements to mitigate them.</p>]]></content:encoded>
    </item>
    <item>
      <title>Seeking Employment</title>
      <link>http://gregoryszorc.com/blog/2019/01/07/seeking-employment</link>
      <pubDate>Mon, 07 Jan 2019 15:25:00 PST</pubDate>
      <category><![CDATA[Personal]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2019/01/07/seeking-employment</guid>
      <description>Seeking Employment</description>
      <content:encoded><![CDATA[<p>After almost seven and a half years as an employee of Mozilla Corporation,
I'm moving on. I have already worked my final day as an employee.</p>
<p>This post is the first time that I've publicly acknowledged my departure.
To any Mozillians reading this, I regret that I did not send out a
farewell email before I left. But the circumstances of my departure weren't
conducive to doing so. I've been drafting a proper farewell blog post. But
it has been very challenging to compose. Furthermore, each passing day
brings with it new insights into my time at Mozilla and a new wrinkle to
integrate into the reflective story I want to tell in that post. I vow to
eventually publish a proper goodbye that serves as the bookend to my
employment at Mozilla. Until then, just let me say that I'm already missing
working with many of you. I've connected with several people since I left
and still owe responses or messages to many more. If you want to get in
touch, my contact info is in my <a href="/resume.pdf">résumé</a>.</p>
<p>I left Mozilla without new employment lined up. That leads me to the
subject line of this post: I'm seeking employment. The remainder of this
post is thus tailored to potential employers.</p>
<p>My <a href="/resume.pdf">résumé</a> has been updated. But that two page summary
only scratches the surface of my experience and set of skills. The
<a href="/work.html">Body of Work</a> page of my website is a more detailed record
of the work I've done. But even it is not complete!</p>
<p>Perusing through my posts on this blog will reveal even more about the
work I've done and how I go about it. My résumé links to a few posts
that I think are great examples of the level of understanding and detail
that I'm capable of harnessing.</p>
<p>As far as the kind of work I want to do or the type of company I want
to work for, I'm trying to keep an open mind. But I do have some biases.</p>
<p>I prefer established companies to early start-ups for various reasons.
Dan Luu's <a href="https://danluu.com/startup-tradeoffs/">Big companies v. startups</a>
is aligned pretty well with my thinking.</p>
<p>One of the reasons I worked for Mozilla was because of my personal
alignment with the
<a href="https://www.mozilla.org/en-US/about/manifesto/">Mozilla Manifesto</a>. So
I gravitate towards employers that share those principles and am
somewhat turned off by those that counteract them. But I recognize that
the world is complex and that competing perspectives aren't intrinsically
evil. In other words, I try to maintain an open mind.</p>
<p>I'm attracted to employers that align their business with improving the
well-being of the planet, especially the people on it. The link
between the business and well-being can be tenuous: a B2B business for
example is presumably selling something that helps people, and that helping
is what matters to me. The tighter the link between the business and
improving the world will increase my attraction to a employer.</p>
<p>I started my university education as a biomedical engineer because I
liked the idea of being at the intersection of technology and medicine.
And part of me really wants to return to this space because there
are few things more noble than helping a fellow human being in need.</p>
<p>As for the kind of role or technical work I want to do, I could go in
any number of directions. I still enjoy doing individual contributor type
work and believe I could be an asset to an employer doing that work. But
I also crave working on a team, performing technical mentorship, and being
a leader of technical components. I enjoy participating in high-level
planning as well as implementing the low-level aspects. I recognize that
while my individual output can be substantial (I can provide data showing
that I was one of the most prolific technical contributors at Mozilla
during my time there) I can be more valuable to an employer when I
bestow skills and knowledge unto others through teaching, mentorship,
setting an example, etc.</p>
<p>I have what I would consider expertise in a few domains that may be
attractive to employers.</p>
<p>I was a technical maintainer of Firefox's build system and initiated a
transition away from an architecture that had been in place since the
Netscape days. I definitely geek out way too much on build systems.</p>
<p>I am a contributor to the Mercurial version control tool. I know way
too much about the internals of Mercurial, Git, and other version
control tools. I am intimately aware of scaling problems with these
tools. Some of the scaling work I did for Mercurial saved Mozilla tens
of thousands of dollars in direct operational costs and probably
hundreds of thousands of dollars in saved people time due to fewer
service disruptions and faster operations.</p>
<p>I have exposure to both client and server side work and the problems
encountered within each domain. I've dabbled in lots of technologies,
operating systems, and tools. I'm not afraid to learn something new.
Although as my experience increases, so does my skepticism of shiny
new things (I've been burned by technical fads too many times).</p>
<p>I have a keen fascination with optimization and scaling, whether it
be on a technical level or in terms of workflows and human behavior.
I like to ask <em>and then what</em> so I'm thinking a few steps out and am
prepared for the next problem or consequence of an immediate action.</p>
<p>I seem to have a knack for caring about user experience and interfaces.
(Although my own visual design skills aren't the greatest - see my
website design for proof.) I'm pretty passionate that tools that people
use should be simple and usable. Cognitive dissonance, latency, and
distractions are real and as an industry we don't do a great job
minimizing these disruptions so focus and productivity can be
maximized. I'm not saying I would be a good product manager or
UI designer. But it's something I've thought about because not many
engineers seem to exhibit the passion for good user experience that
I do and that intersection of skills could be valuable.</p>
<p>My favorite time at Mozilla was when I was working on a unified
<em>engineering productivity</em> team. The team controlled most of the tools
and infrastructure that Firefox developers interacted with in order
to do their jobs. I absolutely loved taking a whole-world view of
that problem space and identifying the high-level problems - and
low-hanging fruit - to improve the overall Firefox development
experience. I derived a lot of satisfaction from identifying pain
points, equating them to a dollar cost by extrapolating people time
wasted due to them, justifying working on them, and finally
celebrating - along with the overall engineering team - when improvements
were made. I think I would be a tremendous asset to a company working
in this space. And if my experience at Mozilla is any indicator, I
would more than offset my total employment cost by doing this kind
of work.</p>
<p>I've been entertaining the idea of contracting for a while before
I resume full-time employment with a single employer. However, I've
never contracted before and need to do some homework before I commit
to that. (Please leave a comment or email me if you have recommendations
on reading material.)</p>
<p>My dream contract gig would likely be to finish the Mercurial wire
protocol and storage work I started last year. I would need to type
up a formal proposal, but the gist of it is the work I started has the
potential to leapfrog Git in terms of both client-side and server-side
performance and scalability. Mercurial would be able to open Git
repositories on the local filesystem as well as consume them via the
Git wire protocol. Transparent Git interoperability would enable
Mercurial to be used as a drop-in replacement for Git, which would
benefit users who don't have control over the server (such as projects
that live on GitHub). Mercurial's new wire protocol is designed with
global scalability and distribution in mind. The goal is to enable
server operators to deploy scalable VCS servers in a turn-key manner
by relying on scalable key-value stores and content distribution
networks as much as possible (Mercurial and Git today require servers
to perform way too much work and aren't designed with modern distributed
systems best practices, which is why scaling them is hard). The new
protocol is being designed such that a <em>Mercurial</em> server could expose
Git data. It would then be possible to teach a Git client to speak the
<em>Mercurial</em> wire protocol, which would result in Mercurial being a more
scalable Git server than Git is today. If my vision is achieved, this
would make server-side VCS scaling problems go away and would eliminate
the religious debate between Git and Mercurial (the answer would be
<em>deploy a Mercurial server, allow data to be exposed to Git, and let
consumers choose</em>). I conservatively estimate that the benefits to
industry would be in the millions of dollars. How I would structure
a contract to deliver aspects of this, I'm not sure. But if you are
willing to invest six figures towards this bet, let's talk. A good
foundation of this work is already implemented in Mercurial and the
Mercurial core development team is already on-board with many aspects
of the vision, so I'm not spewing vapor.</p>
<p>Another potential contract opportunity would be funding
<a href="https://gregoryszorc.com/blog/category/pyoxidizer/">PyOxidizer</a>.
I started the project a few months back as a side-project as an
excuse to learn Rust while solving a <em>fun</em> problem that I thought
needed solving. I was hoping for the project to be useful for
Mercurial and Mozilla one day. But if social media activity is any
indication, there seems to be somewhat widespread interest in this
project. I have no doubt that once complete, companies will be using
PyOxidizer to ship products that generate revenue and that PyOxidizer
will save them engineering resources. I'd very much like to recapture
some of that value into my pockets, if possible. Again, I'm somewhat
naive about how to write contracts since I've never contracted, but I
imagine <em>deliver a tool that allows me to ship product X as a
standalone binary to platforms Y and Z</em> is definitely something that
could be structured as a contract. </p>
<p>As for the timeline, I was at Mozilla for what feels like an eternity
in Silicon Valley. And Mozilla's way of working is substantially
different from many companies. I need some time to decompress and
unlearn some Mozilla habits. My future employer will inherit a happier
and more productive employee by allowing me to take some much-needed
time off.</p>
<p>I'm looking to resume full-time work no sooner than March 1. I'd like
to figure out what the next step in my career is by the end of January.
Then I can sign some papers, pack up my skiis, and become a ski bum
for the month of February: if I don't use this unemployment opportunity
to have at least 20 days on the slopes this season and visit some new
mountains, I will be very disappointed in myself!</p>
<p>If you want to get in touch, my contact info is in my
<a href="/resume.pdf">résumé</a>. I tend not to answer incoming calls from
unknown numbers, so email is preferred. But if you leave a voicemail,
I'll try to get back to you.</p>
<p>I look forward to working for a great engineering organization in the
near future!</p>]]></content:encoded>
    </item>
    <item>
      <title>PyOxidizer Support for Windows</title>
      <link>http://gregoryszorc.com/blog/2019/01/06/pyoxidizer-support-for-windows</link>
      <pubDate>Sun, 06 Jan 2019 10:00:00 PST</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[PyOxidizer]]></category>
      <category><![CDATA[Rust]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2019/01/06/pyoxidizer-support-for-windows</guid>
      <description>PyOxidizer Support for Windows</description>
      <content:encoded><![CDATA[<p>A few weeks ago I
<a href="/blog/2018/12/18/distributing-standalone-python-applications">introduced PyOxidizer</a>,
a project that aims to make it easier to produce completely self-contained
executables embedding a Python interpreter (using Rust). A few days later I
<a href="/blog/2018/12/28/faster-in-memory-python-module-importing/">observed some PyOxidizer performance benefits</a>.</p>
<p>After a few more hacking sessions, I'm very pleased to report that
PyOxidizer is now working on Windows!</p>
<p>I am able to produce a standalone Windows <code>.exe</code> containing a fully
featured CPython interpreter, all its library dependencies (OpenSSL, SQLite,
liblzma, etc), and a copy of the Python standard library (both source and
bytecode data). The binary weighs in at around 25 MB. (It could be smaller
if we didn't embed <code>.py</code> source files or stripped some dependencies.)
The only DLL dependencies of the exe are <code>vcruntime140.dll</code> and various
system DLLs that are always present on Windows.</p>
<p>Like I did for Linux and macOS, I produced a Python script that performs
~500 <code>import</code> statements for the near entirety of the Python standard library.
I then ran this script with both the official 64-bit Python distribution
and an executable produced with PyOxidizer:</p>
<pre><code># Official CPython 3.7.2 Windows distribution.
$ time python.exe &lt; import_stdlib.py
real    0m0.475s

# PyOxidizer with non-PGO CPython 3.7.2
$ time target/release/pyapp.exe &lt; import_stdlib.py
real    0m0.347s
</code></pre>
<p>Compared to the official CPython distribution, a PyOxidizer executable
can import almost the entirety of the Python standard library ~125ms
faster - or ~73% of original. In terms of the percentage of speedup,
the gains are similar to Linux and macOS. However, there is substantial
new process overhead on Windows compared to POSIX architectures. On the
same machine, a <em>hello world</em> Python process will execute in ~10ms on Linux
and ~40ms on Windows. If we remove the startup overhead, importing
the Python standard library runs at ~70% of its original time, making
the relative speedup on par with that seen on macOS + APFS.</p>
<p>Windows support is a major milestone for PyOxidizer. And it was the
hardest platform to make work. CPython's build system on Windows uses
Visual Studio project files. And coercing the build system to produce
static libraries was a real pain. Lots of CPython's build tooling assumes
Python is built in a very specific manner and multiple changes I made
completely break those assumptions. On top of that, it's very easy to
encounter problems with symbol name mismatch due to the use of
<code>__declspec(dllexport)</code> and <code>__declspec(dllimport)</code>. I spent
several hours going down a rabbit hole learning how Rust generates symbols
on Windows for <code>extern {}</code> items. Unfortunately, we currently have
to use a Rust Nightly feature (the <code>static-nobundle</code> linkage kind)
to get things to work. But I <em>think</em> there are options to remove that
requirement.</p>
<p>Up to this point, my work on PyOxidizer has focused on prototyping the
concept. With Windows out of the way and PyOxidizer working on Linux,
macOS, and Windows, I have achieved confidence that my vision of a
single executable embedding a full-featured Python interpreter is
technically viable on major desktop platforms! (BSD people, I care
about you too. The solution for Linux should be portable to BSD.)
This means I can start focusing on features, usability, and optimization.
In other words, I can start building a tool that others will want to use.</p>
<p>As always, you can follow my work on this blog and by following
the <a href="https://github.com/indygreg/python-build-standalone">python-build-standalone</a>
and <a href="https://github.com/indygreg/PyOxidizer">PyOxidizer</a> projects on
GitHub.</p>]]></content:encoded>
    </item>
    <item>
      <title>Faster In-Memory Python Module Importing</title>
      <link>http://gregoryszorc.com/blog/2018/12/28/faster-in-memory-python-module-importing</link>
      <pubDate>Fri, 28 Dec 2018 12:40:00 PST</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[PyOxidizer]]></category>
      <category><![CDATA[Rust]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2018/12/28/faster-in-memory-python-module-importing</guid>
      <description>Faster In-Memory Python Module Importing</description>
      <content:encoded><![CDATA[<p>I <a href="/blog/2018/12/18/distributing-standalone-python-applications/">recently blogged about</a>
distributing standalone Python applications. In that post, I announced
<a href="https://github.com/indygreg/PyOxidizer">PyOxidizer</a> - a tool which
leverages Rust to produce standalone executables embedding Python. One of the
features of PyOxidizer is the ability to import Python modules embedded
within the binary using zero-copy.</p>
<p>I also recently blogged about
<a href="/blog/2018/10/29/global-kernel-locks-in-apfs/">global kernel locks in APFS</a>,
which make filesystem operations slower on macOS. This was the latest wrinkle in
a long battle against Python's slow startup times, which I've posted about
on the official python-dev mailing list
<a href="https://mail.python.org/pipermail/python-dev/2014-May/134528.html">over</a>
<a href="https://mail.python.org/pipermail/python-dev/2018-May/153296.html">the</a>
<a href="https://mail.python.org/pipermail/python-dev/2018-October/155466.html">years</a>.</p>
<p>Since I announced PyOxidizer a few days ago, I've had some productive holiday
hacking sessions!</p>
<p>One of the reached milestones is PyOxidizer now supports macOS.</p>
<p>With that milestone reached, I thought it would be interesting to compare
the performance of a PyOxidizer executable versus a standard CPython build.</p>
<p>I produced a <a href="https://gist.github.com/indygreg/be1c229fa41ced5c76d912f7073f9de6">Python script</a>
that imports almost the entirety of the Python standard library - at least the
modules implemented in Python. That's 508 <code>import</code> statements. I then
executed this script using a typical <code>python3.7</code> binary (with the standard
library on the filesystem) and PyOxidizer-produced standalone executables
with a module importer that loads Python modules from memory using zero copy.</p>
<pre><code># Homebrew installed CPython 3.7.2

# Cold disk cache.
$ sudo purge
$ time /usr/local/bin/python3.7 &lt; import_stdlib.py
real   0m0.694s
user   0m0.354s
sys    0m0.121s

# Hot disk cache.
$ time /usr/local/bin/python3.7 &lt; import_stdlib.py
real   0m0.319s
user   0m0.263s
sys    0m0.050s

# PyOxidizer with non-PGO/non-LTO CPython 3.7.2
$ time target/release/pyapp &lt; import_stdlib.py
real   0m0.223s
user   0m0.201s
sys    0m0.017s

# PyOxidizer with PGO/non-LTO CPython 3.7.2
$ time target/release/pyapp &lt; import_stdlib.py
real   0m0.234s
user   0m0.210s
sys    0m0.019

# PyOxidizer with PTO+LTO CPython 3.7.2
$ sudo purge
$ time target/release/pyapp &lt; import_stdlib.py
real   0m0.442s
user   0m0.252s
sys    0m0.059s

$ time target/release/pyall &lt; import_stdlib.py
real   0m0.221s
user   0m0.197s
sys    0m0.020s
</code></pre>
<p>First, the PyOxidizer times are all relatively similar regardless of whether
PGO or LTO is used to build CPython. That's not too surprising, as I'm
exercising a very limited subset of CPython (and I suspect the benefits
of PGO/LTO aren't as pronounced due to the nature of the CPython API).</p>
<p>But the bigger result is the obvious speedup with PyOxidizer and its
in-memory importing: <strong>PyOxidizer can import almost the entirety of the
Python standard library ~100ms faster - or ~70% of original - than a
typical standalone CPython install</strong> with a hot disk cache! This comes
out to ~0.19ms per <code>import</code> statement. If we run <code>purge</code> to clear out
the disk cache, the performance delta increases to 252ms, or ~64% of
original. All these numbers are on a 2018 6-core 2.9 GHz i9 MacBook Pro,
which has a pretty decent SSD.</p>
<p>And on Linux on an i7-6700K running in a Hyper-V VM:</p>
<pre><code># pyenv installed CPython 3.7.2

# Cold disk cache.
$ time ~/.pyenv/versions/3.7.2/bin/python &lt; import_stdlib.py
real   0m0.405s
user   0m0.165s
sys    0m0.065s

# Hot disk cache.
$ time ~/.pyenv/versions/3.7.2/bin/python &lt; import_stdlib.py
real   0m0.193s
user   0m0.161s
sys    0m0.032s

# PyOxidizer with PGO CPython 3.7.2

# Cold disk cache.
$ time target/release/pyapp &lt; import_stdlib.py
real   0m0.227s
user   0m0.145s
sys    0m0.016s

# Hot disk cache.
$ time target/release/pyapp &lt; import_stdlib.py
real   0m0.152s
user   0m0.136s
sys    0m0.016s
</code></pre>
<p>On a hot disk cache, the run-time improvement of PyOxidizer is ~41ms, or
~78% of original. This comes out to ~0.08ms per <code>import</code> statement. When
flushing caches by writing <code>3</code> to <code>/proc/sys/vm/drop_caches</code>, the delta
increases to ~178ms, or ~56% of original.</p>
<p>Using <code>dtruss -c</code> to execute the binaries, the breakdown in system calls
occurring &gt;10 times is clear:</p>
<pre><code># CPython standalone
fstatfs64                                      16
read_nocancel                                  19
ioctl                                          20
getentropy                                     22
pread                                          26
fcntl                                          27
sigaction                                      32
getdirentries64                                34
fcntl_nocancel                                106
mmap                                          114
close_nocancel                                129
open_nocancel                                 130
lseek                                         148
open                                          168
close                                         170
read                                          282
fstat64                                       403
stat64                                        833

# PyOxidizer
lseek                                          10
read                                           12
read_nocancel                                  14
fstat64                                        16
ioctl                                          22
munmap                                         31
stat64                                         33
sysctl                                         33
sigaction                                      36
mmap                                          122
madvise                                       193
getentropy                                    315
</code></pre>
<p>PyOxidizer avoids hundreds of <code>open()</code>, <code>close()</code>, <code>read()</code>,
<code>fstat64()</code>, and <code>stat64()</code> calls. And by avoiding these calls,
PyOxidizer not only avoids the userland-kernel overhead intrinsic to them,
but also any additional overhead that APFS is imposing via its global
lock(s).</p>
<p>(Why the PyOxidizer binary is making hundreds of calls to <code>getentropy()</code>
I'm not sure. It's definitely coming from Python as a side-effect of a
module import and it is something I'd like to fix, if possible.)</p>
<p>With this experiment, we finally have the ability to better isolate the
impact of filesystem overhead on Python module importing and preliminary
results indicate that the overhead is not insignificant - at least on the
tested systems (I'll get data for Windows when PyOxidizer supports it).
While the test is somewhat contrived (I don't think many applications import
the entirety of the Python standard library), some Python applications do
import hundreds of modules. And as I've
<a href="https://mail.python.org/pipermail/python-dev/2018-May/153296.html">written before</a>,
milliseconds matter. This is especially true if you are invoking Python
processes hundreds or thousands of times in a build system, when running
a test suite, for scripting, etc. Cumulatively you can be importing tens
of thousands of modules. So I think shaving even fractions of a
millisecond from module importing is important.</p>
<p>It's worth noting that in addition to the system call overhead, CPython's
path-based importer runs
<a href="https://github.com/python/cpython/blob/804a5d94b6b7f8cb8546112aee2bc3af362f28f5/Lib/importlib/_bootstrap_external.py">substantially more</a>
Python code
<a href="https://github.com/indygreg/PyOxidizer/blob/c50e63338abd08ebac86746a33d750756d622edc/pyrepackager/src/memoryimporter.py">than PyOxidizer</a>
and this likely contributes several milliseconds of overhead as well. Because
PyOxidizer applications are static, the importer can remain simple (finding a
module in PyOxidizer is essentially a Rust <code>HashMap&lt;String, Vec&lt;u8&gt;</code> lookup).
While it might be useful to isolate the filesystem overhead from Python code
overhead, the thing that end-users care about is overall execution time: they
don't care where that overhead is coming from. So I think it is fair to compare
PyOxidizer - with its intrinsically simpler import model - with what Python
typically does (scan <code>sys.path</code> entries and looking for modules on the
filesystem).</p>
<p>Another difference is that PyOxidizer is almost completely statically linked.
By contrast, a typical CPython install has compiled extension modules as
standalone shared libraries and these shared libraries often link against
other shared libraries (such as libssl). From <code>dtruss</code> timing information,
I don't believe this difference contributes to significant overhead, however.</p>
<p>Finally, I haven't yet optimized PyOxidizer. I still have a few tricks up
my sleeve that can likely shave off more overhead from Python startup. But
so far the results are looking <em>very</em> promising. I dare say they are looking
promising enough that Python distributions themselves might want to look
into the area more thoroughly and consider distribution defaults that rely
less on the every-Python-module-is-a-separate-file model.</p>
<p>Stay tuned for more <a href="https://github.com/indygreg/PyOxidizer">PyOxidizer</a>
updates in the near future!</p>
<p><em>(I updated this post a day after initial publication to add measurements
for Linux.)</em></p>]]></content:encoded>
    </item>
    <item>
      <title>Distributing Standalone Python Applications</title>
      <link>http://gregoryszorc.com/blog/2018/12/18/distributing-standalone-python-applications</link>
      <pubDate>Tue, 18 Dec 2018 15:35:00 PST</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[PyOxidizer]]></category>
      <category><![CDATA[Rust]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2018/12/18/distributing-standalone-python-applications</guid>
      <description>Distributing Standalone Python Applications</description>
      <content:encoded><![CDATA[<h2>The Problem</h2>
<p>Packaging and application distribution is a hard problem on multiple
dimensions. For Python, large aspects of this problem space are more or
less solved if you are distributing open source Python libraries and your
target audience is developers (<em>use pip and PyPI</em>). But if you are distributing
Python <em>applications</em> - standalone executables that use Python - your
world can be much more complicated.</p>
<p>One of the primary reasons why distributing Python applications is difficult
is because of the complex and often sensitive relationship between a Python
application and the environment it runs in.</p>
<p>For starters we have the Python interpreter itself. If your application doesn't
distribute the Python interpreter, you are at the whims of the Python
interpreter provided by the host machine. You may want to target Python 3.7
only. But because Python 3.5 or 3.6 is the most recent version installed by
many Linux distros, you are forced to support older Python versions and all
their quirks and lack of features.</p>
<p>Going down the rabbit hole, even the presence of a supposedly compatible
version of the Python interpreter isn't a guarantee for success! For example,
the Python interpreter could have a built-in extension that links against
an old version of a library. Just last week I was encountering weird SQlite
bugs in Firefox's automation because Python was using an old version of
SQLite with known bugs. Installing a modern SQLite fixed the problems. Or
the interpreter could have modifications or extra installed packages
interfering with the operation of your application. There are never-ending
corner cases. And I can tell you from my experience with having to support
the Firefox build system (which uses Python heavily) that you will encounter
these corner cases given a broad enough user base.</p>
<p>And even if the Python interpreter on the target machine is fully compatible,
getting your code to run on that interpreter could be difficult! Several
Python applications leverage compiled extensions linking against Python's
C API. Distributing the precompiled form of the extension can be challenging,
especially when your code needs to link against 3rd party libraries, which
may conflict with something on the target system. And, the precompiled
extensions need to be built in a very delicate manner to ensure they can
run on as many target machines as possible. But not distributing pre-built
binaries requires the end-user be able to compile Python extensions. Not
every user has such an environment and forcing this requirement on them is
not user friendly.</p>
<p><strong>From an application developer's point of view, distributing a copy of the
Python interpreter along with your application is the only reliable way of
guaranteeing a more uniform end-user experience.</strong> Yes, you will still
have variability because every machine is different. But you've eliminated
the the Python interpreter from the set of unknowns and that is a huge win.
(Unfortunately, distributing a Python interpreter comes with a host of other
problems such as size bloat, security/patching concerns, poking the OS
packaging bears, etc. But those problems are for another post.)</p>
<h2>Existing Solutions</h2>
<p>There are tons of existing tools for <em>solving</em> the Python application
distribution problem.</p>
<p>The approach that tools like <a href="https://shiv.readthedocs.io/en/latest/">Shiv</a>
and <a href="https://github.com/pantsbuild/pex">PEX</a> take is to leverage Python's
built-in support for <em>running</em> zip files. Essentially, if there is a zip
file containing a <code>__main__.py</code> file and you execute <code>python file.zip</code>
(or have a zip file with a <code>#!/usr/bin/env python</code> shebang), Python
can load modules in that zip file and execute an application within. Pretty
cool!</p>
<p>This approach works great if your execution environment supports shebangs
(Windows doesn't) and the Python interpreter is suitable. But if you need
to support Windows or don't have control over the execution environment
and can't guarantee the Python interpreter is <em>good</em>, this approach isn't
suitable.</p>
<p>As stated above, we want to distribute the Python interpreter with our
application to minimize variability. Let's talk about tools that do that.</p>
<p><a href="https://github.com/facebookincubator/xar/">XAR</a> is a pretty cool offering
from Facebook. XAR files are executables that contain
<a href="https://en.wikipedia.org/wiki/SquashFS">SquashFS</a> filesystems. Upon running
the executable, SquashFS filesystems are created. For Python applications,
the XAR contains a copy of the Python interpreter and all your Python modules.
At run-time, these files are <em>extracted</em> to SquashFS filesystems and the
Python interpreter is executed. If you squint hard enough, it is kind of
like a pre-packaged, executable virtualenv which also contains the Python
interpreter.</p>
<p>XARs are pretty cool (and aren't limited to Python). However, because XARs
rely on SquashFS, they have a run-time requirement on the target machine.
This is great if you only need to support Linux and macOS and your target
machines support FUSE and SquashFS. But if you need to support Windows or
a general user population without SquashFS support, XARs won't help you.</p>
<p>Zip files and XARs are great for enterprises that have tightly controlled
environments. But for a general end-user population, we need something
more robust against variance among target machines.</p>
<p>There are a handful of tools for packaging Python applications along with
the Python interpreter in more resilient manners.</p>
<p><a href="http://nuitka.net/pages/overview.html">Nuitka</a> <em>converts</em> Python source
to C code then compiles and links that C code against libpython. You can
perform a static link and compile everything down to a single executable.
If you do the compiling properly, that executable should <em>just work</em> on
pretty much every target machine. That's pretty cool and is exactly the
kind of solution application distributors are looking for: you can't get
much simpler than a self-contained executable! While I'd love to vouch
for Nuitka and recommend using it, I haven't used it so can't. And I'll
be honest, the prospect of compiling Python source to C code kind of
terrifies me. That effectively makes Nuitka a new Python implementation
and I'm not sure I can (yet) place the level of trust in Nuitka that I
have for e.g. CPython and PyPy.</p>
<p>And that leads us to our final category of tools:
<a href="https://docs.python-guide.org/shipping/freezing/">freezing your code</a>. There
are a handful of tools like <a href="https://www.pyinstaller.org/">PyInstaller</a>
which automate the process of building your Python application (often via
standard <code>setup.py</code> mechanisms), assembling all the requisite bits of
the Python interpreter, and producing an artifact that can be distributed
to end users. There are even tools that produce Windows installers, RPMs,
DEBs, etc that you can sign and distribute.</p>
<p>These <em>freezing</em> tools are arguably the state of the art for Python
application distribution to general user populations. On first glance
it seems like all the needed tools are available here. But there are
cracks below the surface.</p>
<h2>Issues with Freezing</h2>
<p>A common problem with freezing is it often relies on the Python interpreter
used to build the frozen application. For example, when building a frozen
application on Linux, it will bundle the system's Python interpreter with
the frozen application. And that interpreter may link against libraries
or libc symbol versions not available on all target machines. So, the
build environment has to be <em>just right</em> in order for the binaries to
run on as many target systems as possible. This isn't an insurmountable
problem. But it adds overhead and complexity to application maintainers.</p>
<p>Another limitation is how these frozen applications handle importing
Python modules.</p>
<p>Multiple tools take the approach of embedding an archive (usually a zip file)
in the executable containing the Python <em>standard library</em> bits not part of
libpython. This includes C extensions (compiled to <code>.so</code> or <code>.pyd</code> files)
and Python source (<code>.py</code>) or bytecode (<code>.pyc</code>) files. There is typically
a step - either at application start time or at module import time - where a
file is extracted to the filesystem such that Python's filesystem-based
importer can load it from there.</p>
<p>For example, PyInstaller <a href="https://pyinstaller.readthedocs.io/en/stable/operating-mode.html#how-the-one-file-program-works">extracts the standard library to a temporary directory
at application start time</a>
(at least when running in single file mode). This can add significant overhead
to the startup time of applications - more than enough to blow through people's
ability to perceive something as <em>instantaneous</em>. This is acceptable for
long-running applications. But for applications (like CLI tools or support
tools for build systems), the overhead can be a non-starter. And, the mere
fact that you are doing filesystem write I/O establishes a requirement that
the application have write access to the filesystem and that write I/O can
perform reasonably well lest application performance suffer. These can be
difficult pills to swallow!</p>
<p>Another limitation is that these tools often assume the executable being
produced is only a Python application. Sometimes Python is <em>part of</em> a
larger application. It would be useful to produce a library that can
easily be embedded within a larger application.</p>
<h2>Improving the State of the Art</h2>
<p>Existing Python application distribution mechanisms don't tick all the
requirements boxes for me. We have tools that are suitable for internal
distribution in well-defined <em>enterprise</em> environments. And we have tools
that target general user populations, albeit with a burden on application
maintainers and often come with a performance hit and/or limited flexibility.</p>
<p>I want something that allows me to produce a standalone, single file executable
containing a Python interpreter, the Python standard library (or a subset of
it), and all the custom code and resources my application needs. That
executable should not require any additional library dependencies beyond what is
already available on most target machines (e.g. libc). That executable should
not require any special filesystem providers (e.g. FUSE/SquashFS) nor should
it require filesystem write access nor perform filesystem write I/O at run-time.
I should be able to embed a Python interpreter within a larger application,
without the overhead of starting the Python interpreter if it isn't needed.</p>
<p>No existing solution ticks all of these boxes.</p>
<p>So I set out to build one.</p>
<p>One problem is producing a Python interpreter that is portable and
fully-featured. You can't punt on this problem because if the core Python
interpreter isn't produced in just the right way, your application will
depend on libraries or symbol versions not available in all environments.</p>
<p>I've created the <a href="https://github.com/indygreg/python-build-standalone">python-build-standalone</a>
project for automating the process of building Python interpreters suitable
for use with standalone, distributable Python applications. The project
produces (and has available for download) binary artifacts including a
pre-compiled Python interpreter and object files used for compiling that
interpreter. The Python interpreter is compiled with PGO/LTO using a modern
Clang, helping to ensure that Python code runs as fast as it can. All of
Python's dependencies are compiled from source with the modern toolchain and
everything is aggressively statically linked to avoid external dependencies.
The toolchain and pre-built distribution are available for downstream
consumers to compile Python extensions with/against.</p>
<p>It's worth noting that use of a modern Clang toolchain is likely sufficiently
different from what you use today. When producing <em>manylinux</em> wheels, it is
recommended to use the <a href="https://github.com/pypa/manylinux">pypa/manylinux</a>
Docker images. These Docker images are based on CentOS 5 (for maximum libc
and other system library compatibility). While they do install a custom
toolchain, Python and any extensions compiled in that environment are compiled
with GCC 4.8.2 (as of this writing). That's a GCC from 2013. A lot has
changed in compilers since 2013 and building Python and extensions with a
compiler released in 2018 should result in various benefits (faster code,
better warnings, etc).</p>
<p>If producing custom CPython builds for standalone distribution interests
you, you should take a look at how I coerced CPython to statically link
all extensions. Spoiler: it involves producing a custom-tailored
<code>Modules/Setup.local</code> file that bypasses <code>setup.py</code>, along with some
<code>Makefile</code> hacks. Because the build environment is deterministic and isolated
in a container, we can get away with some ugly hacks.</p>
<p>A statically linked <code>libpython</code> from which you can produce a standalone
binary embedding Python is only the first layer in the onion. The next layer
is how to handle the Python standard library.</p>
<p><code>libpython</code> only contains the code needed to run the core bits of the Python
interpreter. If we attempt to run a statically linked <code>python</code> executable
without the standard library in the filesystem, things fail pretty fast:</p>
<pre><code>$ rm -rf lib
$ bin/python
Could not find platform independent libraries &lt;prefix&gt;
Could not find platform dependent libraries &lt;exec_prefix&gt;
Consider setting $PYTHONHOME to &lt;prefix&gt;[:&lt;exec_prefix&gt;]
Fatal Python error: initfsencoding: Unable to get the locale encoding
ModuleNotFoundError: No module named 'encodings'

Current thread 0x00007fe9a3432740 (most recent call first):
Aborted (core dumped)
</code></pre>
<p>I'll spare you the details for the moment, but initializing the CPython
interpreter (via <code>Py_Initialize()</code> <em>requires</em> that parts of the Python
standard library be available). This means that in order to fulfill our dream
of a single file executable, we will need custom code that teaches the
embedded Python interpreter to load the standard library from within the
binary... somehow.</p>
<p>As far as I know, efficient embedded standard library handling without run-time
requirements does not exist in the current Python packaging/distribution
ecosystem. So, I had to devise something new.</p>
<p>Enter <a href="https://github.com/indygreg/pyoxidizer">PyOxidizer</a>. PyOxidizer is
a collection of Rust crates that facilitate building an embeddable Python
library, which can easily be added to an executable. We need <em>native</em> code
to interface with the Python C APIs in order to influence Python interpreter
startup. It is 2018 and Rust is a better C/C++, so I chose Rust for this
<em>driver</em> functionality instead of C. Plus, Rust's integrated build system
makes it easier to automate the integration of the custom Python interpreter
files into binaries.</p>
<p>The role of PyOxidizer is to take the pre-built Python interpreter files from
<a href="https://github.com/indygreg/python-build-standalone">python-build-standalone</a>,
combine those files with any other Python files needed to run an application,
and marry them to a Rust crate. This Rust crate can trivially be turned into
a self-contained executable containing a Python application. Or, it can be
combined with another Rust project. Or it can be emitted as a library and
integrated with a non-Rust application. There's a lot of flexibility by design.</p>
<p>The mechanism I used for embedding the Python standard library into a single
file executable without incurring explicit filesystem access at run-time is
(I believe) new, novel, and somewhat crazy. Let me explain how it works.</p>
<p>First, there are no <code>.so</code>/<code>.pyd</code> shared library compiled Python extensions
to worry about. This is because all compiled extensions are statically linked
into the Python interpreter. To the interpreter, they exist as
<a href="https://docs.python.org/3.7/library/importlib.html#importlib.machinery.BuiltinImporter">built-in modules</a>.
Typically, a CPython build will have some modules like <code>_abc</code>, <code>_io</code>, and
<code>sys</code> provided by <em>built-in modules</em>. Modules like <code>_json</code> exist as standalone
shared libraries that are loaded on demand. <code>python-build-standalone</code>'s
modifications to CPython's build system converts all these would-be standalone
shared libraries into <em>built-in modules</em>. (Because we distribute the object
files that compose the eventual <code>libpython</code>, it is possible to filter out
unwanted modules to cut down on binary size if you don't want to ship a
fully-featured Python interpreter.) Because there are no standalone shared
libraries providing Python modules, we don't have the problem of needing to
load a shared library to load a module, which would undermine our goal of
<em>no filesystem access to import modules</em>. And that's a good thing, too,
because <code>dlopen()</code> requires a path: you can't load a shared library from
a memory address. (Fun fact: there are hacks like
<a href="https://sourceware.org/bugzilla/show_bug.cgi?id=11767">dlopen_with_offset()</a>
that provide an API to load a library from memory, but they require a custom
libc. Google uses this approach for their internal single-file Python
application solution.)</p>
<p>From the <code>python-build-standalone</code> artifacts, PyOxidizer collects all files
belonging to the Python standard library (notably <code>.py</code> and <code>.pyc</code> files).
It also collects other source, bytecode, and resource files needed to run
a custom application.</p>
<p>The relevant files are assembled and serialized into data structures which
contain the names of the resources and their raw content. These data structures
are made available to Rust as <code>&amp;'static [u8]</code> variables (essentially a
<code>static void*</code> if you don't speak Rust).</p>
<p>Using the <a href="https://github.com/dgrunwald/rust-cpython">rust-cpython</a> crate,
PyOxidizer defines a custom Python extension module implemented purely in Rust.
When loaded, the module parses the data structures containing available
Python resource names and data into <code>HashMap&lt;&amp;str, &amp;[u8]&gt;</code> instances. In other
words, it builds a native mapping from resource name to a pointer to its raw
data. The Rust-implemented module exports to Python an API for accessing that
data. From the Python side, you do the equivalent of <code>MODULES.get_code('foo')</code>
to request the bytecode for a named Python module. When called, the Rust code
will perform the lookup and return a <code>memoryview</code> instance pointing to the
raw data. (The use of <code>&amp;[u8]</code> and <code>memoryview</code> means that embedded resource
data is loaded from its static, read-only memory location instead of copied
into a data structure managed by Python. This zero copy approach translates to
less overhead for importing modules. Although, the memory needs to be paged
in by the operating system. So on slow filesystems, reducing I/O and e.g.
compressing module data might be a worthwhile optimization. This can be a
future feature.) </p>
<p>Making data embedded within a binary available to a Python module is relatively
easy. I'm definitely not the first person to come up with this idea. What is
hard - and what I <em>might</em> be the first person to actually do - is how you make
the Python module importing mechanism load <em>all</em> standard library modules via
such a mechanism.</p>
<p>With a custom extension module built-in to the binary exposing module data,
it should <em>just</em> be a matter of registering a custom
<a href="https://docs.python.org/3.7/library/sys.html#sys.meta_path">sys.meta_path</a>
importer that knows how to load modules from that custom location. This
problem turns out to be quite hard!</p>
<p>The initialization of a CPython interpreter is - as I've learned - a bit
complex. A CPython interpreter must be initialized via <code>Py_Initialize()</code>
before any Python code can run. That means in order to modify <code>sys.meta_path</code>,
<code>Py_Initialize()</code> must finish.</p>
<p>A lot of activity occurs under the hood during initialization. Applications
embedding Python have very little control over what happens during
<code>Py_Initialize()</code>. You can change some superficial things like what
filesystem paths to use to bootstrap <code>sys.path</code> and what encodings to use
for stdio descriptors. But you can't really influence the core actions that are
being performed. And there's no mechanism to directly influence
<code>sys.meta_path</code> before an <code>import</code> is performed. (Perhaps there should be?)</p>
<p>During <code>Py_Initialize()</code>, the interpreter needs to configure the encodings
for the filesystem and the stdio descriptors. Encodings are loaded from
Python modules provided by the standard library. So, during the course of
<code>Py_Initialize()</code>, the interpreter needs to import some modules originally
backed by <code>.py</code> files. This creates a dilemma: if <code>Py_Initialize()</code>
needs to <code>import</code> modules in the standard library, the standard library
is backed by memory and isn't available to known importing mechanisms, and
there's no opportunity to configure a custom <code>sys.meta_path</code> importer
before <code>Py_Initialize()</code> runs, how do you teach the interpreter about
your custom module importer and the location of the standard library modules
needed by <code>Py_Initialize()</code>?</p>
<p>This is an extremely gnarly problem and it took me some hours and many false
leads to come up with a solution.</p>
<p>My first attempt involved the esoteric
<a href="https://docs.python.org/3/c-api/import.html#c.PyImport_FrozenModules">frozen modules</a>
feature. (This work predated the use of a custom data structure and module
containing modules data.) The Python interpreter has a
<code>const struct _frozen* PyImport_FrozenModules</code> data structure defining an
array of <em>frozen</em> modules. A <em>frozen</em> module is defined by its module
name and precompiled bytecode data (roughly equivalent to <code>.pyc</code> file
content). Partway through <code>Py_Initialize()</code>, the Python interpreter is able
to import modules. And one of the built-in importers that is automatically
registered knows how to load modules if they are in <code>PyImport_FrozenModules</code>!</p>
<p>I attempted to audit Python interpreter startup and find all modules
that were imported during <code>Py_Initialize()</code>. I then defined a custom
<code>PyImport_FrozenModules</code> containing these modules. In theory, the import
of these modules during <code>Py_Initialize()</code> would be handled by the
<a href="https://docs.python.org/3.7/library/importlib.html#importlib.machinery.FrozenImporter">FrozenImporter</a>
and everything would <em>just work</em>: if I were able to get <code>Py_Initialize()</code> to
complete, I'd be able to register a custom <code>sys.meta_path</code> importer
immediately afterwards and we'd be set.</p>
<p>Things did not go as planned.</p>
<p><code>FrozenImporter</code> doesn't fully conform to the
<a href="https://www.python.org/dev/peps/pep-0451/">PEP 451</a> requirements for
setting specific attributes on modules. Without these attributes, the
<code>from . import aliases</code> statement in <code>encodings/__init__.py</code> fails
because the importer is unable to resolve the relative module name. Derp.
One would think CPython's built-in importers would comply with PEP 451
and that all of Python's standard library could be imported as frozen modules.
But this is not the case! I was able to hack around this particular failure
by using an absolute import. But I hit another failure and did not want to
excavate that rabbit hole. Once I realized that <code>FrozenImporter</code> was lacking
mandated module attributes, I concluded that attempting to use <em>frozen modules</em>
as a general import-from-memory mechanism was not viable. Furthermore, the
C code backing <code>FrozenImporter</code> walks the <code>PyImport_FrozenModules</code> array and
does a string compare on the module name to find matches. While I didn't
benchmark, I was concerned that un-indexed scanning at import time would
add considerable overhead when hundreds of modules were in play. (The C code
backing <code>BuiltinImporter</code> uses the same approach and I do worry CPython's
imports of built-in extension modules is causing measurable overhead.)</p>
<p>With <em>frozen modules</em> off the table, I needed to find another way to inject
a custom module importer that was usable during <code>Py_Initialize()</code>. Because
we control the source Python interpreter, modifications to the source code
or even link-time modifications or run-time hacks like trampolines weren't
off the table. But I <strong>really</strong> wanted things to work out of the box because
I don't want to be in the business of maintaining patches to Python
interpreters.</p>
<p>My foray into <em>frozen modules</em> enlightened me to the craziness that is
the bootstrapping of Python's importing mechanism.</p>
<p>I remember hearing that the Python module importing mechanism used to be
written in C and was rewritten in Python. And I knew that the
<a href="https://docs.python.org/3.7/library/importlib.html">importlib</a> package
defined interfaces allowing you to implement your own importers, which
could be registered on
<a href="https://docs.python.org/3.7/library/sys.html#sys.meta_path">sys.meta_path</a>.
But I didn't know how all of this worked at the interpreter level.</p>
<p>The internal <a href="https://github.com/python/cpython/blob/08c2ba0717089662132af69bf5948d82277a8a69/Python/pylifecycle.c#L178">initimport()</a>
C function is responsible for initializing the module importing mechanism. It
does the equivalent of <code>import _frozen_importlib</code>, but using the
<a href="https://docs.python.org/3/c-api/import.html#c.PyImport_ImportFrozenModuleObject">PyImport_ImportFrozenModule()</a>
API. It then manipulates some symbols and calls <code>_frozen_importlib.install()</code>
with references to the <code>sys</code> and <code>imp</code> built-in modules. Later (in
<code>initexternalimport()</code>), a <code>_frozen_importlib_external</code> module is imported
and has code within it executed.</p>
<p>I was initially very confused by this because - while there are references
to <code>_frozen_importlib</code> and <code>_frozen_importlib_external</code> all over the
CPython code base, I couldn't figure out where the code for those modules
actually lived! Some sleuthing of the build directory eventually revealed
that the files <a href="https://github.com/python/cpython/blob/08c2ba0717089662132af69bf5948d82277a8a69/Lib/importlib/_bootstrap.py">Lib/importlib/_bootstrap.py</a>
and <a href="https://github.com/python/cpython/blob/08c2ba0717089662132af69bf5948d82277a8a69/Lib/importlib/_bootstrap_external.py">Lib/importlib/_bootstrap_external.py</a>
were <em>frozen</em> to the module names <code>_frozen_importlib</code> and
<code>_frozen_importlib_external</code>, respectively.</p>
<p>Essentially what is happening is the bulk of Python's import <em>machinery</em> is
implemented in Python (rather than C). But there's a chicken-and-egg
problem where you can't run just any Python code (including any <code>import</code>
statement) until the interpreter is partially or fully initialized.</p>
<p>When building CPython, the Python source code for <code>importlib._bootstrap</code>
and <code>importlib._bootstrap_external</code> are compiled to bytecode. This
bytecode is emitted to <code>.h</code> files, where it is exposed as a
<code>static char *</code>. This bytecode is eventually referenced by the
default <code>PyImport_FrozenModules</code> array, allowing the modules to be
imported via the frozen importer's C API, which bypasses the higher-level
importing mechanism, allowing it to work before the full importing
mechanism is initialized.</p>
<p><code>initimport()</code> and <code>initexternalimport()</code> both call Python functions in
the frozen modules. And we can clearly look at the source of the
corresponding modules and see the Python code do things like
<a href="https://github.com/python/cpython/blob/08c2ba0717089662132af69bf5948d82277a8a69/Lib/importlib/_bootstrap.py#L1158">register the default importers on <code>sys.meta_path</code></a>.</p>
<p>Whew, that was a long journey into the bowels of CPython's internals. How
does all this help with single file Python executables?</p>
<p>Well, the predicament that led us down this rabbit hole was there was no
way to register a custom module importer before <code>Py_Initialize()</code>
completes and before an <code>import</code> is attempted during said <code>Py_Initialize()</code>.</p>
<p>It took me a while, but I finally realized the frozen
<code>importlib._bootstrap_external</code> module provided the window I needed!
<code>importlib._bootstrap_external</code>/<code>_frozen_importlib_external</code> is <em>always</em>
executed during <code>Py_Initialize()</code>. So if you can modify this module's code,
you can run arbitrary code during <code>Py_Initialize()</code> and influence Python
interpreter configuration. And since <code>_frozen_importlib_external</code> is a frozen
module and the <code>PyImport_FrozenModules</code> array is writable and can be modified
before <code>Py_Initialize()</code> is called, all one needs to do is replace the
<code>_frozen_importlib</code> / <code>_frozen_importlib_external</code> bytecode in
<code>PyImport_FrozenModules</code> and you can run arbitrary code during Python
interpreter startup, before <code>Py_Initialize()</code> completes and before any
standard library imports are performed!</p>
<p>My solution to this problem is to concatenate some custom Python code to
<code>importlib/_bootstrap_external.py</code>. This custom code defines a
<code>sys.meta_path</code> importer that knows how to use our Rust-backed built-in
extension module to find and load module data. It redefines the <code>_install()</code>
function so that this custom importer is registered on <code>sys.meta_path</code>
when the function is called during <code>Py_Initialize()</code>. The <em>new</em> Python
source is compiled to bytecode and the <code>PyImport_FrozenModules</code> array is
modified at run-time to point to the modified <code>_frozen_importlib_external</code>
implementation. When <code>Py_Initialize()</code> executes its first standard library
import, module data is provided by the custom <code>sys.meta_path</code> importer,
which grabs it from a Rust extension module, which reads it from a
read-only data structure in the executable binary, which is converted
to a Python <code>memoryview</code> instance and sent back to Python for processing.</p>
<p>There's a bit of <em>magic</em> happening behind the scenes to make all of this
work. PyOxidizer attempts to hide as much of the gory details as possible.
From the perspective of an application maintainer, you just need to define
a minimal config file and it handles most of the low-level details. And there's
even a higher-level Rust API for configuring the embedded Python interpreter,
should you need it.</p>
<p><code>python-build-standalone</code> and <code>PyOxidizer</code> are still in their infancy.
They are very much alpha quality. I consider them technology previews more
than usable software at this point. But I think enough is there to demonstrate
the viability of using Rust as the build system and run-time glue to build
and distribute standalone applications embedding Python.</p>
<p>Time will tell if my utopian vision of zero-copy, no explicit filesystem
I/O for Python module imports will pan out. Others who have ventured into
this space have warned me that lots of Python modules rely on <code>__file__</code>
to derive paths to other resources, which are later <code>stat()</code>d and
<code>open()</code>d. <code>__file__</code> for in-memory modules doesn't exactly make sense
and can't be operated on like normal paths/files. I'm not sure what the
inevitable struggles to support these modules will lead to. Maybe we'll have
to extract things to temporary directories like other standalone Python
applications. Maybe <code>PyOxidizer</code> will take off and people will start using
the <a href="https://docs.python.org/3.7/library/importlib.html#importlib.abc.ResourceReader">ResourceReader</a>
API, which is apparently the proper way to do these things these days.
(Caveat: <code>PyOxidizer</code> doesn't yet implement this API but support is planned.)
Time will tell. I'm not opposed to gross hacks or writing more code as
needed.</p>
<p>Producing highly distributable and performant Python applications has been far
too difficult for far too long. My primary goal for PyOxidizer is to lower these
barriers. By leveraging Rust, I also hope to bring Python and Rust closer
together. I want to enable applications and libraries to effortlessly harness
the powers of both of these fantastic programming languages.</p>
<p>Again, <code>PyOxidizer</code> is still in its infancy. I anticipate a significant amount
of hacking over the holidays and hope to share updates in the weeks ahead. Until
then, please leave comments, watch the <a href="https://github.com/indygreg/PyOxidizer">project on GitHub</a>,
file issues for bugs and feature requests, etc and we'll see where things lead.</p>]]></content:encoded>
    </item>
    <item>
      <title>Absorbing Commit Changes in Mercurial 4.8</title>
      <link>http://gregoryszorc.com/blog/2018/11/05/absorbing-commit-changes-in-mercurial-4.8</link>
      <pubDate>Mon, 05 Nov 2018 09:25:00 PST</pubDate>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2018/11/05/absorbing-commit-changes-in-mercurial-4.8</guid>
      <description>Absorbing Commit Changes in Mercurial 4.8</description>
      <content:encoded><![CDATA[<p>Every so often a tool you use introduces a feature that is so useful
that you can't imagine how things were before that feature existed.
The recent 4.8 release of the
<a href="https://www.mercurial-scm.org/">Mercurial version control tool</a> introduces
such a feature: the <code>hg absorb</code> command.</p>
<p><code>hg absorb</code> is a mechanism to automatically and intelligently incorporate
uncommitted changes into prior commits. Think of it as <em><code>hg histedit</code> or
<code>git rebase -i</code> with auto squashing</em>.</p>
<p>Imagine you have a set of changes to prior commits in your working
directory. <code>hg absorb</code> figures out which changes map to which commits
and <em>absorbs</em> each of those changes into the appropriate commit. Using
<code>hg absorb</code>, you can replace cumbersome and often merge conflict ridden
history editing workflows with a single command that often <em>just works</em>.
Read on for more details and examples.</p>
<p>Modern version control workflows often entail having multiple <em>unlanded</em>
commits in flight. What this looks like varies heavily by the version
control tool, standards and review workflows employed by the specific
project/repository, and personal preferences.</p>
<p>A workflow practiced by a lot of projects is to author your commits
into a sequence of standalone commits, with each commit representing
a discrete, logical unit of work. Each commit is then
reviewed/evaluated/tested on its own as part of a larger series.
(This workflow is practiced by Firefox, the Git and Mercurial projects,
and the Linux Kernel to name a few.)</p>
<p>A common task that arises when working with such a workflow is the need
to incorporate changes into an old commit. For example, let's say we have
a stack of the following commits:</p>
<pre><code>$ hg show stack
  @  1c114a ansible/hg-web: serve static files as immutable content
  o  d2cf48 ansible/hg-web: synchronize templates earlier
  o  c29f28 ansible/hg-web: convert hgrc to a template
  o  166549 ansible/hg-web: tell hgweb that static files are in /static/
  o  d46d6a ansible/hg-web: serve static template files from httpd
  o  37fdad testing: only print when in verbose mode
 /   (stack base)
o  e44c2e (@) testing: install Mercurial 4.8 final
</code></pre>
<p>Contained within this stack are 5 commits changing the way that static
files are served by hg.mozilla.org (but that's not important).</p>
<p>Let's say I submit this stack of commits for review. The reviewer spots
a problem with the second commit (<em>serve static template files from httpd</em>)
and wants me to make a change.</p>
<p>How do you go about making that change?</p>
<p>Again, this depends on the exact tool and workflow you are using.</p>
<p>A common workflow is to not rewrite the existing commits at all: you simply
create a new <em>fixup</em> commit on top of the stack, leaving the existing commits
as-is. e.g.:</p>
<pre><code>$ hg show stack
  o  deadad fix typo in httpd config
  o  1c114a ansible/hg-web: serve static files as immutable content
  o  d2cf48 ansible/hg-web: synchronize templates earlier
  o  c29f28 ansible/hg-web: convert hgrc to a template
  o  166549 ansible/hg-web: tell hgweb that static files are in /static/
  o  d46d6a ansible/hg-web: serve static template files from httpd
  o  37fdad testing: only print when in verbose mode
 /   (stack base)
o  e44c2e (@) testing: install Mercurial 4.8 final
</code></pre>
<p>When the entire series of commits is incorporated into the repository,
the end state of the files is the same, so all is well. But this strategy
of using <em>fixup commits</em> (while popular - especially with Git-based tooling
like GitHub that puts a larger emphasis on the end state of changes rather
than the individual commits) isn't practiced by all projects.
<strong><code>hg absorb</code> will not help you if this is your workflow.</strong></p>
<p>A popular variation of this <em>fixup commit</em> workflow is to author a new commit
then <em>incorporate</em> this commit into a prior commit. This typically involves
the following actions:</p>
<pre><code>&lt;save changes to a file&gt;

$ hg commit
&lt;type commit message&gt;

$ hg histedit
&lt;manually choose what actions to perform to what commits&gt;

OR

&lt;save changes to a file&gt;

$ git add &lt;file&gt;
$ git commit
&lt;type commit message&gt;

$ git rebase --interactive
&lt;manually choose what actions to perform to what commits&gt;
</code></pre>
<p>Essentially, you produce a new commit. Then you run a history editing command.
You then tell that history editing command what to do (e.g. to <em>squash</em> or
<em>fold</em> one commit into another), that command performs work and produces a set
of rewritten commits.</p>
<p>In simple cases, you may make a simple change to a single file. Things are
pretty straightforward. You need to know which two commits to <em>squash</em> together.
This is often trivial. Although it can be cumbersome if there are several
commits and it isn't clear which one should be receiving the new changes.</p>
<p>In more complex cases, you may make multiple modifications to multiple files.
You may even want to <em>squash</em> your <em>fixups</em> into separate commits. And for some
code reviews, this <em>complex</em> case can be quite common. It isn't uncommon for me
to be incorporating dozens of reviewer-suggested changes across several commits!</p>
<p>These complex use cases are where things can get really complicated for version
control tool interactions. Let's say we want to make multiple changes to a file
and then incorporate those changes into multiple commits. To keep it simple,
let's assume 2 modifications in a single file <em>squashing</em> into 2 commits:</p>
<pre><code>&lt;save changes to file&gt;

$ hg commit --interactive
&lt;select changes to commit&gt;
&lt;type commit message&gt;

$ hg commit
&lt;type commit message&gt;

$ hg histedit
&lt;manually choose what actions to perform to what commits&gt;

OR

&lt;save changes to file&gt;

$ git add &lt;file&gt;
$ git add --interactive
&lt;select changes to stage&gt;

$ git commit
&lt;type commit message&gt;

$ git add &lt;file&gt;
$ git commit
&lt;type commit message&gt;

$ git rebase --interactive
&lt;manually choose which actions to perform to what commits&gt;
</code></pre>
<p>We can see that the number of actions required by users has already increased
substantially. Not captured by the number of lines is the effort that must go
into the interactive commands like <code>hg commit --interactive</code>,
<code>git add --interactive</code>, <code>hg histedit</code>, and <code>git rebase --interactive</code>. For
these commands, users must tell the VCS tool exactly what actions to take.
This takes time and requires some cognitive load. This ultimately distracts
the user from the task at hand, which is bad for concentration and productivity.
The user just wants to <em>amend</em> old commits: telling the VCS tool what actions
to take is an obstacle in their way. (A compelling argument can be made that
the work required with these workflows to produce a <em>clean</em> history is too much
effort and it is easier to make the trade-off favoring simpler workflows
versus cleaner history.)</p>
<p><strong>These kinds of <em>squash fixup</em> workflows are what <code>hg absorb</code> is designed to
make easier.</strong> When using <code>hg absorb</code>, the above workflow can be reduced to:</p>
<pre><code>&lt;save changes to file&gt;

$ hg absorb
&lt;hit y to accept changes&gt;

OR

&lt;save changes to file&gt;

$ hg absorb --apply-changes
</code></pre>
<p>Let's assume the following changes are made in the working directory:</p>
<pre><code>$ hg diff
diff --git a/ansible/roles/hg-web/templates/vhost.conf.j2 b/ansible/roles/hg-web/templates/vhost.conf.j2
--- a/ansible/roles/hg-web/templates/vhost.conf.j2
+++ b/ansible/roles/hg-web/templates/vhost.conf.j2
@@ -76,7 +76,7 @@ LimitRequestFields 1000
      # Serve static files straight from disk.
      &lt;Directory /repo/hg/htdocs/static/&gt;
          Options FollowSymLinks
 -        AllowOverride NoneTypo
 +        AllowOverride None
          Require all granted
      &lt;/Directory&gt;

@@ -86,7 +86,7 @@ LimitRequestFields 1000
      # and URLs are versioned by the v-c-t revision, they are immutable
      # and can be served with aggressive caching settings.
      &lt;Location /static/&gt;
 -        Header set Cache-Control "max-age=31536000, immutable, bad"
 +        Header set Cache-Control "max-age=31536000, immutable"
      &lt;/Location&gt;

      #LogLevel debug
</code></pre>
<p>That is, we have 2 separate uncommitted changes to
<code>ansible/roles/hg-web/templates/vhost.conf.j2</code>.</p>
<p>Here is what happens when we run <code>hg absorb</code>:</p>
<pre><code>$ hg absorb
showing changes for ansible/roles/hg-web/templates/vhost.conf.j2
        @@ -78,1 +78,1 @@
d46d6a7 -        AllowOverride NoneTypo
d46d6a7 +        AllowOverride None
        @@ -88,1 +88,1 @@
1c114a3 -        Header set Cache-Control "max-age=31536000, immutable, bad"
1c114a3 +        Header set Cache-Control "max-age=31536000, immutable"

2 changesets affected
1c114a3 ansible/hg-web: serve static files as immutable content
d46d6a7 ansible/hg-web: serve static template files from httpd
apply changes (yn)?
&lt;press "y"&gt;
2 of 2 chunk(s) applied
</code></pre>
<p><code>hg absorb</code> automatically figured out that the 2 separate uncommitted changes
<em>mapped</em> to 2 different changesets (Mercurial's term for <em>commit</em>). It
print a summary of what lines would be changed in what changesets and
prompted me to accept its <em>plan</em> for how to proceed. The human effort involved
is a quick review of the proposed changes and answering a prompt.</p>
<p>At a technical level, <code>hg absorb</code> finds all uncommitted changes and
attempts to map each changed line to an unambiguous prior commit. For
every change that can be mapped cleanly, the uncommitted changes are
<em>absorbed</em> into the appropriate prior commit. Commits impacted by the
operation are rebased automatically. If a change cannot be mapped to an
unambiguous prior commit, it is left uncommitted and users can fall back
to an existing workflow (e.g. using <code>hg histedit</code>).</p>
<p>But wait - there's more!</p>
<p>The automatic rewriting logic of <code>hg absorb</code> is implemented by following
the history of lines. This is fundamentally different from the approach
taken by <code>hg histedit</code> or <code>git rebase</code>, which tend to rely on <em>merge
strategies</em> based on the
<a href="https://stackoverflow.com/questions/4129049/why-is-a-3-way-merge-advantageous-over-a-2-way-merge">3-way merge</a>
to derive a new version of a file given multiple input versions. This
approach combined with the fact that <code>hg absorb</code> skips over changes with
an ambiguous application commit means that <strong><code>hg absorb</code> will never
encounter merge conflicts</strong>! Now, you may be thinking <em>if you ignore
lines with ambiguous application targets, the patch would always apply
cleanly using a classical 3-way merge</em>. This statement logically sounds
correct. But it isn't: <code>hg absorb</code> can avoid merge conflicts when the
merging performed by <code>hg histedit</code> or <code>git rebase -i</code> would fail.</p>
<p>The above example attempts to exercise such a use case. Focusing on the
initial change:</p>
<pre><code>diff --git a/ansible/roles/hg-web/templates/vhost.conf.j2 b/ansible/roles/hg-web/templates/vhost.conf.j2
--- a/ansible/roles/hg-web/templates/vhost.conf.j2
+++ b/ansible/roles/hg-web/templates/vhost.conf.j2
@@ -76,7 +76,7 @@ LimitRequestFields 1000
     # Serve static files straight from disk.
     &lt;Directory /repo/hg/htdocs/static/&gt;
         Options FollowSymLinks
-        AllowOverride NoneTypo
+        AllowOverride None
         Require all granted
     &lt;/Directory&gt;
</code></pre>
<p>This patch needs to be applied against the commit which introduced it. That
commit had the following diff:</p>
<pre><code>diff --git a/ansible/roles/hg-web/templates/vhost.conf.j2 b/ansible/roles/hg-web/templates/vhost.conf.j2
--- a/ansible/roles/hg-web/templates/vhost.conf.j2
+++ b/ansible/roles/hg-web/templates/vhost.conf.j2
@@ -73,6 +73,15 @@ LimitRequestFields 1000
         {% endfor %}
     &lt;/Location&gt;

+    # Serve static files from templates directory straight from disk.
+    &lt;Directory /repo/hg/hg_templates/static/&gt;
+        Options None
+        AllowOverride NoneTypo
+        Require all granted
+    &lt;/Directory&gt;
+
+    Alias /static/ /repo/hg/hg_templates/static/
+
     #LogLevel debug
     LogFormat "%h %v %u %t \"%r\" %&gt;s %b %D \"%{Referer}i\" \"%{User-Agent}i\" \"%{Cookie}i\""
     ErrorLog "/var/log/httpd/hg.mozilla.org/error_log"
</code></pre>
<p>But after that commit was another commit with the following change:</p>
<pre><code>diff --git a/ansible/roles/hg-web/templates/vhost.conf.j2 b/ansible/roles/hg-web/templates/vhost.conf.j2
--- a/ansible/roles/hg-web/templates/vhost.conf.j2
+++ b/ansible/roles/hg-web/templates/vhost.conf.j2
@@ -73,14 +73,21 @@ LimitRequestFields 1000
         {% endfor %}
     &lt;/Location&gt;

-    # Serve static files from templates directory straight from disk.
-    &lt;Directory /repo/hg/hg_templates/static/&gt;
-        Options None
+    # Serve static files straight from disk.
+    &lt;Directory /repo/hg/htdocs/static/&gt;
+        Options FollowSymLinks
         AllowOverride NoneTypo
         Require all granted
     &lt;/Directory&gt;

...
</code></pre>
<p>When we use <code>hg histedit</code> or <code>git rebase -i</code> to rewrite this history, the VCS
would first attempt to re-order commits before squashing 2 commits together.
When we attempt to reorder the <em>fixup</em> diff immediately after the commit that
introduces it, there is a good chance your VCS tool would encounter a merge
conflict. Essentially your VCS is thinking <em>you changed this line but the
lines around the change in the final version are different from the lines
in the initial version: I don't know if those other lines matter and therefore
I don't know what the end state should be, so I'm giving up and letting the
user choose for me</em>.</p>
<p>But since <code>hg absorb</code> operates at the line history level, it knows that this
individual line wasn't actually changed (even though the lines around it did),
assumes there is no conflict, and offers to <em>absorb</em> the change. So not only
is <code>hg absorb</code> significantly simpler than today's <code>hg histedit</code> or
<code>git rebase -i</code> workflows in terms of VCS command interactions, but it can
also avoid time-consuming merge conflict resolution as well!</p>
<p>Another feature of <code>hg absorb</code> is that all the rewriting occurs in memory
and the working directory is not touched when running the command. This means
that the operation is fast (working directory updates often account for a lot
of the execution time of <code>hg histedit</code> or <code>git rebase</code> commands). It also means
that tools looking at the last modified time of files (e.g. build systems
like GNU Make) won't rebuild extra (unrelated) files that were touched
as part of updating the working directory to an old commit in order to apply
changes. This makes <code>hg absorb</code> more friendly to edit-compile-test-commit
loops and allows developers to be more productive.</p>
<p>And that's <code>hg absorb</code> in a nutshell.</p>
<p>When I first saw a demo of <code>hg absorb</code> at a Mercurial developer meetup, my
jaw - along with those all over the room - hit the figurative floor. I thought
it was magical and too good to be true. I thought Facebook (the original authors
of the feature) were trolling us with an impossible demo. But it was all real.
And now <code>hg absorb</code> is available in the core Mercurial distribution for anyone
to use.  </p>
<p>From my experience, <code>hg absorb</code> <em>just works</em> almost all of the time: I run
the command and it maps all of my uncommitted changes to the appropriate
commit and there's nothing more for me to do! In a word, it is magical.</p>
<p>To use <code>hg absorb</code>, you'll need to activate the <code>absorb</code> extension. Simply
put the following in your <code>hgrc</code> config file:</p>
<pre><code>[extensions]
absorb =
</code></pre>
<p><code>hg absorb</code> is currently an experimental feature. That means there is
no commitment to backwards compatibility and some rough edges are
expected. I also anticipate new features (such as <code>hg absorb --interactive</code>)
will be added before the experimental label is removed. If you encounter
problems or want to leave comments, <a href="https://bz.mercurial-scm.org/enter_bug.cgi?product=Mercurial">file a bug</a>,
make noise in <code>#mercurial</code> on Freenode, or
<a href="https://www.mercurial-scm.org/wiki/ContributingChanges">submit a patch</a>.
But don't let the <em>experimental</em> label scare you away from using it:
<code>hg absorb</code> is being used by some large install bases and also by many
of the Mercurial core developers. The <em>experimental</em> label is mainly there
because it is a brand new feature in core Mercurial and the <em>experimental</em>
label is usually affixed to new features.</p>
<p>If you practice workflows that frequently require amending old commits, I
think you'll be shocked at how much easier <code>hg absorb</code> makes these workflows.
I think you'll find it to be a game changer: once you use <code>hg abosrb</code>, you'll
soon wonder how you managed to get work done without it.</p>]]></content:encoded>
    </item>
    <item>
      <title>Global Kernel Locks in APFS</title>
      <link>http://gregoryszorc.com/blog/2018/10/29/global-kernel-locks-in-apfs</link>
      <pubDate>Mon, 29 Oct 2018 14:20:00 PDT</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Apple]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2018/10/29/global-kernel-locks-in-apfs</guid>
      <description>Global Kernel Locks in APFS</description>
      <content:encoded><![CDATA[<p>Over the past several months, a handful of people had been complaining
that Mercurial's test harness was executing much slower on Macs. But
this slowdown seemingly wasn't occurring on Linux or Windows. And not
every Mac user experienced the slowness!</p>
<p>Before jetting off to the Mercurial 4.8 developer meetup in Stockholm
a few weeks ago, I sat down with a relatively fresh 6+6 core MacBook Pro
and experienced the problem firsthand: on my 4+4 core i7-6700K running
Linux, the Mercurial test harness completes in ~12 minutes, but on this
MacBook Pro, it was executing in ~38 minutes! On paper, this result
doesn't make any sense because there's no way that the MacBook Pro should
be ~3x slower than that desktop machine.</p>
<p>Looking at Activity Monitor when running the test harness with 12 tests
in parallel revealed something odd: the system was spending ~75% of overall
CPU time inside the kernel! When reducing the number of tests that ran in
parallel, the percentage of CPU time spent in the kernel decreased and
the overall test harness execution time also decreased. This kind of
behavior is usually a sign of something very inefficient in kernel land.</p>
<p>I sample profiled all processes on the system when running the Mercurial
test harness. Aggregate thread stacks revealed a common pattern:
<code>readdir()</code> being in the stack.</p>
<p>Upon closer examination of the stacks, <code>readdir()</code> calls into
<code>apfs_vnop_readdir()</code>, which calls into some functions with <code>bt</code> or
<code>btree</code> in their name, which call into <code>lck_mtx_lock()</code>,
<code>lck_mtx_lock_grab_mutex()</code> and various other functions with
<code>lck_mtx</code> in their name. And the caller of most <code>readdir()</code> appeared
to be Python 2.7's module importing mechanism (notably
<code>import.c:case_ok()</code>).</p>
<p>APFS refers to the
<a href="https://en.wikipedia.org/wiki/Apple_File_System">Apple File System</a>,
which is a filesystem that Apple introduced in 2017 and is the
default filesystem for new versions of macOS and iOS. If upgrading an
old Mac to a new macOS, its HFS+ filesystems would be automatically
converted to APFS.</p>
<p>While the source code for APFS is not available for me to confirm, the
profiling results showing excessive time spent in
<code>lck_mtx_lock_grab_mutex()</code> combined with the fact that execution time
decreases when the parallel process count decreases leads me to the
conclusion that <strong>APFS obtains a global kernel lock during read-only
operations such as <code>readdir()</code></strong>. In other words, APFS slows down when
attempting to perform parallel read-only I/O.</p>
<p>This isn't the first time I've encountered such behavior in a
filesystem: last year I
<a href="/blog/2017/12/08/good-riddance-to-aufs/">blogged about very similar behavior in AUFS</a>,
which was making Firefox CI significantly slower.</p>
<p>Because Python 2.7's module importing mechanism was triggering the
slowness by calling <code>readdir()</code>, I
<a href="https://mail.python.org/pipermail/python-dev/2018-October/155466.html">posted to python-dev</a>
about the problem, as I thought it was important to notify the larger
Python community. After all, this is a generic problem that affects
the performance of starting <em>any</em> Python process when running on APFS.
i.e. if your build system invokes many Python processes in parallel,
you could be impacted by this. As part of obtaining data for that post, I
discovered that Python 3.7 does not call <code>readdir()</code> as part of
module importing and therefore doesn't exhibit a severe slowdown. (Python's
module importing code was rewritten significantly in Python 3 and the <em>fix</em>
was likely introduced well before Python 3.7.)</p>
<p>I've <a href="https://gist.github.com/indygreg/a50e187f5372807cdcab5ac12bc2feea">produced a gist that can reproduce the problem</a>.
The script essentially performs a recursive directory walk. It exercises
the <code>opendir()</code>, <code>readdir()</code>, <code>closedir()</code>, and <code>lstat()</code> functions
heavily and is essentially a benchmark of the filesystem and filesystem
cache's ability to return file metadata.</p>
<p>When you tell it to walk a very large directory tree - say a Firefox
version control checkout (which has over 250,000 files) - the excessive
time spent in the kernel is very apparent on macOS 10.13 High Sierra:</p>
<pre><code>$ time ./slow-readdir.py -l 12 ~/src/firefox
ran 12 walks across 12 processes in 172.209s

real    2m52.470s
user    1m54.053s
sys    23m42.808s

$ time ./slow-readdir.py -l 12 -j 1 ~/src/firefox
ran 12 walks across 1 processes in 523.440s

real    8m43.740s
user    1m13.397s
sys     3m50.687s

$ time ./slow-readdir.py -l 18 -j 18 ~/src/firefox
ran 18 walks across 18 processes in 210.487s

real    3m30.731s
user    2m40.216s
sys    33m34.406s
</code></pre>
<p>On the same machine upgraded to macOS 10.14 Mojave, we see a bit of a
speedup!:</p>
<pre><code>$ time ./slow-readdir.py -l 12 ~/src/firefox
ran 12 walks across 12 processes in 97.833s

real    1m37.981s
user    1m40.272s
sys    10m49.091s

$ time ./slow-readdir.py -l 12 -j 1 ~/src/firefox
ran 12 walks across 1 processes in 461.415s

real    7m41.657s
user    1m05.830s
sys     3m47.041s

$ time ./slow-readdir.py -l 18 -j 18 ~/src/firefox
ran 18 walks across 18 processes in 140.474s

real    2m20.727s
user    3m01.048s
sys    17m56.228s
</code></pre>
<p>Contrast with my i7-6700K Linux machine backed by EXT4:</p>
<pre><code>$ time ./slow-readdir.py -l 8 ~/src/firefox
ran 8 walks across 8 processes in 6.018s

real    0m6.191s
user    0m29.670s
sys     0m17.838s

$ time ./slow-readdir.py -l 8 -j 1 ~/src/firefox
ran 8 walks across 1 processes in 33.958s

real    0m34.164s
user    0m17.136s
sys     0m13.369s

$ time ./slow-readdir.py -l 12 -j 12 ~/src/firefox
ran 12 walks across 12 processes in 25.465s

real    0m25.640s
user    1m4.801s
sys     1m20.488s
</code></pre>
<p>It is apparent that macOS 10.14 Mojave has received performance work
relative to macOS 10.13! Overall kernel CPU time when performing parallel
directory walks has decreased substantially - to ~50% of original on some
invocations! Stacks seem to reveal new code for lock acquisition, so this
might indicate generic improvements to the kernel's locking mechanism
rather than APFS specific changes. Changes to file metadata caching could
also be responsible for performance changes. Although it is difficult to tell
without access to the APFS source code. Despite those improvements, APFS
is still spending a lot of CPU time in the kernel. And the kernel CPU time
is still comparatively very high compared to Linux/EXT4, even for single
process operation.</p>
<p>At this time, I haven't conducted a comprehensive analysis of APFS to
determine what other filesystem operations seem to acquire global kernel
locks: all I know is <code>readdir()</code> does. A casual analysis of profiled
stacks when running Mercurial's test harness against Python 3.7 seems
to show <code>apfs_*</code> functions still on the stack a lot and that seemingly
indicates more APFS slowness under parallel I/O load. But HFS+ exhibited
similar problems (it appeared HFS+ used a single I/O thread inside the
kernel for many operations, making I/O on macOS pretty bad), so I'm
not sure if these could be considered <em>regressions</em> the way <code>readdir()</code>'s
new behavior is.</p>
<p>I've reported this issue to Apple at
<a href="https://bugreport.apple.com/web/?problemID=45648013">https://bugreport.apple.com/web/?problemID=45648013</a>
and on OpenRadar at <a href="https://openradar.appspot.com/radar?id=5025294012383232">https://openradar.appspot.com/radar?id=5025294012383232</a>.
I'm told that issues get more attention from Apple when there are many
duplicates of the same issue. So please reference this issue if you file your
own report.</p>
<p>Now that I've elaborated on the technical details, I'd like to add some
personal commentary. While this post is about APFS, this issue of global
kernel locks during common I/O operations is not unique to APFS. I
<a href="/blog/2017/12/08/good-riddance-to-aufs/">already referenced</a> similar
issues in AUFS. And I've encountered similar behaviors with Btrfs (although
I can't recall exactly which operations). And NTFS has its own
<a href="https://github.com/Microsoft/WSL/issues/873#issuecomment-425272829">bag of problems</a>.</p>
<p>This seeming pattern of global kernel locks for common filesystem operations
and slow filesystems is really rubbing me the wrong way. Modern NVMe SSDs
are capable of reading and writing well over 2 gigabytes per second and
performing hundreds of thousands of I/O operations per second. We even have
Intel soon producing
<a href="https://newsroom.intel.com/editorials/re-architecting-data-center-memory-storage-hierarchy/">persistent solid state storage that plugs into DIMM slots</a>
because it is that friggin fast.</p>
<p>Today's storage hardware is capable of ludicrous performance. It is fast enough
that you will likely saturate multiple CPU cores processing the read or written
data coming from and going to storage - especially if you are using higher-level,
non-JITed (read: slower) programming languages (like Python). There has also been
a trend that systems are growing more CPU cores faster than they are instructions
per second per core. And SSDs only achieve these ridiculous IOPS numbers if many
I/O operations are <em>queued</em> and can be more efficiently dispatched within the
storage device. What this all means is that it probably makes sense to use
parallel I/O across multiple threads in order to extract all potential
performance from your persistent storage layer.</p>
<p>It's also worth noting that we now have solid state storage that outperforms (in
some dimensions) what DRAM from ~20 years ago was capable of. Put another way I/O
APIs and even some filesystems were designed in an era when its RAM was slower than
what today's persistent storage is capable of! While I'm no filesystems or kernel
expert, it does seem a bit silly to be using APIs and filesystems designed for an
era when storage was multiple orders of magnitude slower and systems only had a
single CPU core.</p>
<p>My takeaway is I can't help but feel that systems-level software (including the
kernel) is severely limiting the performance potential of modern storage
devices. If we have e.g. global kernel locks when performing common I/O operations,
there's no chance we'll come close to harnessing the full potential of today's
storage hardware. Furthermore, the behavior of filesystems is woefully under
documented and software developers have little solid advice for how to achieve
optimal I/O performance. As someone who cares about performance, I want to
squeeze every iota of potential out of hardware. But the lack of documentation
telling me which operations acquire locks, which strategies are best for say
reading or writing 10,000 files using N threads, etc makes this extremely
difficult. And even if this documentation existed, because of differences in
behavior across filesystems and operating systems and the difficulty in
programmatically determining the characteristics of filesystems at run time,
it is practically impossible to design a <em>one size fits all</em> approach to
high performance I/O.</p>
<p>The filesystem is a powerful concept. I want to agree and use the <em>everything is a
file</em> philosophy. Unfortunately, filesystems don't appear to be scaling very well
to support the potential of modern day storage technology. We're probably at the
point where commodity priced solid state storage is far more capable than today's
software for the majority of applications. Storage hardware manufacturers will
keep producing faster and faster storage and their marketing teams will keep
convincing us that we need to buy it. But until software catches up, chances are
most of us won't come close to realizing the true potential of modern storage
hardware. And that's even true for specialized applications that do employ tricks
taking hundreds or thousands of person hours to implement in order to eek out every
iota of performance potential. The average software developer and application
using filesystems as they were designed to be used has little to no chance of
coming close to utilizing the performance potential of modern storage devices.
That's really a shame. </p>]]></content:encoded>
    </item>
    <item>
      <title>Benefits of Clone Offload on Version Control Hosting</title>
      <link>http://gregoryszorc.com/blog/2018/07/27/benefits-of-clone-offload-on-version-control-hosting</link>
      <pubDate>Fri, 27 Jul 2018 15:48:00 PDT</pubDate>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2018/07/27/benefits-of-clone-offload-on-version-control-hosting</guid>
      <description>Benefits of Clone Offload on Version Control Hosting</description>
      <content:encoded><![CDATA[<p>Back in 2015, I implemented a feature in Mercurial 3.6 that allows
servers to advertise URLs of pre-generated <em>bundle</em> files. When a
compatible client performs a <code>hg clone</code> against a repository leveraging
this feature, it downloads and applies the bundle from a URL then goes
back to the server and performs the equivalent of an <code>hg pull</code> to obtain
the changes to the repository made after the bundle was generated.</p>
<p>On <a href="https://hg.mozilla.org/">hg.mozilla.org</a>, we've been using this
feature since 2015. We host bundles in Amazon S3 and make them available
via the CloudFront CDN. We perform
<a href="https://hg.mozilla.org/hgcustom/version-control-tools/file/99f7164339ed/hgext/hgmo/__init__.py#l1022">IP filtering on the server</a>
so clients connecting from AWS IPs are served S3 URLs corresponding to
the closest region / S3 bucket where bundles are hosted. Most
Firefox build and test automation is run out of EC2 and automatically
clones high-volume repositories from an S3 bucket hosted in the same
AWS region. (Doing an intra-region transfer is very fast and clones
can run at &gt;50 MB/s.) Everyone else clones from a CDN. See our
<a href="https://mozilla-version-control-tools.readthedocs.io/en/latest/hgmo/bundleclone.html">official docs</a>
for more.</p>
<p>I <a href="/blog/2015/10/22/cloning-improvements-in-mercurial-3.6/">last reported</a>
on this feature in October 2015. Since then, Bitbucket also
<a href="https://developer.atlassian.com/blog/2017/02/bitbucket-CDN-cloning/">deployed this feature</a>
in early 2017.</p>
<p>I was reminded of this <em>clone bundles</em> feature this week when
kernel.org posted
<a href="https://www.kernel.org/best-way-to-do-linux-clones-for-your-ci.html">Best way to do linux clones for your CI</a>
and that post was making the rounds in my version control circles.
tl;dr git.kernel.org apparently suffers high load due to high
clone volume against the Linux Git repository and since Git doesn't
have an equivalent feature to clone bundles built in to Git itself,
they are asking people to perform equivalent functionality to mitigate
server load.</p>
<p>(A <em>clone bundles</em> feature has been discussed on the Git mailing list
before. I remember finding old discussions when I was doing research
for Mercurial's feature in 2015. I'm sure the topic has come up since.)</p>
<p>Anyway, I thought I'd provide an update on just how valuable the
<em>clone bundles</em> feature is to Mozilla. In doing so, I hope maintainers
of other version control tools see the obvious benefits and consider
adopting the feature sooner.</p>
<p>In a typical week, hg.mozilla.org is currently serving ~135 TB of
data. The overwhelming majority of this data is related to the Mercurial
wire protocol (i.e. not HTML / JSON served from the web interface).
Of that ~135 TB, ~5 TB is served from the CDN, ~126 TB is served from
S3, and ~4 TB is served from the Mercurial servers themselves. In other
words, <strong>we're offloading ~97% of bytes served from the Mercurial servers
to S3 and the CDN</strong>.</p>
<p>If we assume this offloaded ~131 TB is equally distributed throughout
the week, this comes out to ~1,732 Mbps on average. In reality, we do
most of our load from California's Sunday evenings to early Friday
evenings. And load is typically concentrated in the 12 hours when
the sun is over Europe and North America (where most of Mozilla's
employees are based). So the typical throughput we are offloading is
more than 2 Gbps. And at a lower level, automation tends to perform
clones soon after a push is made. So load fluctuates significantly
throughout the day, corresponding to when pushes are made.</p>
<p>By volume, most of the data being offloaded is for the
<a href="https://hg.mozilla.org/mozilla-unified">mozilla-unified</a> Firefox
repository. Without clone bundles and without the special <em>stream
clone</em> Mercurial feature (which we also leverage via clone bundles), the
servers would be generating and sending ~1,588 MB of zstandard level 3
compressed data for each clone of that repository. Each clone would
consume ~280s of CPU time on the server. And at ~195,000 clones per
month, that would come out to ~309 TB/mo or ~72 TB/week. In CPU time,
that would be ~54.6 million CPU-seconds, or ~21 CPU-months. I will
leave it as an exercise to the reader to attach a dollar cost to how
much it would take to operate this service without clone bundles. But
I will say the total AWS bill for our S3 and CDN hosting for this
service is under $50 per month. (It is worth noting that intra-region
data transfer from S3 to other AWS services is free. And we are
definitely taking advantage of that.)</p>
<p>Despite a significant increase in the size of the Firefox repository and
clone volume of it since 2015, our servers are still performing less
work (in terms of bytes transferred and CPU seconds consumed) than they
were in 2015. The ~97% of bytes and millions of CPU seconds offloaded
in any given week have given us a lot of breathing room and have
saved Mozilla several thousand dollars in hosting costs. The feature
has likely helped us avoid many operational incidents due to high server
load. It has made Firefox automation faster and more reliable.</p>
<p>Succinctly, Mercurial's <em>clone bundles</em> feature has successfully and
largely effortlessly offloaded a ton of load from the hg.mozilla.org
Mercurial servers. Other version control tools should implement this
feature because it is a game changer for server operators <strong>and</strong>
results in a better client-side experience (eliminates server-side CPU
bottleneck and may eliminate network bottleneck due to a geo-local CDN
typically being as fast as your Internet pipe). It's a win-win. And a
massive win if you are operating at scale.</p>]]></content:encoded>
    </item>
    <item>
      <title>Deterministic Firefox Builds</title>
      <link>http://gregoryszorc.com/blog/2018/06/20/deterministic-firefox-builds</link>
      <pubDate>Wed, 20 Jun 2018 11:10:00 PDT</pubDate>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2018/06/20/deterministic-firefox-builds</guid>
      <description>Deterministic Firefox Builds</description>
      <content:encoded><![CDATA[<p>As of Firefox 60, the build environment for official Firefox Linux builds
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1399679">switched</a> from CentOS
to Debian.</p>
<p>As part of the transition, we overhauled how the build environment for
Firefox is constructed. We now populate the environment from deterministic
package snapshots and are much more stringent about dependencies and operations
being deterministic and reproducible. The end result is that the build
environment for Firefox is deterministic enough to enable Firefox itself
to be built deterministically.</p>
<p>Changing the underlying operating system environment used for builds was
a risky change. Differences in the resulting build could result in new
bugs or some users not being able to run the official builds. We figured
a good way to mitigate that risk was to make the old and new builds as
bit-identical as possible. After all, if the environments produce the same
bits, then nothing has effectively changed and there should be no new risk
for end-users.</p>
<p>Employing the <em>diffoscope</em> tool, we identified areas where Firefox builds
weren't deterministic in the same environment and where there was variance
across build environments. We iterated on differences and changed systems
so variance would no longer occur. By the end of the process, we had
bit-identical Firefox builds across environments.</p>
<p>So, as of Firefox 60, Firefox builds on Linux are deterministic in our
official build environment!</p>
<p>That being said, the builds we ship to users are using PGO. And an
end-to-end build involving PGO is intrinsically not deterministic because
it relies on timing data that varies from one run to the next. And we don't
yet have continuous automated end-to-end testing that determinism holds.
But the underlying infrastructure to support deterministic and reproducible
Firefox builds is there and is not going away. I think that's a milestone
worth celebrating.</p>
<p>This milestone required the effort of many people, often working indirectly
toward it. Debian's <a href="https://wiki.debian.org/ReproducibleBuilds">reproducible builds</a>
effort gave us an operating system that provided deterministic and
reproducible guarantees. Switching Firefox CI to Taskcluster enabled us
to switch to Debian relatively easily. Many were involved with
non-determinism fixes in Firefox over the years. But Mike Hommey drove the
transition of the build environment to Debian and he deserves recognition for
his individual contribution. Thanks to all these efforts - and especially Mike
Hommey's - we can now say <em>Firefox builds deterministically</em>!</p>
<p>The
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=885777">fx-reproducible-build</a> bug
tracks ongoing efforts to further improve the reproducibility story of
Firefox. (~300 bugs in its dependency tree have already been resolved!)</p>]]></content:encoded>
    </item>
  </channel>
</rss>
