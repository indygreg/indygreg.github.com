<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>Gregory Szorc's Digital Home</title>
    <link>http://gregoryszorc.com/blog</link>
    <description>Rambling on</description>
    <pubDate>Fri, 29 May 2015 18:33:21 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Faster Cloning from hg.mozilla.org With Server Provided Bundles</title>
      <link>http://gregoryszorc.com/blog/2015/05/29/faster-cloning-from-hg.mozilla.org-with-server-provided-bundles</link>
      <pubDate>Fri, 29 May 2015 11:30:00 PDT</pubDate>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2015/05/29/faster-cloning-from-hg.mozilla.org-with-server-provided-bundles</guid>
      <description>Faster Cloning from hg.mozilla.org With Server Provided Bundles</description>
      <content:encoded><![CDATA[<p>When you type <em>hg clone</em>, the Mercurial server will create a <em>bundle</em>
from repository content at the time of the request and stream it to
the client. (Git works essentially the same way.)</p>
<p>This approach usually <em>just works</em>. But there are some downsides,
particularly with large repositories.</p>
<p>Creating bundles for large repositories is not cheap. For
mozilla-central, Firefox's main repository, it takes ~280s of CPU time
on my 2014 MacBook Pro to generate a bundle. Every time a client runs a
<em>hg clone https://hg.mozilla.org/mozilla-central</em>, a server somewhere
is spinning a CPU core generating ~1.1 GB of data. What's more, if
another clone arrives at the same time, another process will perform
the exact same work! When we talk about multiple minutes of CPU time
per request, this extra work starts to add up.</p>
<p>Another problem with large repositories is interrupted downloads. If
you suffer a connectivity blip during your <em>clone</em> command, you'll
have to start from scratch. This potentially means re-transferring
hundreds of megabytes from the server. It also means the server has
to generate a new bundle, consuming even more CPU time. This is not
good for the user or the server.</p>
<p>There have been multiple outages of hg.mozilla.org as a result of
the service being flooded with clone requests to large repositories.
Dozens of clients (most of them in Firefox or Firefox OS
release automation) have cloned the same repository around the same
time and overwhelmed network bandwidth in the data center or CPU
cores on the Mercurial servers.</p>
<p>A common solution to this problem is to not use the <em>clone</em> command
to receive initial repository data from the server. Instead, a
static <em>bundle</em> file will be generated and made available to clients.
Clients will call <em>hg init</em> to create an empty repository then will
perform an <em>hg unbundle</em> to apply the contents of a pre-generated
bundle file. They will then run <em>hg pull</em> to fetch new data that
was created after the bundle was generated. (It's worth noting that
Git's <em>clone --reference</em> option is similar.)</p>
<p>This is a good technical solution. Firefox and Firefox OS release
automation have effectively implemented this. However, it is a lot of
work: you have to build your own bundle generation and hosting
infrastructure and you have to remember that every <em>hg clone</em> should
probably be using bundles instead. It is extra complexity and complexity
that must be undertaken by every client. If a client forgets, the
consequences can be disastrous (clone flooding leading to service
outage). Client-side opt-in is prone to lapses and doesn't scale.</p>
<p><strong>As of today, we've deployed a more scalable, server-based solution to
hg.mozilla.org.</strong></p>
<p>hg.mozilla.org is now itself generating bundles for a handful of
repositories, including mozilla-central, inbound, fx-team, and
mozharness. These bundles are being uploaded to Amazon S3. And
<strong>those bundles are being advertised by the server over Mercurial's
wire protocol</strong>.</p>
<p>When you install the <em>bundleclone</em> Mercurial extension, <em>hg clone</em> is
taught to look for bundles being advertised on the server. If a bundle
is available, the bundle is downloaded, applied, and then the client
does the equivalent of an <em>hg pull</em> to fetch all new data since when the
bundle was generated. If a bundle exists, it is used transparently: no
client side cooperation is needed beyond installing the <em>bundleclone</em>
extension. If a bundle doesn't exist, it simply falls back to
Mercurial's default behavior. <strong>This effectively shifts responsibility
for doing efficient clones from clients to server operators, which
means server operators don't need cooperation from clients to enact
important service changes.</strong> Before, if clients weren't using bundles,
we'd have to wait for clients to update their code. Now, we can see
a repository is being cloned heavily and start generating bundles for
it without having to wait for the client to deploy new code.</p>
<p>Furthermore, we've built primitive <em>content negotiation</em> into the
process. The server doesn't simply advertise one bundle file: it
advertises several bundle files. We offer gzip, bzip2, and <em>stream</em>
bundles. gzip is what Mercurial uses by default. It works OK. bzip2
bundles are smaller, but they take longer to process. <em>stream</em> bundles
are essentially tar archives of the <em>.hg/store</em> directory and are larger
than gzip bundles, but insanely fast because there is very little CPU
required to apply them. In addition, we advertise URLs for multiple S3
regions, currently us-west-2 (Oregon) and us-east-1 (Virigina). This
enables clients to prefer the bundle most appropriate for them.</p>
<p>A benefit of serving bundles from S3 is that Firefox and Firefox OS
release automation (the biggest consumers of hg.mozilla.org) live in
Amazon EC2. They are able to fetch from S3 over a gigabit network.
And, since we're transferring data within the same AWS region, there
are no data transfer costs. Previously, we were transferring ~1.1 GB
from a Mozilla data center to EC2 for each clone. This took up bandwidth
in Mozilla's network and cost Mozilla money to send data thousands of
miles away. And, we never came close to saturating a gigabit network (we
do with stream bundles). Wins everywhere!</p>
<p>The <a href="https://mozilla-version-control-tools.readthedocs.org/en/latest/hgmo/bundleclone.html">full instructions</a>
detail how to use <em>bundleclone</em>. <strong>I recommend everyone at Mozilla
install the extension</strong> because there should be no downside to doing it.</p>
<p>Once <em>bundleclone</em> is deployed to Firefox and Firefox OS release
automation, we should hopefully never again see those machines bring
down hg.mozilla.org due to a flood of clone requests. We should also
see a drastic reduction in load to hg.mozilla.org. I'm optimistic
bandwidth will decrease by over 50%!</p>
<p>It's worth noting that the functionality from the <em>bundleclone</em> extension
is coming to vanilla Mercurial. The functionality (which was initially
added by Mozilla's Mike Hommey) is part of Mercurial's <em>bundle2</em> protocol,
which is available, but isn't enabled by default yet. <em>bundleclone</em> is thus
a temporary solution to bring us server stability and client
improvements until modern Mercurial versions are deployed everywhere
in a few months time.</p>
<p>Finally, I would like to credit Augie Fackler for the
<a href="http://thread.gmane.org/gmane.comp.version-control.mercurial.devel/54872/focus=54872">original idea</a>
for server-assisted bundle-based clones.</p>]]></content:encoded>
    </item>
    <item>
      <title>Firefox Mercurial Repository with CVS History</title>
      <link>http://gregoryszorc.com/blog/2015/05/18/firefox-mercurial-repository-with-cvs-history</link>
      <pubDate>Mon, 18 May 2015 08:40:00 PDT</pubDate>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2015/05/18/firefox-mercurial-repository-with-cvs-history</guid>
      <description>Firefox Mercurial Repository with CVS History</description>
      <content:encoded><![CDATA[<p>When Firefox made the switch from CVS to Mercurial in March 2007, the
CVS history wasn't imported into Mercurial. There were good reasons for
this at the time. But it's a decision that continues to have
side-effects. I am surprised how often I hear of engineers wanting to
access blame and commit info from commits now more than 9 years old!</p>
<p>When individuals created a Git mirror of the Firefox repository a few
years ago, they correctly decided that importing CVS history would be
a good idea. They also correctly decided to combine the logically same
but physically separate <em>release</em> and <em>integration</em> repositories into a
unified Git repository. These are things we can't easily do to the
canonical Mercurial repository because it would break SHA-1 hashes,
breaking many systems, and it would require significant changes in
process, among other reasons.</p>
<p>While Firefox developers do have access to a single Firefox repository
with full CVS history (the Git mirror), they still aren't satisfied.</p>
<p>Running <em>git blame</em> (or <em>hg blame</em> for that matter) can be very
expensive. For this reason, the blame interface is disabled on many
web-based source viewers by default. On GitHub, some blame URLs for
the Firefox repository time out and cause GitHub to display an error
message. No matter how hard you try, you can't easily get blame results
(running a local Git HTTP/HTML interface is still difficult compared to
<em>hg serve</em>).</p>
<p>Another reason developers aren't satisfied with the Git mirror is that
Git's querying tools pale in comparison to Mercurial's. I've said it
before and I'll say it again: Mercurial's revision sets and templates
are incredibly useful features that enable advanced repository querying
and reporting. Git's offerings come nowhere close. (I <em>really</em> wish Git
would steal these awesome features from Mercurial.)</p>
<p>Anyway, enough people were complaining about the lack of a Mercurial
Firefox repository with full CVS history that I decided to create one.
If you point your browsers or Mercurial clients to
<a href="https://hg.mozilla.org/users/gszorc_mozilla.com/gecko-full">https://hg.mozilla.org/users/gszorc_mozilla.com/gecko-full</a>,
you'll be able to access it.</p>
<p>The process used for the conversion was the simplest possible: I used
hg-git to convert the Git mirror back to Mercurial.</p>
<p>Unlike the Git mirror, I didn't include all heads in this new
repository. Instead, there is only mozilla-central's head (the current
development tip). If I were doing this properly, I'd include all heads,
like
<a href="https://hg.mozilla.org/users/gszorc_mozilla.com/gecko-aggregate">gecko-aggregate</a>.</p>
<p>I'm well aware there are oddities in the Git mirror and they now
exist in this new repository as well. My goal for this conversion was to
deliver something: it wasn't a goal to deliver the most correct result
possible.</p>
<p>At this time, this repository should be considered an unstable science
experiment. <strong>By no means should you rely on this repository.</strong> But if
you find it useful, I'd appreciate hearing about it. If enough people
ask, we could probably make this more official.</p>]]></content:encoded>
    </item>
    <item>
      <title>Notes from Git Merge 2015</title>
      <link>http://gregoryszorc.com/blog/2015/05/12/notes-from-git-merge-2015</link>
      <pubDate>Tue, 12 May 2015 15:40:00 PDT</pubDate>
      <category><![CDATA[Git]]></category>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2015/05/12/notes-from-git-merge-2015</guid>
      <description>Notes from Git Merge 2015</description>
      <content:encoded><![CDATA[<p><a href="http://git-merge.com/">Git Merge 2015</a> was a Git user conference held
in Paris on April 8 and 9, 2015.</p>
<p>I'm kind of a version control geek. I'm also responsible for a large
part of Mozilla's version control hosting. So, when the videos were
made public, you can bet I took interest.</p>
<p>This post contains my notes from a few of the Git Merge talks. I try
to separate content/facts from my opinions by isolating my opinions
(within parenthesis).</p>
<h2>Git at Google</h2>
<p><a href="http://git-merge.com/videos/git-at-google-dave-borowitz.html">Git at Google: Making Big Projects (and everyone else) Happy</a>
is from a Googler (Dave Borowitz) who works on JGit for the Git
infrastructure team at Google.</p>
<p>"Everybody in this room is going to feel some kind of pain working with
Git at scale at some time in their career."</p>
<p>First Git usage at Google in 2008 for Android. 2011 googlesource.com
launches.</p>
<p>24,000 total Git repos at Google. 77.1M requests/day. 30-40 TB/day. 2-3
Gbps.</p>
<p>Largest repo is 210GB (not public it appears).</p>
<p>800 repos in AOSP. Google maintains internal fork of all Android repos
(so they can throw stuff over the wall). Fresh AOSP tree is 17 GiB. Lots
of contracts dictating access.</p>
<p>Chrome repos include Chromium, Blink, Chromium OS. Performed giant
Subversion migration. Developers of Chrome very set in their ways. Had
many workflows integrated with Subversion web interface. Subversion
blame was fast, Git blame slow. Built caching backend for Git blame to
make developers happy.</p>
<p>Chromium 2.9 GiB, 3.6M objects, 390k commits. Blink 5.3 GiB, 3.1M
objects, 177k commits. They merged them into a monorepo. Mention of
Facebook's monorepo talk and Mercurial scaling efforts for a repo larger
then Chromium/Blink monorepo. Benefits to developers for doing atomic
refactorings, etc.</p>
<p>"Being big is hard."</p>
<p>AOSP: 1 Gbps -&gt; 2 minutes for 17 GiB. 20 Mbps -&gt; 3 hours. Flaky internet
combined with non-resumable clone results in badness. Delta resolution
can take a while. Checkout of hundreds of thousands of files can be
slow, especially on Windows.</p>
<p>"As tool developers... it's hard to tell people don't check in large
binaries, do things this way, ... when all they are trying to do is
get their job done." (I couldn't agree more: tools should ideally not
impose sub-optimal workflows.)</p>
<p>They prefer scaling pain to supporting multiple tools. (I think this
meant don't use multiple VCSs if you can just make one scale.)</p>
<p>Shallow clone beneficial. But some commands don't work. log not very
useful.</p>
<p>Narrow clones mentioned. Apparently talked about elsewhere at Git Merge
not captured on video. Non-trivial problem for Git. "We have no idea
when this is going to happen."</p>
<p>Split repos until narrow clone is available. Google wrote repo to manage
multiple repos. They view repo and multiple repos as stop-gap until
narrow clone is implemented.</p>
<p>git submodule needs some love. Git commands don't handle submodules
or multiple repos very well. They'd like to see repo features
incorporated into git submodule.</p>
<p>Transition to server operation.</p>
<p>Pre-2.0, counting objects was hard. For Linux kernel, 60s 100% CPU time
per clone to count objects. "Linux isn't even that big."</p>
<p>Traditionally Git is single homed. Load from users. Load from
automation.</p>
<p>Told anecdote about how Google's automation once recloned the repo after
a failed Git command. Accidentally made a change one day that caused a
command to persistently fail. DoS against server. (We've had this at
Mozilla.)</p>
<p>Garbage collection on server is CPU intensive and necessary. Takes cores
away from clients.</p>
<p>Reachability bitmaps implemented in JGit, ported to Git 2.0. Counting
objects for Linux clones went from 60s CPU to ~100ms.</p>
<p>Google puts static, pre-generated bundles on a CDN. Client downloads
bundle then does incremental fetch. Massive reduction in server load.
Bundle files better for users. Resumable.</p>
<p>They have ideas for integrating bundles into git fetch, but it's
"a little way's off." (This feature is partially implemented in
Mercurial 3.4 and we have plans for using it at Mozilla.) It's feature
in repo today.</p>
<p>Shared filesystem would be really nice to spread CPU load. NFS "works."
Performance problems with high throughput repositories.</p>
<p>Master-mirror replication can help. Problems with replication lag.
Consistency is hard.</p>
<p>Google uses a distributed Git store using Bigtable and GFS built on
JGit. Git-aware load balancer. Completely separate pool of garbage
collection workers. They do replication to multiple datacenters before
pushes. 6 datacenters across world. Some of their stuff is open source.
A lot isn't.</p>
<p>Humans have difficulty managing hundreds of repositories. "How do you as
a human know what you need to modify?" Monorepos have this problem too.
Inherent with lots of content. (Seemed to imply it is worse with
multiple repos than with a monorepo.)</p>
<p>Porting changes between forks is hard. e.g. cherry picking between
internal and external Android repos.</p>
<p>ACLs are a mess.</p>
<p>Google built Gerrit code review. It does ACLs, auto rebasing, release
branch management. It's a swiss army knife. (This aligns with my
vision for MozReview and code-centric development.)</p>
<h2>Scaling Git at Twitter</h2>
<p>Wilhelm Bierbaum from Twitter talks about
<a href="http://git-merge.com/videos/scaling-git-at-twitter-wilhelm-bierbaum.html">Scaling Git at Twitter</a>.</p>
<p>"We've decided it's really important to make Twitter a good place to work for
developers. Source control is one of those points where we were
lacking. We had some performance problems with Git in the past."</p>
<p>Twitter runs a monorepo. Used to be 3 repos. "Working with a single
repository is the way they prefer to develop software when developing
hundreds of services." They also have a single build system. They have
a geo diverse workforce.</p>
<p>They use normal canonical implementation of Git + some optimizations.</p>
<p>Benefits of a monorepo:</p>
<p>Visibility. Easier for people to find code in one repo. Code search tools
tailored towards single repos.</p>
<p>Single toolchain. single set of tools to build, test, and deploy. When
improvements to tools made, everyone benefits because one toolchain.</p>
<p>Easy to share code (particularly generated code like IDL). When operating
many small services, services developed together. Code duplication is
minimized. Twitter relies on IDL heavily.</p>
<p>Simpler to predict the impact of your changes. Easier to look at single
code base then to understand how multiple code bases interact. Easy to
make a change and see what breaks rather than submit changes to N repos
and do testing in N repos.</p>
<p>Makes refactoring less arduous.</p>
<p>Surfaces architecture issues earlier.</p>
<p>Breaking changes easier to coordinate</p>
<p>Drawbacks of monorepos:</p>
<p>Large disk footprint for full history.</p>
<p>Tuning filesystem only goes so far.</p>
<p>Forces some organizations to adopt sparse checkouts and shallow clones.</p>
<p>Submodules aren't good enough to use. <em>add</em> and <em>commit</em> don't recognize
submodule boundaries very well and aren't very usable.</p>
<p>"To us, using a tool such as repo that is in effect a secondary version
control tool on top of Git does not feel right and doesn't lead to a
fluid experience."</p>
<p>Twitter has centralized use of Git. Don't really benefit from
distributed version control system. Feature branches. Goal is to live as
close to master as possible. Long-running branches discouraged. Fewer
conflicts to resolve.</p>
<p>They have project-level ownership system. But any developer can change
anything.</p>
<p>They have lots of read-only replicas. Highly available writable server.</p>
<p>They use reference repos heavily so object exchange overhead is
manageable.</p>
<p>Scaling issues with many refs. Partially due to how refs are stored on
disk. File locking limits in OS. Commands like status, add, and commit
can be slow, even with repo garbage collected and packed. Locking issues
with garbage collection.</p>
<p>Incorporated file alteration monitor to make status faster. Reference to
Facebook's work on watchman and its Mercurial integration. Significant
impact on OS X. "Pretty much all our developers use OS X." (I assume
they are using Watchman with Git - I've seen patches for this on the Git
mailing list but they haven't been merged into core yet.)</p>
<p>They implemented a custom index format. Adopted faster hashing
algorithm that uses native instructions.</p>
<p>Discovery with many refs didn't scale. 13 MB of raw data for refs
exchange at Twitter. (!!) Experimenting with clients sending a bloom
filter of refs. Hacked it together via HTTP header.</p>
<p>Fetch protocol is expensive. Lots of random I/O. Can take minutes
to do incremental fetches. Bitmap indices help, but aren't good enough
for them. Since they have central and well-defined environment, they
changed fetch protocol to work like a journal: send all changed data since
client's last fetch. Server work is essentially a sendfile system call.
git push appends push packs to a log-structured journal. On fetch,
clients "replay" the transactions from the journal. Similar to MySQL
binary log replication. (This is very similar to some of the Mercurial
replication work I'm doing at Mozilla. Yay technical validation.)
(Append only files are also how Mercurial's storage model works by
default.)</p>
<p>Log-structured data exchange means server side is cheap. They can insert
HTTP caches to handle Range header aware requests.</p>
<p>Without this hack, they can't scale their servers.</p>
<p>Initial clone is seeded by BitTorrent.</p>
<p>It sounds like everyone's unmerged feature branches are on the one
central repo and get transferred everywhere by default. Their journal
fetch can selectively fetch refs so this isn't a huge problem.</p>
<p>They'd like to experiment with sparse repos. But they haven't gotten to
that yet. They'd like a better storage abstraction in Git to enable
necessary future scalability. They want a network-aware storage backend.
Local objects not necessary if the network has them.</p>
<p>They are running a custom Git distribution/fork on clients. But they
don't want to maintain forever. Prefer to send upstream.</p>]]></content:encoded>
    </item>
    <item>
      <title>Dropping Explicit Support for Mercurial 3.0</title>
      <link>http://gregoryszorc.com/blog/2015/05/07/dropping-explicit-support-for-mercurial-3.0</link>
      <pubDate>Thu, 07 May 2015 16:05:00 PDT</pubDate>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2015/05/07/dropping-explicit-support-for-mercurial-3.0</guid>
      <description>Dropping Explicit Support for Mercurial 3.0</description>
      <content:encoded><![CDATA[<p>As of a few minutes ago, we explicitly dropped support for Mercurial 3.0
for all the Mercurial code in the
<a href="https://hg.mozilla.org/hgcustom/version-control-tools">version-control-tools</a>
repository. File issues in
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1162304">bug 1162304</a>.</p>
<p>Code may still work against Mercurial 3.0. But it isn't supported and
could break hard at any time.</p>
<p>Supporting multiple versions of <em>any</em> software carries
with it some cost. The people writing tooling around Mercurial are busy.
It is a waste of our time to bend over backwards to support old versions
of software that <strong>all</strong> users should have upgraded from months ago.
Still using older Mercurial versions means you aren't getting the best
performance and may encounter bugs that have since been fixed.</p>
<p>See the <a href="https://mozilla-version-control-tools.readthedocs.org/en/latest/hgmozilla/installing.html">Mozilla tailored Mercurial installation instructions</a>
for info on how to upgrade to the latest/greatest Mercurial version.</p>]]></content:encoded>
    </item>
    <item>
      <title>Reporting Mercurial Issues</title>
      <link>http://gregoryszorc.com/blog/2015/05/04/reporting-mercurial-issues</link>
      <pubDate>Mon, 04 May 2015 13:45:00 PDT</pubDate>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2015/05/04/reporting-mercurial-issues</guid>
      <description>Reporting Mercurial Issues</description>
      <content:encoded><![CDATA[<p>I semi-frequently stumble upon conversations in hallways and
on irc.mozilla.org about issues people are having with Mercurial.
These conversations periodically involve a legitimate bug with
Mercurial. Unfortunately, these conversations frequently end
without an actionable result. Unless someone files a bug, pings me,
etc, the complaints disappear into ether. That's not good for
anyone and only results in bugs living longer than they should.</p>
<p>There are posters around Mozilla offices that say
<em>if you see something, file something.</em> This advice does not just
apply to Mozilla projects!</p>
<p><strong>If you encounter an issue in Mercurial, please take the time
to report it somewhere meaningful.</strong> The
<a href="https://mozilla-version-control-tools.readthedocs.org/en/latest/hgmozilla/issues.html">Reporting Issues with Mercurial</a>
page from the
<a href="https://mozilla-version-control-tools.readthedocs.org/en/latest/hgmozilla/index.html">Mercurial for Mozillians</a>
guide tells you how to do this.</p>
<p>It is OK to complain about something. But if you don't inform
someone empowered to do something about it, you are part of the
problem without being part of the solution. Please make the
incremental effort to be part of the solution.</p>]]></content:encoded>
    </item>
    <item>
      <title>Mercurial 3.4 Released</title>
      <link>http://gregoryszorc.com/blog/2015/05/04/mercurial-3.4-released</link>
      <pubDate>Mon, 04 May 2015 12:40:00 PDT</pubDate>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2015/05/04/mercurial-3.4-released</guid>
      <description>Mercurial 3.4 Released</description>
      <content:encoded><![CDATA[<p>Mercurial 3.4 was released on May 1 (following Mercurial's time-based
schedule of releasing a new version every 3 months).</p>
<p>3.4 is a significant release for a few reasons.</p>
<p>First, the next version of the wire protocol (<em>bundle2</em>) has been
marked as non-experimental on servers. This version of the protocol
paves over a number of deficiencies in the classic protocol. I won't
go into low-level details. But I will say that the protocol enables
some rich end-user experiences, such as having the server hand out URLs
for pre-generated bundles (e.g. offload clones to S3), atomic push
operations, and advanced workflows, such as having the server rebase
automatically on push. Of course, you'll need a server running 3.4
to realize the benefits of the new protocol. hg.mozilla.org won't be
updated until at least June 1.</p>
<p>Second, Mercurial 3.4 contains improvements to the tags cache to make
performance concerns a thing of the past. Due to the structure of the
Firefox repositories, the previous implementation of the tags cache
could result in pauses of dozens of seconds during certain workflows.
The problem should go away with Mercurial 3.4. <strong>Please note that on
first use of Mercurial 3.4, your repository may perform a one-time
upgrade of the tags cache. This will spin a full CPU core and will
take up to a few minutes to complete on Firefox repos. Let it run to
completion and performance should not be an issue again.</strong> I wrote the
patches to change the tags cache (with lots of help from Pierre-Yves
David, a Mercurial core contributor). So if you find anything wrong,
I'm the one to complain to.</p>
<p>Third, the HTTP interface to Mercurial (hgweb) now has JSON output
for nearly every endpoint. The implementation isn't yet complete,
but it is better than nothing. But, it should be good enough for
services to start consuming it. Again, this won't be available on
hg.mozilla.org until the server is upgraded on June 1 at the earliest.
This is a feature I added to core Mercurial. If you have feature
requests, send them my way.</p>
<p>Fourth, a number of performance regressions introduced in Mercurial
3.3 were addressed. These performance issues frequently manifested
during <em>hg blame</em> operations. Many Mozillians noticed them on
hg.mozilla.org when looking at blame through the web interface.</p>
<p>For a more comprehensive list of changes, see
<a href="https://groups.google.com/d/msg/mozilla.dev.version-control/z4aWvBoAGYw/d0hUGKJU_psJ">my post about the 3.4 RC</a>
and the
<a href="http://mercurial.selenic.com/wiki/WhatsNew#Mercurial_3.4_.282015-05-01.29">official release notes</a>.</p>
<p>3.4 was a significant release. There are compelling reasons to upgrade.
That being said, there were a lot of changes in 3.4. If you want to wait
until 3.4.1 is released (scheduled for June 1) so you don't run into
any regressions, nobody can fault you for that.</p>
<p>If you want to upgrade, I recommend reading the
<a href="https://mozilla-version-control-tools.readthedocs.org/en/latest/hgmozilla/installing.html">Mercurial for Mozillians Installation Page</a>.</p>]]></content:encoded>
    </item>
    <item>
      <title>Automatically Redirecting Mercurial Pushes</title>
      <link>http://gregoryszorc.com/blog/2015/04/30/automatically-redirecting-mercurial-pushes</link>
      <pubDate>Thu, 30 Apr 2015 12:30:00 PDT</pubDate>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2015/04/30/automatically-redirecting-mercurial-pushes</guid>
      <description>Automatically Redirecting Mercurial Pushes</description>
      <content:encoded><![CDATA[<p>Managing URLs in distributed version control tools can be a pain,
especially if multiple repositories are involved. For example,
with Mozilla's repository-based code review workflow (you push to a
special review repository to initiate code review - this is conceptually
similar to GitHub pull requests), there exist
<a href="https://reviewboard-hg.mozilla.org/">separate code review repositories</a>
for each logical repository. Figuring out how repositories map to each
other and setting up remote paths for each new clone can be a pain and
time sink.</p>
<p>As of today, we can now do something better.</p>
<p>If you push to <em>ssh://reviewboard-hg.mozilla.org/autoreview</em>,
Mercurial will automatically figure out the appropriate review
repository and redirect your push automatically. In other words, if we
have <a href="https://reviewboard.mozilla.org/">MozReview</a> set up to review
whatever repository you are working on,
your push and review request will automatically go through. No need to
figure out what the appropriate review repo is or configure
repository URLs!</p>
<p>Here's what it looks like:</p>
<div class="pygments_murphy"><pre>$ hg push review
pushing to ssh://reviewboard-hg.mozilla.org/autoreview
searching for appropriate review repository
redirecting push to ssh://reviewboard-hg.mozilla.org/version-control-tools/
searching for changes
remote: adding changesets
remote: adding manifests
remote: adding file changes
remote: added 1 changesets with 1 changes to 1 files
remote: Trying to insert into pushlog.
remote: Inserted into the pushlog db successfully.
submitting 1 changesets for review

changeset:  11043:b65b087a81be
summary:    mozreview: create per-commit identifiers (bug 1160266)
review:     https://reviewboard.mozilla.org/r/7953 (draft)

review id:  bz://1160266/gps
review url: https://reviewboard.mozilla.org/r/7951 (draft)
(visit review url to publish this review request so others can see it)
</pre></div>

<p>Read the <a href="https://mozilla-version-control-tools.readthedocs.org/en/latest/mozreview/install.html#review-repositories">full instructions</a>
for more details.</p>
<p>This requires an updated <a href="https://hg.mozilla.org/hgcustom/version-control-tools/">version-control-tools</a>
repository, which you can get by running <em>mach mercurial-setup</em> from a
Firefox repository.</p>
<p>For those that are curious, the <em>autoreview</em> repo/server advertises a list
of repository URLs and their root commit SHA-1. The client automatically
sends the push to a URL sharing the same root commit. The
<a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/0b02cd388590">code</a>
is quite simple.</p>
<p>While this is only implemented for MozReview, I could envision us doing
something similar for other centralized repository-centric services, such
as <em>Try</em> and <em>Autoland</em>. Stay tuned.</p>]]></content:encoded>
    </item>
    <item>
      <title>My Current Thoughts on System Administration</title>
      <link>http://gregoryszorc.com/blog/2015/04/17/my-current-thoughts-on-system-administration</link>
      <pubDate>Fri, 17 Apr 2015 15:35:00 PDT</pubDate>
      <category><![CDATA[sysadmin]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2015/04/17/my-current-thoughts-on-system-administration</guid>
      <description>My Current Thoughts on System Administration</description>
      <content:encoded><![CDATA[<p>I attended PyCon last week. It's a great conference. You should attend.
While I should write up a detailed trip report, I wanted to quickly
share one of my takeaways.</p>
<p><a href="http://www.ansible.com/home">Ansible</a> was talked about a lot at PyCon.
Sitting through a few presentations and talking with others helped me
articulate why I've been drawn to Ansible (over say Puppet, Chef, Salt,
etc) lately.</p>
<p>First, Ansible doesn't require a central server. Administration is done
remotely Ansible establishes a SSH connection to a remote machine and
does stuff. Having Ruby, Python, support libraries, etc installed on
production systems just for system administration never really jived
with me. I love Ansible's default hands off approach. (Yes, you can use
a central server for Ansible, but that's not the default behavior. While
tools like Puppet could be used without a central server, it felt like
they were optimized for central server use and thus local mode felt
awkward.)</p>
<p>Related to central servers, I never liked how that model consists of
clients periodically polling for and applying updates. I like the idea
of immutable server images and periodic updates work against this goal.
The central model also has a major bazooka pointed at you: at any time, you
are only one mistake away from completely hosing every machine doing
continuous polling. e.g. if you accidentally update firewall configs and
lock out central server and SSH connectivity, every machine will pick up
these changes during periodic polling and by the time anyone realizes
what's happened, your machines are all effectively bricked. (Yes, I've
seen this happen.) I like having humans control exactly when my systems
apply changes, thank you. I concede periodic updates and central control
have some benefits.</p>
<p>Choosing not to use a central server by default means that hosts are
modeled as a set of applied Ansible playbooks, not necessarily as a host
with a set of Ansible playbooks attached. Although, Ansible does support
both models. I can easily apply a playbook to a host in a one-off
manner. This means I can have playbooks represent common, one-off tasks
and I can easily run these tasks without having to muck around with the
host to playbook configuration. More on this later.</p>
<p>I love the simplicity of Ansible's configuration. It is just YAML files.
Not some Ruby-inspired DSL that takes hours to learn. With Ansible, I'm
learning what modules are available and how they work, not complicated
syntax. Yes, there is complexity in Ansible's configuration. But at
least I'm not trying to figure out the file syntax as part of learning
it.</p>
<p>Along that vein, I appreciate the readability of Ansible playbooks.
They are simple, linear lists of tasks. Conceptually, I love the promise
of full dependency graphs and concurrent execution. But I've spent hours
debugging race conditions and cyclic dependencies in Puppet that I'm left
unconvinced the complexity and power is worth it. I do wish Ansible
could run faster by running things concurrently. But I think they made
the right decision by following KISS.</p>
<p>I enjoy how Ansible playbooks are effectively high-level scripts. If I
have a shell script or block of code, I can usually port it to Ansible
pretty easily. One pass to do the conversion 1:1. Another pass to
Ansibilize it. Simple.</p>
<p>I love how Ansible playbooks can be checked in to source control and
live next to the code and applications they manage. I frequently see
people maintain separate source control repositories for configuration
management from the code it is managing. This always bothered me. When I
write a service, I want the code for deploying and managing that service
to live next to it in version control. That way, I get the configuration
management and the code versioned in the same timeline. If I check out a
release from 2 years ago, I should still be able to use its exact
configuration management code. This becomes difficult to impossible when
your organization is maintaining configuration management code in a
separate repository where a central server is required to do
deployments (see Puppet).</p>
<p>Before PyCon, I was having an internal monolog about adopting the policy
that all changes to remote servers be implemented with Ansible
playbooks. I'm pleased to report that a fellow contributor to the
Mercurial project has adopted this workflow himself and he only has
great things to say! So, starting today, I'm going to try to enforce
that every change I make to a remote server is performed via Ansible and
that the Ansible playbooks are checked into version control. The Ansible
playbooks will become implicit documentation of every process involved
with maintaining a server.</p>
<p>I've already applied this principle to deploying MozReview. Before,
there was some internal Mozilla wiki documenting commands to execute in
a terminal to deploy MozReview. I have replaced that documentation with
a one-liner that invokes Ansible. And, the Ansible files are now
<a href="https://hg.mozilla.org/hgcustom/version-control-tools/file/1e85a23c4175/ansible">in a public repository</a>.</p>
<p>If you poke around that repository, you'll see that I have Ansible
playbooks referencing Docker. I have Ansible provisioning Docker images
used by the test and development environment. That same Ansible code
is used to configure our production systems (or is at least in the
process of being used in that way). Having dev, test, and prod using the
same configuration management has been a pipe dream of mine and I
finally achieved it! I attempted this before with Puppet but was unable
to make it work just right. The flexibility that Ansible's design
decisions have enabled has made this finally possible.</p>
<p>Ansible is my go to system management tool right now. And I still feel
like I have a lot to learn about its hidden powers.</p>
<p>If you are still using Puppet, Chef, or other tools invented in previous
generations, I urge you to check out Ansible. I think you'll be
pleasantly surprised.</p>]]></content:encoded>
    </item>
    <item>
      <title>Notes from Facebook's Developer Infrastructure at Scale F8 Talk</title>
      <link>http://gregoryszorc.com/blog/2015/03/28/notes-from-facebook's-developer-infrastructure-at-scale-f8-talk</link>
      <pubDate>Sat, 28 Mar 2015 11:45:00 PDT</pubDate>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2015/03/28/notes-from-facebook's-developer-infrastructure-at-scale-f8-talk</guid>
      <description>Notes from Facebook's Developer Infrastructure at Scale F8 Talk</description>
      <content:encoded><![CDATA[<p>Any time Facebook talks about technical matters I tend to listen.
They have a track record of demonstrating engineering leadership
in several spaces. And, unlike many companies that just talk, Facebook
often gives others access to those ideas via source code and healthy
open source projects. It's rare to see a company operating on the
frontier of the computing field provide so much insight into their
inner workings. You can gain so much by riding their cotails and
following their lead instead of clinging to and cargo culting from
the past.</p>
<p>The Facebook F8 developer conference was this past week. All the
talks are <a href="https://developers.facebooklive.com/">now available online</a>.
<strong>I encourage you to glimpse through the list of talks and watch
whatever is relevant to you.</strong> There's really a little bit for
everyone.</p>
<p>Of particular interest to me is the
<a href="https://developers.facebooklive.com/videos/561/big-code-developer-infrastructure-at-facebook-s-scale">Big Code: Developer Infrastructure at Facebook's Scale</a>
talk. This is highly relevant to my job role as Developer Productivity
Engineer at Mozilla.</p>
<p>My notes for this talk follow.</p>
<p><strong>"We don't want humans waiting on computers. We want computers waiting
on humans."</strong> (This is the common theme of the talk.)</p>
<p>In 2005, Facebook was on Subversion. In 2007 moved to Git. Deployed
a bridge so people worked in Git and had distributed workflow but
pushed to Subversion under the hood.</p>
<p>New platforms over time. Server code, iOS, Android. One Git repo
per platform/project -&gt; 3 Git repos. Initially no code sharing, so
no problem. Over time, code sharing between all repos. Lots of code
copying and confusion as to what is where and who owns what.</p>
<p>Facebook is mere weeks away from completing their migration to
consolidate the big three repos to a Mercurial monorepo. (See also
<a href="/blog/2014/09/09/on-monolithic-repositories/">my post about monorepos</a>.)</p>
<p>Reasons:</p>
<ol>
<li>Easier code sharing.</li>
<li>Easier large-scale changes. Rewrite the universe at once.</li>
<li>Unified set of tooling.</li>
</ol>
<p>Facebook employees run &gt;1M source control commands per day. &gt;100k
commits per week. VCS tool needs to be fast to prevent distractions
and context switching, which slow people down.</p>
<p>Facebook implemented sparse checkout and shallow history in Mercurial.
Necessary to scale distributed version control to large repos.</p>
<p><strong>Quote from Google: "We're excited about the work Facebook is doing with
Mercurial and glad to be collaborating with Facebook on Mercurial
development."</strong> (Well, I guess the cat is finally out of the bag:
Google is working on Mercurial. This was kind of an open secret for
months. But I guess now it is official.)</p>
<p>Push-pull-rebase bottleneck: if you rebase and push and someone beats
you to it, you have to pull, rebase, and try again. This gets worse
as commit rate increases and people do needless legwork. <strong>Facebook
has moved to server-side rebasing on push</strong> to mostly eliminate this
pain point. (This is part of a still-experimental feature in Mercurial,
which should hopefully lose its experimental flag soon.)</p>
<p>Starting 13:00 in we have a speaker change and move away from version
control.</p>
<p>IDEs don't scale to Facebook scale. <strong>"Developing in Xcode at Facebook
is an exercise in frustration."</strong> On average 3.5 minutes to open
Facebook for iOS in Xcode. 5 minutes on average to index. Pegs CPU
and makes not very responsive. 50 Xcode crashes per day across all
Facebook iOS developers.</p>
<p><strong>Facebook measures everything about tools. Mercurial operation times.
Xcode times. Build times. Data tells them what tools and workflows
need to be worked on.</strong></p>
<p>Facebook believes IDEs are worth the pain because they make people
more productive.</p>
<p>Facebook wants to support all editors and IDEs since people want to
use whatever is most comfortable.</p>
<p>React Native changed things. Supported developing on multiple
platforms, which no single IDE supports. People launched several
editors and tools to do React Native development. People needed 4
windows to do development. That experience was "not acceptable."
So they built their own IDE. Set of plugins on top of ATOM. Not
a fork. They like hackable and web-y nature of ATOM.</p>
<p>The demo showing iOS development looks very nice! Doing Objective-C,
JavaScript, simulator integration, and version control in one window!</p>
<p>It can connect to remote servers and transparently save and
deploy changes. It can also get real-time compilation errors and hints
from the remote server! (Demo was with Hack. Not sure if others langs
supported. Having beefy central servers for e.g. Gecko development
would be a fun experiment.)</p>
<p>Starting at 32:00 presentation shifts to continuous integration.</p>
<p>Number one goal of CI at Facebook is developer efficiency. <strong>We
don't want developers waiting on computers to build and test diffs.</strong></p>
<p>3 goals for CI:</p>
<ol>
<li>High-signal feedback. Don't want developers chasing failures that
   aren't their fault. Wastes time.</li>
<li>Must provide rapid feedback. Developers don't want to wait.</li>
<li>Provide frequent feedback. Developers should know as soon as
   possible after they did something. (I think this refers to local
   feedback.)</li>
</ol>
<p>Sandcastle is their CI system.</p>
<p>Diff lifecycle discussion.</p>
<p>Basic tests and lint run locally. (My understanding from talking
with Facebookers is "local" often means on a Facebook server, not
local laptop. Machines at developers fingertips are often dumb
terminals.)</p>
<p>They appear to use code coverage to determine what tests to run.
"We're not going to run a test unless your diff might actually have
broken it."</p>
<p>They run flaky tests less often.</p>
<p>They run slow tests less often.</p>
<p><strong>Goal is to get feedback to developers in under 10 minutes.</strong></p>
<p><strong>If they run fewer tests and get back to developers quicker,
things are less likely to break than if they run more tests but
take longer to give feedback.</strong></p>
<p>They also want feedback quickly so reviewers can see results at
review time.</p>
<p>They use Web Driver heavily. Love cross-platform nature of Web Driver.</p>
<p>In addition to test results, performance and size metrics are reported.</p>
<p>They have a "Ship It" button on the diff.</p>
<p>Landcastle handles landing diff.</p>
<p>"It is not OK at Facebook to land a diff without using Landcastle."
(Read: developers don't push directly to the master repo.)</p>
<p>Once Landcastle lands something, it runs tests again. If an issue
is found, a task is filed. Task can be "push blocking."
Code won't ship to users until the "push blocking" issue resolved.
(Tweets confirm they do backouts "fairly aggressively." A valid
resolution to a push blocking task is to backout. But fixing forward
is fine as well.)</p>
<p>After a while, branch cut occurs. Some cherry picks onto release
branches.</p>
<p>In addition to diff-based testing, they do continuous testing runs.
Much more comprehensive. No time restrictions. Continuous runs on
master and release candidate branches. Auto bisect to pin down
regressions.</p>
<p>Sandcastle processes &gt;1000 test results per second. 5 years of machine
work per day. Thousands of machines in 5 data centers.</p>
<p>They started with buildbot. Single master. Hit scaling limits of
single thread single master. Master could not push work to workers
fast enough. Sandcastle has distributed queue. Workers just pull
jobs from distributed queue.</p>
<p>"High-signal feedback is critical." "Flaky failures erode developer
confidence." "We need developers to trust Sandcastle."</p>
<p>Extremely careful separating infra failures from other failures.
Developers don't see infra failures. Infra failures only reported
to Sandcastle team.</p>
<p>Bots look for flaky tests. Stress test individual tests. Run tests
in parallel with themselves. Goal: developers don't see flaky tests.</p>
<p>There is a "not my fault" button that developers can use to report
bad signals.</p>
<p><strong>"Whatever the scale of your engineering organization, developer
efficiency is the key thing that your infrastructure teams should be
striving for. This is why at Facebook we have some of our top
engineers working on developer infrastructure."</strong> (Preach it.)</p>
<p>Excellent talk. <strong>Mozillians doing infra work or who are in charge
of head count for infra work should watch this video.</strong></p>
<p><em>Update 2015-03-28 21:35 UTC - Clarified some bits in response to
new info Tweeted at me. Added link to my monorepos blog post.</em></p>]]></content:encoded>
    </item>
    <item>
      <title>New High Scores for hg.mozilla.org</title>
      <link>http://gregoryszorc.com/blog/2015/03/19/new-high-scores-for-hg.mozilla.org</link>
      <pubDate>Thu, 19 Mar 2015 20:20:00 PDT</pubDate>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2015/03/19/new-high-scores-for-hg.mozilla.org</guid>
      <description>New High Scores for hg.mozilla.org</description>
      <content:encoded><![CDATA[<p>It's been a <a href="/blog/2015/03/18/network-events/">rough week</a>.</p>
<p>The very short summary of events this week is that both the Firefox
and Firefox OS release automation has been performing a denial of
service attack against
<a href="https://hg.mozilla.org/">hg.mozilla.org</a>.</p>
<p>On the face of it, this is nothing new. The release automation
is by far the top consumer of hg.mozilla.org data, requesting several
terabytes per day via several million HTTP requests from thousands of
machines in multiple data centers. The very nature of their existence
makes them a significant denial of service threat.</p>
<p>Lots of things went wrong this week. While a post mortem will shed
light on them, many fall under the umbrella of <em>release automation was
making more requests than it should have and was doing so in a way
that both increased the chances of an outage occurring and increased
the chances of a prolonged outage.</em> This resulted in the hg.mozilla.org
servers working harder than they ever have. As a result, we have some
new <em>high scores</em> to share.</p>
<ul>
<li>
<p>On UTC day March 19, hg.mozilla.org transferred 7.4 TB of data.
  This is a significant increase from the ~4 TB we expect on a typical
  weekday. (Even more significant when you consider that most load is
  generated during peak hours.)</p>
</li>
<li>
<p>During the 1300 UTC hour of March 17, the cluster received 1,363,628
  HTTP requests. No HTTP 503 Service Not Available errors were
  encountered in that window! 300,000 to 400,000 requests per hour is
  typical.</p>
</li>
<li>
<p>During the 0800 UTC hour of March 19, the cluster transferred 776 GB
  of repository data. That comes out to at least 1.725 Gbps on average
  (I didn't calculate TCP and other overhead). Anything greater than 250
  GB per hour is not very common. No HTTP 503 errors were served from
  the origin servers during this hour!</p>
</li>
</ul>
<p>We encountered many periods where hg.mozilla.org was operating more than
twice its normal and expected operating capacity and it was able to
handle the load just fine. As a server operator, I'm proud of this.
The servers were provisioned beyond what is normally needed of them and
it took a truly exceptional event (or two) to bring the service down.
This is generally a good way to do hosted services (you rarely want to be
barely provisioned because you fall over at the slighest change and you
don't want to be grossly over-provisioned because you are wasting money
on idle resources).</p>
<p>Unfortunately, the hg.mozilla.org service did fall over. Multiple times,
in fact. There is room to improve. As proud as I am that the service
operated well beyond its expected limits, I can't help but feel ashamed
that it did eventual cave in under even extreme load and that people are
probably making under-informed general assumptions like <em>Mercurial can't
scale</em>. The simple fact of the matter is that clients cumulatively
generated an exceptional amount of traffic to hg.mozilla.org this week.
All servers have capacity limits. And this week we encountered the limit
for the current configuration of hg.mozilla.org. Cause and effect.</p>]]></content:encoded>
    </item>
  </channel>
</rss>
