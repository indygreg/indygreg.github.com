<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>Gregory Szorc's Digital Home</title>
    <link>http://gregoryszorc.com/blog</link>
    <description>Rambling on</description>
    <pubDate>Sat, 29 Dec 2018 16:56:28 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Faster In-Memory Python Module Importing</title>
      <link>http://gregoryszorc.com/blog/2018/12/28/faster-in-memory-python-module-importing</link>
      <pubDate>Fri, 28 Dec 2018 12:40:00 PST</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[Rust]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2018/12/28/faster-in-memory-python-module-importing</guid>
      <description>Faster In-Memory Python Module Importing</description>
      <content:encoded><![CDATA[<p>I <a href="/blog/2018/12/18/distributing-standalone-python-applications/">recently blogged about</a>
distributing standalone Python applications. In that post, I announced
<a href="https://github.com/indygreg/PyOxidizer">PyOxidizer</a> - a tool which
leverages Rust to produce standalone executables embedding Python. One of the
features of PyOxidizer is the ability to import Python modules embedded
within the binary using zero-copy.</p>
<p>I also recently blogged about
<a href="/blog/2018/10/29/global-kernel-locks-in-apfs/">global kernel locks in APFS</a>,
which make filesystem operations slower on macOS. This was the latest wrinkle in
a long battle against Python's slow startup times, which I've posted about
on the official python-dev mailing list
<a href="https://mail.python.org/pipermail/python-dev/2014-May/134528.html">over</a>
<a href="https://mail.python.org/pipermail/python-dev/2018-May/153296.html">the</a>
<a href="https://mail.python.org/pipermail/python-dev/2018-October/155466.html">years</a>.</p>
<p>Since I announced PyOxidizer a few days ago, I've had some productive holiday
hacking sessions!</p>
<p>One of the reached milestones is PyOxidizer now supports macOS.</p>
<p>With that milestone reached, I thought it would be interesting to compare
the performance of a PyOxidizer executable versus a standard CPython build.</p>
<p>I produced a <a href="https://gist.github.com/indygreg/be1c229fa41ced5c76d912f7073f9de6">Python script</a>
that imports almost the entirety of the Python standard library - at least the
modules implemented in Python. That's 508 <code>import</code> statements. I then
executed this script using a typical <code>python3.7</code> binary (with the standard
library on the filesystem) and PyOxidizer-produced standalone executables
with a module importer that loads Python modules from memory using zero copy.</p>
<pre><code># Homebrew installed CPython 3.7.2

# Cold disk cache.
$ sudo purge
$ time /usr/local/bin/python3.7 &lt; import_stdlib.py
real   0m0.694s
user   0m0.354s
sys    0m0.121s

# Hot disk cache.
$ time /usr/local/bin/python3.7 &lt; import_stdlib.py
real   0m0.319s
user   0m0.263s
sys    0m0.050s

# PyOxidizer with non-PGO/non-LTO CPython 3.7.2
$ time target/release/pyapp &lt; import_stdlib.py
real   0m0.223s
user   0m0.201s
sys    0m0.017s

# PyOxidizer with PGO/non-LTO CPython 3.7.2
$ time target/release/pyapp &lt; import_stdlib.py
real   0m0.234s
user   0m0.210s
sys    0m0.019

# PyOxidizer with PTO+LTO CPython 3.7.2
$ sudo purge
$ time target/release/pyapp &lt; import_stdlib.py
real   0m0.442s
user   0m0.252s
sys    0m0.059s

$ time target/release/pyall &lt; import_stdlib.py
real   0m0.221s
user   0m0.197s
sys    0m0.020s
</code></pre>
<p>First, the PyOxidizer times are all relatively similar regardless of whether
PGO or LTO is used to build CPython. That's not too surprising, as I'm
exercising a very limited subset of CPython (and I suspect the benefits
of PGO/LTO aren't as pronounced due to the nature of the CPython API).</p>
<p>But the bigger result is the obvious speedup with PyOxidizer and its
in-memory importing: <strong>PyOxidizer can import almost the entirety of the
Python standard library ~100ms faster - or ~70% of original - than a
typical standalone CPython install</strong> with a hot disk cache! This comes
out to ~0.19ms per <code>import</code> statement. If we run <code>purge</code> to clear out
the disk cache, the performance delta increases to 252ms, or ~64% of
original. All these numbers are on a 2018 6-core 2.9 GHz i9 MacBook Pro,
which has a pretty decent SSD.</p>
<p>And on Linux on an i7-6700K running in a Hyper-V VM:</p>
<pre><code># pyenv installed CPython 3.7.2

# Cold disk cache.
$ time ~/.pyenv/versions/3.7.2/bin/python &lt; import_stdlib.py
real   0m0.405s
user   0m0.165s
sys    0m0.065s

# Hot disk cache.
$ time ~/.pyenv/versions/3.7.2/bin/python &lt; import_stdlib.py
real   0m0.193s
user   0m0.161s
sys    0m0.032s

# PyOxidizer with PTO CPython 3.7.2

# Cold disk cache.
$ time target/release/pyapp &lt; import_stdlib.py
real   0m0.227s
user   0m0.145s
sys    0m0.016s

# Hot disk cache.
$ time target/release/pyapp &lt; import_stdlib.py
real   0m0.152s
user   0m0.136s
sys    0m0.016s
</code></pre>
<p>On a hot disk cache, the run-time improvement of PyOxidizer is ~41ms, or
~78% of original. This comes out to ~0.08ms per <code>import</code> statement. When
flushing caches by writing <code>3</code> to <code>/proc/sys/vm/drop_caches</code>, the delta
increases to ~178ms, or ~56% of original.</p>
<p>Using <code>dtruss -c</code> to execute the binaries, the breakdown in system calls
occurring &gt;10 times is clear:</p>
<pre><code># CPython standalone
fstatfs64                                      16
read_nocancel                                  19
ioctl                                          20
getentropy                                     22
pread                                          26
fcntl                                          27
sigaction                                      32
getdirentries64                                34
fcntl_nocancel                                106
mmap                                          114
close_nocancel                                129
open_nocancel                                 130
lseek                                         148
open                                          168
close                                         170
read                                          282
fstat64                                       403
stat64                                        833

# PyOxidizer
lseek                                          10
read                                           12
read_nocancel                                  14
fstat64                                        16
ioctl                                          22
munmap                                         31
stat64                                         33
sysctl                                         33
sigaction                                      36
mmap                                          122
madvise                                       193
getentropy                                    315
</code></pre>
<p>PyOxidizer avoids hundreds of <code>open()</code>, <code>close()</code>, <code>read()</code>,
<code>fstat64()</code>, and <code>stat64()</code> calls. And by avoiding these calls,
PyOxidizer not only avoids the userland-kernel overhead intrinsic to them,
but also any additional overhead that APFS is imposing via its global
lock(s).</p>
<p>(Why the PyOxidizer binary is making hundreds of calls to <code>getentropy()</code>
I'm not sure. It's definitely coming from Python as a side-effect of a
module import and it is something I'd like to fix, if possible.)</p>
<p>With this experiment, we finally have the ability to better isolate the
impact of filesystem overhead on Python module importing and preliminary
results indicate that the overhead is not insignificant - at least on the
tested systems (I'll get data for Windows when PyOxidizer supports it).
While the test is somewhat contrived (I don't think many applications import
the entirety of the Python standard library), some Python applications do
import hundreds of modules. And as I've
<a href="https://mail.python.org/pipermail/python-dev/2018-May/153296.html">written before</a>,
milliseconds matter. This is especially true if you are invoking Python
processes hundreds or thousands of times in a build system, when running
a test suite, for scripting, etc. Cumulatively you can be importing tens
of thousands of modules. So I think shaving even fractions of a
millisecond from module importing is important.</p>
<p>It's worth noting that in addition to the system call overhead, CPython's
path-based importer runs
<a href="https://github.com/python/cpython/blob/804a5d94b6b7f8cb8546112aee2bc3af362f28f5/Lib/importlib/_bootstrap_external.py">substantially more</a>
Python code
<a href="https://github.com/indygreg/PyOxidizer/blob/c50e63338abd08ebac86746a33d750756d622edc/pyrepackager/src/memoryimporter.py">than PyOxidizer</a>
and this likely contributes several milliseconds of overhead as well. Because
PyOxidizer applications are static, the importer can remain simple (finding a
module in PyOxidizer is essentially a Rust <code>HashMap&lt;String, Vec&lt;u8&gt;</code> lookup).
While it might be useful to isolate the filesystem overhead from Python code
overhead, the thing that end-users care about is overall execution time: they
don't care where that overhead is coming from. So I think it is fair to compare
PyOxidizer - with its intrinsically simpler import model - with what Python
typically does (scan <code>sys.path</code> entries and looking for modules on the
filesystem).</p>
<p>Another difference is that PyOxidizer is almost completely statically linked.
By contrast, a typical CPython install has compiled extension modules as
standalone shared libraries and these shared libraries often link against
other shared libraries (such as libssl). From <code>dtruss</code> timing information,
I don't believe this difference contributes to significant overhead, however.</p>
<p>Finally, I haven't yet optimized PyOxidizer. I still have a few tricks up
my sleeve that can likely shave off more overhead from Python startup. But
so far the results are looking <em>very</em> promising. I dare say they are looking
promising enough that Python distributions themselves might want to look
into the area more thoroughly and consider distribution defaults that rely
less on the every-Python-module-is-a-separate-file model.</p>
<p>Stay tuned for more <a href="https://github.com/indygreg/PyOxidizer">PyOxidizer</a>
updates in the near future!</p>
<p><em>(I updated this post a day after initial publication to add measurements
for Linux.)</em></p>]]></content:encoded>
    </item>
    <item>
      <title>Distributing Standalone Python Applications</title>
      <link>http://gregoryszorc.com/blog/2018/12/18/distributing-standalone-python-applications</link>
      <pubDate>Tue, 18 Dec 2018 15:35:00 PST</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[Rust]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2018/12/18/distributing-standalone-python-applications</guid>
      <description>Distributing Standalone Python Applications</description>
      <content:encoded><![CDATA[<h2>The Problem</h2>
<p>Packaging and application distribution is a hard problem on multiple
dimensions. For Python, large aspects of this problem space are more or
less solved if you are distributing open source Python libraries and your
target audience is developers (<em>use pip and PyPI</em>). But if you are distributing
Python <em>applications</em> - standalone executables that use Python - your
world can be much more complicated.</p>
<p>One of the primary reasons why distributing Python applications is difficult
is because of the complex and often sensitive relationship between a Python
application and the environment it runs in.</p>
<p>For starters we have the Python interpreter itself. If your application doesn't
distribute the Python interpreter, you are at the whims of the Python
interpreter provided by the host machine. You may want to target Python 3.7
only. But because Python 3.5 or 3.6 is the most recent version installed by
many Linux distros, you are forced to support older Python versions and all
their quirks and lack of features.</p>
<p>Going down the rabbit hole, even the presence of a supposedly compatible
version of the Python interpreter isn't a guarantee for success! For example,
the Python interpreter could have a built-in extension that links against
an old version of a library. Just last week I was encountering weird SQlite
bugs in Firefox's automation because Python was using an old version of
SQLite with known bugs. Installing a modern SQLite fixed the problems. Or
the interpreter could have modifications or extra installed packages
interfering with the operation of your application. There are never-ending
corner cases. And I can tell you from my experience with having to support
the Firefox build system (which uses Python heavily) that you will encounter
these corner cases given a broad enough user base.</p>
<p>And even if the Python interpreter on the target machine is fully compatible,
getting your code to run on that interpreter could be difficult! Several
Python applications leverage compiled extensions linking against Python's
C API. Distributing the precompiled form of the extension can be challenging,
especially when your code needs to link against 3rd party libraries, which
may conflict with something on the target system. And, the precompiled
extensions need to be built in a very delicate manner to ensure they can
run on as many target machines as possible. But not distributing pre-built
binaries requires the end-user be able to compile Python extensions. Not
every user has such an environment and forcing this requirement on them is
not user friendly.</p>
<p><strong>From an application developer's point of view, distributing a copy of the
Python interpreter along with your application is the only reliable way of
guaranteeing a more uniform end-user experience.</strong> Yes, you will still
have variability because every machine is different. But you've eliminated
the the Python interpreter from the set of unknowns and that is a huge win.
(Unfortunately, distributing a Python interpreter comes with a host of other
problems such as size bloat, security/patching concerns, poking the OS
packaging bears, etc. But those problems are for another post.)</p>
<h2>Existing Solutions</h2>
<p>There are tons of existing tools for <em>solving</em> the Python application
distribution problem.</p>
<p>The approach that tools like <a href="https://shiv.readthedocs.io/en/latest/">Shiv</a>
and <a href="https://github.com/pantsbuild/pex">PEX</a> take is to leverage Python's
built-in support for <em>running</em> zip files. Essentially, if there is a zip
file containing a <code>__main__.py</code> file and you execute <code>python file.zip</code>
(or have a zip file with a <code>#!/usr/bin/env python</code> shebang), Python
can load modules in that zip file and execute an application within. Pretty
cool!</p>
<p>This approach works great if your execution environment supports shebangs
(Windows doesn't) and the Python interpreter is suitable. But if you need
to support Windows or don't have control over the execution environment
and can't guarantee the Python interpreter is <em>good</em>, this approach isn't
suitable.</p>
<p>As stated above, we want to distribute the Python interpreter with our
application to minimize variability. Let's talk about tools that do that.</p>
<p><a href="https://github.com/facebookincubator/xar/">XAR</a> is a pretty cool offering
from Facebook. XAR files are executables that contain
<a href="https://en.wikipedia.org/wiki/SquashFS">SquashFS</a> filesystems. Upon running
the executable, SquashFS filesystems are created. For Python applications,
the XAR contains a copy of the Python interpreter and all your Python modules.
At run-time, these files are <em>extracted</em> to SquashFS filesystems and the
Python interpreter is executed. If you squint hard enough, it is kind of
like a pre-packaged, executable virtualenv which also contains the Python
interpreter.</p>
<p>XARs are pretty cool (and aren't limited to Python). However, because XARs
rely on SquashFS, they have a run-time requirement on the target machine.
This is great if you only need to support Linux and macOS and your target
machines support FUSE and SquashFS. But if you need to support Windows or
a general user population without SquashFS support, XARs won't help you.</p>
<p>Zip files and XARs are great for enterprises that have tightly controlled
environments. But for a general end-user population, we need something
more robust against variance among target machines.</p>
<p>There are a handful of tools for packaging Python applications along with
the Python interpreter in more resilient manners.</p>
<p><a href="http://nuitka.net/pages/overview.html">Nuitka</a> <em>converts</em> Python source
to C code then compiles and links that C code against libpython. You can
perform a static link and compile everything down to a single executable.
If you do the compiling properly, that executable should <em>just work</em> on
pretty much every target machine. That's pretty cool and is exactly the
kind of solution application distributors are looking for: you can't get
much simpler than a self-contained executable! While I'd love to vouch
for Nuitka and recommend using it, I haven't used it so can't. And I'll
be honest, the prospect of compiling Python source to C code kind of
terrifies me. That effectively makes Nuitka a new Python implementation
and I'm not sure I can (yet) place the level of trust in Nuitka that I
have for e.g. CPython and PyPy.</p>
<p>And that leads us to our final category of tools:
<a href="https://docs.python-guide.org/shipping/freezing/">freezing your code</a>. There
are a handful of tools like <a href="https://www.pyinstaller.org/">PyInstaller</a>
which automate the process of building your Python application (often via
standard <code>setup.py</code> mechanisms), assembling all the requisite bits of
the Python interpreter, and producing an artifact that can be distributed
to end users. There are even tools that produce Windows installers, RPMs,
DEBs, etc that you can sign and distribute.</p>
<p>These <em>freezing</em> tools are arguably the state of the art for Python
application distribution to general user populations. On first glance
it seems like all the needed tools are available here. But there are
cracks below the surface.</p>
<h2>Issues with Freezing</h2>
<p>A common problem with freezing is it often relies on the Python interpreter
used to build the frozen application. For example, when building a frozen
application on Linux, it will bundle the system's Python interpreter with
the frozen application. And that interpreter may link against libraries
or libc symbol versions not available on all target machines. So, the
build environment has to be <em>just right</em> in order for the binaries to
run on as many target systems as possible. This isn't an insurmountable
problem. But it adds overhead and complexity to application maintainers.</p>
<p>Another limitation is how these frozen applications handle importing
Python modules.</p>
<p>Multiple tools take the approach of embedding an archive (usually a zip file)
in the executable containing the Python <em>standard library</em> bits not part of
libpython. This includes C extensions (compiled to <code>.so</code> or <code>.pyd</code> files)
and Python source (<code>.py</code>) or bytecode (<code>.pyc</code>) files. There is typically
a step - either at application start time or at module import time - where a
file is extracted to the filesystem such that Python's filesystem-based
importer can load it from there.</p>
<p>For example, PyInstaller <a href="https://pyinstaller.readthedocs.io/en/stable/operating-mode.html#how-the-one-file-program-works">extracts the standard library to a temporary directory
at application start time</a>
(at least when running in single file mode). This can add significant overhead
to the startup time of applications - more than enough to blow through people's
ability to perceive something as <em>instantaneous</em>. This is acceptable for
long-running applications. But for applications (like CLI tools or support
tools for build systems), the overhead can be a non-starter. And, the mere
fact that you are doing filesystem write I/O establishes a requirement that
the application have write access to the filesystem and that write I/O can
perform reasonably well lest application performance suffer. These can be
difficult pills to swallow!</p>
<p>Another limitation is that these tools often assume the executable being
produced is only a Python application. Sometimes Python is <em>part of</em> a
larger application. It would be useful to produce a library that can
easily be embedded within a larger application.</p>
<h2>Improving the State of the Art</h2>
<p>Existing Python application distribution mechanisms don't tick all the
requirements boxes for me. We have tools that are suitable for internal
distribution in well-defined <em>enterprise</em> environments. And we have tools
that target general user populations, albeit with a burden on application
maintainers and often come with a performance hit and/or limited flexibility.</p>
<p>I want something that allows me to produce a standalone, single file executable
containing a Python interpreter, the Python standard library (or a subset of
it), and all the custom code and resources my application needs. That
executable should not require any additional library dependencies beyond what is
already available on most target machines (e.g. libc). That executable should
not require any special filesystem providers (e.g. FUSE/SquashFS) nor should
it require filesystem write access nor perform filesystem write I/O at run-time.
I should be able to embed a Python interpreter within a larger application,
without the overhead of starting the Python interpreter if it isn't needed.</p>
<p>No existing solution ticks all of these boxes.</p>
<p>So I set out to build one.</p>
<p>One problem is producing a Python interpreter that is portable and
fully-featured. You can't punt on this problem because if the core Python
interpreter isn't produced in just the right way, your application will
depend on libraries or symbol versions not available in all environments.</p>
<p>I've created the <a href="https://github.com/indygreg/python-build-standalone">python-build-standalone</a>
project for automating the process of building Python interpreters suitable
for use with standalone, distributable Python applications. The project
produces (and has available for download) binary artifacts including a
pre-compiled Python interpreter and object files used for compiling that
interpreter. The Python interpreter is compiled with PGO/LTO using a modern
Clang, helping to ensure that Python code runs as fast as it can. All of
Python's dependencies are compiled from source with the modern toolchain and
everything is aggressively statically linked to avoid external dependencies.
The toolchain and pre-built distribution are available for downstream
consumers to compile Python extensions with/against.</p>
<p>It's worth noting that use of a modern Clang toolchain is likely sufficiently
different from what you use today. When producing <em>manylinux</em> wheels, it is
recommended to use the <a href="https://github.com/pypa/manylinux">pypa/manylinux</a>
Docker images. These Docker images are based on CentOS 5 (for maximum libc
and other system library compatibility). While they do install a custom
toolchain, Python and any extensions compiled in that environment are compiled
with GCC 4.8.2 (as of this writing). That's a GCC from 2013. A lot has
changed in compilers since 2013 and building Python and extensions with a
compiler released in 2018 should result in various benefits (faster code,
better warnings, etc).</p>
<p>If producing custom CPython builds for standalone distribution interests
you, you should take a look at how I coerced CPython to statically link
all extensions. Spoiler: it involves producing a custom-tailored
<code>Modules/Setup.local</code> file that bypasses <code>setup.py</code>, along with some
<code>Makefile</code> hacks. Because the build environment is deterministic and isolated
in a container, we can get away with some ugly hacks.</p>
<p>A statically linked <code>libpython</code> from which you can produce a standalone
binary embedding Python is only the first layer in the onion. The next layer
is how to handle the Python standard library.</p>
<p><code>libpython</code> only contains the code needed to run the core bits of the Python
interpreter. If we attempt to run a statically linked <code>python</code> executable
without the standard library in the filesystem, things fail pretty fast:</p>
<pre><code>$ rm -rf lib
$ bin/python
Could not find platform independent libraries &lt;prefix&gt;
Could not find platform dependent libraries &lt;exec_prefix&gt;
Consider setting $PYTHONHOME to &lt;prefix&gt;[:&lt;exec_prefix&gt;]
Fatal Python error: initfsencoding: Unable to get the locale encoding
ModuleNotFoundError: No module named 'encodings'

Current thread 0x00007fe9a3432740 (most recent call first):
Aborted (core dumped)
</code></pre>
<p>I'll spare you the details for the moment, but initializing the CPython
interpreter (via <code>Py_Initialize()</code> <em>requires</em> that parts of the Python
standard library be available). This means that in order to fulfill our dream
of a single file executable, we will need custom code that teaches the
embedded Python interpreter to load the standard library from within the
binary... somehow.</p>
<p>As far as I know, efficient embedded standard library handling without run-time
requirements does not exist in the current Python packaging/distribution
ecosystem. So, I had to devise something new.</p>
<p>Enter <a href="https://github.com/indygreg/pyoxidizer">PyOxidizer</a>. PyOxidizer is
a collection of Rust crates that facilitate building an embeddable Python
library, which can easily be added to an executable. We need <em>native</em> code
to interface with the Python C APIs in order to influence Python interpreter
startup. It is 2018 and Rust is a better C/C++, so I chose Rust for this
<em>driver</em> functionality instead of C. Plus, Rust's integrated build system
makes it easier to automate the integration of the custom Python interpreter
files into binaries.</p>
<p>The role of PyOxidizer is to take the pre-built Python interpreter files from
<a href="https://github.com/indygreg/python-build-standalone">python-build-standalone</a>,
combine those files with any other Python files needed to run an application,
and marry them to a Rust crate. This Rust crate can trivially be turned into
a self-contained executable containing a Python application. Or, it can be
combined with another Rust project. Or it can be emitted as a library and
integrated with a non-Rust application. There's a lot of flexibility by design.</p>
<p>The mechanism I used for embedding the Python standard library into a single
file executable without incurring explicit filesystem access at run-time is
(I believe) new, novel, and somewhat crazy. Let me explain how it works.</p>
<p>First, there are no <code>.so</code>/<code>.pyd</code> shared library compiled Python extensions
to worry about. This is because all compiled extensions are statically linked
into the Python interpreter. To the interpreter, they exist as
<a href="https://docs.python.org/3.7/library/importlib.html#importlib.machinery.BuiltinImporter">built-in modules</a>.
Typically, a CPython build will have some modules like <code>_abc</code>, <code>_io</code>, and
<code>sys</code> provided by <em>built-in modules</em>. Modules like <code>_json</code> exist as standalone
shared libraries that are loaded on demand. <code>python-build-standalone</code>'s
modifications to CPython's build system converts all these would-be standalone
shared libraries into <em>built-in modules</em>. (Because we distribute the object
files that compose the eventual <code>libpython</code>, it is possible to filter out
unwanted modules to cut down on binary size if you don't want to ship a
fully-featured Python interpreter.) Because there are no standalone shared
libraries providing Python modules, we don't have the problem of needing to
load a shared library to load a module, which would undermine our goal of
<em>no filesystem access to import modules</em>. And that's a good thing, too,
because <code>dlopen()</code> requires a path: you can't load a shared library from
a memory address. (Fun fact: there are hacks like
<a href="https://sourceware.org/bugzilla/show_bug.cgi?id=11767">dlopen_with_offset()</a>
that provide an API to load a library from memory, but they require a custom
libc. Google uses this approach for their internal single-file Python
application solution.)</p>
<p>From the <code>python-build-standalone</code> artifacts, PyOxidizer collects all files
belonging to the Python standard library (notably <code>.py</code> and <code>.pyc</code> files).
It also collects other source, bytecode, and resource files needed to run
a custom application.</p>
<p>The relevant files are assembled and serialized into data structures which
contain the names of the resources and their raw content. These data structures
are made available to Rust as <code>&amp;'static [u8]</code> variables (essentially a
<code>static void*</code> if you don't speak Rust).</p>
<p>Using the <a href="https://github.com/dgrunwald/rust-cpython">rust-cpython</a> crate,
PyOxidizer defines a custom Python extension module implemented purely in Rust.
When loaded, the module parses the data structures containing available
Python resource names and data into <code>HashMap&lt;&amp;str, &amp;[u8]&gt;</code> instances. In other
words, it builds a native mapping from resource name to a pointer to its raw
data. The Rust-implemented module exports to Python an API for accessing that
data. From the Python side, you do the equivalent of <code>MODULES.get_code('foo')</code>
to request the bytecode for a named Python module. When called, the Rust code
will perform the lookup and return a <code>memoryview</code> instance pointing to the
raw data. (The use of <code>&amp;[u8]</code> and <code>memoryview</code> means that embedded resource
data is loaded from its static, read-only memory location instead of copied
into a data structure managed by Python. This zero copy approach translates to
less overhead for importing modules. Although, the memory needs to be paged
in by the operating system. So on slow filesystems, reducing I/O and e.g.
compressing module data might be a worthwhile optimization. This can be a
future feature.) </p>
<p>Making data embedded within a binary available to a Python module is relatively
easy. I'm definitely not the first person to come up with this idea. What is
hard - and what I <em>might</em> be the first person to actually do - is how you make
the Python module importing mechanism load <em>all</em> standard library modules via
such a mechanism.</p>
<p>With a custom extension module built-in to the binary exposing module data,
it should <em>just</em> be a matter of registering a custom
<a href="https://docs.python.org/3.7/library/sys.html#sys.meta_path">sys.meta_path</a>
importer that knows how to load modules from that custom location. This
problem turns out to be quite hard!</p>
<p>The initialization of a CPython interpreter is - as I've learned - a bit
complex. A CPython interpreter must be initialized via <code>Py_Initialize()</code>
before any Python code can run. That means in order to modify <code>sys.meta_path</code>,
<code>Py_Initialize()</code> must finish.</p>
<p>A lot of activity occurs under the hood during initialization. Applications
embedding Python have very little control over what happens during
<code>Py_Initialize()</code>. You can change some superficial things like what
filesystem paths to use to bootstrap <code>sys.path</code> and what encodings to use
for stdio descriptors. But you can't really influence the core actions that are
being performed. And there's no mechanism to directly influence
<code>sys.meta_path</code> before an <code>import</code> is performed. (Perhaps there should be?)</p>
<p>During <code>Py_Initialize()</code>, the interpreter needs to configure the encodings
for the filesystem and the stdio descriptors. Encodings are loaded from
Python modules provided by the standard library. So, during the course of
<code>Py_Initialize()</code>, the interpreter needs to import some modules originally
backed by <code>.py</code> files. This creates a dilemma: if <code>Py_Initialize()</code>
needs to <code>import</code> modules in the standard library, the standard library
is backed by memory and isn't available to known importing mechanisms, and
there's no opportunity to configure a custom <code>sys.meta_path</code> importer
before <code>Py_Initialize()</code> runs, how do you teach the interpreter about
your custom module importer and the location of the standard library modules
needed by <code>Py_Initialize()</code>?</p>
<p>This is an extremely gnarly problem and it took me some hours and many false
leads to come up with a solution.</p>
<p>My first attempt involved the esoteric
<a href="https://docs.python.org/3/c-api/import.html#c.PyImport_FrozenModules">frozen modules</a>
feature. (This work predated the use of a custom data structure and module
containing modules data.) The Python interpreter has a
<code>const struct _frozen* PyImport_FrozenModules</code> data structure defining an
array of <em>frozen</em> modules. A <em>frozen</em> module is defined by its module
name and precompiled bytecode data (roughly equivalent to <code>.pyc</code> file
content). Partway through <code>Py_Initialize()</code>, the Python interpreter is able
to import modules. And one of the built-in importers that is automatically
registered knows how to load modules if they are in <code>PyImport_FrozenModules</code>!</p>
<p>I attempted to audit Python interpreter startup and find all modules
that were imported during <code>Py_Initialize()</code>. I then defined a custom
<code>PyImport_FrozenModules</code> containing these modules. In theory, the import
of these modules during <code>Py_Initialize()</code> would be handled by the
<a href="https://docs.python.org/3.7/library/importlib.html#importlib.machinery.FrozenImporter">FrozenImporter</a>
and everything would <em>just work</em>: if I were able to get <code>Py_Initialize()</code> to
complete, I'd be able to register a custom <code>sys.meta_path</code> importer
immediately afterwards and we'd be set.</p>
<p>Things did not go as planned.</p>
<p><code>FrozenImporter</code> doesn't fully conform to the
<a href="https://www.python.org/dev/peps/pep-0451/">PEP 451</a> requirements for
setting specific attributes on modules. Without these attributes, the
<code>from . import aliases</code> statement in <code>encodings/__init__.py</code> fails
because the importer is unable to resolve the relative module name. Derp.
One would think CPython's built-in importers would comply with PEP 451
and that all of Python's standard library could be imported as frozen modules.
But this is not the case! I was able to hack around this particular failure
by using an absolute import. But I hit another failure and did not want to
excavate that rabbit hole. Once I realized that <code>FrozenImporter</code> was lacking
mandated module attributes, I concluded that attempting to use <em>frozen modules</em>
as a general import-from-memory mechanism was not viable. Furthermore, the
C code backing <code>FrozenImporter</code> walks the <code>PyImport_FrozenModules</code> array and
does a string compare on the module name to find matches. While I didn't
benchmark, I was concerned that un-indexed scanning at import time would
add considerable overhead when hundreds of modules were in play. (The C code
backing <code>BuiltinImporter</code> uses the same approach and I do worry CPython's
imports of built-in extension modules is causing measurable overhead.)</p>
<p>With <em>frozen modules</em> off the table, I needed to find another way to inject
a custom module importer that was usable during <code>Py_Initialize()</code>. Because
we control the source Python interpreter, modifications to the source code
or even link-time modifications or run-time hacks like trampolines weren't
off the table. But I <strong>really</strong> wanted things to work out of the box because
I don't want to be in the business of maintaining patches to Python
interpreters.</p>
<p>My foray into <em>frozen modules</em> enlightened me to the craziness that is
the bootstrapping of Python's importing mechanism.</p>
<p>I remember hearing that the Python module importing mechanism used to be
written in C and was rewritten in Python. And I knew that the
<a href="https://docs.python.org/3.7/library/importlib.html">importlib</a> package
defined interfaces allowing you to implement your own importers, which
could be registered on
<a href="https://docs.python.org/3.7/library/sys.html#sys.meta_path">sys.meta_path</a>.
But I didn't know how all of this worked at the interpreter level.</p>
<p>The internal <a href="https://github.com/python/cpython/blob/08c2ba0717089662132af69bf5948d82277a8a69/Python/pylifecycle.c#L178">initimport()</a>
C function is responsible for initializing the module importing mechanism. It
does the equivalent of <code>import _frozen_importlib</code>, but using the
<a href="https://docs.python.org/3/c-api/import.html#c.PyImport_ImportFrozenModuleObject">PyImport_ImportFrozenModule()</a>
API. It then manipulates some symbols and calls <code>_frozen_importlib.install()</code>
with references to the <code>sys</code> and <code>imp</code> built-in modules. Later (in
<code>initexternalimport()</code>), a <code>_frozen_importlib_external</code> module is imported
and has code within it executed.</p>
<p>I was initially very confused by this because - while there are references
to <code>_frozen_importlib</code> and <code>_frozen_importlib_external</code> all over the
CPython code base, I couldn't figure out where the code for those modules
actually lived! Some sleuthing of the build directory eventually revealed
that the files <a href="https://github.com/python/cpython/blob/08c2ba0717089662132af69bf5948d82277a8a69/Lib/importlib/_bootstrap.py">Lib/importlib/_bootstrap.py</a>
and <a href="https://github.com/python/cpython/blob/08c2ba0717089662132af69bf5948d82277a8a69/Lib/importlib/_bootstrap_external.py">Lib/importlib/_bootstrap_external.py</a>
were <em>frozen</em> to the module names <code>_frozen_importlib</code> and
<code>_frozen_importlib_external</code>, respectively.</p>
<p>Essentially what is happening is the bulk of Python's import <em>machinery</em> is
implemented in Python (rather than C). But there's a chicken-and-egg
problem where you can't run just any Python code (including any <code>import</code>
statement) until the interpreter is partially or fully initialized.</p>
<p>When building CPython, the Python source code for <code>importlib._bootstrap</code>
and <code>importlib._bootstrap_external</code> are compiled to bytecode. This
bytecode is emitted to <code>.h</code> files, where it is exposed as a
<code>static char *</code>. This bytecode is eventually referenced by the
default <code>PyImport_FrozenModules</code> array, allowing the modules to be
imported via the frozen importer's C API, which bypasses the higher-level
importing mechanism, allowing it to work before the full importing
mechanism is initialized.</p>
<p><code>initimport()</code> and <code>initexternalimport()</code> both call Python functions in
the frozen modules. And we can clearly look at the source of the
corresponding modules and see the Python code do things like
<a href="https://github.com/python/cpython/blob/08c2ba0717089662132af69bf5948d82277a8a69/Lib/importlib/_bootstrap.py#L1158">register the default importers on <code>sys.meta_path</code></a>.</p>
<p>Whew, that was a long journey into the bowels of CPython's internals. How
does all this help with single file Python executables?</p>
<p>Well, the predicament that led us down this rabbit hole was there was no
way to register a custom module importer before <code>Py_Initialize()</code>
completes and before an <code>import</code> is attempted during said <code>Py_Initialize()</code>.</p>
<p>It took me a while, but I finally realized the frozen
<code>importlib._bootstrap_external</code> module provided the window I needed!
<code>importlib._bootstrap_external</code>/<code>_frozen_importlib_external</code> is <em>always</em>
executed during <code>Py_Initialize()</code>. So if you can modify this module's code,
you can run arbitrary code during <code>Py_Initialize()</code> and influence Python
interpreter configuration. And since <code>_frozen_importlib_external</code> is a frozen
module and the <code>PyImport_FrozenModules</code> array is writable and can be modified
before <code>Py_Initialize()</code> is called, all one needs to do is replace the
<code>_frozen_importlib</code> / <code>_frozen_importlib_external</code> bytecode in
<code>PyImport_FrozenModules</code> and you can run arbitrary code during Python
interpreter startup, before <code>Py_Initialize()</code> completes and before any
standard library imports are performed!</p>
<p>My solution to this problem is to concatenate some custom Python code to
<code>importlib/_bootstrap_external.py</code>. This custom code defines a
<code>sys.meta_path</code> importer that knows how to use our Rust-backed built-in
extension module to find and load module data. It redefines the <code>_install()</code>
function so that this custom importer is registered on <code>sys.meta_path</code>
when the function is called during <code>Py_Initialize()</code>. The <em>new</em> Python
source is compiled to bytecode and the <code>PyImport_FrozenModules</code> array is
modified at run-time to point to the modified <code>_frozen_importlib_external</code>
implementation. When <code>Py_Initialize()</code> executes its first standard library
import, module data is provided by the custom <code>sys.meta_path</code> importer,
which grabs it from a Rust extension module, which reads it from a
read-only data structure in the executable binary, which is converted
to a Python <code>memoryview</code> instance and sent back to Python for processing.</p>
<p>There's a bit of <em>magic</em> happening behind the scenes to make all of this
work. PyOxidizer attempts to hide as much of the gory details as possible.
From the perspective of an application maintainer, you just need to define
a minimal config file and it handles most of the low-level details. And there's
even a higher-level Rust API for configuring the embedded Python interpreter,
should you need it.</p>
<p><code>python-build-standalone</code> and <code>PyOxidizer</code> are still in their infancy.
They are very much alpha quality. I consider them technology previews more
than usable software at this point. But I think enough is there to demonstrate
the viability of using Rust as the build system and run-time glue to build
and distribute standalone applications embedding Python.</p>
<p>Time will tell if my utopian vision of zero-copy, no explicit filesystem
I/O for Python module imports will pan out. Others who have ventured into
this space have warned me that lots of Python modules rely on <code>__file__</code>
to derive paths to other resources, which are later <code>stat()</code>d and
<code>open()</code>d. <code>__file__</code> for in-memory modules doesn't exactly make sense
and can't be operated on like normal paths/files. I'm not sure what the
inevitable struggles to support these modules will lead to. Maybe we'll have
to extract things to temporary directories like other standalone Python
applications. Maybe <code>PyOxidizer</code> will take off and people will start using
the <a href="https://docs.python.org/3.7/library/importlib.html#importlib.abc.ResourceReader">ResourceReader</a>
API, which is apparently the proper way to do these things these days.
(Caveat: <code>PyOxidizer</code> doesn't yet implement this API but support is planned.)
Time will tell. I'm not opposed to gross hacks or writing more code as
needed.</p>
<p>Producing highly distributable and performant Python applications has been far
too difficult for far too long. My primary goal for PyOxidizer is to lower these
barriers. By leveraging Rust, I also hope to bring Python and Rust closer
together. I want to enable applications and libraries to effortlessly harness
the powers of both of these fantastic programming languages.</p>
<p>Again, <code>PyOxidizer</code> is still in its infancy. I anticipate a significant amount
of hacking over the holidays and hope to share updates in the weeks ahead. Until
then, please leave comments, watch the <a href="https://github.com/indygreg/PyOxidizer">project on GitHub</a>,
file issues for bugs and feature requests, etc and we'll see where things lead.</p>]]></content:encoded>
    </item>
    <item>
      <title>Absorbing Commit Changes in Mercurial 4.8</title>
      <link>http://gregoryszorc.com/blog/2018/11/05/absorbing-commit-changes-in-mercurial-4.8</link>
      <pubDate>Mon, 05 Nov 2018 09:25:00 PST</pubDate>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2018/11/05/absorbing-commit-changes-in-mercurial-4.8</guid>
      <description>Absorbing Commit Changes in Mercurial 4.8</description>
      <content:encoded><![CDATA[<p>Every so often a tool you use introduces a feature that is so useful
that you can't imagine how things were before that feature existed.
The recent 4.8 release of the
<a href="https://www.mercurial-scm.org/">Mercurial version control tool</a> introduces
such a feature: the <code>hg absorb</code> command.</p>
<p><code>hg absorb</code> is a mechanism to automatically and intelligently incorporate
uncommitted changes into prior commits. Think of it as <em><code>hg histedit</code> or
<code>git rebase -i</code> with auto squashing</em>.</p>
<p>Imagine you have a set of changes to prior commits in your working
directory. <code>hg absorb</code> figures out which changes map to which commits
and <em>absorbs</em> each of those changes into the appropriate commit. Using
<code>hg absorb</code>, you can replace cumbersome and often merge conflict ridden
history editing workflows with a single command that often <em>just works</em>.
Read on for more details and examples.</p>
<p>Modern version control workflows often entail having multiple <em>unlanded</em>
commits in flight. What this looks like varies heavily by the version
control tool, standards and review workflows employed by the specific
project/repository, and personal preferences.</p>
<p>A workflow practiced by a lot of projects is to author your commits
into a sequence of standalone commits, with each commit representing
a discrete, logical unit of work. Each commit is then
reviewed/evaluated/tested on its own as part of a larger series.
(This workflow is practiced by Firefox, the Git and Mercurial projects,
and the Linux Kernel to name a few.)</p>
<p>A common task that arises when working with such a workflow is the need
to incorporate changes into an old commit. For example, let's say we have
a stack of the following commits:</p>
<pre><code>$ hg show stack
  @  1c114a ansible/hg-web: serve static files as immutable content
  o  d2cf48 ansible/hg-web: synchronize templates earlier
  o  c29f28 ansible/hg-web: convert hgrc to a template
  o  166549 ansible/hg-web: tell hgweb that static files are in /static/
  o  d46d6a ansible/hg-web: serve static template files from httpd
  o  37fdad testing: only print when in verbose mode
 /   (stack base)
o  e44c2e (@) testing: install Mercurial 4.8 final
</code></pre>
<p>Contained within this stack are 5 commits changing the way that static
files are served by hg.mozilla.org (but that's not important).</p>
<p>Let's say I submit this stack of commits for review. The reviewer spots
a problem with the second commit (<em>serve static template files from httpd</em>)
and wants me to make a change.</p>
<p>How do you go about making that change?</p>
<p>Again, this depends on the exact tool and workflow you are using.</p>
<p>A common workflow is to not rewrite the existing commits at all: you simply
create a new <em>fixup</em> commit on top of the stack, leaving the existing commits
as-is. e.g.:</p>
<pre><code>$ hg show stack
  o  deadad fix typo in httpd config
  o  1c114a ansible/hg-web: serve static files as immutable content
  o  d2cf48 ansible/hg-web: synchronize templates earlier
  o  c29f28 ansible/hg-web: convert hgrc to a template
  o  166549 ansible/hg-web: tell hgweb that static files are in /static/
  o  d46d6a ansible/hg-web: serve static template files from httpd
  o  37fdad testing: only print when in verbose mode
 /   (stack base)
o  e44c2e (@) testing: install Mercurial 4.8 final
</code></pre>
<p>When the entire series of commits is incorporated into the repository,
the end state of the files is the same, so all is well. But this strategy
of using <em>fixup commits</em> (while popular - especially with Git-based tooling
like GitHub that puts a larger emphasis on the end state of changes rather
than the individual commits) isn't practiced by all projects.
<strong><code>hg absorb</code> will not help you if this is your workflow.</strong></p>
<p>A popular variation of this <em>fixup commit</em> workflow is to author a new commit
then <em>incorporate</em> this commit into a prior commit. This typically involves
the following actions:</p>
<pre><code>&lt;save changes to a file&gt;

$ hg commit
&lt;type commit message&gt;

$ hg histedit
&lt;manually choose what actions to perform to what commits&gt;

OR

&lt;save changes to a file&gt;

$ git add &lt;file&gt;
$ git commit
&lt;type commit message&gt;

$ git rebase --interactive
&lt;manually choose what actions to perform to what commits&gt;
</code></pre>
<p>Essentially, you produce a new commit. Then you run a history editing command.
You then tell that history editing command what to do (e.g. to <em>squash</em> or
<em>fold</em> one commit into another), that command performs work and produces a set
of rewritten commits.</p>
<p>In simple cases, you may make a simple change to a single file. Things are
pretty straightforward. You need to know which two commits to <em>squash</em> together.
This is often trivial. Although it can be cumbersome if there are several
commits and it isn't clear which one should be receiving the new changes.</p>
<p>In more complex cases, you may make multiple modifications to multiple files.
You may even want to <em>squash</em> your <em>fixups</em> into separate commits. And for some
code reviews, this <em>complex</em> case can be quite common. It isn't uncommon for me
to be incorporating dozens of reviewer-suggested changes across several commits!</p>
<p>These complex use cases are where things can get really complicated for version
control tool interactions. Let's say we want to make multiple changes to a file
and then incorporate those changes into multiple commits. To keep it simple,
let's assume 2 modifications in a single file <em>squashing</em> into 2 commits:</p>
<pre><code>&lt;save changes to file&gt;

$ hg commit --interactive
&lt;select changes to commit&gt;
&lt;type commit message&gt;

$ hg commit
&lt;type commit message&gt;

$ hg histedit
&lt;manually choose what actions to perform to what commits&gt;

OR

&lt;save changes to file&gt;

$ git add &lt;file&gt;
$ git add --interactive
&lt;select changes to stage&gt;

$ git commit
&lt;type commit message&gt;

$ git add &lt;file&gt;
$ git commit
&lt;type commit message&gt;

$ git rebase --interactive
&lt;manually choose which actions to perform to what commits&gt;
</code></pre>
<p>We can see that the number of actions required by users has already increased
substantially. Not captured by the number of lines is the effort that must go
into the interactive commands like <code>hg commit --interactive</code>,
<code>git add --interactive</code>, <code>hg histedit</code>, and <code>git rebase --interactive</code>. For
these commands, users must tell the VCS tool exactly what actions to take.
This takes time and requires some cognitive load. This ultimately distracts
the user from the task at hand, which is bad for concentration and productivity.
The user just wants to <em>amend</em> old commits: telling the VCS tool what actions
to take is an obstacle in their way. (A compelling argument can be made that
the work required with these workflows to produce a <em>clean</em> history is too much
effort and it is easier to make the trade-off favoring simpler workflows
versus cleaner history.)</p>
<p><strong>These kinds of <em>squash fixup</em> workflows are what <code>hg absorb</code> is designed to
make easier.</strong> When using <code>hg absorb</code>, the above workflow can be reduced to:</p>
<pre><code>&lt;save changes to file&gt;

$ hg absorb
&lt;hit y to accept changes&gt;

OR

&lt;save changes to file&gt;

$ hg absorb --apply-changes
</code></pre>
<p>Let's assume the following changes are made in the working directory:</p>
<pre><code>$ hg diff
diff --git a/ansible/roles/hg-web/templates/vhost.conf.j2 b/ansible/roles/hg-web/templates/vhost.conf.j2
--- a/ansible/roles/hg-web/templates/vhost.conf.j2
+++ b/ansible/roles/hg-web/templates/vhost.conf.j2
@@ -76,7 +76,7 @@ LimitRequestFields 1000
      # Serve static files straight from disk.
      &lt;Directory /repo/hg/htdocs/static/&gt;
          Options FollowSymLinks
 -        AllowOverride NoneTypo
 +        AllowOverride None
          Require all granted
      &lt;/Directory&gt;

@@ -86,7 +86,7 @@ LimitRequestFields 1000
      # and URLs are versioned by the v-c-t revision, they are immutable
      # and can be served with aggressive caching settings.
      &lt;Location /static/&gt;
 -        Header set Cache-Control "max-age=31536000, immutable, bad"
 +        Header set Cache-Control "max-age=31536000, immutable"
      &lt;/Location&gt;

      #LogLevel debug
</code></pre>
<p>That is, we have 2 separate uncommitted changes to
<code>ansible/roles/hg-web/templates/vhost.conf.j2</code>.</p>
<p>Here is what happens when we run <code>hg absorb</code>:</p>
<pre><code>$ hg absorb
showing changes for ansible/roles/hg-web/templates/vhost.conf.j2
        @@ -78,1 +78,1 @@
d46d6a7 -        AllowOverride NoneTypo
d46d6a7 +        AllowOverride None
        @@ -88,1 +88,1 @@
1c114a3 -        Header set Cache-Control "max-age=31536000, immutable, bad"
1c114a3 +        Header set Cache-Control "max-age=31536000, immutable"

2 changesets affected
1c114a3 ansible/hg-web: serve static files as immutable content
d46d6a7 ansible/hg-web: serve static template files from httpd
apply changes (yn)?
&lt;press "y"&gt;
2 of 2 chunk(s) applied
</code></pre>
<p><code>hg absorb</code> automatically figured out that the 2 separate uncommitted changes
<em>mapped</em> to 2 different changesets (Mercurial's term for <em>commit</em>). It
print a summary of what lines would be changed in what changesets and
prompted me to accept its <em>plan</em> for how to proceed. The human effort involved
is a quick review of the proposed changes and answering a prompt.</p>
<p>At a technical level, <code>hg absorb</code> finds all uncommitted changes and
attempts to map each changed line to an unambiguous prior commit. For
every change that can be mapped cleanly, the uncommitted changes are
<em>absorbed</em> into the appropriate prior commit. Commits impacted by the
operation are rebased automatically. If a change cannot be mapped to an
unambiguous prior commit, it is left uncommitted and users can fall back
to an existing workflow (e.g. using <code>hg histedit</code>).</p>
<p>But wait - there's more!</p>
<p>The automatic rewriting logic of <code>hg absorb</code> is implemented by following
the history of lines. This is fundamentally different from the approach
taken by <code>hg histedit</code> or <code>git rebase</code>, which tend to rely on <em>merge
strategies</em> based on the
<a href="https://stackoverflow.com/questions/4129049/why-is-a-3-way-merge-advantageous-over-a-2-way-merge">3-way merge</a>
to derive a new version of a file given multiple input versions. This
approach combined with the fact that <code>hg absorb</code> skips over changes with
an ambiguous application commit means that <strong><code>hg absorb</code> will never
encounter merge conflicts</strong>! Now, you may be thinking <em>if you ignore
lines with ambiguous application targets, the patch would always apply
cleanly using a classical 3-way merge</em>. This statement logically sounds
correct. But it isn't: <code>hg absorb</code> can avoid merge conflicts when the
merging performed by <code>hg histedit</code> or <code>git rebase -i</code> would fail.</p>
<p>The above example attempts to exercise such a use case. Focusing on the
initial change:</p>
<pre><code>diff --git a/ansible/roles/hg-web/templates/vhost.conf.j2 b/ansible/roles/hg-web/templates/vhost.conf.j2
--- a/ansible/roles/hg-web/templates/vhost.conf.j2
+++ b/ansible/roles/hg-web/templates/vhost.conf.j2
@@ -76,7 +76,7 @@ LimitRequestFields 1000
     # Serve static files straight from disk.
     &lt;Directory /repo/hg/htdocs/static/&gt;
         Options FollowSymLinks
-        AllowOverride NoneTypo
+        AllowOverride None
         Require all granted
     &lt;/Directory&gt;
</code></pre>
<p>This patch needs to be applied against the commit which introduced it. That
commit had the following diff:</p>
<pre><code>diff --git a/ansible/roles/hg-web/templates/vhost.conf.j2 b/ansible/roles/hg-web/templates/vhost.conf.j2
--- a/ansible/roles/hg-web/templates/vhost.conf.j2
+++ b/ansible/roles/hg-web/templates/vhost.conf.j2
@@ -73,6 +73,15 @@ LimitRequestFields 1000
         {% endfor %}
     &lt;/Location&gt;

+    # Serve static files from templates directory straight from disk.
+    &lt;Directory /repo/hg/hg_templates/static/&gt;
+        Options None
+        AllowOverride NoneTypo
+        Require all granted
+    &lt;/Directory&gt;
+
+    Alias /static/ /repo/hg/hg_templates/static/
+
     #LogLevel debug
     LogFormat "%h %v %u %t \"%r\" %&gt;s %b %D \"%{Referer}i\" \"%{User-Agent}i\" \"%{Cookie}i\""
     ErrorLog "/var/log/httpd/hg.mozilla.org/error_log"
</code></pre>
<p>But after that commit was another commit with the following change:</p>
<pre><code>diff --git a/ansible/roles/hg-web/templates/vhost.conf.j2 b/ansible/roles/hg-web/templates/vhost.conf.j2
--- a/ansible/roles/hg-web/templates/vhost.conf.j2
+++ b/ansible/roles/hg-web/templates/vhost.conf.j2
@@ -73,14 +73,21 @@ LimitRequestFields 1000
         {% endfor %}
     &lt;/Location&gt;

-    # Serve static files from templates directory straight from disk.
-    &lt;Directory /repo/hg/hg_templates/static/&gt;
-        Options None
+    # Serve static files straight from disk.
+    &lt;Directory /repo/hg/htdocs/static/&gt;
+        Options FollowSymLinks
         AllowOverride NoneTypo
         Require all granted
     &lt;/Directory&gt;

...
</code></pre>
<p>When we use <code>hg histedit</code> or <code>git rebase -i</code> to rewrite this history, the VCS
would first attempt to re-order commits before squashing 2 commits together.
When we attempt to reorder the <em>fixup</em> diff immediately after the commit that
introduces it, there is a good chance your VCS tool would encounter a merge
conflict. Essentially your VCS is thinking <em>you changed this line but the
lines around the change in the final version are different from the lines
in the initial version: I don't know if those other lines matter and therefore
I don't know what the end state should be, so I'm giving up and letting the
user choose for me</em>.</p>
<p>But since <code>hg absorb</code> operates at the line history level, it knows that this
individual line wasn't actually changed (even though the lines around it did),
assumes there is no conflict, and offers to <em>absorb</em> the change. So not only
is <code>hg absorb</code> significantly simpler than today's <code>hg histedit</code> or
<code>git rebase -i</code> workflows in terms of VCS command interactions, but it can
also avoid time-consuming merge conflict resolution as well!</p>
<p>Another feature of <code>hg absorb</code> is that all the rewriting occurs in memory
and the working directory is not touched when running the command. This means
that the operation is fast (working directory updates often account for a lot
of the execution time of <code>hg histedit</code> or <code>git rebase</code> commands). It also means
that tools looking at the last modified time of files (e.g. build systems
like GNU Make) won't rebuild extra (unrelated) files that were touched
as part of updating the working directory to an old commit in order to apply
changes. This makes <code>hg absorb</code> more friendly to edit-compile-test-commit
loops and allows developers to be more productive.</p>
<p>And that's <code>hg absorb</code> in a nutshell.</p>
<p>When I first saw a demo of <code>hg absorb</code> at a Mercurial developer meetup, my
jaw - along with those all over the room - hit the figurative floor. I thought
it was magical and too good to be true. I thought Facebook (the original authors
of the feature) were trolling us with an impossible demo. But it was all real.
And now <code>hg absorb</code> is available in the core Mercurial distribution for anyone
to use.  </p>
<p>From my experience, <code>hg absorb</code> <em>just works</em> almost all of the time: I run
the command and it maps all of my uncommitted changes to the appropriate
commit and there's nothing more for me to do! In a word, it is magical.</p>
<p>To use <code>hg absorb</code>, you'll need to activate the <code>absorb</code> extension. Simply
put the following in your <code>hgrc</code> config file:</p>
<pre><code>[extensions]
absorb =
</code></pre>
<p><code>hg absorb</code> is currently an experimental feature. That means there is
no commitment to backwards compatibility and some rough edges are
expected. I also anticipate new features (such as <code>hg absorb --interactive</code>)
will be added before the experimental label is removed. If you encounter
problems or want to leave comments, <a href="https://bz.mercurial-scm.org/enter_bug.cgi?product=Mercurial">file a bug</a>,
make noise in <code>#mercurial</code> on Freenode, or
<a href="https://www.mercurial-scm.org/wiki/ContributingChanges">submit a patch</a>.
But don't let the <em>experimental</em> label scare you away from using it:
<code>hg absorb</code> is being used by some large install bases and also by many
of the Mercurial core developers. The <em>experimental</em> label is mainly there
because it is a brand new feature in core Mercurial and the <em>experimental</em>
label is usually affixed to new features.</p>
<p>If you practice workflows that frequently require amending old commits, I
think you'll be shocked at how much easier <code>hg absorb</code> makes these workflows.
I think you'll find it to be a game changer: once you use <code>hg abosrb</code>, you'll
soon wonder how you managed to get work done without it.</p>]]></content:encoded>
    </item>
    <item>
      <title>Global Kernel Locks in APFS</title>
      <link>http://gregoryszorc.com/blog/2018/10/29/global-kernel-locks-in-apfs</link>
      <pubDate>Mon, 29 Oct 2018 14:20:00 PDT</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Apple]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2018/10/29/global-kernel-locks-in-apfs</guid>
      <description>Global Kernel Locks in APFS</description>
      <content:encoded><![CDATA[<p>Over the past several months, a handful of people had been complaining
that Mercurial's test harness was executing much slower on Macs. But
this slowdown seemingly wasn't occurring on Linux or Windows. And not
every Mac user experienced the slowness!</p>
<p>Before jetting off to the Mercurial 4.8 developer meetup in Stockholm
a few weeks ago, I sat down with a relatively fresh 6+6 core MacBook Pro
and experienced the problem firsthand: on my 4+4 core i7-6700K running
Linux, the Mercurial test harness completes in ~12 minutes, but on this
MacBook Pro, it was executing in ~38 minutes! On paper, this result
doesn't make any sense because there's no way that the MacBook Pro should
be ~3x slower than that desktop machine.</p>
<p>Looking at Activity Monitor when running the test harness with 12 tests
in parallel revealed something odd: the system was spending ~75% of overall
CPU time inside the kernel! When reducing the number of tests that ran in
parallel, the percentage of CPU time spent in the kernel decreased and
the overall test harness execution time also decreased. This kind of
behavior is usually a sign of something very inefficient in kernel land.</p>
<p>I sample profiled all processes on the system when running the Mercurial
test harness. Aggregate thread stacks revealed a common pattern:
<code>readdir()</code> being in the stack.</p>
<p>Upon closer examination of the stacks, <code>readdir()</code> calls into
<code>apfs_vnop_readdir()</code>, which calls into some functions with <code>bt</code> or
<code>btree</code> in their name, which call into <code>lck_mtx_lock()</code>,
<code>lck_mtx_lock_grab_mutex()</code> and various other functions with
<code>lck_mtx</code> in their name. And the caller of most <code>readdir()</code> appeared
to be Python 2.7's module importing mechanism (notably
<code>import.c:case_ok()</code>).</p>
<p>APFS refers to the
<a href="https://en.wikipedia.org/wiki/Apple_File_System">Apple File System</a>,
which is a filesystem that Apple introduced in 2017 and is the
default filesystem for new versions of macOS and iOS. If upgrading an
old Mac to a new macOS, its HFS+ filesystems would be automatically
converted to APFS.</p>
<p>While the source code for APFS is not available for me to confirm, the
profiling results showing excessive time spent in
<code>lck_mtx_lock_grab_mutex()</code> combined with the fact that execution time
decreases when the parallel process count decreases leads me to the
conclusion that <strong>APFS obtains a global kernel lock during read-only
operations such as <code>readdir()</code></strong>. In other words, APFS slows down when
attempting to perform parallel read-only I/O.</p>
<p>This isn't the first time I've encountered such behavior in a
filesystem: last year I
<a href="/blog/2017/12/08/good-riddance-to-aufs/">blogged about very similar behavior in AUFS</a>,
which was making Firefox CI significantly slower.</p>
<p>Because Python 2.7's module importing mechanism was triggering the
slowness by calling <code>readdir()</code>, I
<a href="https://mail.python.org/pipermail/python-dev/2018-October/155466.html">posted to python-dev</a>
about the problem, as I thought it was important to notify the larger
Python community. After all, this is a generic problem that affects
the performance of starting <em>any</em> Python process when running on APFS.
i.e. if your build system invokes many Python processes in parallel,
you could be impacted by this. As part of obtaining data for that post, I
discovered that Python 3.7 does not call <code>readdir()</code> as part of
module importing and therefore doesn't exhibit a severe slowdown. (Python's
module importing code was rewritten significantly in Python 3 and the <em>fix</em>
was likely introduced well before Python 3.7.)</p>
<p>I've <a href="https://gist.github.com/indygreg/a50e187f5372807cdcab5ac12bc2feea">produced a gist that can reproduce the problem</a>.
The script essentially performs a recursive directory walk. It exercises
the <code>opendir()</code>, <code>readdir()</code>, <code>closedir()</code>, and <code>lstat()</code> functions
heavily and is essentially a benchmark of the filesystem and filesystem
cache's ability to return file metadata.</p>
<p>When you tell it to walk a very large directory tree - say a Firefox
version control checkout (which has over 250,000 files) - the excessive
time spent in the kernel is very apparent on macOS 10.13 High Sierra:</p>
<pre><code>$ time ./slow-readdir.py -l 12 ~/src/firefox
ran 12 walks across 12 processes in 172.209s

real    2m52.470s
user    1m54.053s
sys    23m42.808s

$ time ./slow-readdir.py -l 12 -j 1 ~/src/firefox
ran 12 walks across 1 processes in 523.440s

real    8m43.740s
user    1m13.397s
sys     3m50.687s

$ time ./slow-readdir.py -l 18 -j 18 ~/src/firefox
ran 18 walks across 18 processes in 210.487s

real    3m30.731s
user    2m40.216s
sys    33m34.406s
</code></pre>
<p>On the same machine upgraded to macOS 10.14 Mojave, we see a bit of a
speedup!:</p>
<pre><code>$ time ./slow-readdir.py -l 12 ~/src/firefox
ran 12 walks across 12 processes in 97.833s

real    1m37.981s
user    1m40.272s
sys    10m49.091s

$ time ./slow-readdir.py -l 12 -j 1 ~/src/firefox
ran 12 walks across 1 processes in 461.415s

real    7m41.657s
user    1m05.830s
sys     3m47.041s

$ time ./slow-readdir.py -l 18 -j 18 ~/src/firefox
ran 18 walks across 18 processes in 140.474s

real    2m20.727s
user    3m01.048s
sys    17m56.228s
</code></pre>
<p>Contrast with my i7-6700K Linux machine backed by EXT4:</p>
<pre><code>$ time ./slow-readdir.py -l 8 ~/src/firefox
ran 8 walks across 8 processes in 6.018s

real    0m6.191s
user    0m29.670s
sys     0m17.838s

$ time ./slow-readdir.py -l 8 -j 1 ~/src/firefox
ran 8 walks across 1 processes in 33.958s

real    0m34.164s
user    0m17.136s
sys     0m13.369s

$ time ./slow-readdir.py -l 12 -j 12 ~/src/firefox
ran 12 walks across 12 processes in 25.465s

real    0m25.640s
user    1m4.801s
sys     1m20.488s
</code></pre>
<p>It is apparent that macOS 10.14 Mojave has received performance work
relative to macOS 10.13! Overall kernel CPU time when performing parallel
directory walks has decreased substantially - to ~50% of original on some
invocations! Stacks seem to reveal new code for lock acquisition, so this
might indicate generic improvements to the kernel's locking mechanism
rather than APFS specific changes. Changes to file metadata caching could
also be responsible for performance changes. Although it is difficult to tell
without access to the APFS source code. Despite those improvements, APFS
is still spending a lot of CPU time in the kernel. And the kernel CPU time
is still comparatively very high compared to Linux/EXT4, even for single
process operation.</p>
<p>At this time, I haven't conducted a comprehensive analysis of APFS to
determine what other filesystem operations seem to acquire global kernel
locks: all I know is <code>readdir()</code> does. A casual analysis of profiled
stacks when running Mercurial's test harness against Python 3.7 seems
to show <code>apfs_*</code> functions still on the stack a lot and that seemingly
indicates more APFS slowness under parallel I/O load. But HFS+ exhibited
similar problems (it appeared HFS+ used a single I/O thread inside the
kernel for many operations, making I/O on macOS pretty bad), so I'm
not sure if these could be considered <em>regressions</em> the way <code>readdir()</code>'s
new behavior is.</p>
<p>I've reported this issue to Apple at
<a href="https://bugreport.apple.com/web/?problemID=45648013">https://bugreport.apple.com/web/?problemID=45648013</a>
and on OpenRadar at <a href="https://openradar.appspot.com/radar?id=5025294012383232">https://openradar.appspot.com/radar?id=5025294012383232</a>.
I'm told that issues get more attention from Apple when there are many
duplicates of the same issue. So please reference this issue if you file your
own report.</p>
<p>Now that I've elaborated on the technical details, I'd like to add some
personal commentary. While this post is about APFS, this issue of global
kernel locks during common I/O operations is not unique to APFS. I
<a href="/blog/2017/12/08/good-riddance-to-aufs/">already referenced</a> similar
issues in AUFS. And I've encountered similar behaviors with Btrfs (although
I can't recall exactly which operations). And NTFS has its own
<a href="https://github.com/Microsoft/WSL/issues/873#issuecomment-425272829">bag of problems</a>.</p>
<p>This seeming pattern of global kernel locks for common filesystem operations
and slow filesystems is really rubbing me the wrong way. Modern NVMe SSDs
are capable of reading and writing well over 2 gigabytes per second and
performing hundreds of thousands of I/O operations per second. We even have
Intel soon producing
<a href="https://newsroom.intel.com/editorials/re-architecting-data-center-memory-storage-hierarchy/">persistent solid state storage that plugs into DIMM slots</a>
because it is that friggin fast.</p>
<p>Today's storage hardware is capable of ludicrous performance. It is fast enough
that you will likely saturate multiple CPU cores processing the read or written
data coming from and going to storage - especially if you are using higher-level,
non-JITed (read: slower) programming languages (like Python). There has also been
a trend that systems are growing more CPU cores faster than they are instructions
per second per core. And SSDs only achieve these ridiculous IOPS numbers if many
I/O operations are <em>queued</em> and can be more efficiently dispatched within the
storage device. What this all means is that it probably makes sense to use
parallel I/O across multiple threads in order to extract all potential
performance from your persistent storage layer.</p>
<p>It's also worth noting that we now have solid state storage that outperforms (in
some dimensions) what DRAM from ~20 years ago was capable of. Put another way I/O
APIs and even some filesystems were designed in an era when its RAM was slower than
what today's persistent storage is capable of! While I'm no filesystems or kernel
expert, it does seem a bit silly to be using APIs and filesystems designed for an
era when storage was multiple orders of magnitude slower and systems only had a
single CPU core.</p>
<p>My takeaway is I can't help but feel that systems-level software (including the
kernel) is severely limiting the performance potential of modern storage
devices. If we have e.g. global kernel locks when performing common I/O operations,
there's no chance we'll come close to harnessing the full potential of today's
storage hardware. Furthermore, the behavior of filesystems is woefully under
documented and software developers have little solid advice for how to achieve
optimal I/O performance. As someone who cares about performance, I want to
squeeze every iota of potential out of hardware. But the lack of documentation
telling me which operations acquire locks, which strategies are best for say
reading or writing 10,000 files using N threads, etc makes this extremely
difficult. And even if this documentation existed, because of differences in
behavior across filesystems and operating systems and the difficulty in
programmatically determining the characteristics of filesystems at run time,
it is practically impossible to design a <em>one size fits all</em> approach to
high performance I/O.</p>
<p>The filesystem is a powerful concept. I want to agree and use the <em>everything is a
file</em> philosophy. Unfortunately, filesystems don't appear to be scaling very well
to support the potential of modern day storage technology. We're probably at the
point where commodity priced solid state storage is far more capable than today's
software for the majority of applications. Storage hardware manufacturers will
keep producing faster and faster storage and their marketing teams will keep
convincing us that we need to buy it. But until software catches up, chances are
most of us won't come close to realizing the true potential of modern storage
hardware. And that's even true for specialized applications that do employ tricks
taking hundreds or thousands of person hours to implement in order to eek out every
iota of performance potential. The average software developer and application
using filesystems as they were designed to be used has little to no chance of
coming close to utilizing the performance potential of modern storage devices.
That's really a shame. </p>]]></content:encoded>
    </item>
    <item>
      <title>Benefits of Clone Offload on Version Control Hosting</title>
      <link>http://gregoryszorc.com/blog/2018/07/27/benefits-of-clone-offload-on-version-control-hosting</link>
      <pubDate>Fri, 27 Jul 2018 15:48:00 PDT</pubDate>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2018/07/27/benefits-of-clone-offload-on-version-control-hosting</guid>
      <description>Benefits of Clone Offload on Version Control Hosting</description>
      <content:encoded><![CDATA[<p>Back in 2015, I implemented a feature in Mercurial 3.6 that allows
servers to advertise URLs of pre-generated <em>bundle</em> files. When a
compatible client performs a <code>hg clone</code> against a repository leveraging
this feature, it downloads and applies the bundle from a URL then goes
back to the server and performs the equivalent of an <code>hg pull</code> to obtain
the changes to the repository made after the bundle was generated.</p>
<p>On <a href="https://hg.mozilla.org/">hg.mozilla.org</a>, we've been using this
feature since 2015. We host bundles in Amazon S3 and make them available
via the CloudFront CDN. We perform
<a href="https://hg.mozilla.org/hgcustom/version-control-tools/file/99f7164339ed/hgext/hgmo/__init__.py#l1022">IP filtering on the server</a>
so clients connecting from AWS IPs are served S3 URLs corresponding to
the closest region / S3 bucket where bundles are hosted. Most
Firefox build and test automation is run out of EC2 and automatically
clones high-volume repositories from an S3 bucket hosted in the same
AWS region. (Doing an intra-region transfer is very fast and clones
can run at &gt;50 MB/s.) Everyone else clones from a CDN. See our
<a href="https://mozilla-version-control-tools.readthedocs.io/en/latest/hgmo/bundleclone.html">official docs</a>
for more.</p>
<p>I <a href="/blog/2015/10/22/cloning-improvements-in-mercurial-3.6/">last reported</a>
on this feature in October 2015. Since then, Bitbucket also
<a href="https://developer.atlassian.com/blog/2017/02/bitbucket-CDN-cloning/">deployed this feature</a>
in early 2017.</p>
<p>I was reminded of this <em>clone bundles</em> feature this week when
kernel.org posted
<a href="https://www.kernel.org/best-way-to-do-linux-clones-for-your-ci.html">Best way to do linux clones for your CI</a>
and that post was making the rounds in my version control circles.
tl;dr git.kernel.org apparently suffers high load due to high
clone volume against the Linux Git repository and since Git doesn't
have an equivalent feature to clone bundles built in to Git itself,
they are asking people to perform equivalent functionality to mitigate
server load.</p>
<p>(A <em>clone bundles</em> feature has been discussed on the Git mailing list
before. I remember finding old discussions when I was doing research
for Mercurial's feature in 2015. I'm sure the topic has come up since.)</p>
<p>Anyway, I thought I'd provide an update on just how valuable the
<em>clone bundles</em> feature is to Mozilla. In doing so, I hope maintainers
of other version control tools see the obvious benefits and consider
adopting the feature sooner.</p>
<p>In a typical week, hg.mozilla.org is currently serving ~135 TB of
data. The overwhelming majority of this data is related to the Mercurial
wire protocol (i.e. not HTML / JSON served from the web interface).
Of that ~135 TB, ~5 TB is served from the CDN, ~126 TB is served from
S3, and ~4 TB is served from the Mercurial servers themselves. In other
words, <strong>we're offloading ~97% of bytes served from the Mercurial servers
to S3 and the CDN</strong>.</p>
<p>If we assume this offloaded ~131 TB is equally distributed throughout
the week, this comes out to ~1,732 Mbps on average. In reality, we do
most of our load from California's Sunday evenings to early Friday
evenings. And load is typically concentrated in the 12 hours when
the sun is over Europe and North America (where most of Mozilla's
employees are based). So the typical throughput we are offloading is
more than 2 Gbps. And at a lower level, automation tends to perform
clones soon after a push is made. So load fluctuates significantly
throughout the day, corresponding to when pushes are made.</p>
<p>By volume, most of the data being offloaded is for the
<a href="https://hg.mozilla.org/mozilla-unified">mozilla-unified</a> Firefox
repository. Without clone bundles and without the special <em>stream
clone</em> Mercurial feature (which we also leverage via clone bundles), the
servers would be generating and sending ~1,588 MB of zstandard level 3
compressed data for each clone of that repository. Each clone would
consume ~280s of CPU time on the server. And at ~195,000 clones per
month, that would come out to ~309 TB/mo or ~72 TB/week. In CPU time,
that would be ~54.6 million CPU-seconds, or ~21 CPU-months. I will
leave it as an exercise to the reader to attach a dollar cost to how
much it would take to operate this service without clone bundles. But
I will say the total AWS bill for our S3 and CDN hosting for this
service is under $50 per month. (It is worth noting that intra-region
data transfer from S3 to other AWS services is free. And we are
definitely taking advantage of that.)</p>
<p>Despite a significant increase in the size of the Firefox repository and
clone volume of it since 2015, our servers are still performing less
work (in terms of bytes transferred and CPU seconds consumed) than they
were in 2015. The ~97% of bytes and millions of CPU seconds offloaded
in any given week have given us a lot of breathing room and have
saved Mozilla several thousand dollars in hosting costs. The feature
has likely helped us avoid many operational incidents due to high server
load. It has made Firefox automation faster and more reliable.</p>
<p>Succinctly, Mercurial's <em>clone bundles</em> feature has successfully and
largely effortlessly offloaded a ton of load from the hg.mozilla.org
Mercurial servers. Other version control tools should implement this
feature because it is a game changer for server operators <strong>and</strong>
results in a better client-side experience (eliminates server-side CPU
bottleneck and may eliminate network bottleneck due to a geo-local CDN
typically being as fast as your Internet pipe). It's a win-win. And a
massive win if you are operating at scale.</p>]]></content:encoded>
    </item>
    <item>
      <title>Deterministic Firefox Builds</title>
      <link>http://gregoryszorc.com/blog/2018/06/20/deterministic-firefox-builds</link>
      <pubDate>Wed, 20 Jun 2018 11:10:00 PDT</pubDate>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2018/06/20/deterministic-firefox-builds</guid>
      <description>Deterministic Firefox Builds</description>
      <content:encoded><![CDATA[<p>As of Firefox 60, the build environment for official Firefox Linux builds
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1399679">switched</a> from CentOS
to Debian.</p>
<p>As part of the transition, we overhauled how the build environment for
Firefox is constructed. We now populate the environment from deterministic
package snapshots and are much more stringent about dependencies and operations
being deterministic and reproducible. The end result is that the build
environment for Firefox is deterministic enough to enable Firefox itself
to be built deterministically.</p>
<p>Changing the underlying operating system environment used for builds was
a risky change. Differences in the resulting build could result in new
bugs or some users not being able to run the official builds. We figured
a good way to mitigate that risk was to make the old and new builds as
bit-identical as possible. After all, if the environments produce the same
bits, then nothing has effectively changed and there should be no new risk
for end-users.</p>
<p>Employing the <em>diffoscope</em> tool, we identified areas where Firefox builds
weren't deterministic in the same environment and where there was variance
across build environments. We iterated on differences and changed systems
so variance would no longer occur. By the end of the process, we had
bit-identical Firefox builds across environments.</p>
<p>So, as of Firefox 60, Firefox builds on Linux are deterministic in our
official build environment!</p>
<p>That being said, the builds we ship to users are using PGO. And an
end-to-end build involving PGO is intrinsically not deterministic because
it relies on timing data that varies from one run to the next. And we don't
yet have continuous automated end-to-end testing that determinism holds.
But the underlying infrastructure to support deterministic and reproducible
Firefox builds is there and is not going away. I think that's a milestone
worth celebrating.</p>
<p>This milestone required the effort of many people, often working indirectly
toward it. Debian's <a href="https://wiki.debian.org/ReproducibleBuilds">reproducible builds</a>
effort gave us an operating system that provided deterministic and
reproducible guarantees. Switching Firefox CI to Taskcluster enabled us
to switch to Debian relatively easily. Many were involved with
non-determinism fixes in Firefox over the years. But Mike Hommey drove the
transition of the build environment to Debian and he deserves recognition for
his individual contribution. Thanks to all these efforts - and especially Mike
Hommey's - we can now say <em>Firefox builds deterministically</em>!</p>
<p>The
<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=885777">fx-reproducible-build</a> bug
tracks ongoing efforts to further improve the reproducibility story of
Firefox. (~300 bugs in its dependency tree have already been resolved!)</p>]]></content:encoded>
    </item>
    <item>
      <title>Scaling Firefox Development Workflows</title>
      <link>http://gregoryszorc.com/blog/2018/05/16/scaling-firefox-development-workflows</link>
      <pubDate>Wed, 16 May 2018 16:10:00 PDT</pubDate>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2018/05/16/scaling-firefox-development-workflows</guid>
      <description>Scaling Firefox Development Workflows</description>
      <content:encoded><![CDATA[<p>One of the central themes of my time at Mozilla has been my pursuit
of making it easier to contribute to and hack on Firefox.</p>
<p>I vividly remember my first day at Mozilla in 2011 when I went to
build Firefox for the first time. I thought the entire experience -
from obtaining the source code, installing build dependencies, building,
running tests, submitting patches for review, etc was quite... lacking.
When I asked others if they thought this was an issue, many rightfully
identified problems (like the build system being slow). But there was
a significant population who seemed to be naive and/or apathetic to
the breadth of the user experience shortcomings. This is totally
understandable: the scope of the problem is immense and various
people don't have the perspective, are blinded/biased by personal
experience, and/or don't have the product design or UX experience
necessary to comprehend the problem.</p>
<p><strong>When it comes to contributing to Firefox, I think the problems have
as much to do with user experience (UX) as they do with technical
matters.</strong> As I
<a href="/blog/2012/05/07/improving-the-mozilla-build-system-experience/">wrote in 2012</a>,
<em>user experience matters and developers are people too.</em> You can have
a technically superior product, but if the UX is bad, you will have a
hard time attracting and retaining new users. And existing users won't
be as happy. These are the kinds of problems that a product manager or
designer deals with. A difference is that in the case of Firefox
development, the target audience is a very narrow and highly
technically-minded subset of the larger population - much smaller than
what your typical product targets. The total addressable population is
(realistically) in the thousands instead of millions. But this doesn't
mean you ignore the principles of good product design when designing
developer tooling. <strong>When it comes to developer tooling and workflows, I
think it is important to have a <em>product manager</em> mindset and treat it
not as a collection of tools for technically-minded individuals, but as
a product having an overall experience.</strong> You only have to look as far as
the Firefox Developer Tools to see this approach applied and the positive
results it has achieved.</p>
<p>Historically, Mozilla has lacked a formal team with the domain expertise
and mandate to treat Firefox contribution as a <em>product</em>. We didn't have
anything close to this until a few years ago. Before we had such a team,
I took on some of these problems individually. In 2012, I wrote <code>mach</code> - a
generic CLI command dispatch tool - to provide a central, convenient,
and easy-to-use command to discover development actions and to run them.
(Read the <a href="/blog/2012/09/26/mach-has-landed/">announcement blog post</a> for
some historical context.) I also
<a href="/blog/2012/09/18/bootstrap-your-system-to-build-firefox/">introduced</a>
a one-line bootstrap tool (now <code>mach bootstrap</code>) to make it easier to
configure your machine for building Firefox. A few months later, I
was responsible for
<a href="/blog/2013/02/28/moz.build-files-and-the-firefox-build-system/">introducing moz.build files</a>,
which paved the way for countless optimizations and for rearchitecting
the Firefox build system to use modern tools - a project that is still
ongoing (digging out from ~two decades of technical debt is a massive
effort). And a few months after that, I started going down the version
control rabbit hole and improving matters there. And I was also heavily
involved with MozReview for improving the code review experience.</p>
<p>Looking back, I was responsible for and participated in a ton of
foundational changes to how Firefox is developed. Of course, dozens of
others have contributed to getting us to where we are today and I can't
and won't take credit for the hard work of others. Nor will I claim I was the
only person coming up with good ideas or transforming them into reality. I
can name several projects (like Taskcluster and Treeherder) that have
been just as or more transformational than the changes I can take credit
for. It would be vain and naive of me to elevate my contributions on a
taller pedestal and I hope nobody reads this and thinks I'm doing that.</p>
<p>(On a personal note, numerous people have told me that things like <code>mach</code>
and the bootstrap tool have transformed the Firefox contribution experience
for the better. I've also had very senior people tell me that they don't
understand why these tools are important and/or are skeptical of the need
for investments in this space. I've found this dichotomy perplexing and
troubling. Because some of the <em>detractors</em> (for lack of a better word) are
highly influential and respected, their apparent skepticism sews seeds of
doubt and causes me to second guess my contributions and world view. This
feels like a form or variation of imposter syndrome and it is something I
have struggled with during my time at Mozilla.)</p>
<p>From my perspective, the previous five or so years in Firefox development
workflows has been about initiating foundational changes and executing on
them. When it was introduced, <code>mach</code> was <em>radical</em>. It didn't do much and
its use was optional. Now almost everyone uses it. Similar stories have
unfolded for Taskcluster, MozReview, and various other tools and
platforms. In other words, we laid a foundation and have been steadily
building upon it for the past several years. That's not to say other
foundational changes haven't occurred since (they have - the imminent switch
to Phabricator is a terrific example). But the volume of foundational
changes has slowed since 2012-2014. (I think this is due to Mozilla
deciding to invest more in tools as a result of growing pains from
significant company expansion that began in 2010. With that investment, we
invested in the bigger ticket long-standing workflow pain points, such as
CI (Taskcluster), the Firefox build system, Treeherder, and code review.)</p>
<h2>Workflows Today and in the Future</h2>
<p>Over the past several years, the size, scope, and complexity of Firefox
development activities has increased.</p>
<p>One way to see this is at the source code level. The following chart
shows the size of the <a href="https://hg.mozilla.org/mozilla-central/">mozilla-central</a>
version control repository over time.</p>
<p><img alt="mozilla-central size over time" src="/images/firefox-repo-size-over-time.png" /></p>
<p>The size increases are obvious. The increases cumulatively represent
new features, technologies, and workflows. For example, the repository
contains thousands of <em>Web Platform Tests</em> (WPT) files, a shared test
suite for web platform implementations, like Gecko and Blink. WPT didn't
exist a few years ago. Now we have files under source control, tools for
running those tests, and workflows revolving around changing those tests.
The incorporation of Rust and components of Servo into Firefox is also
responsible for significant changes. Firefox features such as Developer
Tools have been introduced or ballooned in size in recent years. The
<em>Go Faster</em> project and the move to system add-ons has introduced various
new workflows and challenges for testing Firefox.</p>
<p>Many of these changes are building upon the user-facing foundational
workflow infrastructure that was last significantly changed in 2012-2014.
This has definitely contributed to some growing pains. For example, there
are now 92 <code>mach</code> commands instead of like 5. <code>mach help</code> - intended to
answer <em>what can I do and how should I do it</em> - is overwhelming, especially
to new users. The repository is around 2 gigabytes of data to clone instead
of around 500 megabytes. We have 240,000 files in a full checkout instead
of 70,000 files. There's a <strong>ton</strong> of new pieces floating around. Any
product manager tasked with user acquisition and retention will tell you
that increasing the barrier to entry and use will jeopardize these
outcomes. But with the growth of Firefox's technical underbelly in the
previous years, we've made it harder to contribute by requiring users to
download and see a lot more files (version control) and be overwhelmed
by all the options for actions to take (<code>mach</code> having 92 commands). And
as the sheer number of components constituting Firefox increases, it
becomes harder and harder for everyone - not just new contributors - to
reason about how everything fits together.</p>
<p>I've been framing this general problem as <em>scaling Firefox development
workflows</em> and <strong>every time I think about the high-level challenges facing
Firefox contribution today and in the years ahead, this problem floats
to the top of my list of concerns</strong>. Yes, we have pressing issues like
improving the code review experience and making the Firefox build
system and Taskcluster-based CI fast, efficient, and reliable. But even
if you make these individual pieces great, there is still a cross-domain
problem of how all these components weave together. <strong>This is why I think
it is important to take a wholistic view and treat developer workflow
as a product.</strong></p>
<p>When I look at this the way a product manager or designer would, I see a
few fundamental problems that need addressing.</p>
<p>First, we're not optimizing for comprehensive end-to-end workflows. By and
large, we're designing our tools in isolation. We focus more on maximizing
the individual components instead of maximizing the interaction between
them. For example, Taskcluster and Treeherder are pretty good in isolation.
But we're missing features like Treeherder being able to tell me the
command to run locally to reproduce a failure: I want to see a failure on
Treeherder and be able to copy and paste commands into my terminal to
debug the failure. In the case of code review, we've designed two good
code review tools (MozReview and Phabricator) but we haven't invested in
making submitting code reviews turn key (the initial system configuration
is difficult and we still don't have things like automatic bug filing or
reviewer selection). <strong>We are leaving many workflow optimizations on
the table by not implementing thoughtful tie-ins and transitions between
various tools.</strong></p>
<p>Second, by-and-large we're still optimizing for a single, monolithic user
segment instead of recognizing and optimizing for different users and
their workflow requirements. For example, <code>mach help</code> lists 92 commands.
I don't think any single person cares about all 92 of those commands. The
average person may only care about 10 or even 20. In terms of user
interface design, the features and workflow requirements of small user
segments are polluting the interface for all users and making the entire
experience complicated and difficult to reason about. As a concrete
example, why should a system add-on developer or a Firefox Developer Tools
developer (these people tend to care about testing a standalone Firefox
add-on) care about Gecko's build system or tests? If you aren't touching
Gecko or Firefox's <em>chrome</em> code, why should you be exposed to workflows
and requirements that don't have a major impact on you? Or something more
extreme, if you are developing a standalone Rust module or Python package
in mozilla-central, why do you need to care about Firefox at all? (Yes,
Firefox or another downstream consumer may care about changes to that
<em>standalone</em> component and you can't ignore those dependencies. But it
should at least be possible to hide those dependencies.)</p>
<p>Waving my hands, the solution to these problems is to treat Firefox
development workflow as a product and to apply the same rigor that we
use for actual Firefox product development. Give people with a vision
for the entire workflow the ability to prioritize investment across
tools and platforms. Give them a process for defining features that
work across tools. Perform formal user studies. See how people are
actually using the tools you build. Bring in design and user experience
experts to help formulate better workflows. Perform user typing so
different, segmentable workflows can be optimized for. Treat developers
as you treat users of <em>real</em> products: listen to them. Give developers
a voice to express frustrations. Let them tell you what they are trying
to do and what they wish they could do. Integrate this feedback into a
feature roadmap. Turn common feedback into action items for new features.</p>
<p>If you think these ideas are silly and it doesn't make sense to apply a
<em>product mindset</em> to developer workflows and tooling, then you should be
asking whether product management and all that it entails is also a silly
idea. If you believe that aspects of product management have beneficial
outcomes (which most companies do because otherwise there wouldn't be
product managers), then why <em>wouldn't</em> you want to apply the methods of
that discipline to developers and development workflows? Developers are
users too and the fact that they work for the same company that is
creating the product shouldn't make them immune from the benefits of
product management.</p>
<p>If we want to make contributing to Firefox an even better experience for
Mozilla employees and community contributors, I think we need to take a step
back and assess the situation as a product manager would. The improvements
that have been made to the individual pieces constituting Firefox's
development workflow during my nearly seven years at Mozilla have been
incredible. But I think in order to achieve the next round of major
advancements in workflow productivity, we'll need to focus on how all of
the pieces fit together. And that requires treating the entire workflow
as a cohesive product.</p>]]></content:encoded>
    </item>
    <item>
      <title>Revisiting Using Docker</title>
      <link>http://gregoryszorc.com/blog/2018/05/16/revisiting-using-docker</link>
      <pubDate>Wed, 16 May 2018 13:45:00 PDT</pubDate>
      <category><![CDATA[Docker]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2018/05/16/revisiting-using-docker</guid>
      <description>Revisiting Using Docker</description>
      <content:encoded><![CDATA[<p>When Docker was taking off like wildfire in 2013, I was caught up in the
excitement like everyone else. I remember knowing of the existence
of LXC and container technologies in Linux at the time. But Docker seemed to
be the first open source tool to actually make that technology usable (a
terrific example of how user experience matters).</p>
<p>At Mozilla, Docker was adopted all around me and by me for various utilities.
<a href="https://docs.taskcluster.net/">Taskcluster</a> - Mozilla's task execution
framework geared for running complex CI systems - adopted Docker as a
mechanism to run processes in self-contained images. Various groups in
Mozilla adopted Docker for running services in production. I adopted Docker
for
<a href="/blog/2015/01/24/end-to-end-testing-with-docker/">integration testing of complex systems</a>.</p>
<p>Having seen various groups use Docker and having spent a lot of time in the
trenches battling technical problems, my conclusion is <strong>Docker is unsuitable
as a general purpose container runtime. Instead, Docker has its niche
for hosting complex network services.</strong> Other uses of Docker should be highly
scrutinized and potentially discouraged.</p>
<p>When Docker hit first the market, it was arguably the only game in town.
Using Docker to achieve containerization was defensible because there weren't
exactly many (any?) practical alternatives. So if you wanted to use containers,
you used Docker.</p>
<p>Fast forward a few years. We now have the
<a href="https://www.opencontainers.org/">Open Container Initiative</a> (OCI). There are
specifications describing common container formats. So you can produce a
container once and take it to any number OCI compatible <em>container runtimes</em>
for execution. And in 2018, there are a <em>ton</em> of players in this space.
<a href="https://github.com/opencontainers/runc">runc</a>,
<a href="https://github.com/rkt/rkt">rkt</a>, and
<a href="https://github.com/google/gvisor">gVisor</a> are just some. So Docker is no
longer the only viable tool for executing a container. If you are just
getting started with the container space, you would be wise to research the
available options and their pros and cons.</p>
<p>When you look at all the options for running containers in 2018, I think it
is obvious that Docker - usable though it may be - is not ideal for a
significant number of container use cases. If you divide use cases into a spectrum
where one end is <em>run a process in a sandbox</em> and the other is <em>run a complex system
of orchestrated services in production</em>, Docker appears to be focusing on the
latter. Take it from <a href="https://www.docker.com/what-docker">Docker themselves</a>:</p>
<p><em>Docker is the company driving the container movement and the only container
platform provider to address every application across the hybrid cloud. Today's
businesses are under pressure to digitally transform but are constrained by
existing applications and infrastructure while rationalizing an increasingly
diverse portfolio of clouds, datacenters and application architectures. Docker
enables true independence between applications and infrastructure and developers
and IT ops to unlock their potential and creates a model for better
collaboration and innovation.</em></p>
<p>That description of Docker (the company) does a pretty good job of
describing what Docker (the technology) has become: a constellation
of software components providing the underbelly for managing complex
applications in complex infrastructures. That's pretty far detached on the
spectrum from <em>run a process in a sandbox</em>.</p>
<p>Just because Docker (the company) is focused on a complex space doesn't mean
they are incapable of exceeding at solving simple problems. However, I believe
that in this particular case, the complexity of what Docker (the company) is
focusing on has inhibited its Docker products to adequately address simple
problems.</p>
<p>Let's dive into some technical specifics.</p>
<p>At its most primitive, Docker is a glorified tool to run a process in a
sandbox. On Linux, this is accomplished by using
the <a href="http://man7.org/linux/man-pages/man2/clone.2.html">clone(2)</a> function
with specific flags and combined with various other techniques (filesystem
remounting, capabilities, cgroups, chroot, seccomp, etc) to <em>sandbox</em> the
process from the main operating system environment and kernel. There are a host
of tools living at this not-quite-containers level that make it easy to run
a sandboxed process. The
<a href="https://github.com/projectatomic/bubblewrap">bubblewrap</a> tool is one of them.</p>
<p>Strictly speaking, you don't need anything fancy to create a process
sandbox: just an executable you want to invoke and an executable that makes
a set of system calls (like bubblewrap) to run that executable.</p>
<p>When you install Docker on a machine, it starts a daemon running as root.
That daemon listens for HTTP requests on a network port and/or UNIX socket.
When you run <code>docker run</code> from the command line, that command establishes
a connection to the Docker daemon and sends any number of HTTP requests to
instruct the daemon to take actions.</p>
<p>A daemon with a remote control protocol is useful. But it shouldn't be the
only way to spawn containers with Docker. If all I want to do is spawn a temporary
container that is destroyed afterwards, I should be able to do that from
a local command without touching a network service. Something like bubblewrap.
The daemon adds all kinds of complexity and overhead. Especially if I just want
to run a simple, short-lived command.</p>
<p>Docker at this point is already pretty far detached from a tool like bubblewrap.
And the disparity gets worse.</p>
<p>Docker adds another abstraction on top of basic process sandboxing in the form
of storage / filesystem management. Docker insists that processes execute in
self-contained, chroot()'d filesystem environment and that these environments
(Docker images) be managed by Docker itself. When Docker images are <em>imported</em>
into Docker, Docker manages them using one of a handful of
<a href="https://docs.docker.com/storage/storagedriver/">storage drivers</a>. You can choose
from devicemapper, overlayfs, zfs, btrfs, and aufs and employ various
configurations of all these. Docker images are composed of <em>layers</em>, with one
layer stacked on top of the prior. This allows you to have an immutable base
layer (that can be shared across containers) where run-time file changes can be
isolated to a specific container instance.</p>
<p>Docker's ability to manage storage is pretty cool. And I dare say Docker's killer
feature in the very beginning of Docker was the ability to easily produce and
exchange self-contained Docker <em>images</em> across machines.</p>
<p>But this utility comes at a <em>very</em> steep price. Again, if our use case is
<em>run a process in a sandbox</em>, do we really care about all this advanced
storage functionality? Yes, if you are running hundreds of containers on
a single system, a storage model built on top of copy-on-write is perhaps
necessary for scaling. But for simple cases where you just want to run a single
or small number of processes, it is extremely overkill and adds many more
problems than it solves.</p>
<p>I cannot stress this enough, but <strong>I have spent hours debugging and working
around problems due to how filesystems/storage works in Docker</strong>.</p>
<p>When Docker was initially released, aufs was widely used. As I
<a href="/blog/2017/12/08/good-riddance-to-aufs/">previously wrote</a>, aufs has abysmal
performance as you scale up the number of concurrent I/O operations. We shaved
<strong>minutes</strong> off tasks in Firefox CI by ditching aufs for overlayfs.</p>
<p>But overlayfs is far from a panacea. File metadata-only updates are
<a href="https://hg.mozilla.org/hgcustom/version-control-tools/rev/63f19cfacc5c">apparently very slow in overlayfs</a>.
We're talking ~100ms to call <code>fchownat()</code> or <code>utimensat()</code>. If you perform
an <code>rsync -a</code> or <code>chown -R</code> on a directory with only just a hundred files that
were defined in a base image layer, you can have delays of seconds.</p>
<p>The Docker storage drivers backed by <em>real</em> filesystems like zfs and btrfs are
a bit better. But they have their quirks too. For example, creating layers in
images is comparatively very slow compared to overlayfs (which are practically
instantaneous). This matters when you are iterating on a Dockerfile for example
and want to quickly test changes. Your edit-compile cycle grows frustratingly
long very quickly.</p>
<p>And I could opine on a handful of other problems I've encountered over the years.</p>
<p>Having spent hours of my life debugging and working around issues with
Docker's storage, my current attitude is <em>enough of this complexity, just let me
use a directory backed by the local filesystem, dammit</em>.</p>
<p>For many use cases, <strong>you don't need the storage complexity that Docker forces
upon you</strong>. Pointing Docker at a directory on a local filesystem to chroot into
is <em>good enough</em>. I know the behavior and performance properties of common Linux
filesystems. ext4 isn't going to start making <code>fchownat()</code> or <code>utimensat()</code> calls
take ~100ms. It isn't going to complain when a hard link spans multiple layers in
an image. Or slow down to a crawl when multiple threads are performing concurrent
read I/O. There's not going to be intrinsically complicated algorithms and
caching to walk N image layers to find the most recent version of a file (or if
there is, it will be so far down the stack in kernel land that I likely won't
ever have to deal with it as a normal user). Docker images with their multiple
layers add complexity and overhead. For many use uses, the pain it inflicts
offsets the initial convenience it saves.</p>
<p>Docker's optimized-for-complex-use-cases architecture demonstrates its
inefficiency in simple benchmarks.</p>
<p>On my machine, <code>docker run -i --rm debian:stretch /bin/ls /</code> takes ~850ms.
Almost a second to perform a directory listing (sometimes it does take over
1 second - I was being generous and quoting a quicker time). This command
takes ~1ms when run in a local shell. So we're at 2.5-3 magnitudes of overhead.
The time here does include time to initially create the container and
destroy it afterwards. We can isolate that overhead by starting a persistent
container and running <code>docker exec -i &lt;cid&gt; /bin/ls /</code> to spawn a new process
in an existing container. This takes ~85ms. So, ~2 magnitudes of overhead to
spawn a process in a Docker container versus spawning it <em>natively</em>. What's
adding so much overhead, I'm not sure. Yes, there are HTTP requests under
the hood. But HTTP to a local daemon shouldn't be that slow. I'm not sure
what's going on.</p>
<p>If we <code>docker export</code> that image to the local filesystem and use <code>runc state</code>
to configure so we can run it with <code>runc</code>, <code>runc run</code> takes ~85ms to run
<code>/bin/ls /</code>. If we <code>runc exec &lt;cid&gt; /bin/ls /</code> to start a process in an
existing container, that completes in ~10ms. <code>runc</code> appears to be executing
these simple tasks ~10x faster than Docker.</p>
<p>But to even get to that point, we had to make a filesystem available to
spawn the container in. With Docker, you need to load an image into Docker.
Using <code>docker save</code> to produce a 105,523,712 tar file,
<code>docker load -i image.tar</code> takes ~1200ms to complete. <code>tar xf image.tar</code>
takes ~65ms to extract that image to the local filesystem. Granted, Docker
is computing the SHA-256 of the image as part of import. But SHA-256 runs
at ~250MB/s on my machine and on that ~105MB input takes ~400ms. Where is
that extra ~750ms of overhead in Docker coming from?</p>
<p>The Docker image loading overhead is still present on large images. With
a 4,336,605,184 image, <code>docker load</code> was taking ~32s and <code>tar x</code> was
taking ~2s. Obviously the filesystem was buffering writes in the <code>tar</code>
case. And the ~2s is ignoring the ~17s to obtain the SHA-256 of the
entire input. But there's still a substantial disparity here. (I suspect
a lot of it is overlayfs not being as optimal as ext4.)</p>
<p>Several years ago there weren't many good choices for tools to execute containers.
But today, there are good tools readily available. And thanks to OCI standards,
you can often swap in alternate container runtimes. Docker (the tool) has an
architecture that is optimized for solving complex use cases (coincidentally use
cases that Docker the company makes money from). Because of this, my conclusion -
drawn from using Docker for several years - is that Docker is unsuitable for
many common use cases. <strong>If you care about low container startup/teardown
overhead, low latency when interacting with containers (including spawning
processes from outside of them), and for workloads where Docker's storage model
interferes with understanding or performance, I think Docker should be avoided.</strong>
A simpler tool (such as <code>runc</code> or even <code>bubblewrap</code>) should be used instead.</p>
<p>Call me a curmudgeon, but having seen all the problems that Docker's complexity
causes, I'd rather see my containers resemble a tarball that can easily be
chroot()'d into. <strong>I will likely be revisiting projects that use Docker and
replacing Docker with something lighter weight and architecturally simpler.</strong> As
for the use of Docker in the more complex environments it seems to be designed
for, I don't have a meaningful opinion as I've never really used it in that
capacity. But given my negative experiences with Docker over the years, I am
definitely biased against Docker and will lean towards simpler products, especially
if their storage/filesystem management model is simpler. Docker introduced
containers to the masses and they should be commended for that. But for my
day-to-day use cases for containers, Docker is simply not the right tool for
the job.</p>
<p>I'm not sure exactly what I'll replace Docker with for my simpler use cases.
If you have experiences you'd like to share, sharing them in the comments
will be greatly appreciated.</p>]]></content:encoded>
    </item>
    <item>
      <title>Release of python-zstandard 0.9</title>
      <link>http://gregoryszorc.com/blog/2018/04/09/release-of-python-zstandard-0.9</link>
      <pubDate>Mon, 09 Apr 2018 09:30:00 PDT</pubDate>
      <category><![CDATA[Python]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2018/04/09/release-of-python-zstandard-0.9</guid>
      <description>Release of python-zstandard 0.9</description>
      <content:encoded><![CDATA[<p>I have just released
<a href="https://pypi.python.org/pypi/zstandard/0.9.0">python-zstandard 0.9.0</a>. You can
install the latest release by running <code>pip install zstandard==0.9.0</code>.</p>
<p><a href="http://facebook.github.io/zstd/">Zstandard</a> is a highly tunable and therefore
flexible compression algorithm with support for modern features such as
multi-threaded compression and <em>dictionaries</em>. Its performance is remarkable
and if you use it as a drop-in replacement for zlib, bzip2, or other common
algorithms, you'll frequently see more than a doubling in performance.</p>
<p>python-zstandard provides rich bindings to the zstandard C library without
sacrificing performance, safety, features, or a Pythonic feel. The bindings
run on Python 2.7, 3.4, 3.5, 3.6, 3.7 using either a C extension or CFFI
bindings, so it works with CPython and PyPy.</p>
<p>I can make a compelling argument that python-zstandard is one of the
richest compression packages available to Python programmers. Using it, you
will be able to leverage compression in ways you couldn't with other packages
(especially those in the standard library) all while achieving ridiculous
performance. Due to my focus on performance, python-zstandard is able to
outperform Python bindings to other compression libraries that <em>should</em> be
faster. This is because python-zstandard is very diligent about minimizing
memory allocations and copying, minimizing Python object creation, reusing
state, etc.</p>
<p>While python-zstandard is formally marked as a beta-level project and hasn't
yet reached a 1.0 release, it is suitable for production usage.
python-zstandard 0.8 shipped with Mercurial and is in active production
use there. I'm also aware of other consumers using it in production, including
at Facebook and Mozilla.</p>
<p>The sections below document some of the new features of python-zstandard 0.9.</p>
<h2>File Object Interface for Reading</h2>
<p>The 0.9 release contains a <code>stream_reader()</code> API on the compressor and
decompressor objects that allows you to treat those objects as readable file
objects. This means that you can pass a <code>ZstdCompressor</code> or <code>ZstdDecompressor</code>
around to things that accept file objects and things generally <em>just work</em>.
e.g.:</p>
<div class="pygments_murphy"><pre><span></span>   <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">compressed_file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">ifh</span><span class="p">:</span>
       <span class="n">cctx</span> <span class="o">=</span> <span class="n">zstd</span><span class="o">.</span><span class="n">ZstdDecompressor</span><span class="p">()</span>
       <span class="k">with</span> <span class="n">cctx</span><span class="o">.</span><span class="n">stream_reader</span><span class="p">(</span><span class="n">ifh</span><span class="p">)</span> <span class="k">as</span> <span class="n">reader</span><span class="p">:</span>
           <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
               <span class="n">chunk</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">32768</span><span class="p">)</span>
               <span class="k">if</span> <span class="ow">not</span> <span class="n">chunk</span><span class="p">:</span>
                   <span class="k">break</span>
</pre></div>

<p>This is probably the most requested python-zstandard feature.</p>
<p>While the feature is usable, it isn't complete. Support for <code>readline()</code>,
<code>readinto()</code>, and a few other APIs is not yet implemented. In addition,
you can't use these <em>reader</em> objects for opening zstandard compressed
tarball files because Python's <code>tarfile</code> package insists on doing
backward seeks when reading. The current implementation doesn't support
backwards seeking because that requires buffering decompressed output and that
is not trivial to implement. I recognize that all these features are useful
and I will try to work them into a subsequent release of 0.9.</p>
<h2>Negative Compression Levels</h2>
<p>The 1.3.4 release of zstandard (which python-zstandard 0.9 bundles) supports
negative compression levels. I won't go into details, but negative compression
levels disable extra compression features and allow you to trade compression
ratio for more speed.</p>
<p>When compressing a 6,472,921,921 byte uncompressed bundle of the Firefox
Mercurial repository, the previous fastest we could go with level 1 was
~510 MB/s (measured on the input side) yielding a 1,675,227,803 file (25.88%
of original).</p>
<p>With level <code>-1</code>, we compress to 1,934,253,955 (29.88% of original) at
~590 MB/s. With level <code>-5</code>, we compress to 2,339,110,873 bytes (36.14% of
original) at ~720 MB/s.</p>
<p>On the decompress side, level 1 decompresses at ~1,150 MB/s (measured at
the output side), -1 at ~1,320 MB/s, and -5 at ~1,350 MB/s (generally speaking,
zstandard's decompression speeds are relatively similar - and fast - across
compression levels).</p>
<p>And that's just with a single thread. zstandard supports using multiple
threads to compress a single input and python-zstandard makes this feature
easy to use. Using 8 threads on my 4+4 core i7-6700K, level 1 compresses
at ~2,000 MB/s (3.9x speedup), -1 at ~2,300 MB/s (3.9x speedup), and -5
at ~2,700 MB/s (3.75x speedup).</p>
<p>That's with a large input. What about small inputs?</p>
<p>If we take 456,599 Mercurial commit objects spanning 298,609,254 bytes from
the Firefox repository and compress them individually, at level 1 we yield
a total of 133,457,198 bytes (44.7% of original) at ~112 MB/s. At level -1,
we compress to 161,241,797 bytes (54.0% of original) at ~215 MB/s. And at
level -5, we compress to 185,885,545 bytes (62.3% of original) at ~395 MB/s.</p>
<p>On the decompression side, level 1 decompresses at ~260 MB/s, -1 at
~1,000 MB/s, and -5 at ~1,150 MB/s.</p>
<p>Again, that's 456,599 operations on a single thread with Python.</p>
<p>python-zstandard has an <em>experimental</em> API where you can pass in a collection
of inputs and it batch compresses or decompresses them in a single operation.
It releases and GIL and uses multiple threads. It puts the results in shared
buffers in order to minimize the overhead of memory allocations and Python
object creation and garbage collection. Using this mode with 8 threads on
my 4+4 core i7-6700K, level 1 compresses at ~525 MB/s, -1 at ~1,070 MB/s,
and -5 at ~1,930 MB/s. On the decompression side, level 1 is ~1,320 MB/s,
-1 at ~3,800 MB/s, and -5 at ~4,430 MB/s.</p>
<p>So, my consumer grade desktop i7-6700K is capable of emitting decompressed
data at over 4 GB/s with Python. That's pretty good if you ask me. (Full
disclosure: the timings were taken just around the compression operation
itself: overhead of loading data into memory was not taken into account. See
the <code>bench.py</code> script in the
<a href="https://github.com/indygreg/python-zstandard">source repository</a> for more.</p>
<h2>Long Distance Matching Mode</h2>
<p>Negative compression levels take zstandard into performance territory that
has historically been reserved for compression formats like lz4 that are
optimized for that domain. <em>Long distance matching</em> takes zstandard in the
other direction, towards compression formats that aim to achieve optimal
compression ratios at the expense of time and memory usage.</p>
<p>python-zstandard 0.9 supports long distance matching and all the configurable
parameters exposed by the zstandard API.</p>
<p>I'm not going to capture many performance numbers here because python-zstandard
performs about the same as the C implementation because <em>LDM</em> mode spends
most of its time in zstandard C code. If you are interested in numbers, I
recommend reading the zstandard
<a href="https://github.com/facebook/zstd/releases/tag/v1.3.2">1.3.2</a>
and <a href="https://github.com/facebook/zstd/releases/tag/v1.3.4">1.3.4</a> release notes.</p>
<p>I will, however, underscore that zstandard can achieve close to lzma's
compression ratios (what the <code>xz</code> utility uses) while completely smoking
lzma on decompression speed. For a bundle of the Firefox Mercurial repository,
zstandard level 19 with a long distance window size of 512 MB using 8 threads
compresses to 1,033,633,309 bytes (16.0%) in ~260s wall, 1,730s CPU.
<code>xz -T8 -8</code> compresses to 1,009,233,160 (15.6%) in ~367s wall, ~2,790s CPU.</p>
<p>On the decompression side, zstandard takes ~4.8s and runs at ~1,350 MB/s as
measured on the output side while <code>xz</code> takes ~54s and runs at ~114 MB/s.
Zstandard, however, does use a lot more memory than <code>xz</code> for decompression,
so that performance comes with a cost (512 MB versus 32 MB for this
configuration).</p>
<h2>Other Notable Changes</h2>
<p>python-zstandard now uses the <em>advanced</em> compression and decompression APIs
everywhere. All tunable compression and decompression parameters are available
to python-zstandard. This includes support for disabling magic headers in frames
(saves 4 bytes per frame - this can matter for very small inputs, especially when
using dictionary compression).</p>
<p>The full dictionary training API is exposed. Dictionary training can now use
multiple threads.</p>
<p>There are a handful of utility functions for inspecting zstandard frames,
querying the state of compressors, etc.</p>
<p>Lots of work has gone into shoring up the code base. We now build with warnings
as errors in CI. I performed a number of focused auditing passes to fix
various classes of deficiencies in the C code. This includes use of the
<em>buffer protocol</em>: python-zstandard is now able to accept <em>any</em> Python
object that provides a view into its underlying raw data.</p>
<p>Decompression contexts can now be constructed with a max memory threshold
so attempts to decompress something that would require more memory will
result in error.</p>
<p>See the
<a href="https://github.com/indygreg/python-zstandard/releases/tag/0.9.0">full release notes</a>
for more.</p>
<h2>Conclusion</h2>
<p>Since I last released a major version of python-zstandard, a lot has changed in
the zstandard world. As I
<a href="/blog/2017/03/07/better-compression-with-zstandard/">blogged last year</a>,
zstandard circa early 2017 was a very compelling compression format: it already
outperformed popular compression formats like zlib and bzip2 across the board.
As a <em>general purpose</em> compression format, it made a compelling case for itself.
In my mind, <em>brotli</em> was its only real challenger.</p>
<p>As I wrote then, zstandard isn't perfect. (Nothing is.) But a year later, it
is refreshing to see advancements.</p>
<p>A criticism one year ago was zstandard was pretty good as a general purpose
compression format but it wasn't great if you live at the fringes. If you were
a speed freak, you'd probably use lz4. If you cared about compression ratios,
you'd probably use lzma. But recent releases of zstandard have made huge strides
into the territory of these niche formats. Negative compression levels allow
zstandard to flirt with lz4's performance. Long distance matching allows
zstandard to achieve close to lzma's compression ratios. <strong>This is a big friggin
deal because it makes it much, much harder to justify a domain-specific compression
format over zstandard.</strong> I think lzma still has a significant edge for ultra
compression ratios when memory utilization is a concern. But for many consumers,
memory is readily available and it is easy to justify trading potentially hundreds
of megabytes of memory to achieve a 10x speedup for decompression. Even if you
aren't willing to sacrifice more memory, the ability to tweak compression
parameters is huge. You can do things like store multiple versions of a
compressed document and conditionally serve the one most appropriate for the
client, all while running the same zstandard-only code on the client. That's
huge.</p>
<p>A year later, zstandard continues to impress me for its set of features and its
versatility. The library is continuing to evolve - all while maintaining
backwards compatibility on the decoding side. (That's a sign of a good
format design if you ask me.) I was honestly shocked to see that zstandard
was able to change its compression settings in a way that allowed it to compete
with lz4 and lzma without requiring a format change.</p>
<p>The more I use zstandard, the more I think that <em>everyone should use this</em> and
that popular compression formats just aren't cut out for modern computing any
more. Every time I download a zlib/gz or bzip2 compressed archive, I'm thinking
<em>if only they used zstandard this archive would be smaller, it would have
decompressed already, and I wouldn't be thinking about how annoying it is
to wait for compression operations to complete</em>. In my mind, zstandard is such
an obvious advancement over the status quo and is such a versatile format -
now covering the gamut of super fast compression to ultra ratios - that it is
bordering on negligent to not use zstandard. With the removal of the controversial
patent rights grant license clause in zstandard 1.3.1, that justifiable
resistance to widespread adoption of zstandard has been eliminated. Zstandard
is objectively superior for many workloads and I heavily encourage its use. I
believe python-zstandard provides a high-quality interface to zstandard and
I encourage you to give it and zstandard a try the next time you compress data.</p>
<p>If you run into any problems or want to get involved with development,
python-zstandard lives at
<a href="https://github.com/indygreg/python-zstandard">indygreg/python-zstandard</a> on
GitHub.</p>
<p>*(I updated the post on 2018-05-16 to remove a paragraph about zstandard
competition. In the original post, I unfairly compared zstandard to Snappy
instead of Brotli and made some inaccurate statements around that comparison.)</p>]]></content:encoded>
    </item>
    <item>
      <title>High-level Problems with Git and How to Fix Them</title>
      <link>http://gregoryszorc.com/blog/2017/12/11/high-level-problems-with-git-and-how-to-fix-them</link>
      <pubDate>Mon, 11 Dec 2017 10:30:00 PST</pubDate>
      <category><![CDATA[Git]]></category>
      <category><![CDATA[Mercurial]]></category>
      <category><![CDATA[Mozilla]]></category>
      <guid isPermaLink="true">http://gregoryszorc.com/blog/2017/12/11/high-level-problems-with-git-and-how-to-fix-them</guid>
      <description>High-level Problems with Git and How to Fix Them</description>
      <content:encoded><![CDATA[<p>I have a... complicated relationship with Git.</p>
<p>When Git first came onto the scene in the mid 2000's, I was initially
skeptical because of its horrible user interface. But once I learned
it, I appreciated its speed and features - especially the ease at which
you could create feature branches, merge, and even create commits
offline (which was a big deal in the era when Subversion was the
dominant version control tool in open source and you needed to speak with
a server in order to commit code). When I started using Git day-to-day,
it was such an obvious improvement over what I was using before (mainly
Subversion and even CVS).</p>
<p>When I started working for Mozilla in 2011, I was exposed to the
Mercurial version control, which then - and still today - hosts the
canonical repository for Firefox. I didn't like Mercurial initially.
Actually, I despised it. I thought it was slow and its features lacking.
And I frequently encountered repository corruption.</p>
<p>My first experience learning the <em>internals</em> of both Git and Mercurial
came when I found myself hacking on
<a href="http://hg-git.github.io/]">hg-git</a> - a tool that allows you to convert
Git and Mercurial repositories to/from each other. I was hacking on hg-git
so I could improve the performance of converting Mercurial repositories
to Git repositories. And I was doing that because I wanted to use Git -
not Mercurial - to hack on Firefox. I was trying to enable an unofficial
Git mirror of the Firefox repository to synchronize faster so it would
be more usable. The ulterior motive was to demonstrate that Git is a
superior version control tool and that Firefox should switch its canonical
version control tool from Mercurial to Git.</p>
<p>In what is a textbook definition of <em>irony</em>, what happened instead was
I actually learned how Mercurial worked, interacted with the Mercurial
Community, realized that Mozilla's documentation and developer practices
were... lacking, and that Mercurial was actually a much, much more
pleasant tool to use than Git. It's an old post, but I
<a href="/blog/2013/05/12/thoughts-on-mercurial-(and-git)/">summarized my conversion</a>
four and a half years ago. This started a chain of events that somehow
resulted in me contributing a ton of patches to Mercurial, taking
stewardship of <em>hg.mozilla.org</em>, and becoming a member of the Mercurial
Steering Committee - the governance group for the Mercurial Project.</p>
<p>I've been an advocate of Mercurial over the years. Some would probably say
I'm a Mercurial fanboy. I reject that characterization because <em>fanboy</em> has
connotations that imply I'm ignorant of realities. I'm well aware of
Mercurial's faults and weaknesses. I'm well aware of Mercurial's relative
lack of popularity, I'm well aware that this lack of popularity almost
certainly turns away contributors to Firefox and other Mozilla projects
because people don't want to have to learn a new tool. I'm well aware that
there are changes underway to enable Git to scale to <em>very large
repositories</em> and that these changes could threaten Mercurial's scalability
advantages over Git, making choices to use Mercurial even harder to defend.
(As an aside, the party most responsible for pushing Git to adopt
architectural changes to enable it to scale these days is Microsoft.
Could anyone have foreseen that?!)</p>
<p>I've achieved mastery in both Git and Mercurial. I know their internals
and their command line interfaces extremely well. I understand the
architecture and principles upon which both are built. I'm also exposed
to some very experienced and knowledgeable people in the Mercurial
Community. People who have been around version control for much, much
longer than me and have knowledge of random version control tools you've
probably never heard of. This knowledge and exposure allows me to make
connections and see opportunities for version control that quite frankly
most do not. </p>
<p>In this post, I'll be talking about some high-level, high-impact problems
with Git and possible solutions for them. My primary goal of this post is
to foster positive change in Git and the services around it. While I
personally prefer Mercurial, improving Git is good for everyone. Put
another way, I want my knowledge and perspective from being part of
a version control community to be put to good wherever it can.</p>
<p>Speaking of Mercurial, as I said, I'm a heavy contributor and am somewhat
influential in the Mercurial Community. I want to be clear that my opinions
in this post are my own and I'm not speaking on behalf of the Mercurial
Project or the larger Mercurial Community. I also don't intend to claim
that Mercurial is <em>holier-than-thou</em>. Mercurial has tons of user interface
failings and deficiencies. And I'll even admit to being frustrated that some
systemic failings in Mercurial have gone unaddressed for as long as they
have. But that's for another post. This post is about Git. Let's get started.</p>
<h2>The Staging Area</h2>
<p>The staging area is a feature that should not be enabled in the default
Git configuration.</p>
<p>Most people see version control as an obstacle standing in the way of
accomplishing some other task. They just want to save their progress
towards some goal. In other words, they want version control to be a
<em>save file</em> feature in their workflow.</p>
<p>Unfortunately, modern version control tools don't work that way. For
starters, they require people to specify a <em>commit message</em> every time
they save. This in of itself can be annoying. But we generally accept
that as the price you pay for version control: that <em>commit message</em> has
value to others (or even your future self). So you must record it.</p>
<p>Most people want the barrier to saving changes to be effortless. A commit
message is already too annoying for many users! The Git staging area
establishes a <em>higher</em> barrier to saving. Instead of just saving your
changes, you must first <em>stage</em> your changes to be saved.</p>
<p>If you requested <em>save</em> in your favorite GUI application, text editor,
etc and it popped open a <em>select the changes you would like to
save dialog</em>, you would rightly think <em>just save all my changes already,
dammit.</em> But this is exactly what Git does with its staging area! Git
is saying <em>I know all the changes you made: now tell me which changes
you'd like to save.</em> To the average user, this is infuriating because
it works in contrast to how the <em>save</em> feature works in almost every
other application.</p>
<p>There is a counterargument to be made here. You could say that the
editor/application/etc is complex - that it has multiple <em>contexts</em>
(files) - that each context is independent - and that the user should
have full control over which contexts (files) - and even changes within
those contexts - to save. I agree: this is a compelling feature. However,
it isn't an appropriate <em>default</em> feature. The ability to pick which
changes to save is a power-user feature. Most users just want to save all
the changes all the time. So that should be the default behavior. And
the Git staging area should be an opt-in feature.</p>
<p>If intrinsic workflow warts aren't enough, the Git staging area has a
horrible user interface. It is often referred to as the <em>cache</em>
<a href="https://stackoverflow.com/questions/6716355/why-staging-directory-is-also-called-index-git-index/6718135#6718135">for historical reasons</a>.
<em>Cache</em> of course means something to anyone who knows anything about
computers or programming. And Git's use of <em>cache</em> doesn't at all align
with that common definition. Yet the the terminology in Git persists.
You have to run commands like <code>git diff --cached</code> to examine the state
of the <em>staging area</em>. Huh?!</p>
<p>But Git also refers to the <em>staging area</em> as the <em>index</em>. And this
terminology also appears in Git commands! <code>git help commit</code> has numerous
references to the <em>index</em>. Let's see what <code>git help glossary</code> has to say::</p>
<pre><code>index
    A collection of files with stat information, whose contents are
    stored as objects. The index is a stored version of your working tree.
    Truth be told, it can also contain a second, and even a third
    version of a working tree, which are used when merging.

index entry
    The information regarding a particular file, stored in the index.
    An index entry can be unmerged, if a merge was started, but not
    yet finished (i.e. if the index contains multiple versions of that
    file).
</code></pre>
<p>In terms of end-user documentation, this is a train wreck. It tells the
lay user absolutely nothing about what the <em>index</em> actually is. Instead,
it casually throws out references to <em>stat information</em> (requires the user
know what the <code>stat()</code> function call and struct are) and <em>objects</em> (a Git
term for a piece of data stored by Git). It even undermines its own credibility
with that <em>truth be told</em> sentence. This definition is so bad that it
would probably improve user understanding if it were deleted!</p>
<p>Of course, <code>git help index</code> says <em>No manual entry for gitindex</em>. So
there is literally no hope for you to get a concise, understandable
definition of the <em>index</em>. Instead, it is one of those concepts that you
think you learn from interacting with it all the time. <em>Oh, when I
<code>git add</code> something it gets into this state where <code>git commit</code> will
actually save it.</em></p>
<p>And even if you know what the Git staging area/index/cached is, it can
still confound you. Do you know the interaction between uncommitted
changes in the staging area and working directory when you <code>git rebase</code>?
What about <code>git checkout</code>? What about the various <code>git reset</code> invocations?
I have a confession: I can't remember all the edge cases either. To play
it safe, I try to make sure all my outstanding changes are committed
before I run something like <code>git rebase</code> because I <em>know</em> that will be
safe.</p>
<p>The Git staging area doesn't have to be this complicated. A <em>re-branding</em>
away from <em>index</em> to <em>staging area</em> would go a long way. Adding an alias
from <code>git diff --staged</code> to <code>git diff --cached</code> and removing references
to the <em>cache</em> from common user commands would make a lot of sense and
reduce end-user confusion.</p>
<p>Of course, the Git staging area doesn't really need to exist at all!
The staging area is essentially a <em>soft commit</em>. It performs the
<em>save progress</em> role - the basic requirement of a version control tool.
And in some aspects it is actually a better <em>save progress</em> implementation
than a <em>commit</em> because it doesn't require you to type a commit message!
Because the <em>staging area</em> is a soft commit, all workflows using it can
be modeled as if it were a real commit and the <em>staging area</em> didn't
exist at all! For example, instead of <code>git add --interactive</code> +
<code>git commit</code>, you can run <code>git commit --interactive</code>. Or if you wish
to incrementally add new changes to an in-progress commit, you can
run <code>git commit --amend</code> or <code>git commit --amend --interactive</code> or
<code>git commit --amend --all</code>. If you actually understand the various modes
of <code>git reset</code>, you can use those to <em>uncommit</em>. Of course, the user
interface to performing these actions in Git today is a bit convoluted.
But if the <em>staging area</em> didn't exist, new high-level commands like
<code>git amend</code> and <code>git uncommit</code> could certainly be invented. </p>
<p>To the average user, the <em>staging area</em> is a complicated concept. I'm
a power user. I understand its purpose and how to harness its power. Yet
when I use Mercurial (which doesn't have a <em>staging area</em>), I don't miss
the <em>staging area</em> at all. Instead, I learn that all operations involving
the <em>staging area</em> can be modeled as other fundamental primitives (like
<em>commit amend</em>) that you are likely to encounter anyway. The <em>staging
area</em> therefore constitutes an unnecessary burden and cognitive load on
users. While powerful, its complexity and incurred confusion does not
justify its existence in the default Git configuration. The <em>staging
area</em> is a power-user feature and should be opt-in by default. </p>
<h2>Branches and Remotes Management is Complex and Time-Consuming</h2>
<p>When I first used Git (coming from CVS and Subversion), I thought
branches and remotes were incredible because they enabled new workflows
that allowed you to easily track multiple lines of work across many
repositories. And ~10 years later, I still believe the workflows they
enable are important. However, having amassed a broader perspective, I
also believe their implementation is poor and this unnecessarily confuses
many users and wastes the time of <em>all</em> users.</p>
<p>My initial <em>zen moment</em> with Git - the time when Git finally clicked for me -
was when I understood Git's object model: that Git is just a
content indexed key-value store consisting of a different object types
(blobs, trees, and commits) that have a particular relationship with
each other. <em>Refs</em> are symbolic names pointing to Git commit objects. And
Git <em>branches</em> - both local and remote - are just <em>refs</em> having a
well-defined naming convention (<code>refs/heads/&lt;name&gt;</code> for local branches and
<code>refs/remotes/&lt;remote&gt;/&lt;name&gt;</code> for remote branches). Even <em>tags</em> and
<em>notes</em> are defined via <em>refs</em>.</p>
<p><em>Refs</em> are a necessary primitive in Git because the Git storage model is
to throw all <em>objects</em> into a single, key-value namespace. Since the store
is content indexed and the key name is a cryptographic hash of the object's
content (which for all intents and purposes is random gibberish to
end-users), the Git store by itself is unable to locate objects. If all you
had was the key-value store and you wanted to <em>find all commits</em>, you would
need to walk every object in the store and read it to see if it is a commit
object. You'd then need to buffer metadata about those objects in memory so
you could reassemble them into say a DAG to facilitate looking at commit
history. This approach obviously doesn't scale. <em>Refs</em> short-circuit this
process by providing pointers to objects of importance. It may help to
think of the set of <em>refs</em> as an <em>index</em> into the Git store.  </p>
<p><em>Refs</em> also serve another role: as guards against garbage collection.
I won't go into details about loose objects and packfiles, but it's worth
noting that Git's key-value store also behaves in ways similar to
a generational garbage collector like you would find in programming languages
such as Java and Python. The important thing to know is that Git will
garbage collect (read: delete) objects that are unused. And the mechanism
it uses to determine which objects are unused is to iterate through <em>refs</em>
and walk all transitive references from that initial pointer. If there is
an object in the store that can't be traced back to a <em>ref</em>, it is
<em>unreachable</em> and can be deleted.</p>
<p><em>Reflogs</em> maintain the history of a value for a <em>ref</em>: for each <em>ref</em> they
contain a log of what <em>commit</em> it was pointing to, when that pointer
was established, who established it, etc. <em>Reflogs</em> serve two purposes:
facilitating <em>undoing</em> a previous action and holding a reference to <em>old</em>
data to prevent it from being garbage collected. The two use cases are
related: if you don't care about undo, you don't need the old reference
to prevent garbage collection.</p>
<p>This design of Git's store is actually quite sensible. It's not perfect
(nothing is). But it is a solid foundation to build a version control tool
(or even other data storage applications) on top of.</p>
<p>The title of this section has to do with sub-optimal branches and
remotes management. But I've hardly said anything about branches or remotes!
And this leads me to my main complaint about Git's branches and remotes:
that they are very thin veneer over <em>refs</em>. The properties of Git's
underlying key-value store unnecessarily bleed into user-facing concepts
(like branches and remotes) and therefore dictate sub-optimal practices.
This is what's referred to as a <em>leaky abstraction</em>.</p>
<p>I'll give some examples.</p>
<p>As I stated above, many users treat version control as a <em>save file</em>
step in their workflow. I believe that any step that interferes with users
saving their work is user hostile. This even includes writing a commit
message! I already argued that the <em>staging area</em> significantly interferes
with this critical task. Git <em>branches</em> do as well.</p>
<p>If we were designing a version control tool from scratch (or if you were
a new user to version control), you would probably think that a sane
feature/requirement would be to update to <em>any</em> revision and start making
changes. In Git speak, this would be something like
<code>git checkout b201e96f</code>, make some file changes, <code>git commit</code>. I think
that's a pretty basic workflow requirement for a version control tool.
And the workflow I suggested is pretty intuitive: choose the thing to
start working on, make some changes, then save those changes.</p>
<p>Let's see what happens when we actually do this:</p>
<pre><code>$ git checkout b201e96f
Note: checking out 'b201e96f'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b &lt;new-branch-name&gt;

HEAD is now at b201e96f94... Merge branch 'rs/config-write-section-fix' into maint

$ echo 'my change' &gt;&gt; README.md
$ git commit -a -m 'my change'
[detached HEAD aeb0c997ff] my change
 1 file changed, 1 insertion(+)

$ git push indygreg
fatal: You are not currently on a branch.
To push the history leading to the current (detached HEAD)
state now, use

    git push indygreg HEAD:&lt;name-of-remote-branch&gt;

$ git checkout master
Warning: you are leaving 1 commit behind, not connected to
any of your branches:

  aeb0c997ff my change

If you want to keep it by creating a new branch, this may be a good time
to do so with:

 git branch &lt;new-branch-name&gt; aeb0c997ff

Switched to branch 'master'
Your branch is up to date with 'origin/master'.
</code></pre>
<p>I know what all these messages mean because I've mastered Git. But if
you were a newcomer (or even a seasoned user), you might be very confused.
Just so we're on the same page, here is what's happening (along with
some commentary).</p>
<p>When I run <code>git checkout b201e96f</code>, Git is trying to tell me that I'm
potentially doing something that could result in the loss of my data. A
golden rule of version control tools is <em>don't lose the user's data</em>. When
I run <code>git checkout</code>, Git should be stating the risk for data loss very
clearly. But instead, the <em>If you want to create a new branch</em> sentence is
hiding this fact by instead phrasing things around <em>retaining commits you
create</em> rather than the possible loss of data. It's up to the user
to make the connection that <em>retaining commits you create</em> actually means
<em>don't eat my data</em>. Preventing data loss is critical and Git should not
mince words here!</p>
<p>The <code>git commit</code> seems to work like normal. However, since we're in a
<em>detached HEAD</em> state (a phrase that is likely gibberish to most users),
that commit isn't referred to by any <em>ref</em>, so it can be <em>lost</em> easily.
Git <em>should</em> be telling me that I just committed something it may not
be able to find in the future. But it doesn't. Again, Git isn't being
as protective of my data as it needs to be.</p>
<p>The failure in the <code>git push</code> command is essentially telling me I need
to give things a name in order to <em>push</em>. <em>Pushing</em> is effectively <em>remote
save</em>. And I'm going to apply my reasoning about version control tools
not interfering with <em>save</em> to <em>pushing</em> as well: Git is adding an
extra barrier to <em>remote save</em> by refusing to push commits without a
<em>branch</em> attached and by doing so is being user hostile.</p>
<p>Finally, we <code>git checkout master</code> to move to another commit. Here, Git
is actually doing something halfway reasonable. It is telling me I'm
leaving commits behind, which commits those are, and the command to
use to <em>keep</em> those commits. The warning is good but not great. I think
it needs to be stronger to reflect the risk around data loss if that
suggested Git commit isn't executed. (Of course, the <em>reflog</em> for <code>HEAD</code>
will ensure that data isn't immediately deleted. But users shouldn't
need to involve <em>reflogs</em> to not lose data that wasn't rewritten.)</p>
<p>The point I want to make is that Git doesn't allow you to just <em>update
and save</em>. Because its <em>dumb</em> store requires pointers to relevant commits
(<em>refs</em>) and because that requirement isn't abstracted away or paved over
by user-friendly features in the frontend, Git is effectively requiring
end-users to define names (<em>branches</em>) for all commits. If you fail to
define a name, it gets a lot harder to find your commits, exchange them,
and Git may delete your data. While it is technically possible to not
create branches, the version control tool is essentially unusable without
them.</p>
<p>When local branches are exchanged, they appear as <em>remote branches</em> to
others. Essentially, you give each instance of the repository a name
(the <em>remote</em>). And branches/refs fetched from a named <em>remote</em> appear
as a <em>ref</em> in the <em>ref namespace</em> for that <em>remote</em>. e.g.
<em>refs/remotes/origin</em> holds <em>refs</em> for the <em>origin</em> <em>remote</em>. (Git allows
you to not have to specify the <em>refs/remotes</em> part, so you can refer
to e.g. <em>refs/remotes/origin/master</em> as <em>origin/master</em>.)</p>
<p>Again, if you were designing a version control tool from scratch or you
were a new Git user, you'd probably think <em>remote refs</em> would make
good starting points for work. For example, if you know you should be
saving new work on top of the <em>master</em> branch, you might be inclined
to begin that work by running <code>git checkout origin/master</code>. But like
our specific-commit checkout above:</p>
<pre><code>$ git checkout origin/master
Note: checking out 'origin/master'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b &lt;new-branch-name&gt;

HEAD is now at 95ec6b1b33... RelNotes: the eighth batch
</code></pre>
<p>This is the same message we got for a direct checkout. But we did
supply a <em>ref</em>/<em>remote branch</em> name. What gives? Essentially, Git tries
to enforce that the <em>refs/remotes/</em> namespace is read-only and only
updated by operations that exchange data with a remote, namely <code>git fetch</code>,
<code>git pull</code>, and <code>git push</code>.</p>
<p>For this to work correctly, you need to create a new <em>local branch</em>
(which initially points to the commit that <code>refs/remotes/origin/master</code>
points to) and then switch/activate that <em>local branch</em>.</p>
<p>I could go on talking about all the subtle nuances of how Git branches
are managed. But I won't.</p>
<p>If you've used Git, you know you need to use branches. You may or may
not recognize just how frequently you have to type a branch name into
a <code>git</code> command. I guarantee that if you are familiar with version control
tools and workflows that aren't based on having to manage <em>refs</em> to
track data, you will find Git's forced usage of <em>refs</em> and <em>branches</em>
a bit absurd. I half jokingly refer to Git as <em>Game of Refs</em>. I say that
because coming from Mercurial (which doesn't require you to name things),
Git workflows feel to me like all I'm doing is typing the names of branches
and <em>refs</em> into <code>git</code> commands. I feel like I'm wasting my precious
time telling Git the names of things only because this is necessary to
placate the leaky abstraction of Git's storage layer which requires
references to relevant commits.</p>
<p>Git and version control doesn't have to be this way.</p>
<p>As I said, my Mercurial workflow doesn't rely on naming things. Unlike
Git, Mercurial's store has an explicit (not shared) storage location
for commits (<em>changesets</em> in Mercurial parlance). And this data structure
is ordered, meaning a changeset <em>later</em>  always occurs after its
parent/predecessor. This means that Mercurial can open a single
file/index to quickly find all <em>changesets</em>. Because Mercurial doesn't
need pointers to commits of relevance, names aren't required.</p>
<p>My <em>Zen of Mercurial</em> moment came when I realized you didn't have
to name things in Mercurial. Having used Git before Mercurial, I
was conditioned to always be naming things. This is the Git way
after all. And, truth be told, it is common to name things in Mercurial
as well. Mercurial's <em>named branches</em> were the way to do <em>feature
branches</em> in Mercurial for years. Some used the <em>MQ</em> extension (essentially
a port of <a href="https://en.wikipedia.org/wiki/Quilt_(software)">quilt</a>), which
also requires naming individual patches. Git users coming to Mercurial
were missing Git branches and Mercurial's <em>bookmarks</em> were a poor
<em>port</em> of Git branches.</p>
<p>But recently, more and more Mercurial users have been coming to the
realization that names aren't really necessary. If the tool doesn't
actually require naming things, why force users to name things? As long
as users can find the commits they need to find, do you actually need
names?</p>
<p>As a demonstration, my Mercurial workflow leans heavily on the <code>hg show work</code>
and <code>hg show stack</code> commands. You will need to enable the <em>show</em> extension
by putting the following in your hgrc config file to use them:</p>
<pre><code>[extensions]
show =
</code></pre>
<p>Running <code>hg show work</code> (I have also set the config
<code>commands.show.aliasprefix=s</code>to enable me to type <code>hg swork</code>) finds all
in-progress changesets and other likely-relevant changesets (those
with names and DAG heads). It prints a concise DAG of those changesets:</p>
<p><img alt="hg show work output" src="/images/hg-show-work.png" /></p>
<p>And <code>hg show stack</code> shows just the current line of work and its
relationship to other important heads:</p>
<p><img alt="hg show stack output" src="/images/hg-show-stack.png" /></p>
<p>Aside from the <code>@</code> bookmark/name set on that top-most changeset, there are
no names! (That <code>@</code> comes from the remote repository, which has set that name.)</p>
<p>Outside of code archeology workflows, <code>hg show work</code> shows the changesets I
care about 95% of the time. With all I care about (my in-progress work and
possible rebase targets) rendered concisely, I don't have to name things
because I can just find whatever I'm looking for by running <code>hg show work</code>!
Yes, you need to run <code>hg show work</code>, visually scan for what you are looking
for, and copy a (random) hash fragment into a number of commands. This
sounds like a lot of work. But I believe it is far less work than naming
things. Only when you practice this workflow do you realize just how much
time you actually spend finding and then typing names in to <code>hg</code> and -
especailly - <code>git</code> commands! The ability to just <code>hg update</code> to a changeset
and commit without having to name things is just so liberating. It feels
like my version control tool is putting up fewer barriers and letting me
work quickly.</p>
<p>Another benefit of <code>hg show work</code> and <code>hg show stack</code> are that they present
a concise DAG visualization to users. This helps educate users about the
underlying <em>shape</em> of repository data. When you see connected nodes on a
graph and how they change over time, it makes it a lot easier to understand
concepts like <em>merge</em> and <em>rebase</em>. </p>
<p>This <em>nameless</em> workflow may sound radical. But that's because we're all
conditioned to naming things. I initially thought it was crazy as well. But
once you have a mechanism that gives you rapid access to data you care
about (<code>hg show work</code> in Mercurial's case), names become very optional. Now,
a pure <em>nameless</em> workflow isn't without its limitations. You want names
to identify the main <em>targets</em> for work (e.g. the <em>master</em> branch). And when
you exchange work with others, names are easier to work with, especially
since names survive rewriting. But in my experience, most of my commits
are only exchanged with me (synchronizing my in-progress commits across
devices) and with code review tools (which don't really need names and
can operate against raw commits). My most frequent use of names comes
when I'm in <em>repository maintainer mode</em> and I need to ensure commits
have names for others to reference.</p>
<p>Could Git support <em>nameless</em> workflows? In theory it can.</p>
<p>Git needs <em>refs</em> to find relevant commits in its store. And the wire
protocol uses <em>refs</em> to exchange data. So <em>refs</em> have to exist for Git
to function (assuming Git doesn't radically change its storage and
exchange mechanisms to mitigate the need for <em>refs</em>, but that would be
a massive change and I don't see this happening).</p>
<p>While there is a fundamental requirement for <em>refs</em> to exist, this
doesn't necessarily mean that user-facing names must exist. The reason
that we need <em>branches</em> today is because <em>branches</em> are little more than
a <em>ref</em> with special behavior. It is theoretically possible to invent a
mechanism that transparently maps <em>nameless</em> commits onto <em>refs</em>. For
example, you could create a <em>refs/nameless/</em> namespace that was
automatically populated with DAG heads that didn't have names attached.
And Git could exchange these <em>refs</em> just like it can <em>branches</em> today.
It would be a lot of work to think through all the implications and to
design and implement support for <em>nameless</em> development in Git. But I
think it is possible.</p>
<p>I encourage the Git community to investigate supporting <em>nameless</em> workflows.
Having adopted this workflow in Mercurial, Git's workflow around naming
branches feels heavyweight and restrictive to me. Put another way, <em>nameless</em>
commits are actually lighter-weight branches than Git branches! To the
common user who just wants version control to be a <em>save</em> feature,
requiring names establishes a barrier towards that goal. So removing the
naming requirement would make Git simpler and more approachable to new
users.</p>
<h2>Forks aren't the Model You are Looking For</h2>
<p>This section is more about hosted Git services (like GitHub, Bitbucket, and
GitLab) than Git itself. But since hosted Git services are synonymous
with <em>Git</em> and interaction with a hosted Git services is a regular
part of a common Git user's workflow, I feel like I need to cover it.
(For what it's worth, my experience at Mozilla tells me that a large
percentage of people who say <em>I prefer Git</em> or <em>we should use Git</em>
actually mean <em>I like GitHub</em>. Git and GitHub/Bitbucket/GitLab are
effectively the same thing in the minds of many and anyone finding
themselves discussing version control needs to keep this in mind because
<em>Git</em> is more than just the command line tool: it is an ecosystem.)</p>
<p>I'll come right out and say it: I think <em>forks</em> are a relatively poor
model for collaborating. They are light years better than what
existed before. But they are still so far from the turn-key experience
that should be possible. The <em>fork</em> hasn't really changed much since
the current implementation of it was made popular by GitHub many years
ago. And I view this as a general failure of hosted services to
innovate.</p>
<p>So we have a shared understanding, a <em>fork</em> (as implemented on GitHub,
Bitbucket, GitLab, etc) is essentially a complete copy of a repository
(a <code>git clone</code> if using Git) and a fresh workspace for additional
value-added services the hosting provider offers (pull requests, issues,
wikis, project tracking, release tracking, etc). If you open the main
web page for a <em>fork</em> on these services, it looks just like the main
project's. You know it is a fork because there are cosmetics somewhere
(typically next to the project/repository name) saying <em>forked from</em>.</p>
<p>Before service providers adopted the <em>fork</em> terminology, <em>fork</em> was
used in open source to refer to a splintering of a project. If
someone or a group of people didn't like the direction a project was
taking, wanted to take over ownership of a project because of
stagnation, etc, they would <em>fork it</em>. The <em>fork</em> was based on the
original (and there may even be active collaboration between the
fork and original), but the intent of the <em>fork</em> was to create
distance between the original project and its new incantation. A
new entity that was sufficiently independent of the original.</p>
<p><em>Forks</em> on service providers mostly retain this <em>old school</em> <em>fork</em>
model. The <em>fork</em> gets a new copy of issues, wikis, etc. And anyone
who <em>forks</em> establishes what looks like an independent incantation
of a project. It's worth noting that the execution varies by service
provider. For example, GitHub won't enable <em>Issues</em> for a fork by
default, thereby encouraging people to file issues against the
<em>upstream</em> project it was forked from. (This is good default behavior.)</p>
<p>And I know why service providers (initially) implemented things this
way: it was easy. If you are building a product, it's simpler to just
say <em>a user's version of this project is a <code>git clone</code> and they get
a fresh database</em>. On a technical level, this meets the traditional
definition of <em>fork</em>. And rather than introduce a new term into the
vernacular, they just re-purposed <em>fork</em> (albeit with <em>softer</em>
connotations, since the traditional <em>fork</em> commonly implied there
was some form of strife precipitating a <em>fork</em>).</p>
<p>To help differentiate flavors of <em>forks</em>, I'm going to define the
terms <em>soft fork</em> and <em>hard fork</em>. A <em>soft fork</em> is a <em>fork</em> that
exists for purposes of collaboration. The differentiating feature
between a <em>soft fork</em> and <em>hard fork</em> is whether the <em>fork</em> is
intended to be used as its own project. If it is, it is a
<em>hard fork</em>. If not - if all changes are intended to be <em>merged</em>
into the <em>upstream</em> project and be consumed from there - it is a
<em>soft fork</em>.</p>
<p>I don't have concrete numbers, but I'm willing to wager that the vast
majority of <em>forks</em> on Git service providers which have changes are
<em>soft forks</em> rather than <em>hard forks</em>. In other words, these <em>forks</em>
exist purely as a conduit to collaborate with the canonical/upstream
project (or to facilitate a short-lived one-off change).</p>
<p>The current implementation of <em>fork</em> - which borrows a lot from its
predecessor of the same name - is a good - but not great - way to
facilitate collaboration. It isn't great because it technically
resembles what you'd expect to see for <em>hard fork</em> use cases even
though it is used predominantly with <em>soft forks</em>. This mismatch
creates problems.</p>
<p>If you were to take a step back and invent your own version control
hosted service and weren't tainted by exposure to existing services
and were willing to think a bit beyond making it a glorified frontend
for the <code>git</code> command line interface, you might realize that the problem
you are solving - the product you are selling - is collaboration as
a service, not a Git hosting service. And if your product is
collaboration, then implementing your collaboration model around the
<em>hard fork</em> model with strong barriers between the original project and
its <em>forks</em> is counterproductive and undermines your own product.
But this is how GitHub, Bitbucket, GitLab, and others have implemented
their product!</p>
<p>To improve collaboration on version control hosted services, the concept
of a <em>fork</em> needs to significantly curtailed. Replacing it should be
a UI and workflow that revolves around the central, canonical repository.</p>
<p>You shouldn't need to create your own <em>clone</em> or <em>fork</em> of a repository
in order to contribute. Instead, you should be able to clone the
canonical repository. When you create commits, those commits should
be stored and/or more tightly affiliated with the original project - not
inside a <em>fork</em>.</p>
<p>One potential implementation is doable today. I'm going to call it
<em>workspaces</em>. Here's how it would work.</p>
<p>There would exist a namespace for <em>refs</em> that can be controlled by
the user. For example, on GitHub (where my username is <em>indygreg</em>),
if I wanted to contribute to some random project, I would <code>git push</code>
my refs somewhere under <code>refs/users/indygreg/</code> directly to that
project's. No <em>forking</em> necessary. If I wanted to contribute to a
project, I would just clone its repo then push to my <em>workspace</em> under
it. You could do this today by configuring your Git <em>refspec</em> properly.
For pushes, it would look something like
<code>refs/heads/*:refs/users/indygreg/*</code> (that tells Git to map local <em>refs</em>
under <code>refs/heads/</code> to <code>refs/users/indygreg/</code> on that <em>remote</em> repository).
If this became a popular feature, presumably the Git wire protocol could
be taught to advertise this feature such that Git clients automatically
configured themselves to push to user-specific <em>workspaces</em> attached to
the original repository.</p>
<p>There are several advantages to such a <em>workspace</em> model. Many of them
revolve around eliminating <em>forks</em>.</p>
<p>At initial contribution time, no server-side <em>fork</em> is necessary in order
to contribute. You would be able to <em>clone and contribute</em> without waiting
for or configuring a <em>fork</em>. Or if you can create commits from the web
interface, the clone wouldn't even be necessary! Lowering the barrier to
contribution is a good thing, especially if collaboration is the product
you are selling.</p>
<p>In the web UI, <em>workspaces</em> would also revolve around the source project
and not be off in their own world like <em>forks</em> are today. People could
more easily see what others are up to. And fetching their work would
require typing in their username as opposed to configuring a whole new
remote. This would bring communities closer and hopefully lead to better
collaboration.</p>
<p>Not requiring <em>forks</em> also eliminates the need to synchronize your <em>fork</em>
with the upstream repository. I don't know about you, but one of the things
that bothers me about the <em>Game of Refs</em> that Git imposes is that I have
to keep my <em>refs</em> in sync with the upstream <em>refs</em>. When I fetch from
<em>origin</em> and pull down a new <em>master</em> branch, I need to <code>git merge</code>
that branch into my local <em>master</em> branch. Then I need to push that new
<em>master</em> branch to my fork. This is quite tedious. And it is easy to merge
the wrong branches and get your <em>branch</em> state out of whack. There are
better ways to map remote <em>refs</em> into your local names to make this far
less confusing.</p>
<p>Another win here is not having to push and store data multiple times.
When working on a <em>fork</em> (which is a separate repository), after you
<code>git fetch</code> changes from upstream, you need to eventually <code>git push</code> those
into your <em>fork</em>. If you've ever worked on a large repository and didn't
have a super fast Internet connection, you may have been stymied by
having to <code>git push</code> large amounts of data to your <em>fork</em>. This is quite
annoying, especially for people with slow Internet connections. Wouldn't
it be nice if that <code>git push</code> only pushed the data that was truly new and
didn't already exist somewhere else on the server? A <em>workspace</em> model
where development all occurs in the original repository would fix this.
As a bonus, it would make the storage problem on servers easier because
you would eliminate thousands of forks and you probably wouldn't have to
care as much about data duplication across repos/clones because the
version control tool solves a lot of this problem for you, courtesy of
having all data live alongside or in the original repository instead of
in a <em>fork</em>.</p>
<p>Another win from <em>workspace</em>-centric development would be the potential to
do more user-friendly things after <em>pull/merge requests</em> are incorporated
in the official project. For example, the <em>ref</em> in your workspace could
be deleted automatically. This would ease the burden on users to clean up
after their submissions are accepted. Again, instead of mashing keys to
play the <em>Game of Refs</em>, this would all be taken care of for you
automatically. (Yes, I know there are scripts and shell aliases to
make this more turn-key. But user-friendly behavior shouldn't have to
be opt-in: it should be the default.)</p>
<p>But <em>workspaces</em> aren't all rainbows and unicorns. There are access
control concerns. You probably don't want users able to mutate the
<em>workspaces</em> of other users. Or do you? You can make a compelling
case that project <em>administrators</em> should have that ability. And what if
someone pushes bad or illegal content to a workspace and you receive
a cease and desist? Can you take down just the offending workspace while
complying with the order? And what happens if the original project is
deleted? Do all its workspaces die with it? These are not trivial
concerns. But they don't feel impossible to tackle either.</p>
<p><em>Workspaces</em> are only one potential alternative to <em>forks</em>. And I can
come up with multiple implementations of the <em>workspace</em> concept. Although
many of them are constrained by current features in the Git wire protocol.
But Git is (finally) getting a more extensible wire protocol, so hopefully
this will enable <em>nice things</em>.</p>
<p>I challenge Git service providers like GitHub, Bitbucket, and GitLab to
think outside the box and implement something better than how <em>forks</em>
are implemented today. It will be a large shift. But I think users will
appreciate it in the long run.</p>
<h2>Conclusion</h2>
<p>Git is an ubiquitous version control tool. But it is
<a href="http://stevelosh.com/blog/2013/04/git-koans/">frequently lampooned</a> for
its <a href="https://stevebennett.me/2012/02/24/10-things-i-hate-about-git/">poor usability</a>
and <a href="https://git-man-page-generator.lokaltog.net/">documentation</a>.
We even have
<a href="https://spderosso.github.io/onward13.pdf">research</a>
<a href="https://spderosso.github.io/oopsla16.pdf">papers</a> telling us which parts
are bad. Nobody I know has had a pleasant initial experience with Git.
And it is clear that few people actually understand Git: most just know
the command incantations they need to know to accomplish a small set of
common activities. (If you are such a person, there is nothing to be
ashamed about: Git is a <em>hard</em> tool.)</p>
<p>Popular Git-based hosting and collaboration services (such as GitHub,
Bitbucket, and GitLab) exist. While they've made strides to make it
easier to commit data to a Git repository (I purposefully avoid saying
<em>use Git</em> because the most usable tools seem to avoid the <code>git</code> command
line interface as much as possible), they are often a thin veneer over
Git itself (see <em>forks</em>). And Git is a thin veneer over a content
indexed key-value store (see forced usage of bookmarks).</p>
<p>As an industry, we should be concerned about the lousy usability of Git
and the tools and services that surround it. Some may say that Git -
with its near monopoly over version control mindset - is a success. I
have a different view: I think it is a failure that a tool with a user
experience this bad has achieved the success it has.</p>
<p>The cost to Git's poor usability can be measured in tens if not hundreds
of millions of dollars in time people have wasted because they couldn't
figure out how to use Git. Git should be viewed as a source of
embarrassment, not a success story.</p>
<p>What's really concerning is that the usability problems of Git have been
known for years. Yet it is as popular as ever and there have been few
substantial usability improvements. We do have some
<a href="http://gitless.com/">alternative frontends</a> floating around. But these
haven't caught on.</p>
<p>I'm at a loss to understand how an open source tool as popular as Git
has remained so mediocre for so long. The source code is out there.
Anybody can submit a patch to fix it. Why is it that so many people get
tripped up by the same poor usability issues years after Git became
the common version control tool? It certainly appears that as an
industry we have been unable or unwilling to address systemic deficiencies
in a critical tool. Why this is, I'm not sure.</p>
<p>Despite my pessimism about Git's usability and its poor track record of
being attentive to the needs of people who aren't power users, I'm
optimistic that the future will be brighter. While the ~7000 words in this
post pale in comparison to the aggregate word count that has been
written about Git, hopefully this post strikes a nerve and causes
positive change. Just because one generation has toiled with the
usability problems of Git doesn't mean the next generation has to
suffer through the same. Git can be improved and I encourage that change
to happen. The three issues above and their possible solutions would
be a good place to start.</p>]]></content:encoded>
    </item>
  </channel>
</rss>
